var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var index = createCommonjsModule(function (module, exports) {
	(function webpackUniversalModuleDefinition(root, factory) {
		module.exports = factory();
	})(commonjsGlobal, function () {
		return (/******/function (modules) {
				// webpackBootstrap
				/******/ // The module cache
				/******/var installedModules = {};
				/******/
				/******/ // The require function
				/******/function __webpack_require__(moduleId) {
					/******/
					/******/ // Check if module is in cache
					/******/if (installedModules[moduleId])
						/******/return installedModules[moduleId].exports;
					/******/
					/******/ // Create a new module (and put it into the cache)
					/******/var module = installedModules[moduleId] = {
						/******/exports: {},
						/******/id: moduleId,
						/******/loaded: false
						/******/ };
					/******/
					/******/ // Execute the module function
					/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
					/******/
					/******/ // Flag the module as loaded
					/******/module.loaded = true;
					/******/
					/******/ // Return the exports of the module
					/******/return module.exports;
					/******/
				}
				/******/
				/******/
				/******/ // expose the modules object (__webpack_modules__)
				/******/__webpack_require__.m = modules;
				/******/
				/******/ // expose the module cache
				/******/__webpack_require__.c = installedModules;
				/******/
				/******/ // __webpack_public_path__
				/******/__webpack_require__.p = "";
				/******/
				/******/ // Load entry module and return exports
				/******/return __webpack_require__(0);
				/******/
			}(
			/************************************************************************/
			/******/[
			/* 0 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				// NOTE!!!
				//
				// We have to load polyfills directly from source as non-minified files are not
				// published by the polyfills. An issue was raised to discuss this problem and
				// to see if it can be resolved.
				//
				// See https://github.com/webcomponents/custom-elements/issues/45

				// ES2015 polyfills required for the polyfills to work in older browsers.

				__webpack_require__(1).shim();
				__webpack_require__(26).shim();
				__webpack_require__(31).polyfill();

				// We have to include this first so that it can patch native. This must be done
				// before any polyfills are loaded.
				__webpack_require__(34);

				// Template polyfill is necessary to use shadycss in IE11
				// this comes before custom elements because of
				// https://github.com/webcomponents/template/blob/master/template.js#L39
				__webpack_require__(35);

				// This comes after the native shim because it requries it to be patched first.
				__webpack_require__(36);

				// Force the polyfill in Safari 10.0.0 and 10.0.1.
				var _window = window,
				    navigator = _window.navigator;
				var userAgent = navigator.userAgent;

				var safari = userAgent.indexOf('Safari/60') !== -1;
				var safariVersion = safari && userAgent.match(/Version\/([^\s]+)/)[1];
				var safariVersions = [0, 1].map(function (v) {
					return '10.0.' + v;
				}).concat(['10.0']);

				if (safari && safariVersions.indexOf(safariVersion) > -1) {
					window.ShadyDOM = { force: true };
				}

				// ShadyDOM comes first. Both because it may need to be forced and the
				// ShadyCSS polyfill requires it to function.
				__webpack_require__(51);
				__webpack_require__(67);

				/***/
			},
			/* 1 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				var define = __webpack_require__(2);

				var implementation = __webpack_require__(6);
				var getPolyfill = __webpack_require__(24);
				var shim = __webpack_require__(25);

				// eslint-disable-next-line no-unused-vars
				var boundFromShim = function from(array) {
					// eslint-disable-next-line no-invalid-this
					return implementation.apply(this || Array, arguments);
				};

				define(boundFromShim, {
					'getPolyfill': getPolyfill,
					'implementation': implementation,
					'shim': shim
				});

				module.exports = boundFromShim;

				/***/
			},
			/* 2 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
					return typeof obj;
				} : function (obj) {
					return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
				};

				var keys = __webpack_require__(3);
				var foreach = __webpack_require__(5);
				var hasSymbols = typeof Symbol === 'function' && _typeof(Symbol()) === 'symbol';

				var toStr = Object.prototype.toString;

				var isFunction = function isFunction(fn) {
					return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
				};

				var arePropertyDescriptorsSupported = function arePropertyDescriptorsSupported() {
					var obj = {};
					try {
						Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
						/* eslint-disable no-unused-vars, no-restricted-syntax */
						for (var _ in obj) {
							return false;
						}
						/* eslint-enable no-unused-vars, no-restricted-syntax */
						return obj.x === obj;
					} catch (e) {
						/* this is IE 8. */
						return false;
					}
				};
				var supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();

				var defineProperty = function defineProperty(object, name, value, predicate) {
					if (name in object && (!isFunction(predicate) || !predicate())) {
						return;
					}
					if (supportsDescriptors) {
						Object.defineProperty(object, name, {
							configurable: true,
							enumerable: false,
							value: value,
							writable: true
						});
					} else {
						object[name] = value;
					}
				};

				var defineProperties = function defineProperties(object, map) {
					var predicates = arguments.length > 2 ? arguments[2] : {};
					var props = keys(map);
					if (hasSymbols) {
						props = props.concat(Object.getOwnPropertySymbols(map));
					}
					foreach(props, function (name) {
						defineProperty(object, name, map[name], predicates[name]);
					});
				};

				defineProperties.supportsDescriptors = !!supportsDescriptors;

				module.exports = defineProperties;

				/***/
			},
			/* 3 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				// modified from https://github.com/es-shims/es5-shim

				var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
					return typeof obj;
				} : function (obj) {
					return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
				};

				var has = Object.prototype.hasOwnProperty;
				var toStr = Object.prototype.toString;
				var slice = Array.prototype.slice;
				var isArgs = __webpack_require__(4);
				var isEnumerable = Object.prototype.propertyIsEnumerable;
				var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
				var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
				var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];
				var equalsConstructorPrototype = function equalsConstructorPrototype(o) {
					var ctor = o.constructor;
					return ctor && ctor.prototype === o;
				};
				var excludedKeys = {
					$console: true,
					$external: true,
					$frame: true,
					$frameElement: true,
					$frames: true,
					$innerHeight: true,
					$innerWidth: true,
					$outerHeight: true,
					$outerWidth: true,
					$pageXOffset: true,
					$pageYOffset: true,
					$parent: true,
					$scrollLeft: true,
					$scrollTop: true,
					$scrollX: true,
					$scrollY: true,
					$self: true,
					$webkitIndexedDB: true,
					$webkitStorageInfo: true,
					$window: true
				};
				var hasAutomationEqualityBug = function () {
					/* global window */
					if (typeof window === 'undefined') {
						return false;
					}
					for (var k in window) {
						try {
							if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && _typeof(window[k]) === 'object') {
								try {
									equalsConstructorPrototype(window[k]);
								} catch (e) {
									return true;
								}
							}
						} catch (e) {
							return true;
						}
					}
					return false;
				}();
				var equalsConstructorPrototypeIfNotBuggy = function equalsConstructorPrototypeIfNotBuggy(o) {
					/* global window */
					if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
						return equalsConstructorPrototype(o);
					}
					try {
						return equalsConstructorPrototype(o);
					} catch (e) {
						return false;
					}
				};

				var keysShim = function keys(object) {
					var isObject = object !== null && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object';
					var isFunction = toStr.call(object) === '[object Function]';
					var isArguments = isArgs(object);
					var isString = isObject && toStr.call(object) === '[object String]';
					var theKeys = [];

					if (!isObject && !isFunction && !isArguments) {
						throw new TypeError('Object.keys called on a non-object');
					}

					var skipProto = hasProtoEnumBug && isFunction;
					if (isString && object.length > 0 && !has.call(object, 0)) {
						for (var i = 0; i < object.length; ++i) {
							theKeys.push(String(i));
						}
					}

					if (isArguments && object.length > 0) {
						for (var j = 0; j < object.length; ++j) {
							theKeys.push(String(j));
						}
					} else {
						for (var name in object) {
							if (!(skipProto && name === 'prototype') && has.call(object, name)) {
								theKeys.push(String(name));
							}
						}
					}

					if (hasDontEnumBug) {
						var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

						for (var k = 0; k < dontEnums.length; ++k) {
							if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
								theKeys.push(dontEnums[k]);
							}
						}
					}
					return theKeys;
				};

				keysShim.shim = function shimObjectKeys() {
					if (Object.keys) {
						var keysWorksWithArguments = function () {
							// Safari 5.0 bug
							return (Object.keys(arguments) || '').length === 2;
						}(1, 2);
						if (!keysWorksWithArguments) {
							var originalKeys = Object.keys;
							Object.keys = function keys(object) {
								if (isArgs(object)) {
									return originalKeys(slice.call(object));
								} else {
									return originalKeys(object);
								}
							};
						}
					} else {
						Object.keys = keysShim;
					}
					return Object.keys || keysShim;
				};

				module.exports = keysShim;

				/***/
			},
			/* 4 */
			/***/function (module, exports) {

				'use strict';

				var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
					return typeof obj;
				} : function (obj) {
					return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
				};

				var toStr = Object.prototype.toString;

				module.exports = function isArguments(value) {
					var str = toStr.call(value);
					var isArgs = str === '[object Arguments]';
					if (!isArgs) {
						isArgs = str !== '[object Array]' && value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
					}
					return isArgs;
				};

				/***/
			},
			/* 5 */
			/***/function (module, exports) {

				'use strict';

				var hasOwn = Object.prototype.hasOwnProperty;
				var toString = Object.prototype.toString;

				module.exports = function forEach(obj, fn, ctx) {
					if (toString.call(fn) !== '[object Function]') {
						throw new TypeError('iterator must be a function');
					}
					var l = obj.length;
					if (l === +l) {
						for (var i = 0; i < l; i++) {
							fn.call(ctx, obj[i], i, obj);
						}
					} else {
						for (var k in obj) {
							if (hasOwn.call(obj, k)) {
								fn.call(ctx, obj[k], k, obj);
							}
						}
					}
				};

				/***/
			},
			/* 6 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				var ES = __webpack_require__(7);
				var supportsDescriptors = __webpack_require__(2).supportsDescriptors;

				/*! https://mths.be/array-from v0.2.0 by @mathias */
				module.exports = function from(arrayLike) {
					var defineProperty = supportsDescriptors ? Object.defineProperty : function put(object, key, descriptor) {
						object[key] = descriptor.value;
					};
					var C = this;
					if (arrayLike === null || typeof arrayLike === 'undefined') {
						throw new TypeError('`Array.from` requires an array-like object, not `null` or `undefined`');
					}
					var items = ES.ToObject(arrayLike);

					var mapFn, T;
					if (typeof arguments[1] !== 'undefined') {
						mapFn = arguments[1];
						if (!ES.IsCallable(mapFn)) {
							throw new TypeError('When provided, the second argument to `Array.from` must be a function');
						}
						if (arguments.length > 2) {
							T = arguments[2];
						}
					}

					var len = ES.ToLength(items.length);
					var A = ES.IsCallable(C) ? ES.ToObject(new C(len)) : new Array(len);
					var k = 0;
					var kValue, mappedValue;
					while (k < len) {
						kValue = items[k];
						if (mapFn) {
							mappedValue = typeof T === 'undefined' ? mapFn(kValue, k) : ES.Call(mapFn, T, [kValue, k]);
						} else {
							mappedValue = kValue;
						}
						defineProperty(A, k, {
							'configurable': true,
							'enumerable': true,
							'value': mappedValue,
							'writable': true
						});
						k += 1;
					}
					A.length = len;
					return A;
				};

				/***/
			},
			/* 7 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
					return typeof obj;
				} : function (obj) {
					return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
				};

				var toStr = Object.prototype.toString;
				var hasSymbols = typeof Symbol === 'function' && _typeof(Symbol.iterator) === 'symbol';
				var symbolToStr = hasSymbols ? Symbol.prototype.toString : toStr;

				var $isNaN = __webpack_require__(8);
				var $isFinite = __webpack_require__(9);
				var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;

				var assign = __webpack_require__(10);
				var sign = __webpack_require__(11);
				var mod = __webpack_require__(12);
				var isPrimitive = __webpack_require__(13);
				var toPrimitive = __webpack_require__(14);
				var parseInteger = parseInt;
				var bind = __webpack_require__(19);
				var strSlice = bind.call(Function.call, String.prototype.slice);
				var isBinary = bind.call(Function.call, RegExp.prototype.test, /^0b[01]+$/i);
				var isOctal = bind.call(Function.call, RegExp.prototype.test, /^0o[0-7]+$/i);
				var nonWS = ['\x85', '\u200B', '\uFFFE'].join('');
				var nonWSregex = new RegExp('[' + nonWS + ']', 'g');
				var hasNonWS = bind.call(Function.call, RegExp.prototype.test, nonWSregex);
				var invalidHexLiteral = /^[\-\+]0x[0-9a-f]+$/i;
				var isInvalidHexLiteral = bind.call(Function.call, RegExp.prototype.test, invalidHexLiteral);

				// whitespace from: http://es5.github.io/#x15.5.4.20
				// implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
				var ws = ['\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003', '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028', '\u2029\uFEFF'].join('');
				var trimRegex = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
				var replace = bind.call(Function.call, String.prototype.replace);
				var trim = function trim(value) {
					return replace(value, trimRegex, '');
				};

				var ES5 = __webpack_require__(21);

				var hasRegExpMatcher = __webpack_require__(23);

				// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-abstract-operations
				var ES6 = assign(assign({}, ES5), {

					// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-call-f-v-args
					Call: function Call(F, V) {
						var args = arguments.length > 2 ? arguments[2] : [];
						if (!this.IsCallable(F)) {
							throw new TypeError(F + ' is not a function');
						}
						return F.apply(V, args);
					},

					// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toprimitive
					ToPrimitive: toPrimitive,

					// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toboolean
					// ToBoolean: ES5.ToBoolean,

					// http://www.ecma-international.org/ecma-262/6.0/#sec-tonumber
					ToNumber: function ToNumber(argument) {
						var value = isPrimitive(argument) ? argument : toPrimitive(argument, 'number');
						if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'symbol') {
							throw new TypeError('Cannot convert a Symbol value to a number');
						}
						if (typeof value === 'string') {
							if (isBinary(value)) {
								return this.ToNumber(parseInteger(strSlice(value, 2), 2));
							} else if (isOctal(value)) {
								return this.ToNumber(parseInteger(strSlice(value, 2), 8));
							} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
								return NaN;
							} else {
								var trimmed = trim(value);
								if (trimmed !== value) {
									return this.ToNumber(trimmed);
								}
							}
						}
						return Number(value);
					},

					// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tointeger
					// ToInteger: ES5.ToNumber,

					// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint32
					// ToInt32: ES5.ToInt32,

					// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint32
					// ToUint32: ES5.ToUint32,

					// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint16
					ToInt16: function ToInt16(argument) {
						var int16bit = this.ToUint16(argument);
						return int16bit >= 0x8000 ? int16bit - 0x10000 : int16bit;
					},

					// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint16
					// ToUint16: ES5.ToUint16,

					// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint8
					ToInt8: function ToInt8(argument) {
						var int8bit = this.ToUint8(argument);
						return int8bit >= 0x80 ? int8bit - 0x100 : int8bit;
					},

					// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8
					ToUint8: function ToUint8(argument) {
						var number = this.ToNumber(argument);
						if ($isNaN(number) || number === 0 || !$isFinite(number)) {
							return 0;
						}
						var posInt = sign(number) * Math.floor(Math.abs(number));
						return mod(posInt, 0x100);
					},

					// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8clamp
					ToUint8Clamp: function ToUint8Clamp(argument) {
						var number = this.ToNumber(argument);
						if ($isNaN(number) || number <= 0) {
							return 0;
						}
						if (number >= 0xFF) {
							return 0xFF;
						}
						var f = Math.floor(argument);
						if (f + 0.5 < number) {
							return f + 1;
						}
						if (number < f + 0.5) {
							return f;
						}
						if (f % 2 !== 0) {
							return f + 1;
						}
						return f;
					},

					// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tostring
					ToString: function ToString(argument) {
						if ((typeof argument === 'undefined' ? 'undefined' : _typeof(argument)) === 'symbol') {
							throw new TypeError('Cannot convert a Symbol value to a string');
						}
						return String(argument);
					},

					// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toobject
					ToObject: function ToObject(value) {
						this.RequireObjectCoercible(value);
						return Object(value);
					},

					// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-topropertykey
					ToPropertyKey: function ToPropertyKey(argument) {
						var key = this.ToPrimitive(argument, String);
						return (typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'symbol' ? symbolToStr.call(key) : this.ToString(key);
					},

					// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
					ToLength: function ToLength(argument) {
						var len = this.ToInteger(argument);
						if (len <= 0) {
							return 0;
						} // includes converting -0 to +0
						if (len > MAX_SAFE_INTEGER) {
							return MAX_SAFE_INTEGER;
						}
						return len;
					},

					// http://www.ecma-international.org/ecma-262/6.0/#sec-canonicalnumericindexstring
					CanonicalNumericIndexString: function CanonicalNumericIndexString(argument) {
						if (toStr.call(argument) !== '[object String]') {
							throw new TypeError('must be a string');
						}
						if (argument === '-0') {
							return -0;
						}
						var n = this.ToNumber(argument);
						if (this.SameValue(this.ToString(n), argument)) {
							return n;
						}
						return void 0;
					},

					// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-requireobjectcoercible
					RequireObjectCoercible: ES5.CheckObjectCoercible,

					// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isarray
					IsArray: Array.isArray || function IsArray(argument) {
						return toStr.call(argument) === '[object Array]';
					},

					// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-iscallable
					// IsCallable: ES5.IsCallable,

					// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isconstructor
					IsConstructor: function IsConstructor(argument) {
						return typeof argument === 'function' && !!argument.prototype; // unfortunately there's no way to truly check this without try/catch `new argument`
					},

					// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isextensible-o
					IsExtensible: function IsExtensible(obj) {
						if (!Object.preventExtensions) {
							return true;
						}
						if (isPrimitive(obj)) {
							return false;
						}
						return Object.isExtensible(obj);
					},

					// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isinteger
					IsInteger: function IsInteger(argument) {
						if (typeof argument !== 'number' || $isNaN(argument) || !$isFinite(argument)) {
							return false;
						}
						var abs = Math.abs(argument);
						return Math.floor(abs) === abs;
					},

					// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ispropertykey
					IsPropertyKey: function IsPropertyKey(argument) {
						return typeof argument === 'string' || (typeof argument === 'undefined' ? 'undefined' : _typeof(argument)) === 'symbol';
					},

					// http://www.ecma-international.org/ecma-262/6.0/#sec-isregexp
					IsRegExp: function IsRegExp(argument) {
						if (!argument || (typeof argument === 'undefined' ? 'undefined' : _typeof(argument)) !== 'object') {
							return false;
						}
						if (hasSymbols) {
							var isRegExp = argument[Symbol.match];
							if (typeof isRegExp !== 'undefined') {
								return ES5.ToBoolean(isRegExp);
							}
						}
						return hasRegExpMatcher(argument);
					},

					// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevalue
					// SameValue: ES5.SameValue,

					// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero
					SameValueZero: function SameValueZero(x, y) {
						return x === y || $isNaN(x) && $isNaN(y);
					},

					Type: function Type(x) {
						if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'symbol') {
							return 'Symbol';
						}
						return ES5.Type(x);
					},

					// http://www.ecma-international.org/ecma-262/6.0/#sec-speciesconstructor
					SpeciesConstructor: function SpeciesConstructor(O, defaultConstructor) {
						if (this.Type(O) !== 'Object') {
							throw new TypeError('Assertion failed: Type(O) is not Object');
						}
						var C = O.constructor;
						if (typeof C === 'undefined') {
							return defaultConstructor;
						}
						if (this.Type(C) !== 'Object') {
							throw new TypeError('O.constructor is not an Object');
						}
						var S = hasSymbols && Symbol.species ? C[Symbol.species] : undefined;
						if (S == null) {
							return defaultConstructor;
						}
						if (this.IsConstructor(S)) {
							return S;
						}
						throw new TypeError('no constructor found');
					}
				});

				delete ES6.CheckObjectCoercible; // renamed in ES6 to RequireObjectCoercible

				module.exports = ES6;

				/***/
			},
			/* 8 */
			/***/function (module, exports) {

				"use strict";

				module.exports = Number.isNaN || function isNaN(a) {
					return a !== a;
				};

				/***/
			},
			/* 9 */
			/***/function (module, exports) {

				'use strict';

				var $isNaN = Number.isNaN || function (a) {
					return a !== a;
				};

				module.exports = Number.isFinite || function (x) {
					return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity;
				};

				/***/
			},
			/* 10 */
			/***/function (module, exports) {

				"use strict";

				var has = Object.prototype.hasOwnProperty;
				module.exports = Object.assign || function assign(target, source) {
					for (var key in source) {
						if (has.call(source, key)) {
							target[key] = source[key];
						}
					}
					return target;
				};

				/***/
			},
			/* 11 */
			/***/function (module, exports) {

				"use strict";

				module.exports = function sign(number) {
					return number >= 0 ? 1 : -1;
				};

				/***/
			},
			/* 12 */
			/***/function (module, exports) {

				"use strict";

				module.exports = function mod(number, modulo) {
					var remain = number % modulo;
					return Math.floor(remain >= 0 ? remain : remain + modulo);
				};

				/***/
			},
			/* 13 */
			/***/function (module, exports) {

				'use strict';

				var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
					return typeof obj;
				} : function (obj) {
					return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
				};

				module.exports = function isPrimitive(value) {
					return value === null || typeof value !== 'function' && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object';
				};

				/***/
			},
			/* 14 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
					return typeof obj;
				} : function (obj) {
					return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
				};

				var hasSymbols = typeof Symbol === 'function' && _typeof(Symbol.iterator) === 'symbol';

				var isPrimitive = __webpack_require__(15);
				var isCallable = __webpack_require__(16);
				var isDate = __webpack_require__(17);
				var isSymbol = __webpack_require__(18);

				var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
					if (typeof O === 'undefined' || O === null) {
						throw new TypeError('Cannot call method on ' + O);
					}
					if (typeof hint !== 'string' || hint !== 'number' && hint !== 'string') {
						throw new TypeError('hint must be "string" or "number"');
					}
					var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
					var method, result, i;
					for (i = 0; i < methodNames.length; ++i) {
						method = O[methodNames[i]];
						if (isCallable(method)) {
							result = method.call(O);
							if (isPrimitive(result)) {
								return result;
							}
						}
					}
					throw new TypeError('No default value');
				};

				var GetMethod = function GetMethod(O, P) {
					var func = O[P];
					if (func !== null && typeof func !== 'undefined') {
						if (!isCallable(func)) {
							throw new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');
						}
						return func;
					}
				};

				// http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive
				module.exports = function ToPrimitive(input, PreferredType) {
					if (isPrimitive(input)) {
						return input;
					}
					var hint = 'default';
					if (arguments.length > 1) {
						if (PreferredType === String) {
							hint = 'string';
						} else if (PreferredType === Number) {
							hint = 'number';
						}
					}

					var exoticToPrim;
					if (hasSymbols) {
						if (Symbol.toPrimitive) {
							exoticToPrim = GetMethod(input, Symbol.toPrimitive);
						} else if (isSymbol(input)) {
							exoticToPrim = Symbol.prototype.valueOf;
						}
					}
					if (typeof exoticToPrim !== 'undefined') {
						var result = exoticToPrim.call(input, hint);
						if (isPrimitive(result)) {
							return result;
						}
						throw new TypeError('unable to convert exotic object to primitive');
					}
					if (hint === 'default' && (isDate(input) || isSymbol(input))) {
						hint = 'string';
					}
					return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
				};

				/***/
			},
			/* 15 */
			/***/function (module, exports) {

				'use strict';

				var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
					return typeof obj;
				} : function (obj) {
					return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
				};

				module.exports = function isPrimitive(value) {
					return value === null || typeof value !== 'function' && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object';
				};

				/***/
			},
			/* 16 */
			/***/function (module, exports) {

				'use strict';

				var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
					return typeof obj;
				} : function (obj) {
					return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
				};

				var fnToStr = Function.prototype.toString;

				var constructorRegex = /^\s*class /;
				var isES6ClassFn = function isES6ClassFn(value) {
					try {
						var fnStr = fnToStr.call(value);
						var singleStripped = fnStr.replace(/\/\/.*\n/g, '');
						var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, '');
						var spaceStripped = multiStripped.replace(/\n/mg, ' ').replace(/ {2}/g, ' ');
						return constructorRegex.test(spaceStripped);
					} catch (e) {
						return false; // not a function
					}
				};

				var tryFunctionObject = function tryFunctionObject(value) {
					try {
						if (isES6ClassFn(value)) {
							return false;
						}
						fnToStr.call(value);
						return true;
					} catch (e) {
						return false;
					}
				};
				var toStr = Object.prototype.toString;
				var fnClass = '[object Function]';
				var genClass = '[object GeneratorFunction]';
				var hasToStringTag = typeof Symbol === 'function' && _typeof(Symbol.toStringTag) === 'symbol';

				module.exports = function isCallable(value) {
					if (!value) {
						return false;
					}
					if (typeof value !== 'function' && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object') {
						return false;
					}
					if (hasToStringTag) {
						return tryFunctionObject(value);
					}
					if (isES6ClassFn(value)) {
						return false;
					}
					var strClass = toStr.call(value);
					return strClass === fnClass || strClass === genClass;
				};

				/***/
			},
			/* 17 */
			/***/function (module, exports) {

				'use strict';

				var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
					return typeof obj;
				} : function (obj) {
					return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
				};

				var getDay = Date.prototype.getDay;
				var tryDateObject = function tryDateObject(value) {
					try {
						getDay.call(value);
						return true;
					} catch (e) {
						return false;
					}
				};

				var toStr = Object.prototype.toString;
				var dateClass = '[object Date]';
				var hasToStringTag = typeof Symbol === 'function' && _typeof(Symbol.toStringTag) === 'symbol';

				module.exports = function isDateObject(value) {
					if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object' || value === null) {
						return false;
					}
					return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
				};

				/***/
			},
			/* 18 */
			/***/function (module, exports) {

				'use strict';

				var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
					return typeof obj;
				} : function (obj) {
					return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
				};

				var toStr = Object.prototype.toString;
				var hasSymbols = typeof Symbol === 'function' && _typeof(Symbol()) === 'symbol';

				if (hasSymbols) {
					var symToStr = Symbol.prototype.toString;
					var symStringRegex = /^Symbol\(.*\)$/;
					var isSymbolObject = function isSymbolObject(value) {
						if (_typeof(value.valueOf()) !== 'symbol') {
							return false;
						}
						return symStringRegex.test(symToStr.call(value));
					};
					module.exports = function isSymbol(value) {
						if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'symbol') {
							return true;
						}
						if (toStr.call(value) !== '[object Symbol]') {
							return false;
						}
						try {
							return isSymbolObject(value);
						} catch (e) {
							return false;
						}
					};
				} else {
					module.exports = function isSymbol(value) {
						// this environment does not support Symbols.
						return false;
					};
				}

				/***/
			},
			/* 19 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				var implementation = __webpack_require__(20);

				module.exports = Function.prototype.bind || implementation;

				/***/
			},
			/* 20 */
			/***/function (module, exports) {

				'use strict';

				var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
				var slice = Array.prototype.slice;
				var toStr = Object.prototype.toString;
				var funcType = '[object Function]';

				module.exports = function bind(that) {
					var target = this;
					if (typeof target !== 'function' || toStr.call(target) !== funcType) {
						throw new TypeError(ERROR_MESSAGE + target);
					}
					var args = slice.call(arguments, 1);

					var bound;
					var binder = function binder() {
						if (this instanceof bound) {
							var result = target.apply(this, args.concat(slice.call(arguments)));
							if (Object(result) === result) {
								return result;
							}
							return this;
						} else {
							return target.apply(that, args.concat(slice.call(arguments)));
						}
					};

					var boundLength = Math.max(0, target.length - args.length);
					var boundArgs = [];
					for (var i = 0; i < boundLength; i++) {
						boundArgs.push('$' + i);
					}

					bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

					if (target.prototype) {
						var Empty = function Empty() {};
						Empty.prototype = target.prototype;
						bound.prototype = new Empty();
						Empty.prototype = null;
					}

					return bound;
				};

				/***/
			},
			/* 21 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
					return typeof obj;
				} : function (obj) {
					return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
				};

				var $isNaN = __webpack_require__(8);
				var $isFinite = __webpack_require__(9);

				var sign = __webpack_require__(11);
				var mod = __webpack_require__(12);

				var IsCallable = __webpack_require__(16);
				var toPrimitive = __webpack_require__(22);

				// https://es5.github.io/#x9
				var ES5 = {
					ToPrimitive: toPrimitive,

					ToBoolean: function ToBoolean(value) {
						return Boolean(value);
					},
					ToNumber: function ToNumber(value) {
						return Number(value);
					},
					ToInteger: function ToInteger(value) {
						var number = this.ToNumber(value);
						if ($isNaN(number)) {
							return 0;
						}
						if (number === 0 || !$isFinite(number)) {
							return number;
						}
						return sign(number) * Math.floor(Math.abs(number));
					},
					ToInt32: function ToInt32(x) {
						return this.ToNumber(x) >> 0;
					},
					ToUint32: function ToUint32(x) {
						return this.ToNumber(x) >>> 0;
					},
					ToUint16: function ToUint16(value) {
						var number = this.ToNumber(value);
						if ($isNaN(number) || number === 0 || !$isFinite(number)) {
							return 0;
						}
						var posInt = sign(number) * Math.floor(Math.abs(number));
						return mod(posInt, 0x10000);
					},
					ToString: function ToString(value) {
						return String(value);
					},
					ToObject: function ToObject(value) {
						this.CheckObjectCoercible(value);
						return Object(value);
					},
					CheckObjectCoercible: function CheckObjectCoercible(value, optMessage) {
						/* jshint eqnull:true */
						if (value == null) {
							throw new TypeError(optMessage || 'Cannot call method on ' + value);
						}
						return value;
					},
					IsCallable: IsCallable,
					SameValue: function SameValue(x, y) {
						if (x === y) {
							// 0 === -0, but they are not identical.
							if (x === 0) {
								return 1 / x === 1 / y;
							}
							return true;
						}
						return $isNaN(x) && $isNaN(y);
					},

					// http://www.ecma-international.org/ecma-262/5.1/#sec-8
					Type: function Type(x) {
						if (x === null) {
							return 'Null';
						}
						if (typeof x === 'undefined') {
							return 'Undefined';
						}
						if (typeof x === 'function' || (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object') {
							return 'Object';
						}
						if (typeof x === 'number') {
							return 'Number';
						}
						if (typeof x === 'boolean') {
							return 'Boolean';
						}
						if (typeof x === 'string') {
							return 'String';
						}
					}
				};

				module.exports = ES5;

				/***/
			},
			/* 22 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				var toStr = Object.prototype.toString;

				var isPrimitive = __webpack_require__(15);

				var isCallable = __webpack_require__(16);

				// https://es5.github.io/#x8.12
				var ES5internalSlots = {
					'[[DefaultValue]]': function DefaultValue(O, hint) {
						var actualHint = hint || (toStr.call(O) === '[object Date]' ? String : Number);

						if (actualHint === String || actualHint === Number) {
							var methods = actualHint === String ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
							var value, i;
							for (i = 0; i < methods.length; ++i) {
								if (isCallable(O[methods[i]])) {
									value = O[methods[i]]();
									if (isPrimitive(value)) {
										return value;
									}
								}
							}
							throw new TypeError('No default value');
						}
						throw new TypeError('invalid [[DefaultValue]] hint supplied');
					}
				};

				// https://es5.github.io/#x9
				module.exports = function ToPrimitive(input, PreferredType) {
					if (isPrimitive(input)) {
						return input;
					}
					return ES5internalSlots['[[DefaultValue]]'](input, PreferredType);
				};

				/***/
			},
			/* 23 */
			/***/function (module, exports) {

				'use strict';

				var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
					return typeof obj;
				} : function (obj) {
					return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
				};

				var regexExec = RegExp.prototype.exec;
				var tryRegexExec = function tryRegexExec(value) {
					try {
						regexExec.call(value);
						return true;
					} catch (e) {
						return false;
					}
				};
				var toStr = Object.prototype.toString;
				var regexClass = '[object RegExp]';
				var hasToStringTag = typeof Symbol === 'function' && _typeof(Symbol.toStringTag) === 'symbol';

				module.exports = function isRegex(value) {
					if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object') {
						return false;
					}
					return hasToStringTag ? tryRegexExec(value) : toStr.call(value) === regexClass;
				};

				/***/
			},
			/* 24 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				var ES = __webpack_require__(7);
				var implementation = __webpack_require__(6);

				var tryCall = function tryCall(fn) {
					try {
						fn();
						return true;
					} catch (e) {
						return false;
					}
				};

				module.exports = function getPolyfill() {
					var implemented = ES.IsCallable(Array.from) && tryCall(function () {
						Array.from({ 'length': -Infinity });
					}) && !tryCall(function () {
						Array.from([], undefined);
					});

					return implemented ? Array.from : implementation;
				};

				/***/
			},
			/* 25 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				var define = __webpack_require__(2);
				var getPolyfill = __webpack_require__(24);

				module.exports = function shimArrayFrom() {
					var polyfill = getPolyfill();

					define(Array, { 'from': polyfill }, {
						'from': function from() {
							return Array.from !== polyfill;
						}
					});

					return polyfill;
				};

				/***/
			},
			/* 26 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				var defineProperties = __webpack_require__(2);

				var implementation = __webpack_require__(27);
				var getPolyfill = __webpack_require__(29);
				var shim = __webpack_require__(30);

				var polyfill = getPolyfill();

				defineProperties(polyfill, {
					implementation: implementation,
					getPolyfill: getPolyfill,
					shim: shim
				});

				module.exports = polyfill;

				/***/
			},
			/* 27 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				// modified from https://github.com/es-shims/es6-shim

				var keys = __webpack_require__(3);
				var bind = __webpack_require__(19);
				var canBeObject = function canBeObject(obj) {
					return typeof obj !== 'undefined' && obj !== null;
				};
				var hasSymbols = __webpack_require__(28)();
				var toObject = Object;
				var push = bind.call(Function.call, Array.prototype.push);
				var propIsEnumerable = bind.call(Function.call, Object.prototype.propertyIsEnumerable);
				var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;

				module.exports = function assign(target, source1) {
					if (!canBeObject(target)) {
						throw new TypeError('target must be an object');
					}
					var objTarget = toObject(target);
					var s, source, i, props, syms, value, key;
					for (s = 1; s < arguments.length; ++s) {
						source = toObject(arguments[s]);
						props = keys(source);
						var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
						if (getSymbols) {
							syms = getSymbols(source);
							for (i = 0; i < syms.length; ++i) {
								key = syms[i];
								if (propIsEnumerable(source, key)) {
									push(props, key);
								}
							}
						}
						for (i = 0; i < props.length; ++i) {
							key = props[i];
							value = source[key];
							if (propIsEnumerable(source, key)) {
								objTarget[key] = value;
							}
						}
					}
					return objTarget;
				};

				/***/
			},
			/* 28 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
					return typeof obj;
				} : function (obj) {
					return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
				};

				var keys = __webpack_require__(3);

				module.exports = function hasSymbols() {
					if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
						return false;
					}
					if (_typeof(Symbol.iterator) === 'symbol') {
						return true;
					}

					var obj = {};
					var sym = Symbol('test');
					var symObj = Object(sym);
					if (typeof sym === 'string') {
						return false;
					}

					if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
						return false;
					}
					if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
						return false;
					}

					// temp disabled per https://github.com/ljharb/object.assign/issues/17
					// if (sym instanceof Symbol) { return false; }
					// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
					// if (!(symObj instanceof Symbol)) { return false; }

					var symVal = 42;
					obj[sym] = symVal;
					for (sym in obj) {
						return false;
					}
					if (keys(obj).length !== 0) {
						return false;
					}
					if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
						return false;
					}

					if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
						return false;
					}

					var syms = Object.getOwnPropertySymbols(obj);
					if (syms.length !== 1 || syms[0] !== sym) {
						return false;
					}

					if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
						return false;
					}

					if (typeof Object.getOwnPropertyDescriptor === 'function') {
						var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
						if (descriptor.value !== symVal || descriptor.enumerable !== true) {
							return false;
						}
					}

					return true;
				};

				/***/
			},
			/* 29 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				var implementation = __webpack_require__(27);

				var lacksProperEnumerationOrder = function lacksProperEnumerationOrder() {
					if (!Object.assign) {
						return false;
					}
					// v8, specifically in node 4.x, has a bug with incorrect property enumeration order
					// note: this does not detect the bug unless there's 20 characters
					var str = 'abcdefghijklmnopqrst';
					var letters = str.split('');
					var map = {};
					for (var i = 0; i < letters.length; ++i) {
						map[letters[i]] = letters[i];
					}
					var obj = Object.assign({}, map);
					var actual = '';
					for (var k in obj) {
						actual += k;
					}
					return str !== actual;
				};

				var assignHasPendingExceptions = function assignHasPendingExceptions() {
					if (!Object.assign || !Object.preventExtensions) {
						return false;
					}
					// Firefox 37 still has "pending exception" logic in its Object.assign implementation,
					// which is 72% slower than our shim, and Firefox 40's native implementation.
					var thrower = Object.preventExtensions({ 1: 2 });
					try {
						Object.assign(thrower, 'xy');
					} catch (e) {
						return thrower[1] === 'y';
					}
					return false;
				};

				module.exports = function getPolyfill() {
					if (!Object.assign) {
						return implementation;
					}
					if (lacksProperEnumerationOrder()) {
						return implementation;
					}
					if (assignHasPendingExceptions()) {
						return implementation;
					}
					return Object.assign;
				};

				/***/
			},
			/* 30 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				var define = __webpack_require__(2);
				var getPolyfill = __webpack_require__(29);

				module.exports = function shimAssign() {
					var polyfill = getPolyfill();
					define(Object, { assign: polyfill }, { assign: function assign() {
							return Object.assign !== polyfill;
						} });
					return polyfill;
				};

				/***/
			},
			/* 31 */
			/***/function (module, exports, __webpack_require__) {

				var require;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__; /* WEBPACK VAR INJECTION */(function (process, global) {
					'use strict';

					var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
						return typeof obj;
					} : function (obj) {
						return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
					};

					/*!
      * @overview es6-promise - a tiny implementation of Promises/A+.
      * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
      * @license   Licensed under MIT license
      *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
      * @version   4.0.5
      */

					(function (global, factory) {
						(_typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : !(__WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
					})(undefined, function () {
						'use strict';

						function objectOrFunction(x) {
							return typeof x === 'function' || (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x !== null;
						}

						function isFunction(x) {
							return typeof x === 'function';
						}

						var _isArray = undefined;
						if (!Array.isArray) {
							_isArray = function _isArray(x) {
								return Object.prototype.toString.call(x) === '[object Array]';
							};
						} else {
							_isArray = Array.isArray;
						}

						var isArray = _isArray;

						var len = 0;
						var vertxNext = undefined;
						var customSchedulerFn = undefined;

						var asap = function asap(callback, arg) {
							queue[len] = callback;
							queue[len + 1] = arg;
							len += 2;
							if (len === 2) {
								// If len is 2, that means that we need to schedule an async flush.
								// If additional callbacks are queued before the queue is flushed, they
								// will be processed by this flush that we are scheduling.
								if (customSchedulerFn) {
									customSchedulerFn(flush);
								} else {
									scheduleFlush();
								}
							}
						};

						function setScheduler(scheduleFn) {
							customSchedulerFn = scheduleFn;
						}

						function setAsap(asapFn) {
							asap = asapFn;
						}

						var browserWindow = typeof window !== 'undefined' ? window : undefined;
						var browserGlobal = browserWindow || {};
						var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
						var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

						// test for web worker but not in IE10
						var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

						// node
						function useNextTick() {
							// node version 0.10.x displays a deprecation warning when nextTick is used recursively
							// see https://github.com/cujojs/when/issues/410 for details
							return function () {
								return process.nextTick(flush);
							};
						}

						// vertx
						function useVertxTimer() {
							if (typeof vertxNext !== 'undefined') {
								return function () {
									vertxNext(flush);
								};
							}

							return useSetTimeout();
						}

						function useMutationObserver() {
							var iterations = 0;
							var observer = new BrowserMutationObserver(flush);
							var node = document.createTextNode('');
							observer.observe(node, { characterData: true });

							return function () {
								node.data = iterations = ++iterations % 2;
							};
						}

						// web worker
						function useMessageChannel() {
							var channel = new MessageChannel();
							channel.port1.onmessage = flush;
							return function () {
								return channel.port2.postMessage(0);
							};
						}

						function useSetTimeout() {
							// Store setTimeout reference so es6-promise will be unaffected by
							// other code modifying setTimeout (like sinon.useFakeTimers())
							var globalSetTimeout = setTimeout;
							return function () {
								return globalSetTimeout(flush, 1);
							};
						}

						var queue = new Array(1000);
						function flush() {
							for (var i = 0; i < len; i += 2) {
								var callback = queue[i];
								var arg = queue[i + 1];

								callback(arg);

								queue[i] = undefined;
								queue[i + 1] = undefined;
							}

							len = 0;
						}

						function attemptVertx() {
							try {
								var r = require;
								var vertx = __webpack_require__(33);
								vertxNext = vertx.runOnLoop || vertx.runOnContext;
								return useVertxTimer();
							} catch (e) {
								return useSetTimeout();
							}
						}

						var scheduleFlush = undefined;
						// Decide what async method to use to triggering processing of queued callbacks:
						if (isNode) {
							scheduleFlush = useNextTick();
						} else if (BrowserMutationObserver) {
							scheduleFlush = useMutationObserver();
						} else if (isWorker) {
							scheduleFlush = useMessageChannel();
						} else if (browserWindow === undefined && "function" === 'function') {
							scheduleFlush = attemptVertx();
						} else {
							scheduleFlush = useSetTimeout();
						}

						function then(onFulfillment, onRejection) {
							var _arguments = arguments;

							var parent = this;

							var child = new this.constructor(noop);

							if (child[PROMISE_ID] === undefined) {
								makePromise(child);
							}

							var _state = parent._state;

							if (_state) {
								(function () {
									var callback = _arguments[_state - 1];
									asap(function () {
										return invokeCallback(_state, child, callback, parent._result);
									});
								})();
							} else {
								subscribe(parent, child, onFulfillment, onRejection);
							}

							return child;
						}

						/**
        `Promise.resolve` returns a promise that will become resolved with the
        passed `value`. It is shorthand for the following:
      
        ```javascript
        let promise = new Promise(function(resolve, reject){
          resolve(1);
        });
      
        promise.then(function(value){
          // value === 1
        });
        ```
      
        Instead of writing the above, your code now simply becomes the following:
      
        ```javascript
        let promise = Promise.resolve(1);
      
        promise.then(function(value){
          // value === 1
        });
        ```
      
        @method resolve
        @static
        @param {Any} value value that the returned promise will be resolved with
        Useful for tooling.
        @return {Promise} a promise that will become fulfilled with the given
        `value`
      */
						function resolve(object) {
							/*jshint validthis:true */
							var Constructor = this;

							if (object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object.constructor === Constructor) {
								return object;
							}

							var promise = new Constructor(noop);
							_resolve(promise, object);
							return promise;
						}

						var PROMISE_ID = Math.random().toString(36).substring(16);

						function noop() {}

						var PENDING = void 0;
						var FULFILLED = 1;
						var REJECTED = 2;

						var GET_THEN_ERROR = new ErrorObject();

						function selfFulfillment() {
							return new TypeError("You cannot resolve a promise with itself");
						}

						function cannotReturnOwn() {
							return new TypeError('A promises callback cannot return that same promise.');
						}

						function getThen(promise) {
							try {
								return promise.then;
							} catch (error) {
								GET_THEN_ERROR.error = error;
								return GET_THEN_ERROR;
							}
						}

						function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
							try {
								then.call(value, fulfillmentHandler, rejectionHandler);
							} catch (e) {
								return e;
							}
						}

						function handleForeignThenable(promise, thenable, then) {
							asap(function (promise) {
								var sealed = false;
								var error = tryThen(then, thenable, function (value) {
									if (sealed) {
										return;
									}
									sealed = true;
									if (thenable !== value) {
										_resolve(promise, value);
									} else {
										fulfill(promise, value);
									}
								}, function (reason) {
									if (sealed) {
										return;
									}
									sealed = true;

									_reject(promise, reason);
								}, 'Settle: ' + (promise._label || ' unknown promise'));

								if (!sealed && error) {
									sealed = true;
									_reject(promise, error);
								}
							}, promise);
						}

						function handleOwnThenable(promise, thenable) {
							if (thenable._state === FULFILLED) {
								fulfill(promise, thenable._result);
							} else if (thenable._state === REJECTED) {
								_reject(promise, thenable._result);
							} else {
								subscribe(thenable, undefined, function (value) {
									return _resolve(promise, value);
								}, function (reason) {
									return _reject(promise, reason);
								});
							}
						}

						function handleMaybeThenable(promise, maybeThenable, then$$) {
							if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {
								handleOwnThenable(promise, maybeThenable);
							} else {
								if (then$$ === GET_THEN_ERROR) {
									_reject(promise, GET_THEN_ERROR.error);
								} else if (then$$ === undefined) {
									fulfill(promise, maybeThenable);
								} else if (isFunction(then$$)) {
									handleForeignThenable(promise, maybeThenable, then$$);
								} else {
									fulfill(promise, maybeThenable);
								}
							}
						}

						function _resolve(promise, value) {
							if (promise === value) {
								_reject(promise, selfFulfillment());
							} else if (objectOrFunction(value)) {
								handleMaybeThenable(promise, value, getThen(value));
							} else {
								fulfill(promise, value);
							}
						}

						function publishRejection(promise) {
							if (promise._onerror) {
								promise._onerror(promise._result);
							}

							publish(promise);
						}

						function fulfill(promise, value) {
							if (promise._state !== PENDING) {
								return;
							}

							promise._result = value;
							promise._state = FULFILLED;

							if (promise._subscribers.length !== 0) {
								asap(publish, promise);
							}
						}

						function _reject(promise, reason) {
							if (promise._state !== PENDING) {
								return;
							}
							promise._state = REJECTED;
							promise._result = reason;

							asap(publishRejection, promise);
						}

						function subscribe(parent, child, onFulfillment, onRejection) {
							var _subscribers = parent._subscribers;
							var length = _subscribers.length;

							parent._onerror = null;

							_subscribers[length] = child;
							_subscribers[length + FULFILLED] = onFulfillment;
							_subscribers[length + REJECTED] = onRejection;

							if (length === 0 && parent._state) {
								asap(publish, parent);
							}
						}

						function publish(promise) {
							var subscribers = promise._subscribers;
							var settled = promise._state;

							if (subscribers.length === 0) {
								return;
							}

							var child = undefined,
							    callback = undefined,
							    detail = promise._result;

							for (var i = 0; i < subscribers.length; i += 3) {
								child = subscribers[i];
								callback = subscribers[i + settled];

								if (child) {
									invokeCallback(settled, child, callback, detail);
								} else {
									callback(detail);
								}
							}

							promise._subscribers.length = 0;
						}

						function ErrorObject() {
							this.error = null;
						}

						var TRY_CATCH_ERROR = new ErrorObject();

						function tryCatch(callback, detail) {
							try {
								return callback(detail);
							} catch (e) {
								TRY_CATCH_ERROR.error = e;
								return TRY_CATCH_ERROR;
							}
						}

						function invokeCallback(settled, promise, callback, detail) {
							var hasCallback = isFunction(callback),
							    value = undefined,
							    error = undefined,
							    succeeded = undefined,
							    failed = undefined;

							if (hasCallback) {
								value = tryCatch(callback, detail);

								if (value === TRY_CATCH_ERROR) {
									failed = true;
									error = value.error;
									value = null;
								} else {
									succeeded = true;
								}

								if (promise === value) {
									_reject(promise, cannotReturnOwn());
									return;
								}
							} else {
								value = detail;
								succeeded = true;
							}

							if (promise._state !== PENDING) {
								// noop
							} else if (hasCallback && succeeded) {
								_resolve(promise, value);
							} else if (failed) {
								_reject(promise, error);
							} else if (settled === FULFILLED) {
								fulfill(promise, value);
							} else if (settled === REJECTED) {
								_reject(promise, value);
							}
						}

						function initializePromise(promise, resolver) {
							try {
								resolver(function resolvePromise(value) {
									_resolve(promise, value);
								}, function rejectPromise(reason) {
									_reject(promise, reason);
								});
							} catch (e) {
								_reject(promise, e);
							}
						}

						var id = 0;
						function nextId() {
							return id++;
						}

						function makePromise(promise) {
							promise[PROMISE_ID] = id++;
							promise._state = undefined;
							promise._result = undefined;
							promise._subscribers = [];
						}

						function Enumerator(Constructor, input) {
							this._instanceConstructor = Constructor;
							this.promise = new Constructor(noop);

							if (!this.promise[PROMISE_ID]) {
								makePromise(this.promise);
							}

							if (isArray(input)) {
								this._input = input;
								this.length = input.length;
								this._remaining = input.length;

								this._result = new Array(this.length);

								if (this.length === 0) {
									fulfill(this.promise, this._result);
								} else {
									this.length = this.length || 0;
									this._enumerate();
									if (this._remaining === 0) {
										fulfill(this.promise, this._result);
									}
								}
							} else {
								_reject(this.promise, validationError());
							}
						}

						function validationError() {
							return new Error('Array Methods must be provided an Array');
						}

						Enumerator.prototype._enumerate = function () {
							var length = this.length;
							var _input = this._input;

							for (var i = 0; this._state === PENDING && i < length; i++) {
								this._eachEntry(_input[i], i);
							}
						};

						Enumerator.prototype._eachEntry = function (entry, i) {
							var c = this._instanceConstructor;
							var resolve$$ = c.resolve;

							if (resolve$$ === resolve) {
								var _then = getThen(entry);

								if (_then === then && entry._state !== PENDING) {
									this._settledAt(entry._state, i, entry._result);
								} else if (typeof _then !== 'function') {
									this._remaining--;
									this._result[i] = entry;
								} else if (c === Promise) {
									var promise = new c(noop);
									handleMaybeThenable(promise, entry, _then);
									this._willSettleAt(promise, i);
								} else {
									this._willSettleAt(new c(function (resolve$$) {
										return resolve$$(entry);
									}), i);
								}
							} else {
								this._willSettleAt(resolve$$(entry), i);
							}
						};

						Enumerator.prototype._settledAt = function (state, i, value) {
							var promise = this.promise;

							if (promise._state === PENDING) {
								this._remaining--;

								if (state === REJECTED) {
									_reject(promise, value);
								} else {
									this._result[i] = value;
								}
							}

							if (this._remaining === 0) {
								fulfill(promise, this._result);
							}
						};

						Enumerator.prototype._willSettleAt = function (promise, i) {
							var enumerator = this;

							subscribe(promise, undefined, function (value) {
								return enumerator._settledAt(FULFILLED, i, value);
							}, function (reason) {
								return enumerator._settledAt(REJECTED, i, reason);
							});
						};

						/**
        `Promise.all` accepts an array of promises, and returns a new promise which
        is fulfilled with an array of fulfillment values for the passed promises, or
        rejected with the reason of the first passed promise to be rejected. It casts all
        elements of the passed iterable to promises as it runs this algorithm.
      
        Example:
      
        ```javascript
        let promise1 = resolve(1);
        let promise2 = resolve(2);
        let promise3 = resolve(3);
        let promises = [ promise1, promise2, promise3 ];
      
        Promise.all(promises).then(function(array){
          // The array here would be [ 1, 2, 3 ];
        });
        ```
      
        If any of the `promises` given to `all` are rejected, the first promise
        that is rejected will be given as an argument to the returned promises's
        rejection handler. For example:
      
        Example:
      
        ```javascript
        let promise1 = resolve(1);
        let promise2 = reject(new Error("2"));
        let promise3 = reject(new Error("3"));
        let promises = [ promise1, promise2, promise3 ];
      
        Promise.all(promises).then(function(array){
          // Code here never runs because there are rejected promises!
        }, function(error) {
          // error.message === "2"
        });
        ```
      
        @method all
        @static
        @param {Array} entries array of promises
        @param {String} label optional string for labeling the promise.
        Useful for tooling.
        @return {Promise} promise that is fulfilled when all `promises` have been
        fulfilled, or rejected if any of them become rejected.
        @static
      */
						function all(entries) {
							return new Enumerator(this, entries).promise;
						}

						/**
        `Promise.race` returns a new promise which is settled in the same way as the
        first passed promise to settle.
      
        Example:
      
        ```javascript
        let promise1 = new Promise(function(resolve, reject){
          setTimeout(function(){
            resolve('promise 1');
          }, 200);
        });
      
        let promise2 = new Promise(function(resolve, reject){
          setTimeout(function(){
            resolve('promise 2');
          }, 100);
        });
      
        Promise.race([promise1, promise2]).then(function(result){
          // result === 'promise 2' because it was resolved before promise1
          // was resolved.
        });
        ```
      
        `Promise.race` is deterministic in that only the state of the first
        settled promise matters. For example, even if other promises given to the
        `promises` array argument are resolved, but the first settled promise has
        become rejected before the other promises became fulfilled, the returned
        promise will become rejected:
      
        ```javascript
        let promise1 = new Promise(function(resolve, reject){
          setTimeout(function(){
            resolve('promise 1');
          }, 200);
        });
      
        let promise2 = new Promise(function(resolve, reject){
          setTimeout(function(){
            reject(new Error('promise 2'));
          }, 100);
        });
      
        Promise.race([promise1, promise2]).then(function(result){
          // Code here never runs
        }, function(reason){
          // reason.message === 'promise 2' because promise 2 became rejected before
          // promise 1 became fulfilled
        });
        ```
      
        An example real-world use case is implementing timeouts:
      
        ```javascript
        Promise.race([ajax('foo.json'), timeout(5000)])
        ```
      
        @method race
        @static
        @param {Array} promises array of promises to observe
        Useful for tooling.
        @return {Promise} a promise which settles in the same way as the first passed
        promise to settle.
      */
						function race(entries) {
							/*jshint validthis:true */
							var Constructor = this;

							if (!isArray(entries)) {
								return new Constructor(function (_, reject) {
									return reject(new TypeError('You must pass an array to race.'));
								});
							} else {
								return new Constructor(function (resolve, reject) {
									var length = entries.length;
									for (var i = 0; i < length; i++) {
										Constructor.resolve(entries[i]).then(resolve, reject);
									}
								});
							}
						}

						/**
        `Promise.reject` returns a promise rejected with the passed `reason`.
        It is shorthand for the following:
      
        ```javascript
        let promise = new Promise(function(resolve, reject){
          reject(new Error('WHOOPS'));
        });
      
        promise.then(function(value){
          // Code here doesn't run because the promise is rejected!
        }, function(reason){
          // reason.message === 'WHOOPS'
        });
        ```
      
        Instead of writing the above, your code now simply becomes the following:
      
        ```javascript
        let promise = Promise.reject(new Error('WHOOPS'));
      
        promise.then(function(value){
          // Code here doesn't run because the promise is rejected!
        }, function(reason){
          // reason.message === 'WHOOPS'
        });
        ```
      
        @method reject
        @static
        @param {Any} reason value that the returned promise will be rejected with.
        Useful for tooling.
        @return {Promise} a promise rejected with the given `reason`.
      */
						function reject(reason) {
							/*jshint validthis:true */
							var Constructor = this;
							var promise = new Constructor(noop);
							_reject(promise, reason);
							return promise;
						}

						function needsResolver() {
							throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
						}

						function needsNew() {
							throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
						}

						/**
        Promise objects represent the eventual result of an asynchronous operation. The
        primary way of interacting with a promise is through its `then` method, which
        registers callbacks to receive either a promise's eventual value or the reason
        why the promise cannot be fulfilled.
      
        Terminology
        -----------
      
        - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
        - `thenable` is an object or function that defines a `then` method.
        - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
        - `exception` is a value that is thrown using the throw statement.
        - `reason` is a value that indicates why a promise was rejected.
        - `settled` the final resting state of a promise, fulfilled or rejected.
      
        A promise can be in one of three states: pending, fulfilled, or rejected.
      
        Promises that are fulfilled have a fulfillment value and are in the fulfilled
        state.  Promises that are rejected have a rejection reason and are in the
        rejected state.  A fulfillment value is never a thenable.
      
        Promises can also be said to *resolve* a value.  If this value is also a
        promise, then the original promise's settled state will match the value's
        settled state.  So a promise that *resolves* a promise that rejects will
        itself reject, and a promise that *resolves* a promise that fulfills will
        itself fulfill.
      
      
        Basic Usage:
        ------------
      
        ```js
        let promise = new Promise(function(resolve, reject) {
          // on success
          resolve(value);
      
          // on failure
          reject(reason);
        });
      
        promise.then(function(value) {
          // on fulfillment
        }, function(reason) {
          // on rejection
        });
        ```
      
        Advanced Usage:
        ---------------
      
        Promises shine when abstracting away asynchronous interactions such as
        `XMLHttpRequest`s.
      
        ```js
        function getJSON(url) {
          return new Promise(function(resolve, reject){
            let xhr = new XMLHttpRequest();
      
            xhr.open('GET', url);
            xhr.onreadystatechange = handler;
            xhr.responseType = 'json';
            xhr.setRequestHeader('Accept', 'application/json');
            xhr.send();
      
            function handler() {
              if (this.readyState === this.DONE) {
                if (this.status === 200) {
                  resolve(this.response);
                } else {
                  reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
                }
              }
            };
          });
        }
      
        getJSON('/posts.json').then(function(json) {
          // on fulfillment
        }, function(reason) {
          // on rejection
        });
        ```
      
        Unlike callbacks, promises are great composable primitives.
      
        ```js
        Promise.all([
          getJSON('/posts'),
          getJSON('/comments')
        ]).then(function(values){
          values[0] // => postsJSON
          values[1] // => commentsJSON
      
          return values;
        });
        ```
      
        @class Promise
        @param {function} resolver
        Useful for tooling.
        @constructor
      */
						function Promise(resolver) {
							this[PROMISE_ID] = nextId();
							this._result = this._state = undefined;
							this._subscribers = [];

							if (noop !== resolver) {
								typeof resolver !== 'function' && needsResolver();
								this instanceof Promise ? initializePromise(this, resolver) : needsNew();
							}
						}

						Promise.all = all;
						Promise.race = race;
						Promise.resolve = resolve;
						Promise.reject = reject;
						Promise._setScheduler = setScheduler;
						Promise._setAsap = setAsap;
						Promise._asap = asap;

						Promise.prototype = {
							constructor: Promise,

							/**
         The primary way of interacting with a promise is through its `then` method,
         which registers callbacks to receive either a promise's eventual value or the
         reason why the promise cannot be fulfilled.
       
         ```js
         findUser().then(function(user){
           // user is available
         }, function(reason){
           // user is unavailable, and you are given the reason why
         });
         ```
       
         Chaining
         --------
       
         The return value of `then` is itself a promise.  This second, 'downstream'
         promise is resolved with the return value of the first promise's fulfillment
         or rejection handler, or rejected if the handler throws an exception.
       
         ```js
         findUser().then(function (user) {
           return user.name;
         }, function (reason) {
           return 'default name';
         }).then(function (userName) {
           // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
           // will be `'default name'`
         });
       
         findUser().then(function (user) {
           throw new Error('Found user, but still unhappy');
         }, function (reason) {
           throw new Error('`findUser` rejected and we're unhappy');
         }).then(function (value) {
           // never reached
         }, function (reason) {
           // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
           // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
         });
         ```
         If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
       
         ```js
         findUser().then(function (user) {
           throw new PedagogicalException('Upstream error');
         }).then(function (value) {
           // never reached
         }).then(function (value) {
           // never reached
         }, function (reason) {
           // The `PedgagocialException` is propagated all the way down to here
         });
         ```
       
         Assimilation
         ------------
       
         Sometimes the value you want to propagate to a downstream promise can only be
         retrieved asynchronously. This can be achieved by returning a promise in the
         fulfillment or rejection handler. The downstream promise will then be pending
         until the returned promise is settled. This is called *assimilation*.
       
         ```js
         findUser().then(function (user) {
           return findCommentsByAuthor(user);
         }).then(function (comments) {
           // The user's comments are now available
         });
         ```
       
         If the assimliated promise rejects, then the downstream promise will also reject.
       
         ```js
         findUser().then(function (user) {
           return findCommentsByAuthor(user);
         }).then(function (comments) {
           // If `findCommentsByAuthor` fulfills, we'll have the value here
         }, function (reason) {
           // If `findCommentsByAuthor` rejects, we'll have the reason here
         });
         ```
       
         Simple Example
         --------------
       
         Synchronous Example
       
         ```javascript
         let result;
       
         try {
           result = findResult();
           // success
         } catch(reason) {
           // failure
         }
         ```
       
         Errback Example
       
         ```js
         findResult(function(result, err){
           if (err) {
             // failure
           } else {
             // success
           }
         });
         ```
       
         Promise Example;
       
         ```javascript
         findResult().then(function(result){
           // success
         }, function(reason){
           // failure
         });
         ```
       
         Advanced Example
         --------------
       
         Synchronous Example
       
         ```javascript
         let author, books;
       
         try {
           author = findAuthor();
           books  = findBooksByAuthor(author);
           // success
         } catch(reason) {
           // failure
         }
         ```
       
         Errback Example
       
         ```js
       
         function foundBooks(books) {
       
         }
       
         function failure(reason) {
       
         }
       
         findAuthor(function(author, err){
           if (err) {
             failure(err);
             // failure
           } else {
             try {
               findBoooksByAuthor(author, function(books, err) {
                 if (err) {
                   failure(err);
                 } else {
                   try {
                     foundBooks(books);
                   } catch(reason) {
                     failure(reason);
                   }
                 }
               });
             } catch(error) {
               failure(err);
             }
             // success
           }
         });
         ```
       
         Promise Example;
       
         ```javascript
         findAuthor().
           then(findBooksByAuthor).
           then(function(books){
             // found books
         }).catch(function(reason){
           // something went wrong
         });
         ```
       
         @method then
         @param {Function} onFulfilled
         @param {Function} onRejected
         Useful for tooling.
         @return {Promise}
       */
							then: then,

							/**
         `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
         as the catch block of a try/catch statement.
       
         ```js
         function findAuthor(){
           throw new Error('couldn't find that author');
         }
       
         // synchronous
         try {
           findAuthor();
         } catch(reason) {
           // something went wrong
         }
       
         // async with promises
         findAuthor().catch(function(reason){
           // something went wrong
         });
         ```
       
         @method catch
         @param {Function} onRejection
         Useful for tooling.
         @return {Promise}
       */
							'catch': function _catch(onRejection) {
								return this.then(null, onRejection);
							}
						};

						function polyfill() {
							var local = undefined;

							if (typeof global !== 'undefined') {
								local = global;
							} else if (typeof self !== 'undefined') {
								local = self;
							} else {
								try {
									local = Function('return this')();
								} catch (e) {
									throw new Error('polyfill failed because global object is unavailable in this environment');
								}
							}

							var P = local.Promise;

							if (P) {
								var promiseToString = null;
								try {
									promiseToString = Object.prototype.toString.call(P.resolve());
								} catch (e) {
									// silently ignored
								}

								if (promiseToString === '[object Promise]' && !P.cast) {
									return;
								}
							}

							local.Promise = Promise;
						}

						// Strange compat..
						Promise.polyfill = polyfill;
						Promise.Promise = Promise;

						return Promise;
					});
					
					/* WEBPACK VAR INJECTION */
				}).call(exports, __webpack_require__(32), function () {
					return this;
				}());

				/***/
			},
			/* 32 */
			/***/function (module, exports) {

				'use strict';

				// shim for using process in browser

				var process = module.exports = {};

				// cached from whatever global is present so that test runners that stub it
				// don't break things.  But we need to wrap it in a try catch in case it is
				// wrapped in strict mode code which doesn't define any globals.  It's inside a
				// function because try/catches deoptimize in certain engines.

				var cachedSetTimeout;
				var cachedClearTimeout;

				function defaultSetTimout() {
					throw new Error('setTimeout has not been defined');
				}
				function defaultClearTimeout() {
					throw new Error('clearTimeout has not been defined');
				}
				(function () {
					try {
						if (typeof setTimeout === 'function') {
							cachedSetTimeout = setTimeout;
						} else {
							cachedSetTimeout = defaultSetTimout;
						}
					} catch (e) {
						cachedSetTimeout = defaultSetTimout;
					}
					try {
						if (typeof clearTimeout === 'function') {
							cachedClearTimeout = clearTimeout;
						} else {
							cachedClearTimeout = defaultClearTimeout;
						}
					} catch (e) {
						cachedClearTimeout = defaultClearTimeout;
					}
				})();
				function runTimeout(fun) {
					if (cachedSetTimeout === setTimeout) {
						//normal enviroments in sane situations
						return setTimeout(fun, 0);
					}
					// if setTimeout wasn't available but was latter defined
					if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
						cachedSetTimeout = setTimeout;
						return setTimeout(fun, 0);
					}
					try {
						// when when somebody has screwed with setTimeout but no I.E. maddness
						return cachedSetTimeout(fun, 0);
					} catch (e) {
						try {
							// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
							return cachedSetTimeout.call(null, fun, 0);
						} catch (e) {
							// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
							return cachedSetTimeout.call(this, fun, 0);
						}
					}
				}
				function runClearTimeout(marker) {
					if (cachedClearTimeout === clearTimeout) {
						//normal enviroments in sane situations
						return clearTimeout(marker);
					}
					// if clearTimeout wasn't available but was latter defined
					if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
						cachedClearTimeout = clearTimeout;
						return clearTimeout(marker);
					}
					try {
						// when when somebody has screwed with setTimeout but no I.E. maddness
						return cachedClearTimeout(marker);
					} catch (e) {
						try {
							// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
							return cachedClearTimeout.call(null, marker);
						} catch (e) {
							// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
							// Some versions of I.E. have different rules for clearTimeout vs setTimeout
							return cachedClearTimeout.call(this, marker);
						}
					}
				}
				var queue = [];
				var draining = false;
				var currentQueue;
				var queueIndex = -1;

				function cleanUpNextTick() {
					if (!draining || !currentQueue) {
						return;
					}
					draining = false;
					if (currentQueue.length) {
						queue = currentQueue.concat(queue);
					} else {
						queueIndex = -1;
					}
					if (queue.length) {
						drainQueue();
					}
				}

				function drainQueue() {
					if (draining) {
						return;
					}
					var timeout = runTimeout(cleanUpNextTick);
					draining = true;

					var len = queue.length;
					while (len) {
						currentQueue = queue;
						queue = [];
						while (++queueIndex < len) {
							if (currentQueue) {
								currentQueue[queueIndex].run();
							}
						}
						queueIndex = -1;
						len = queue.length;
					}
					currentQueue = null;
					draining = false;
					runClearTimeout(timeout);
				}

				process.nextTick = function (fun) {
					var args = new Array(arguments.length - 1);
					if (arguments.length > 1) {
						for (var i = 1; i < arguments.length; i++) {
							args[i - 1] = arguments[i];
						}
					}
					queue.push(new Item(fun, args));
					if (queue.length === 1 && !draining) {
						runTimeout(drainQueue);
					}
				};

				// v8 likes predictible objects
				function Item(fun, array) {
					this.fun = fun;
					this.array = array;
				}
				Item.prototype.run = function () {
					this.fun.apply(null, this.array);
				};
				process.title = 'browser';
				process.browser = true;
				process.env = {};
				process.argv = [];
				process.version = ''; // empty string to avoid regexp issues
				process.versions = {};

				function noop() {}

				process.on = noop;
				process.addListener = noop;
				process.once = noop;
				process.off = noop;
				process.removeListener = noop;
				process.removeAllListeners = noop;
				process.emit = noop;

				process.binding = function (name) {
					throw new Error('process.binding is not supported');
				};

				process.cwd = function () {
					return '/';
				};
				process.chdir = function (dir) {
					throw new Error('process.chdir is not supported');
				};
				process.umask = function () {
					return 0;
				};

				/***/
			},
			/* 33 */
			/***/function (module, exports) {

				/* (ignored) */

				/***/},
			/* 34 */
			/***/function (module, exports) {

				"use strict";

				window.customElements && eval("/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * This shim allows elements written in, or compiled to, ES5 to work on native\n * implementations of Custom Elements.\n *\n * ES5-style classes don't work with native Custom Elements because the\n * HTMLElement constructor uses the value of `new.target` to look up the custom\n * element definition for the currently called constructor. `new.target` is only\n * set when `new` is called and is only propagated via super() calls. super()\n * is not emulatable in ES5. The pattern of `SuperClass.call(this)`` only works\n * when extending other ES5-style classes, and does not propagate `new.target`.\n *\n * This shim allows the native HTMLElement constructor to work by generating and\n * registering a stand-in class instead of the users custom element class. This\n * stand-in class's constructor has an actual call to super().\n * `customElements.define()` and `customElements.get()` are both overridden to\n * hide this stand-in class from users.\n *\n * In order to create instance of the user-defined class, rather than the stand\n * in, the stand-in's constructor swizzles its instances prototype and invokes\n * the user-defined constructor. When the user-defined constructor is called\n * directly it creates an instance of the stand-in class to get a real extension\n * of HTMLElement and returns that.\n *\n * There are two important constructors: A patched HTMLElement constructor, and\n * the StandInElement constructor. They both will be called to create an element\n * but which is called first depends on whether the browser creates the element\n * or the user-defined constructor is called directly. The variables\n * `browserConstruction` and `userConstruction` control the flow between the\n * two constructors.\n *\n * This shim should be better than forcing the polyfill because:\n *   1. It's smaller\n *   2. All reaction timings are the same as native (mostly synchronous)\n *   3. All reaction triggering DOM operations are automatically supported\n *\n * There are some restrictions and requirements on ES5 constructors:\n *   1. All constructors in a inheritance hierarchy must be ES5-style, so that\n *      they can be called with Function.call(). This effectively means that the\n *      whole application must be compiled to ES5.\n *   2. Constructors must return the value of the emulated super() call. Like\n *      `return SuperClass.call(this)`\n *   3. The `this` reference should not be used before the emulated super() call\n *      just like `this` is illegal to use before super() in ES6.\n *   4. Constructors should not create other custom elements before the emulated\n *      super() call. This is the same restriction as with native custom\n *      elements.\n *\n *  Compiling valid class-based custom elements to ES5 will satisfy these\n *  requirements with the latest version of popular transpilers.\n */\n(() => {\n  'use strict';\n\n  // Do nothing if `customElements` does not exist.\n  if (!window.customElements) return;\n\n  const NativeHTMLElement = window.HTMLElement;\n  const nativeDefine = window.customElements.define;\n  const nativeGet = window.customElements.get;\n\n  /**\n   * Map of user-provided constructors to tag names.\n   *\n   * @type {Map<Function, string>}\n   */\n  const tagnameByConstructor = new Map();\n\n  /**\n   * Map of tag names to user-provided constructors.\n   *\n   * @type {Map<string, Function>}\n   */\n  const constructorByTagname = new Map();\n\n\n  /**\n   * Whether the constructors are being called by a browser process, ie parsing\n   * or createElement.\n   */\n  let browserConstruction = false;\n\n  /**\n   * Whether the constructors are being called by a user-space process, ie\n   * calling an element constructor.\n   */\n  let userConstruction = false;\n\n  window.HTMLElement = function() {\n    if (!browserConstruction) {\n      const tagname = tagnameByConstructor.get(this.constructor);\n      const fakeClass = nativeGet.call(window.customElements, tagname);\n\n      // Make sure that the fake constructor doesn't call back to this constructor\n      userConstruction = true;\n      const instance = new (fakeClass)();\n      return instance;\n    }\n    // Else do nothing. This will be reached by ES5-style classes doing\n    // HTMLElement.call() during initialization\n    browserConstruction = false;\n  };\n  // By setting the patched HTMLElement's prototype property to the native\n  // HTMLElement's prototype we make sure that:\n  //     document.createElement('a') instanceof HTMLElement\n  // works because instanceof uses HTMLElement.prototype, which is on the\n  // ptototype chain of built-in elements.\n  window.HTMLElement.prototype = NativeHTMLElement.prototype;\n\n  window.customElements.define = (tagname, elementClass) => {\n    const elementProto = elementClass.prototype;\n    const StandInElement = class extends NativeHTMLElement {\n      constructor() {\n        // Call the native HTMLElement constructor, this gives us the\n        // under-construction instance as `this`:\n        super();\n\n        // The prototype will be wrong up because the browser used our fake\n        // class, so fix it:\n        Object.setPrototypeOf(this, elementProto);\n\n        if (!userConstruction) {\n          // Make sure that user-defined constructor bottom's out to a do-nothing\n          // HTMLElement() call\n          browserConstruction = true;\n          // Call the user-defined constructor on our instance:\n          elementClass.call(this);\n        }\n        userConstruction = false;\n      }\n    };\n    const standInProto = StandInElement.prototype;\n    StandInElement.observedAttributes = elementClass.observedAttributes;\n    standInProto.connectedCallback = elementProto.connectedCallback;\n    standInProto.disconnectedCallback = elementProto.disconnectedCallback;\n    standInProto.attributeChangedCallback = elementProto.attributeChangedCallback;\n    standInProto.adoptedCallback = elementProto.adoptedCallback;\n\n    tagnameByConstructor.set(elementClass, tagname);\n    constructorByTagname.set(tagname, elementClass);\n    nativeDefine.call(window.customElements, tagname, StandInElement);\n  };\n\n  window.customElements.get = (tagname) => constructorByTagname.get(tagname);\n\n})();\n");

				/***/
			},
			/* 35 */
			/***/function (module, exports) {

				'use strict';

				/**
     * @license
     * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
     */

				// minimal template polyfill

				(function () {

					var needsTemplate = typeof HTMLTemplateElement === 'undefined';

					// NOTE: Patch document.importNode to work around IE11 bug that
					// casues children of a document fragment imported while
					// there is a mutation observer to not have a parentNode (!?!)
					// It's important that this is the first patch to `importNode` so that
					// dom produced for later patches is correct.
					if (/Trident/.test(navigator.userAgent)) {
						(function () {
							var Native_importNode = Document.prototype.importNode;
							Document.prototype.importNode = function () {
								var n = Native_importNode.apply(this, arguments);
								// Copy all children to a new document fragment since
								// this one may be broken
								if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
									var f = this.createDocumentFragment();
									f.appendChild(n);
									return f;
								} else {
									return n;
								}
							};
						})();
					}

					// NOTE: we rely on this cloneNode not causing element upgrade.
					// This means this polyfill must load before the CE polyfill and
					// this would need to be re-worked if a browser supports native CE
					// but not <template>.
					var Native_cloneNode = Node.prototype.cloneNode;
					var Native_createElement = Document.prototype.createElement;
					var Native_importNode = Document.prototype.importNode;

					// returns true if nested templates cannot be cloned (they cannot be on
					// some impl's like Safari 8 and Edge)
					// OR if cloning a document fragment does not result in a document fragment
					var needsCloning = function () {
						if (!needsTemplate) {
							var t = document.createElement('template');
							var t2 = document.createElement('template');
							t2.content.appendChild(document.createElement('div'));
							t.content.appendChild(t2);
							var clone = t.cloneNode(true);
							return clone.content.childNodes.length === 0 || clone.content.firstChild.content.childNodes.length === 0 || !(document.createDocumentFragment().cloneNode() instanceof DocumentFragment);
						}
					}();

					var TEMPLATE_TAG = 'template';
					var PolyfilledHTMLTemplateElement = function PolyfilledHTMLTemplateElement() {};

					if (needsTemplate) {
						var contentDoc;
						var canDecorate;
						var templateStyle;
						var head;
						var canProtoPatch;
						var escapeDataRegExp;

						(function () {
							var defineInnerHTML = function defineInnerHTML(obj) {
								Object.defineProperty(obj, 'innerHTML', {
									get: function get() {
										var o = '';
										for (var e = this.content.firstChild; e; e = e.nextSibling) {
											o += e.outerHTML || escapeData(e.data);
										}
										return o;
									},
									set: function set(text) {
										contentDoc.body.innerHTML = text;
										PolyfilledHTMLTemplateElement.bootstrap(contentDoc);
										while (this.content.firstChild) {
											this.content.removeChild(this.content.firstChild);
										}
										while (contentDoc.body.firstChild) {
											this.content.appendChild(contentDoc.body.firstChild);
										}
									},
									configurable: true
								});
							};

							var escapeReplace = function escapeReplace(c) {
								switch (c) {
									case '&':
										return '&amp;';
									case '<':
										return '&lt;';
									case '>':
										return '&gt;';
									case '\xA0':
										return '&nbsp;';
								}
							};

							var escapeData = function escapeData(s) {
								return s.replace(escapeDataRegExp, escapeReplace);
							};

							contentDoc = document.implementation.createHTMLDocument('template');
							canDecorate = true;
							templateStyle = document.createElement('style');

							templateStyle.textContent = TEMPLATE_TAG + '{display:none;}';

							head = document.head;

							head.insertBefore(templateStyle, head.firstElementChild);

							/**
         Provides a minimal shim for the <template> element.
       */
							PolyfilledHTMLTemplateElement.prototype = Object.create(HTMLElement.prototype);

							// if elements do not have `innerHTML` on instances, then
							// templates can be patched by swizzling their prototypes.
							canProtoPatch = !document.createElement('div').hasOwnProperty('innerHTML');

							/**
         The `decorate` method moves element children to the template's `content`.
         NOTE: there is no support for dynamically adding elements to templates.
       */

							PolyfilledHTMLTemplateElement.decorate = function (template) {
								// if the template is decorated, return fast
								if (template.content) {
									return;
								}
								template.content = contentDoc.createDocumentFragment();
								var child;
								while (child = template.firstChild) {
									template.content.appendChild(child);
								}
								// NOTE: prefer prototype patching for performance and
								// because on some browsers (IE11), re-defining `innerHTML`
								// can result in intermittent errors.
								if (canProtoPatch) {
									template.__proto__ = PolyfilledHTMLTemplateElement.prototype;
								} else {
									template.cloneNode = function (deep) {
										return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
									};
									// add innerHTML to template, if possible
									// Note: this throws on Safari 7
									if (canDecorate) {
										try {
											defineInnerHTML(template);
										} catch (err) {
											canDecorate = false;
										}
									}
								}
								// bootstrap recursively
								PolyfilledHTMLTemplateElement.bootstrap(template.content);
							};

							defineInnerHTML(PolyfilledHTMLTemplateElement.prototype);

							/**
         The `bootstrap` method is called automatically and "fixes" all
         <template> elements in the document referenced by the `doc` argument.
       */
							PolyfilledHTMLTemplateElement.bootstrap = function (doc) {
								var templates = doc.querySelectorAll(TEMPLATE_TAG);
								for (var i = 0, l = templates.length, t; i < l && (t = templates[i]); i++) {
									PolyfilledHTMLTemplateElement.decorate(t);
								}
							};

							// auto-bootstrapping for main document
							document.addEventListener('DOMContentLoaded', function () {
								PolyfilledHTMLTemplateElement.bootstrap(document);
							});

							// Patch document.createElement to ensure newly created templates have content
							Document.prototype.createElement = function () {
								'use strict';

								var el = Native_createElement.apply(this, arguments);
								if (el.localName === 'template') {
									PolyfilledHTMLTemplateElement.decorate(el);
								}
								return el;
							};

							escapeDataRegExp = /[&\u00A0<>]/g;
						})();
					}

					// make cloning/importing work!
					if (needsTemplate || needsCloning) {

						PolyfilledHTMLTemplateElement._cloneNode = function (template, deep) {
							var clone = Native_cloneNode.call(template, false);
							// NOTE: decorate doesn't auto-fix children because they are already
							// decorated so they need special clone fixup.
							if (this.decorate) {
								this.decorate(clone);
							}
							if (deep) {
								// NOTE: use native clone node to make sure CE's wrapped
								// cloneNode does not cause elements to upgrade.
								clone.content.appendChild(Native_cloneNode.call(template.content, true));
								// now ensure nested templates are cloned correctly.
								this.fixClonedDom(clone.content, template.content);
							}
							return clone;
						};

						PolyfilledHTMLTemplateElement.prototype.cloneNode = function (deep) {
							return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
						};

						// Given a source and cloned subtree, find <template>'s in the cloned
						// subtree and replace them with cloned <template>'s from source.
						// We must do this because only the source templates have proper .content.
						PolyfilledHTMLTemplateElement.fixClonedDom = function (clone, source) {
							// do nothing if cloned node is not an element
							if (!source.querySelectorAll) return;
							// these two lists should be coincident
							var s$ = source.querySelectorAll(TEMPLATE_TAG);
							var t$ = clone.querySelectorAll(TEMPLATE_TAG);
							for (var i = 0, l = t$.length, t, s; i < l; i++) {
								s = s$[i];
								t = t$[i];
								if (this.decorate) {
									this.decorate(s);
								}
								t.parentNode.replaceChild(s.cloneNode(true), t);
							}
						};

						// override all cloning to fix the cloned subtree to contain properly
						// cloned templates.
						Node.prototype.cloneNode = function (deep) {
							var dom;
							// workaround for Edge bug cloning documentFragments
							// https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8619646/
							if (this instanceof DocumentFragment) {
								if (!deep) {
									return this.ownerDocument.createDocumentFragment();
								} else {
									dom = this.ownerDocument.importNode(this, true);
								}
							} else {
								dom = Native_cloneNode.call(this, deep);
							}
							// template.content is cloned iff `deep`.
							if (deep) {
								PolyfilledHTMLTemplateElement.fixClonedDom(dom, this);
							}
							return dom;
						};

						// NOTE: we are cloning instead of importing <template>'s.
						// However, the ownerDocument of the cloned template will be correct!
						// This is because the native import node creates the right document owned
						// subtree and `fixClonedDom` inserts cloned templates into this subtree,
						// thus updating the owner doc.
						Document.prototype.importNode = function (element, deep) {
							if (element.localName === TEMPLATE_TAG) {
								return PolyfilledHTMLTemplateElement._cloneNode(element, deep);
							} else {
								var dom = Native_importNode.call(this, element, deep);
								if (deep) {
									PolyfilledHTMLTemplateElement.fixClonedDom(dom, element);
								}
								return dom;
							}
						};

						if (needsCloning) {
							window.HTMLTemplateElement.prototype.cloneNode = function (deep) {
								return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
							};
						}
					}

					if (needsTemplate) {
						window.HTMLTemplateElement = PolyfilledHTMLTemplateElement;
					}
				})();

				/***/
			},
			/* 36 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				var _CustomElementInternals = __webpack_require__(37);

				var _CustomElementInternals2 = _interopRequireDefault(_CustomElementInternals);

				var _CustomElementRegistry = __webpack_require__(40);

				var _CustomElementRegistry2 = _interopRequireDefault(_CustomElementRegistry);

				var _HTMLElement = __webpack_require__(43);

				var _HTMLElement2 = _interopRequireDefault(_HTMLElement);

				var _Document = __webpack_require__(46);

				var _Document2 = _interopRequireDefault(_Document);

				var _Node = __webpack_require__(48);

				var _Node2 = _interopRequireDefault(_Node);

				var _Element = __webpack_require__(49);

				var _Element2 = _interopRequireDefault(_Element);

				function _interopRequireDefault(obj) {
					return obj && obj.__esModule ? obj : { default: obj };
				}

				/**
     * @license
     * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
     */

				var priorCustomElements = window['customElements'];

				if (!priorCustomElements || priorCustomElements['forcePolyfill'] || typeof priorCustomElements['define'] != 'function' || typeof priorCustomElements['get'] != 'function') {
					/** @type {!CustomElementInternals} */
					var internals = new _CustomElementInternals2.default();

					(0, _HTMLElement2.default)(internals);
					(0, _Document2.default)(internals);
					(0, _Node2.default)(internals);
					(0, _Element2.default)(internals);

					// The main document is always associated with the registry.
					document.__CE_hasRegistry = true;

					/** @type {!CustomElementRegistry} */
					var customElements = new _CustomElementRegistry2.default(internals);

					Object.defineProperty(window, 'customElements', {
						configurable: true,
						enumerable: true,
						value: customElements
					});
				}

				/***/
			},
			/* 37 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});

				var _createClass = function () {
					function defineProperties(target, props) {
						for (var i = 0; i < props.length; i++) {
							var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
						}
					}return function (Constructor, protoProps, staticProps) {
						if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
					};
				}();

				var _Utilities = __webpack_require__(38);

				var Utilities = _interopRequireWildcard(_Utilities);

				var _CustomElementState = __webpack_require__(39);

				var _CustomElementState2 = _interopRequireDefault(_CustomElementState);

				function _interopRequireDefault(obj) {
					return obj && obj.__esModule ? obj : { default: obj };
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					} else {
						var newObj = {};if (obj != null) {
							for (var key in obj) {
								if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
							}
						}newObj.default = obj;return newObj;
					}
				}

				function _classCallCheck(instance, Constructor) {
					if (!(instance instanceof Constructor)) {
						throw new TypeError("Cannot call a class as a function");
					}
				}

				var CustomElementInternals = function () {
					function CustomElementInternals() {
						_classCallCheck(this, CustomElementInternals);

						/** @type {!Map<string, !CustomElementDefinition>} */
						this._localNameToDefinition = new Map();

						/** @type {!Map<!Function, !CustomElementDefinition>} */
						this._constructorToDefinition = new Map();

						/** @type {!Array<!function(!Node)>} */
						this._patches = [];

						/** @type {boolean} */
						this._hasPatches = false;
					}

					/**
      * @param {string} localName
      * @param {!CustomElementDefinition} definition
      */

					_createClass(CustomElementInternals, [{
						key: 'setDefinition',
						value: function setDefinition(localName, definition) {
							this._localNameToDefinition.set(localName, definition);
							this._constructorToDefinition.set(definition.constructor, definition);
						}

						/**
       * @param {string} localName
       * @return {!CustomElementDefinition|undefined}
       */

					}, {
						key: 'localNameToDefinition',
						value: function localNameToDefinition(localName) {
							return this._localNameToDefinition.get(localName);
						}

						/**
       * @param {!Function} constructor
       * @return {!CustomElementDefinition|undefined}
       */

					}, {
						key: 'constructorToDefinition',
						value: function constructorToDefinition(constructor) {
							return this._constructorToDefinition.get(constructor);
						}

						/**
       * @param {!function(!Node)} listener
       */

					}, {
						key: 'addPatch',
						value: function addPatch(listener) {
							this._hasPatches = true;
							this._patches.push(listener);
						}

						/**
       * @param {!Node} node
       */

					}, {
						key: 'patchTree',
						value: function patchTree(node) {
							var _this = this;

							if (!this._hasPatches) return;

							Utilities.walkDeepDescendantElements(node, function (element) {
								return _this.patch(element);
							});
						}

						/**
       * @param {!Node} node
       */

					}, {
						key: 'patch',
						value: function patch(node) {
							if (!this._hasPatches) return;

							if (node.__CE_patched) return;
							node.__CE_patched = true;

							for (var i = 0; i < this._patches.length; i++) {
								this._patches[i](node);
							}
						}

						/**
       * @param {!Node} root
       */

					}, {
						key: 'connectTree',
						value: function connectTree(root) {
							var elements = [];

							Utilities.walkDeepDescendantElements(root, function (element) {
								return elements.push(element);
							});

							for (var i = 0; i < elements.length; i++) {
								var element = elements[i];
								if (element.__CE_state === _CustomElementState2.default.custom) {
									this.connectedCallback(element);
								} else {
									this.upgradeElement(element);
								}
							}
						}

						/**
       * @param {!Node} root
       */

					}, {
						key: 'disconnectTree',
						value: function disconnectTree(root) {
							var elements = [];

							Utilities.walkDeepDescendantElements(root, function (element) {
								return elements.push(element);
							});

							for (var i = 0; i < elements.length; i++) {
								var element = elements[i];
								if (element.__CE_state === _CustomElementState2.default.custom) {
									this.disconnectedCallback(element);
								}
							}
						}

						/**
       * Upgrades all uncustomized custom elements at and below a root node for
       * which there is a definition. When custom element reaction callbacks are
       * assumed to be called synchronously (which, by the current DOM / HTML spec
       * definitions, they are *not*), callbacks for both elements customized
       * synchronously by the parser and elements being upgraded occur in the same
       * relative order.
       *
       * NOTE: This function, when used to simulate the construction of a tree that
       * is already created but not customized (i.e. by the parser), does *not*
       * prevent the element from reading the 'final' (true) state of the tree. For
       * example, the element, during truly synchronous parsing / construction would
       * see that it contains no children as they have not yet been inserted.
       * However, this function does not modify the tree, the element will
       * (incorrectly) have children. Additionally, self-modification restrictions
       * for custom element constructors imposed by the DOM spec are *not* enforced.
       *
       *
       * The following nested list shows the steps extending down from the HTML
       * spec's parsing section that cause elements to be synchronously created and
       * upgraded:
       *
       * The "in body" insertion mode:
       * https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
       * - Switch on token:
       *   .. other cases ..
       *   -> Any other start tag
       *      - [Insert an HTML element](below) for the token.
       *
       * Insert an HTML element:
       * https://html.spec.whatwg.org/multipage/syntax.html#insert-an-html-element
       * - Insert a foreign element for the token in the HTML namespace:
       *   https://html.spec.whatwg.org/multipage/syntax.html#insert-a-foreign-element
       *   - Create an element for a token:
       *     https://html.spec.whatwg.org/multipage/syntax.html#create-an-element-for-the-token
       *     - Will execute script flag is true?
       *       - (Element queue pushed to the custom element reactions stack.)
       *     - Create an element:
       *       https://dom.spec.whatwg.org/#concept-create-element
       *       - Sync CE flag is true?
       *         - Constructor called.
       *         - Self-modification restrictions enforced.
       *       - Sync CE flag is false?
       *         - (Upgrade reaction enqueued.)
       *     - Attributes appended to element.
       *       (`attributeChangedCallback` reactions enqueued.)
       *     - Will execute script flag is true?
       *       - (Element queue popped from the custom element reactions stack.
       *         Reactions in the popped stack are invoked.)
       *   - (Element queue pushed to the custom element reactions stack.)
       *   - Insert the element:
       *     https://dom.spec.whatwg.org/#concept-node-insert
       *     - Shadow-including descendants are connected. During parsing
       *       construction, there are no shadow-*excluding* descendants.
       *       However, the constructor may have validly attached a shadow
       *       tree to itself and added descendants to that shadow tree.
       *       (`connectedCallback` reactions enqueued.)
       *   - (Element queue popped from the custom element reactions stack.
       *     Reactions in the popped stack are invoked.)
       *
       * @param {!Node} root
       * @param {!Set<Node>=} visitedImports
       */

					}, {
						key: 'patchAndUpgradeTree',
						value: function patchAndUpgradeTree(root) {
							var _this2 = this;

							var visitedImports = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();

							var elements = [];

							var gatherElements = function gatherElements(element) {
								if (element.localName === 'link' && element.getAttribute('rel') === 'import') {
									// The HTML Imports polyfill sets a descendant element of the link to
									// the `import` property, specifically this is *not* a Document.
									var importNode = /** @type {?Node} */element.import;

									if (importNode instanceof Node && importNode.readyState === 'complete') {
										importNode.__CE_isImportDocument = true;

										// Connected links are associated with the registry.
										importNode.__CE_hasRegistry = true;
									} else {
										// If this link's import root is not available, its contents can't be
										// walked. Wait for 'load' and walk it when it's ready.
										element.addEventListener('load', function () {
											var importNode = /** @type {!Node} */element.import;

											if (importNode.__CE_documentLoadHandled) return;
											importNode.__CE_documentLoadHandled = true;

											importNode.__CE_isImportDocument = true;

											// Connected links are associated with the registry.
											importNode.__CE_hasRegistry = true;

											// Clone the `visitedImports` set that was populated sync during
											// the `patchAndUpgradeTree` call that caused this 'load' handler to
											// be added. Then, remove *this* link's import node so that we can
											// walk that import again, even if it was partially walked later
											// during the same `patchAndUpgradeTree` call.
											var clonedVisitedImports = new Set(visitedImports);
											visitedImports.delete(importNode);

											_this2.patchAndUpgradeTree(importNode, visitedImports);
										});
									}
								} else {
									elements.push(element);
								}
							};

							// `walkDeepDescendantElements` populates (and internally checks against)
							// `visitedImports` when traversing a loaded import.
							Utilities.walkDeepDescendantElements(root, gatherElements, visitedImports);

							if (this._hasPatches) {
								for (var i = 0; i < elements.length; i++) {
									this.patch(elements[i]);
								}
							}

							for (var _i = 0; _i < elements.length; _i++) {
								this.upgradeElement(elements[_i]);
							}
						}

						/**
       * @param {!Element} element
       */

					}, {
						key: 'upgradeElement',
						value: function upgradeElement(element) {
							var currentState = element.__CE_state;
							if (currentState !== undefined) return;

							var definition = this.localNameToDefinition(element.localName);
							if (!definition) return;

							definition.constructionStack.push(element);

							var constructor = definition.constructor;
							try {
								try {
									var result = new constructor();
									if (result !== element) {
										throw new Error('The custom element constructor did not produce the element being upgraded.');
									}
								} finally {
									definition.constructionStack.pop();
								}
							} catch (e) {
								element.__CE_state = _CustomElementState2.default.failed;
								throw e;
							}

							element.__CE_state = _CustomElementState2.default.custom;
							element.__CE_definition = definition;

							if (definition.attributeChangedCallback) {
								var observedAttributes = definition.observedAttributes;
								for (var i = 0; i < observedAttributes.length; i++) {
									var name = observedAttributes[i];
									var value = element.getAttribute(name);
									if (value !== null) {
										this.attributeChangedCallback(element, name, null, value, null);
									}
								}
							}

							if (Utilities.isConnected(element)) {
								this.connectedCallback(element);
							}
						}

						/**
       * @param {!Element} element
       */

					}, {
						key: 'connectedCallback',
						value: function connectedCallback(element) {
							var definition = element.__CE_definition;
							if (definition.connectedCallback) {
								definition.connectedCallback.call(element);
							}
						}

						/**
       * @param {!Element} element
       */

					}, {
						key: 'disconnectedCallback',
						value: function disconnectedCallback(element) {
							var definition = element.__CE_definition;
							if (definition.disconnectedCallback) {
								definition.disconnectedCallback.call(element);
							}
						}

						/**
       * @param {!Element} element
       * @param {string} name
       * @param {?string} oldValue
       * @param {?string} newValue
       * @param {?string} namespace
       */

					}, {
						key: 'attributeChangedCallback',
						value: function attributeChangedCallback(element, name, oldValue, newValue, namespace) {
							var definition = element.__CE_definition;
							if (definition.attributeChangedCallback && definition.observedAttributes.indexOf(name) > -1) {
								definition.attributeChangedCallback.call(element, name, oldValue, newValue, namespace);
							}
						}
					}]);

					return CustomElementInternals;
				}();

				exports.default = CustomElementInternals;

				/***/
			},
			/* 38 */
			/***/function (module, exports) {

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});
				exports.isValidCustomElementName = isValidCustomElementName;
				exports.isConnected = isConnected;
				exports.walkDeepDescendantElements = walkDeepDescendantElements;
				exports.setPropertyUnchecked = setPropertyUnchecked;
				var reservedTagList = new Set(['annotation-xml', 'color-profile', 'font-face', 'font-face-src', 'font-face-uri', 'font-face-format', 'font-face-name', 'missing-glyph']);

				/**
     * @param {string} localName
     * @returns {boolean}
     */
				function isValidCustomElementName(localName) {
					var reserved = reservedTagList.has(localName);
					var validForm = /^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(localName);
					return !reserved && validForm;
				}

				/**
     * @private
     * @param {!Node} node
     * @return {boolean}
     */
				function isConnected(node) {
					// Use `Node#isConnected`, if defined.
					var nativeValue = node.isConnected;
					if (nativeValue !== undefined) {
						return nativeValue;
					}

					/** @type {?Node|undefined} */
					var current = node;
					while (current && !(current.__CE_isImportDocument || current instanceof Document)) {
						current = current.parentNode || (window.ShadowRoot && current instanceof ShadowRoot ? current.host : undefined);
					}
					return !!(current && (current.__CE_isImportDocument || current instanceof Document));
				}

				/**
     * @param {!Node} root
     * @param {!Node} start
     * @return {?Node}
     */
				function nextSiblingOrAncestorSibling(root, start) {
					var node = start;
					while (node && node !== root && !node.nextSibling) {
						node = node.parentNode;
					}
					return !node || node === root ? null : node.nextSibling;
				}

				/**
     * @param {!Node} root
     * @param {!Node} start
     * @return {?Node}
     */
				function nextNode(root, start) {
					return start.firstChild ? start.firstChild : nextSiblingOrAncestorSibling(root, start);
				}

				/**
     * @param {!Node} root
     * @param {!function(!Element)} callback
     * @param {!Set<Node>=} visitedImports
     */
				function walkDeepDescendantElements(root, callback) {
					var visitedImports = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();

					var node = root;
					while (node) {
						if (node.nodeType === Node.ELEMENT_NODE) {
							var element = /** @type {!Element} */node;

							callback(element);

							var localName = element.localName;
							if (localName === 'link' && element.getAttribute('rel') === 'import') {
								// If this import (polyfilled or not) has it's root node available,
								// walk it.
								var importNode = /** @type {!Node} */element.import;
								if (importNode instanceof Node && !visitedImports.has(importNode)) {
									// Prevent multiple walks of the same import root.
									visitedImports.add(importNode);

									for (var child = importNode.firstChild; child; child = child.nextSibling) {
										walkDeepDescendantElements(child, callback, visitedImports);
									}
								}

								// Ignore descendants of import links to prevent attempting to walk the
								// elements created by the HTML Imports polyfill that we just walked
								// above.
								node = nextSiblingOrAncestorSibling(root, element);
								continue;
							} else if (localName === 'template') {
								// Ignore descendants of templates. There shouldn't be any descendants
								// because they will be moved into `.content` during construction in
								// browsers that support template but, in case they exist and are still
								// waiting to be moved by a polyfill, they will be ignored.
								node = nextSiblingOrAncestorSibling(root, element);
								continue;
							}

							// Walk shadow roots.
							var shadowRoot = element.__CE_shadowRoot;
							if (shadowRoot) {
								for (var _child = shadowRoot.firstChild; _child; _child = _child.nextSibling) {
									walkDeepDescendantElements(_child, callback, visitedImports);
								}
							}
						}

						node = nextNode(root, node);
					}
				}

				/**
     * Used to suppress Closure's "Modifying the prototype is only allowed if the
     * constructor is in the same scope" warning without using
     * `@suppress {newCheckTypes, duplicate}` because `newCheckTypes` is too broad.
     *
     * @param {!Object} destination
     * @param {string} name
     * @param {*} value
     */
				function setPropertyUnchecked(destination, name, value) {
					destination[name] = value;
				}

				/***/
			},
			/* 39 */
			/***/function (module, exports) {

				"use strict";

				Object.defineProperty(exports, "__esModule", {
					value: true
				});
				/**
     * @enum {number}
     */
				var CustomElementState = {
					custom: 1,
					failed: 2
				};

				exports.default = CustomElementState;

				/***/
			},
			/* 40 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});

				var _createClass = function () {
					function defineProperties(target, props) {
						for (var i = 0; i < props.length; i++) {
							var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
						}
					}return function (Constructor, protoProps, staticProps) {
						if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
					};
				}();

				var _CustomElementInternals = __webpack_require__(37);

				var _CustomElementInternals2 = _interopRequireDefault(_CustomElementInternals);

				var _DocumentConstructionObserver = __webpack_require__(41);

				var _DocumentConstructionObserver2 = _interopRequireDefault(_DocumentConstructionObserver);

				var _Deferred = __webpack_require__(42);

				var _Deferred2 = _interopRequireDefault(_Deferred);

				var _Utilities = __webpack_require__(38);

				var Utilities = _interopRequireWildcard(_Utilities);

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					} else {
						var newObj = {};if (obj != null) {
							for (var key in obj) {
								if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
							}
						}newObj.default = obj;return newObj;
					}
				}

				function _interopRequireDefault(obj) {
					return obj && obj.__esModule ? obj : { default: obj };
				}

				function _classCallCheck(instance, Constructor) {
					if (!(instance instanceof Constructor)) {
						throw new TypeError("Cannot call a class as a function");
					}
				}

				/**
     * @unrestricted
     */
				var CustomElementRegistry = function () {

					/**
      * @param {!CustomElementInternals} internals
      */
					function CustomElementRegistry(internals) {
						_classCallCheck(this, CustomElementRegistry);

						/**
       * @private
       * @type {boolean}
       */
						this._elementDefinitionIsRunning = false;

						/**
       * @private
       * @type {!CustomElementInternals}
       */
						this._internals = internals;

						/**
       * @private
       * @type {!Map<string, !Deferred<undefined>>}
       */
						this._whenDefinedDeferred = new Map();

						/**
       * The default flush callback triggers the document walk synchronously.
       * @private
       * @type {!Function}
       */
						this._flushCallback = function (fn) {
							return fn();
						};

						/**
       * @private
       * @type {boolean}
       */
						this._flushPending = false;

						/**
       * @private
       * @type {!Array<string>}
       */
						this._unflushedLocalNames = [];

						/**
       * @private
       * @type {!DocumentConstructionObserver}
       */
						this._documentConstructionObserver = new _DocumentConstructionObserver2.default(internals, document);
					}

					/**
      * @param {string} localName
      * @param {!Function} constructor
      */

					_createClass(CustomElementRegistry, [{
						key: 'define',
						value: function define(localName, constructor) {
							var _this = this;

							if (!(constructor instanceof Function)) {
								throw new TypeError('Custom element constructors must be functions.');
							}

							if (!Utilities.isValidCustomElementName(localName)) {
								throw new SyntaxError('The element name \'' + localName + '\' is not valid.');
							}

							if (this._internals.localNameToDefinition(localName)) {
								throw new Error('A custom element with name \'' + localName + '\' has already been defined.');
							}

							if (this._elementDefinitionIsRunning) {
								throw new Error('A custom element is already being defined.');
							}
							this._elementDefinitionIsRunning = true;

							var connectedCallback = void 0;
							var disconnectedCallback = void 0;
							var adoptedCallback = void 0;
							var attributeChangedCallback = void 0;
							var observedAttributes = void 0;
							try {
								(function () {
									var getCallback = function getCallback(name) {
										var callbackValue = prototype[name];
										if (callbackValue !== undefined && !(callbackValue instanceof Function)) {
											throw new Error('The \'' + name + '\' callback must be a function.');
										}
										return callbackValue;
									};

									/** @type {!Object} */
									var prototype = constructor.prototype;
									if (!(prototype instanceof Object)) {
										throw new TypeError('The custom element constructor\'s prototype is not an object.');
									}

									connectedCallback = getCallback('connectedCallback');
									disconnectedCallback = getCallback('disconnectedCallback');
									adoptedCallback = getCallback('adoptedCallback');
									attributeChangedCallback = getCallback('attributeChangedCallback');
									observedAttributes = constructor['observedAttributes'] || [];
								})();
							} catch (e) {
								return;
							} finally {
								this._elementDefinitionIsRunning = false;
							}

							var definition = {
								localName: localName,
								constructor: constructor,
								connectedCallback: connectedCallback,
								disconnectedCallback: disconnectedCallback,
								adoptedCallback: adoptedCallback,
								attributeChangedCallback: attributeChangedCallback,
								observedAttributes: observedAttributes,
								constructionStack: []
							};

							this._internals.setDefinition(localName, definition);

							this._unflushedLocalNames.push(localName);

							// If we've already called the flush callback and it hasn't called back yet,
							// don't call it again.
							if (!this._flushPending) {
								this._flushPending = true;
								this._flushCallback(function () {
									return _this._flush();
								});
							}
						}
					}, {
						key: '_flush',
						value: function _flush() {
							// If no new definitions were defined, don't attempt to flush. This could
							// happen if a flush callback keeps the function it is given and calls it
							// multiple times.
							if (this._flushPending === false) return;

							this._flushPending = false;
							this._internals.patchAndUpgradeTree(document);

							while (this._unflushedLocalNames.length > 0) {
								var localName = this._unflushedLocalNames.shift();
								var deferred = this._whenDefinedDeferred.get(localName);
								if (deferred) {
									deferred.resolve(undefined);
								}
							}
						}

						/**
       * @param {string} localName
       * @return {Function|undefined}
       */

					}, {
						key: 'get',
						value: function get(localName) {
							var definition = this._internals.localNameToDefinition(localName);
							if (definition) {
								return definition.constructor;
							}

							return undefined;
						}

						/**
       * @param {string} localName
       * @return {!Promise<undefined>}
       */

					}, {
						key: 'whenDefined',
						value: function whenDefined(localName) {
							if (!Utilities.isValidCustomElementName(localName)) {
								return Promise.reject(new SyntaxError('\'' + localName + '\' is not a valid custom element name.'));
							}

							var prior = this._whenDefinedDeferred.get(localName);
							if (prior) {
								return prior.toPromise();
							}

							var deferred = new _Deferred2.default();
							this._whenDefinedDeferred.set(localName, deferred);

							var definition = this._internals.localNameToDefinition(localName);
							// Resolve immediately only if the given local name has a definition *and*
							// the full document walk to upgrade elements with that local name has
							// already happened.
							if (definition && this._unflushedLocalNames.indexOf(localName) === -1) {
								deferred.resolve(undefined);
							}

							return deferred.toPromise();
						}
					}, {
						key: 'polyfillWrapFlushCallback',
						value: function polyfillWrapFlushCallback(outer) {
							this._documentConstructionObserver.disconnect();
							var inner = this._flushCallback;
							this._flushCallback = function (flush) {
								return outer(function () {
									return inner(flush);
								});
							};
						}
					}]);

					return CustomElementRegistry;
				}();

				// Closure compiler exports.


				exports.default = CustomElementRegistry;
				window['CustomElementRegistry'] = CustomElementRegistry;
				CustomElementRegistry.prototype['define'] = CustomElementRegistry.prototype.define;
				CustomElementRegistry.prototype['get'] = CustomElementRegistry.prototype.get;
				CustomElementRegistry.prototype['whenDefined'] = CustomElementRegistry.prototype.whenDefined;
				CustomElementRegistry.prototype['polyfillWrapFlushCallback'] = CustomElementRegistry.prototype.polyfillWrapFlushCallback;

				/***/
			},
			/* 41 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});

				var _createClass = function () {
					function defineProperties(target, props) {
						for (var i = 0; i < props.length; i++) {
							var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
						}
					}return function (Constructor, protoProps, staticProps) {
						if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
					};
				}();

				var _CustomElementInternals = __webpack_require__(37);

				var _CustomElementInternals2 = _interopRequireDefault(_CustomElementInternals);

				function _interopRequireDefault(obj) {
					return obj && obj.__esModule ? obj : { default: obj };
				}

				function _classCallCheck(instance, Constructor) {
					if (!(instance instanceof Constructor)) {
						throw new TypeError("Cannot call a class as a function");
					}
				}

				var DocumentConstructionObserver = function () {
					function DocumentConstructionObserver(internals, doc) {
						_classCallCheck(this, DocumentConstructionObserver);

						/**
       * @type {!CustomElementInternals}
       */
						this._internals = internals;

						/**
       * @type {!Document}
       */
						this._document = doc;

						/**
       * @type {MutationObserver|undefined}
       */
						this._observer = undefined;

						// Simulate tree construction for all currently accessible nodes in the
						// document.
						this._internals.patchAndUpgradeTree(this._document);

						if (this._document.readyState === 'loading') {
							this._observer = new MutationObserver(this._handleMutations.bind(this));

							// Nodes created by the parser are given to the observer *before* the next
							// task runs. Inline scripts are run in a new task. This means that the
							// observer will be able to handle the newly parsed nodes before the inline
							// script is run.
							this._observer.observe(this._document, {
								childList: true,
								subtree: true
							});
						}
					}

					_createClass(DocumentConstructionObserver, [{
						key: 'disconnect',
						value: function disconnect() {
							if (this._observer) {
								this._observer.disconnect();
							}
						}

						/**
       * @param {!Array<!MutationRecord>} mutations
       */

					}, {
						key: '_handleMutations',
						value: function _handleMutations(mutations) {
							// Once the document's `readyState` is 'interactive' or 'complete', all new
							// nodes created within that document will be the result of script and
							// should be handled by patching.
							var readyState = this._document.readyState;
							if (readyState === 'interactive' || readyState === 'complete') {
								this.disconnect();
							}

							for (var i = 0; i < mutations.length; i++) {
								var addedNodes = mutations[i].addedNodes;
								for (var j = 0; j < addedNodes.length; j++) {
									var node = addedNodes[j];
									this._internals.patchAndUpgradeTree(node);
								}
							}
						}
					}]);

					return DocumentConstructionObserver;
				}();

				exports.default = DocumentConstructionObserver;

				/***/
			},
			/* 42 */
			/***/function (module, exports) {

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});

				var _createClass = function () {
					function defineProperties(target, props) {
						for (var i = 0; i < props.length; i++) {
							var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
						}
					}return function (Constructor, protoProps, staticProps) {
						if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
					};
				}();

				function _classCallCheck(instance, Constructor) {
					if (!(instance instanceof Constructor)) {
						throw new TypeError("Cannot call a class as a function");
					}
				}

				/**
     * @template T
     */
				var Deferred = function () {
					function Deferred() {
						var _this = this;

						_classCallCheck(this, Deferred);

						/**
       * @private
       * @type {T|undefined}
       */
						this._value = undefined;

						/**
       * @private
       * @type {Function|undefined}
       */
						this._resolve = undefined;

						/**
       * @private
       * @type {!Promise<T>}
       */
						this._promise = new Promise(function (resolve) {
							_this._resolve = resolve;

							if (_this._value) {
								resolve(_this._value);
							}
						});
					}

					/**
      * @param {T} value
      */

					_createClass(Deferred, [{
						key: 'resolve',
						value: function resolve(value) {
							if (this._value) {
								throw new Error('Already resolved.');
							}

							this._value = value;

							if (this._resolve) {
								this._resolve(value);
							}
						}

						/**
       * @return {!Promise<T>}
       */

					}, {
						key: 'toPromise',
						value: function toPromise() {
							return this._promise;
						}
					}]);

					return Deferred;
				}();

				exports.default = Deferred;

				/***/
			},
			/* 43 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});

				exports.default = function (internals) {
					window['HTMLElement'] = function () {
						/**
       * @type {function(new: HTMLElement): !HTMLElement}
       */
						function HTMLElement() {
							// This should really be `new.target` but `new.target` can't be emulated
							// in ES5. Assuming the user keeps the default value of the constructor's
							// prototype's `constructor` property, this is equivalent.
							/** @type {!Function} */
							var constructor = this.constructor;

							var definition = internals.constructorToDefinition(constructor);
							if (!definition) {
								throw new Error('The custom element being constructed was not registered with `customElements`.');
							}

							var constructionStack = definition.constructionStack;

							if (constructionStack.length === 0) {
								var _element = _Native2.default.Document_createElement.call(document, definition.localName);
								Object.setPrototypeOf(_element, constructor.prototype);
								_element.__CE_state = _CustomElementState2.default.custom;
								_element.__CE_definition = definition;
								internals.patch(_element);
								return _element;
							}

							var lastIndex = constructionStack.length - 1;
							var element = constructionStack[lastIndex];
							if (element === _AlreadyConstructedMarker2.default) {
								throw new Error('The HTMLElement constructor was either called reentrantly for this constructor or called multiple times.');
							}
							constructionStack[lastIndex] = _AlreadyConstructedMarker2.default;

							Object.setPrototypeOf(element, constructor.prototype);
							internals.patch( /** @type {!HTMLElement} */element);

							return element;
						}

						HTMLElement.prototype = _Native2.default.HTMLElement.prototype;

						return HTMLElement;
					}();
				};

				var _Native = __webpack_require__(44);

				var _Native2 = _interopRequireDefault(_Native);

				var _CustomElementInternals = __webpack_require__(37);

				var _CustomElementInternals2 = _interopRequireDefault(_CustomElementInternals);

				var _CustomElementState = __webpack_require__(39);

				var _CustomElementState2 = _interopRequireDefault(_CustomElementState);

				var _AlreadyConstructedMarker = __webpack_require__(45);

				var _AlreadyConstructedMarker2 = _interopRequireDefault(_AlreadyConstructedMarker);

				function _interopRequireDefault(obj) {
					return obj && obj.__esModule ? obj : { default: obj };
				}

				

				/**
     * @param {!CustomElementInternals} internals
     */

				/***/
			},
			/* 44 */
			/***/function (module, exports) {

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});
				exports.default = {
					Document_createElement: window.Document.prototype.createElement,
					Document_createElementNS: window.Document.prototype.createElementNS,
					Document_importNode: window.Document.prototype.importNode,
					Document_prepend: window.Document.prototype['prepend'],
					Document_append: window.Document.prototype['append'],
					Node_cloneNode: window.Node.prototype.cloneNode,
					Node_appendChild: window.Node.prototype.appendChild,
					Node_insertBefore: window.Node.prototype.insertBefore,
					Node_removeChild: window.Node.prototype.removeChild,
					Node_replaceChild: window.Node.prototype.replaceChild,
					Node_textContent: Object.getOwnPropertyDescriptor(window.Node.prototype, 'textContent'),
					Element_attachShadow: window.Element.prototype['attachShadow'],
					Element_innerHTML: Object.getOwnPropertyDescriptor(window.Element.prototype, 'innerHTML'),
					Element_getAttribute: window.Element.prototype.getAttribute,
					Element_setAttribute: window.Element.prototype.setAttribute,
					Element_removeAttribute: window.Element.prototype.removeAttribute,
					Element_getAttributeNS: window.Element.prototype.getAttributeNS,
					Element_setAttributeNS: window.Element.prototype.setAttributeNS,
					Element_removeAttributeNS: window.Element.prototype.removeAttributeNS,
					Element_insertAdjacentElement: window.Element.prototype['insertAdjacentElement'],
					Element_prepend: window.Element.prototype['prepend'],
					Element_append: window.Element.prototype['append'],
					Element_before: window.Element.prototype['before'],
					Element_after: window.Element.prototype['after'],
					Element_replaceWith: window.Element.prototype['replaceWith'],
					Element_remove: window.Element.prototype['remove'],
					HTMLElement: window.HTMLElement,
					HTMLElement_innerHTML: Object.getOwnPropertyDescriptor(window.HTMLElement.prototype, 'innerHTML'),
					HTMLElement_insertAdjacentElement: window.HTMLElement.prototype['insertAdjacentElement']
				};

				/***/
			},
			/* 45 */
			/***/function (module, exports) {

				"use strict";

				Object.defineProperty(exports, "__esModule", {
					value: true
				});

				function _classCallCheck(instance, Constructor) {
					if (!(instance instanceof Constructor)) {
						throw new TypeError("Cannot call a class as a function");
					}
				}

				/**
     * This class exists only to work around Closure's lack of a way to describe
     * singletons. It represents the 'already constructed marker' used in custom
     * element construction stacks.
     *
     * https://html.spec.whatwg.org/#concept-already-constructed-marker
     */
				var AlreadyConstructedMarker = function AlreadyConstructedMarker() {
					_classCallCheck(this, AlreadyConstructedMarker);
				};

				exports.default = new AlreadyConstructedMarker();

				/***/
			},
			/* 46 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});

				exports.default = function (internals) {
					Utilities.setPropertyUnchecked(Document.prototype, 'createElement',
					/**
      * @this {Document}
      * @param {string} localName
      * @return {!Element}
      */
					function (localName) {
						// Only create custom elements if this document is associated with the registry.
						if (this.__CE_hasRegistry) {
							var definition = internals.localNameToDefinition(localName);
							if (definition) {
								return new definition.constructor();
							}
						}

						var result = /** @type {!Element} */
						_Native2.default.Document_createElement.call(this, localName);
						internals.patch(result);
						return result;
					});

					Utilities.setPropertyUnchecked(Document.prototype, 'importNode',
					/**
      * @this {Document}
      * @param {!Node} node
      * @param {boolean=} deep
      * @return {!Node}
      */
					function (node, deep) {
						var clone = _Native2.default.Document_importNode.call(this, node, deep);
						// Only create custom elements if this document is associated with the registry.
						if (!this.__CE_hasRegistry) {
							internals.patchTree(clone);
						} else {
							internals.patchAndUpgradeTree(clone);
						}
						return clone;
					});

					var NS_HTML = "http://www.w3.org/1999/xhtml";

					Utilities.setPropertyUnchecked(Document.prototype, 'createElementNS',
					/**
      * @this {Document}
      * @param {?string} namespace
      * @param {string} localName
      * @return {!Element}
      */
					function (namespace, localName) {
						// Only create custom elements if this document is associated with the registry.
						if (this.__CE_hasRegistry && (namespace === null || namespace === NS_HTML)) {
							var definition = internals.localNameToDefinition(localName);
							if (definition) {
								return new definition.constructor();
							}
						}

						var result = /** @type {!Element} */
						_Native2.default.Document_createElementNS.call(this, namespace, localName);
						internals.patch(result);
						return result;
					});

					(0, _ParentNode2.default)(internals, Document.prototype, {
						prepend: _Native2.default.Document_prepend,
						append: _Native2.default.Document_append
					});
				};

				var _Native = __webpack_require__(44);

				var _Native2 = _interopRequireDefault(_Native);

				var _CustomElementInternals = __webpack_require__(37);

				var _CustomElementInternals2 = _interopRequireDefault(_CustomElementInternals);

				var _Utilities = __webpack_require__(38);

				var Utilities = _interopRequireWildcard(_Utilities);

				var _ParentNode = __webpack_require__(47);

				var _ParentNode2 = _interopRequireDefault(_ParentNode);

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					} else {
						var newObj = {};if (obj != null) {
							for (var key in obj) {
								if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
							}
						}newObj.default = obj;return newObj;
					}
				}

				function _interopRequireDefault(obj) {
					return obj && obj.__esModule ? obj : { default: obj };
				}

				

				/**
     * @param {!CustomElementInternals} internals
     */

				/***/
			},
			/* 47 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});

				exports.default = function (internals, destination, builtIn) {
					/**
      * @param {...(!Node|string)} nodes
      */
					destination['prepend'] = function () {
						for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {
							nodes[_key] = arguments[_key];
						}

						// TODO: Fix this for when one of `nodes` is a DocumentFragment!
						var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {
							// DocumentFragments are not connected and will not be added to the list.
							return node instanceof Node && Utilities.isConnected(node);
						});

						builtIn.prepend.apply(this, nodes);

						for (var i = 0; i < connectedBefore.length; i++) {
							internals.disconnectTree(connectedBefore[i]);
						}

						if (Utilities.isConnected(this)) {
							for (var _i = 0; _i < nodes.length; _i++) {
								var node = nodes[_i];
								if (node instanceof Element) {
									internals.connectTree(node);
								}
							}
						}
					};

					/**
      * @param {...(!Node|string)} nodes
      */
					destination['append'] = function () {
						for (var _len2 = arguments.length, nodes = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
							nodes[_key2] = arguments[_key2];
						}

						// TODO: Fix this for when one of `nodes` is a DocumentFragment!
						var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {
							// DocumentFragments are not connected and will not be added to the list.
							return node instanceof Node && Utilities.isConnected(node);
						});

						builtIn.append.apply(this, nodes);

						for (var i = 0; i < connectedBefore.length; i++) {
							internals.disconnectTree(connectedBefore[i]);
						}

						if (Utilities.isConnected(this)) {
							for (var _i2 = 0; _i2 < nodes.length; _i2++) {
								var node = nodes[_i2];
								if (node instanceof Element) {
									internals.connectTree(node);
								}
							}
						}
					};
				};

				var _CustomElementInternals = __webpack_require__(37);

				var _CustomElementInternals2 = _interopRequireDefault(_CustomElementInternals);

				var _Utilities = __webpack_require__(38);

				var Utilities = _interopRequireWildcard(_Utilities);

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					} else {
						var newObj = {};if (obj != null) {
							for (var key in obj) {
								if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
							}
						}newObj.default = obj;return newObj;
					}
				}

				function _interopRequireDefault(obj) {
					return obj && obj.__esModule ? obj : { default: obj };
				}

				/**
     * @typedef {{
     *   prepend: !function(...(!Node|string)),
      *  append: !function(...(!Node|string)),
     * }}
     */
				var ParentNodeNativeMethods = void 0;

				/**
     * @param {!CustomElementInternals} internals
     * @param {!Object} destination
     * @param {!ParentNodeNativeMethods} builtIn
     */
				

				/***/
			},
			/* 48 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});

				exports.default = function (internals) {
					// `Node#nodeValue` is implemented on `Attr`.
					// `Node#textContent` is implemented on `Attr`, `Element`.

					Utilities.setPropertyUnchecked(Node.prototype, 'insertBefore',
					/**
      * @this {Node}
      * @param {!Node} node
      * @param {?Node} refNode
      * @return {!Node}
      */
					function (node, refNode) {
						if (node instanceof DocumentFragment) {
							var insertedNodes = Array.prototype.slice.apply(node.childNodes);
							var _nativeResult = _Native2.default.Node_insertBefore.call(this, node, refNode);

							// DocumentFragments can't be connected, so `disconnectTree` will never
							// need to be called on a DocumentFragment's children after inserting it.

							if (Utilities.isConnected(this)) {
								for (var i = 0; i < insertedNodes.length; i++) {
									internals.connectTree(insertedNodes[i]);
								}
							}

							return _nativeResult;
						}

						var nodeWasConnected = Utilities.isConnected(node);
						var nativeResult = _Native2.default.Node_insertBefore.call(this, node, refNode);

						if (nodeWasConnected) {
							internals.disconnectTree(node);
						}

						if (Utilities.isConnected(this)) {
							internals.connectTree(node);
						}

						return nativeResult;
					});

					Utilities.setPropertyUnchecked(Node.prototype, 'appendChild',
					/**
      * @this {Node}
      * @param {!Node} node
      * @return {!Node}
      */
					function (node) {
						if (node instanceof DocumentFragment) {
							var insertedNodes = Array.prototype.slice.apply(node.childNodes);
							var _nativeResult2 = _Native2.default.Node_appendChild.call(this, node);

							// DocumentFragments can't be connected, so `disconnectTree` will never
							// need to be called on a DocumentFragment's children after inserting it.

							if (Utilities.isConnected(this)) {
								for (var i = 0; i < insertedNodes.length; i++) {
									internals.connectTree(insertedNodes[i]);
								}
							}

							return _nativeResult2;
						}

						var nodeWasConnected = Utilities.isConnected(node);
						var nativeResult = _Native2.default.Node_appendChild.call(this, node);

						if (nodeWasConnected) {
							internals.disconnectTree(node);
						}

						if (Utilities.isConnected(this)) {
							internals.connectTree(node);
						}

						return nativeResult;
					});

					Utilities.setPropertyUnchecked(Node.prototype, 'cloneNode',
					/**
      * @this {Node}
      * @param {boolean=} deep
      * @return {!Node}
      */
					function (deep) {
						var clone = _Native2.default.Node_cloneNode.call(this, deep);
						// Only create custom elements if this element's owner document is
						// associated with the registry.
						if (!this.ownerDocument.__CE_hasRegistry) {
							internals.patchTree(clone);
						} else {
							internals.patchAndUpgradeTree(clone);
						}
						return clone;
					});

					Utilities.setPropertyUnchecked(Node.prototype, 'removeChild',
					/**
      * @this {Node}
      * @param {!Node} node
      * @return {!Node}
      */
					function (node) {
						var nodeWasConnected = Utilities.isConnected(node);
						var nativeResult = _Native2.default.Node_removeChild.call(this, node);

						if (nodeWasConnected) {
							internals.disconnectTree(node);
						}

						return nativeResult;
					});

					Utilities.setPropertyUnchecked(Node.prototype, 'replaceChild',
					/**
      * @this {Node}
      * @param {!Node} nodeToInsert
      * @param {!Node} nodeToRemove
      * @return {!Node}
      */
					function (nodeToInsert, nodeToRemove) {
						if (nodeToInsert instanceof DocumentFragment) {
							var insertedNodes = Array.prototype.slice.apply(nodeToInsert.childNodes);
							var _nativeResult3 = _Native2.default.Node_replaceChild.call(this, nodeToInsert, nodeToRemove);

							// DocumentFragments can't be connected, so `disconnectTree` will never
							// need to be called on a DocumentFragment's children after inserting it.

							if (Utilities.isConnected(this)) {
								internals.disconnectTree(nodeToRemove);
								for (var i = 0; i < insertedNodes.length; i++) {
									internals.connectTree(insertedNodes[i]);
								}
							}

							return _nativeResult3;
						}

						var nodeToInsertWasConnected = Utilities.isConnected(nodeToInsert);
						var nativeResult = _Native2.default.Node_replaceChild.call(this, nodeToInsert, nodeToRemove);
						var thisIsConnected = Utilities.isConnected(this);

						if (thisIsConnected) {
							internals.disconnectTree(nodeToRemove);
						}

						if (nodeToInsertWasConnected) {
							internals.disconnectTree(nodeToInsert);
						}

						if (thisIsConnected) {
							internals.connectTree(nodeToInsert);
						}

						return nativeResult;
					});

					function patch_textContent(destination, baseDescriptor) {
						Object.defineProperty(destination, 'textContent', {
							enumerable: baseDescriptor.enumerable,
							configurable: true,
							get: baseDescriptor.get,
							set: /** @this {Node} */function set(assignedValue) {
								// If this is a text node then there are no nodes to disconnect.
								if (this.nodeType === Node.TEXT_NODE) {
									baseDescriptor.set.call(this, assignedValue);
									return;
								}

								var removedNodes = undefined;
								// Checking for `firstChild` is faster than reading `childNodes.length`
								// to compare with 0.
								if (this.firstChild) {
									// Using `childNodes` is faster than `children`, even though we only
									// care about elements.
									var childNodes = this.childNodes;
									var childNodesLength = childNodes.length;
									if (childNodesLength > 0 && Utilities.isConnected(this)) {
										// Copying an array by iterating is faster than using slice.
										removedNodes = new Array(childNodesLength);
										for (var i = 0; i < childNodesLength; i++) {
											removedNodes[i] = childNodes[i];
										}
									}
								}

								baseDescriptor.set.call(this, assignedValue);

								if (removedNodes) {
									for (var _i = 0; _i < removedNodes.length; _i++) {
										internals.disconnectTree(removedNodes[_i]);
									}
								}
							}
						});
					}

					if (_Native2.default.Node_textContent && _Native2.default.Node_textContent.get) {
						patch_textContent(Node.prototype, _Native2.default.Node_textContent);
					} else {
						internals.addPatch(function (element) {
							patch_textContent(element, {
								enumerable: true,
								configurable: true,
								// NOTE: This implementation of the `textContent` getter assumes that
								// text nodes' `textContent` getter will not be patched.
								get: /** @this {Node} */function get() {
									/** @type {!Array<string>} */
									var parts = [];

									for (var i = 0; i < this.childNodes.length; i++) {
										parts.push(this.childNodes[i].textContent);
									}

									return parts.join('');
								},
								set: /** @this {Node} */function set(assignedValue) {
									while (this.firstChild) {
										_Native2.default.Node_removeChild.call(this, this.firstChild);
									}
									_Native2.default.Node_appendChild.call(this, document.createTextNode(assignedValue));
								}
							});
						});
					}
				};

				var _Native = __webpack_require__(44);

				var _Native2 = _interopRequireDefault(_Native);

				var _CustomElementInternals = __webpack_require__(37);

				var _CustomElementInternals2 = _interopRequireDefault(_CustomElementInternals);

				var _Utilities = __webpack_require__(38);

				var Utilities = _interopRequireWildcard(_Utilities);

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					} else {
						var newObj = {};if (obj != null) {
							for (var key in obj) {
								if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
							}
						}newObj.default = obj;return newObj;
					}
				}

				function _interopRequireDefault(obj) {
					return obj && obj.__esModule ? obj : { default: obj };
				}

				

				/**
     * @param {!CustomElementInternals} internals
     */

				/***/
			},
			/* 49 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});

				exports.default = function (internals) {
					if (_Native2.default.Element_attachShadow) {
						Utilities.setPropertyUnchecked(Element.prototype, 'attachShadow',
						/**
       * @this {Element}
       * @param {!{mode: string}} init
       * @return {ShadowRoot}
       */
						function (init) {
							var shadowRoot = _Native2.default.Element_attachShadow.call(this, init);
							this.__CE_shadowRoot = shadowRoot;
							return shadowRoot;
						});
					} else {
						console.warn('Custom Elements: `Element#attachShadow` was not patched.');
					}

					function patch_innerHTML(destination, baseDescriptor) {
						Object.defineProperty(destination, 'innerHTML', {
							enumerable: baseDescriptor.enumerable,
							configurable: true,
							get: baseDescriptor.get,
							set: /** @this {Element} */function set(htmlString) {
								var _this = this;

								var isConnected = Utilities.isConnected(this);

								// NOTE: In IE11, when using the native `innerHTML` setter, all nodes
								// that were previously descendants of the context element have all of
								// their children removed as part of the set - the entire subtree is
								// 'disassembled'. This work around walks the subtree *before* using the
								// native setter.
								/** @type {!Array<!Element>|undefined} */
								var removedElements = undefined;
								if (isConnected) {
									removedElements = [];
									Utilities.walkDeepDescendantElements(this, function (element) {
										if (element !== _this) {
											removedElements.push(element);
										}
									});
								}

								baseDescriptor.set.call(this, htmlString);

								if (removedElements) {
									for (var i = 0; i < removedElements.length; i++) {
										var element = removedElements[i];
										if (element.__CE_state === _CustomElementState2.default.custom) {
											internals.disconnectedCallback(element);
										}
									}
								}

								// Only create custom elements if this element's owner document is
								// associated with the registry.
								if (!this.ownerDocument.__CE_hasRegistry) {
									internals.patchTree(this);
								} else {
									internals.patchAndUpgradeTree(this);
								}
								return htmlString;
							}
						});
					}

					if (_Native2.default.Element_innerHTML && _Native2.default.Element_innerHTML.get) {
						patch_innerHTML(Element.prototype, _Native2.default.Element_innerHTML);
					} else if (_Native2.default.HTMLElement_innerHTML && _Native2.default.HTMLElement_innerHTML.get) {
						patch_innerHTML(HTMLElement.prototype, _Native2.default.HTMLElement_innerHTML);
					} else {
						(function () {

							/** @type {HTMLDivElement} */
							var rawDiv = _Native2.default.Document_createElement.call(document, 'div');

							internals.addPatch(function (element) {
								patch_innerHTML(element, {
									enumerable: true,
									configurable: true,
									// Implements getting `innerHTML` by performing an unpatched `cloneNode`
									// of the element and returning the resulting element's `innerHTML`.
									// TODO: Is this too expensive?
									get: /** @this {Element} */function get() {
										return _Native2.default.Node_cloneNode.call(this, true).innerHTML;
									},
									// Implements setting `innerHTML` by creating an unpatched element,
									// setting `innerHTML` of that element and replacing the target
									// element's children with those of the unpatched element.
									set: /** @this {Element} */function set(assignedValue) {
										// NOTE: re-route to `content` for `template` elements.
										// We need to do this because `template.appendChild` does not
										// route into `template.content`.
										/** @type {!Node} */
										var content = this.localName === 'template' ? /** @type {!HTMLTemplateElement} */this.content : this;
										rawDiv.innerHTML = assignedValue;

										while (content.childNodes.length > 0) {
											_Native2.default.Node_removeChild.call(content, content.childNodes[0]);
										}
										while (rawDiv.childNodes.length > 0) {
											_Native2.default.Node_appendChild.call(content, rawDiv.childNodes[0]);
										}
									}
								});
							});
						})();
					}

					Utilities.setPropertyUnchecked(Element.prototype, 'setAttribute',
					/**
      * @this {Element}
      * @param {string} name
      * @param {string} newValue
      */
					function (name, newValue) {
						// Fast path for non-custom elements.
						if (this.__CE_state !== _CustomElementState2.default.custom) {
							return _Native2.default.Element_setAttribute.call(this, name, newValue);
						}

						var oldValue = _Native2.default.Element_getAttribute.call(this, name);
						_Native2.default.Element_setAttribute.call(this, name, newValue);
						newValue = _Native2.default.Element_getAttribute.call(this, name);
						if (oldValue !== newValue) {
							internals.attributeChangedCallback(this, name, oldValue, newValue, null);
						}
					});

					Utilities.setPropertyUnchecked(Element.prototype, 'setAttributeNS',
					/**
      * @this {Element}
      * @param {?string} namespace
      * @param {string} name
      * @param {string} newValue
      */
					function (namespace, name, newValue) {
						// Fast path for non-custom elements.
						if (this.__CE_state !== _CustomElementState2.default.custom) {
							return _Native2.default.Element_setAttributeNS.call(this, namespace, name, newValue);
						}

						var oldValue = _Native2.default.Element_getAttributeNS.call(this, namespace, name);
						_Native2.default.Element_setAttributeNS.call(this, namespace, name, newValue);
						newValue = _Native2.default.Element_getAttributeNS.call(this, namespace, name);
						if (oldValue !== newValue) {
							internals.attributeChangedCallback(this, name, oldValue, newValue, namespace);
						}
					});

					Utilities.setPropertyUnchecked(Element.prototype, 'removeAttribute',
					/**
      * @this {Element}
      * @param {string} name
      */
					function (name) {
						// Fast path for non-custom elements.
						if (this.__CE_state !== _CustomElementState2.default.custom) {
							return _Native2.default.Element_removeAttribute.call(this, name);
						}

						var oldValue = _Native2.default.Element_getAttribute.call(this, name);
						_Native2.default.Element_removeAttribute.call(this, name);
						if (oldValue !== null) {
							internals.attributeChangedCallback(this, name, oldValue, null, null);
						}
					});

					Utilities.setPropertyUnchecked(Element.prototype, 'removeAttributeNS',
					/**
      * @this {Element}
      * @param {?string} namespace
      * @param {string} name
      */
					function (namespace, name) {
						// Fast path for non-custom elements.
						if (this.__CE_state !== _CustomElementState2.default.custom) {
							return _Native2.default.Element_removeAttributeNS.call(this, namespace, name);
						}

						var oldValue = _Native2.default.Element_getAttributeNS.call(this, namespace, name);
						_Native2.default.Element_removeAttributeNS.call(this, namespace, name);
						// In older browsers, `Element#getAttributeNS` may return the empty string
						// instead of null if the attribute does not exist. For details, see;
						// https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNS#Notes
						var newValue = _Native2.default.Element_getAttributeNS.call(this, namespace, name);
						if (oldValue !== newValue) {
							internals.attributeChangedCallback(this, name, oldValue, newValue, namespace);
						}
					});

					function patch_insertAdjacentElement(destination, baseMethod) {
						Utilities.setPropertyUnchecked(destination, 'insertAdjacentElement',
						/**
       * @this {Element}
       * @param {string} where
       * @param {!Element} element
       * @return {?Element}
       */
						function (where, element) {
							var wasConnected = Utilities.isConnected(element);
							var insertedElement = /** @type {!Element} */
							baseMethod.call(this, where, element);

							if (wasConnected) {
								internals.disconnectTree(element);
							}

							if (Utilities.isConnected(insertedElement)) {
								internals.connectTree(element);
							}
							return insertedElement;
						});
					}

					if (_Native2.default.HTMLElement_insertAdjacentElement) {
						patch_insertAdjacentElement(HTMLElement.prototype, _Native2.default.HTMLElement_insertAdjacentElement);
					} else if (_Native2.default.Element_insertAdjacentElement) {
						patch_insertAdjacentElement(Element.prototype, _Native2.default.Element_insertAdjacentElement);
					} else {
						console.warn('Custom Elements: `Element#insertAdjacentElement` was not patched.');
					}

					(0, _ParentNode2.default)(internals, Element.prototype, {
						prepend: _Native2.default.Element_prepend,
						append: _Native2.default.Element_append
					});

					(0, _ChildNode2.default)(internals, Element.prototype, {
						before: _Native2.default.Element_before,
						after: _Native2.default.Element_after,
						replaceWith: _Native2.default.Element_replaceWith,
						remove: _Native2.default.Element_remove
					});
				};

				var _Native = __webpack_require__(44);

				var _Native2 = _interopRequireDefault(_Native);

				var _CustomElementInternals = __webpack_require__(37);

				var _CustomElementInternals2 = _interopRequireDefault(_CustomElementInternals);

				var _CustomElementState = __webpack_require__(39);

				var _CustomElementState2 = _interopRequireDefault(_CustomElementState);

				var _Utilities = __webpack_require__(38);

				var Utilities = _interopRequireWildcard(_Utilities);

				var _ParentNode = __webpack_require__(47);

				var _ParentNode2 = _interopRequireDefault(_ParentNode);

				var _ChildNode = __webpack_require__(50);

				var _ChildNode2 = _interopRequireDefault(_ChildNode);

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					} else {
						var newObj = {};if (obj != null) {
							for (var key in obj) {
								if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
							}
						}newObj.default = obj;return newObj;
					}
				}

				function _interopRequireDefault(obj) {
					return obj && obj.__esModule ? obj : { default: obj };
				}

				

				/**
     * @param {!CustomElementInternals} internals
     */

				/***/
			},
			/* 50 */
			/***/function (module, exports, __webpack_require__) {

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});

				exports.default = function (internals, destination, builtIn) {
					/**
      * @param {...(!Node|string)} nodes
      */
					destination['before'] = function () {
						for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {
							nodes[_key] = arguments[_key];
						}

						// TODO: Fix this for when one of `nodes` is a DocumentFragment!
						var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {
							// DocumentFragments are not connected and will not be added to the list.
							return node instanceof Node && Utilities.isConnected(node);
						});

						builtIn.before.apply(this, nodes);

						for (var i = 0; i < connectedBefore.length; i++) {
							internals.disconnectTree(connectedBefore[i]);
						}

						if (Utilities.isConnected(this)) {
							for (var _i = 0; _i < nodes.length; _i++) {
								var node = nodes[_i];
								if (node instanceof Element) {
									internals.connectTree(node);
								}
							}
						}
					};

					/**
      * @param {...(!Node|string)} nodes
      */
					destination['after'] = function () {
						for (var _len2 = arguments.length, nodes = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
							nodes[_key2] = arguments[_key2];
						}

						// TODO: Fix this for when one of `nodes` is a DocumentFragment!
						var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {
							// DocumentFragments are not connected and will not be added to the list.
							return node instanceof Node && Utilities.isConnected(node);
						});

						builtIn.after.apply(this, nodes);

						for (var i = 0; i < connectedBefore.length; i++) {
							internals.disconnectTree(connectedBefore[i]);
						}

						if (Utilities.isConnected(this)) {
							for (var _i2 = 0; _i2 < nodes.length; _i2++) {
								var node = nodes[_i2];
								if (node instanceof Element) {
									internals.connectTree(node);
								}
							}
						}
					};

					/**
      * @param {...(!Node|string)} nodes
      */
					destination['replaceWith'] = function () {
						for (var _len3 = arguments.length, nodes = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
							nodes[_key3] = arguments[_key3];
						}

						// TODO: Fix this for when one of `nodes` is a DocumentFragment!
						var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {
							// DocumentFragments are not connected and will not be added to the list.
							return node instanceof Node && Utilities.isConnected(node);
						});

						var wasConnected = Utilities.isConnected(this);

						builtIn.replaceWith.apply(this, nodes);

						for (var i = 0; i < connectedBefore.length; i++) {
							internals.disconnectTree(connectedBefore[i]);
						}

						if (wasConnected) {
							internals.disconnectTree(this);
							for (var _i3 = 0; _i3 < nodes.length; _i3++) {
								var node = nodes[_i3];
								if (node instanceof Element) {
									internals.connectTree(node);
								}
							}
						}
					};

					destination['remove'] = function () {
						var wasConnected = Utilities.isConnected(this);

						builtIn.remove.call(this);

						if (wasConnected) {
							internals.disconnectTree(this);
						}
					};
				};

				var _CustomElementInternals = __webpack_require__(37);

				var _CustomElementInternals2 = _interopRequireDefault(_CustomElementInternals);

				var _Utilities = __webpack_require__(38);

				var Utilities = _interopRequireWildcard(_Utilities);

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					} else {
						var newObj = {};if (obj != null) {
							for (var key in obj) {
								if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
							}
						}newObj.default = obj;return newObj;
					}
				}

				function _interopRequireDefault(obj) {
					return obj && obj.__esModule ? obj : { default: obj };
				}

				/**
     * @typedef {{
     *   before: !function(...(!Node|string)),
     *   after: !function(...(!Node|string)),
     *   replaceWith: !function(...(!Node|string)),
     *   remove: !function(),
     * }}
     */
				var ChildNodeNativeMethods = void 0;

				/**
     * @param {!CustomElementInternals} internals
     * @param {!Object} destination
     * @param {!ChildNodeNativeMethods} builtIn
     */
				

				/***/
			},
			/* 51 */
			/***/function (module, exports, __webpack_require__) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				/**
     * Patches elements that interacts with ShadyDOM
     * such that tree traversal and mutation apis act like they would under
     * ShadowDOM.
     *
     * This import enables seemless interaction with ShadyDOM powered
     * custom elements, enabling better interoperation with 3rd party code,
     * libraries, and frameworks that use DOM tree manipulation apis.
     */

				'use strict';

				var _utils = __webpack_require__(52);

				var utils = _interopRequireWildcard(_utils);

				var _flush = __webpack_require__(53);

				var _observeChanges = __webpack_require__(54);

				var _nativeMethods = __webpack_require__(55);

				var nativeMethods = _interopRequireWildcard(_nativeMethods);

				var _nativeTree = __webpack_require__(56);

				var nativeTree = _interopRequireWildcard(_nativeTree);

				var _patchBuiltins = __webpack_require__(58);

				var _patchEvents = __webpack_require__(63);

				var _attachShadow = __webpack_require__(64);

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					} else {
						var newObj = {};if (obj != null) {
							for (var key in obj) {
								if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
							}
						}newObj.default = obj;return newObj;
					}
				}

				if (utils.settings.inUse) {

					window.ShadyDOM = {
						// TODO(sorvell): remove when Polymer does not depend on this.
						inUse: utils.settings.inUse,
						// TODO(sorvell): remove when Polymer does not depend on this.
						patch: function patch(node) {
							return node;
						},
						isShadyRoot: utils.isShadyRoot,
						enqueue: _flush.enqueue,
						flush: _flush.flush,
						settings: utils.settings,
						filterMutations: _observeChanges.filterMutations,
						observeChildren: _observeChanges.observeChildren,
						unobserveChildren: _observeChanges.unobserveChildren,
						nativeMethods: nativeMethods,
						nativeTree: nativeTree
					};

					// Apply patches to events...
					(0, _patchEvents.patchEvents)();
					// Apply patches to builtins (e.g. Element.prototype) where applicable.
					(0, _patchBuiltins.patchBuiltins)();

					window.ShadowRoot = _attachShadow.ShadyRoot;
				}

				/***/
			},
			/* 52 */
			/***/function (module, exports) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});
				exports.isShadyRoot = isShadyRoot;
				exports.ownerShadyRootForNode = ownerShadyRootForNode;
				exports.matchesSelector = matchesSelector;
				exports.extend = extend;
				exports.extendAll = extendAll;
				exports.mixin = mixin;
				exports.patchPrototype = patchPrototype;
				exports.microtask = microtask;
				var settings = exports.settings = window.ShadyDOM || {};

				settings.hasNativeShadowDOM = Boolean(Element.prototype.attachShadow && Node.prototype.getRootNode);

				var desc = Object.getOwnPropertyDescriptor(Node.prototype, 'firstChild');

				settings.hasDescriptors = Boolean(desc && desc.configurable && desc.get);
				settings.inUse = settings.force || !settings.hasNativeShadowDOM;

				function isShadyRoot(obj) {
					return Boolean(obj.__localName === 'ShadyRoot');
				}

				function ownerShadyRootForNode(node) {
					var root = node.getRootNode();
					if (isShadyRoot(root)) {
						return root;
					}
				}

				var p = Element.prototype;
				var matches = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;

				function matchesSelector(element, selector) {
					return matches.call(element, selector);
				}

				function copyOwnProperty(name, source, target) {
					var pd = Object.getOwnPropertyDescriptor(source, name);
					if (pd) {
						Object.defineProperty(target, name, pd);
					}
				}

				function extend(target, source) {
					if (target && source) {
						var n$ = Object.getOwnPropertyNames(source);
						for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
							copyOwnProperty(n, source, target);
						}
					}
					return target || source;
				}

				function extendAll(target) {
					for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
						sources[_key - 1] = arguments[_key];
					}

					for (var i = 0; i < sources.length; i++) {
						extend(target, sources[i]);
					}
					return target;
				}

				function mixin(target, source) {
					for (var i in source) {
						target[i] = source[i];
					}
					return target;
				}

				function patchPrototype(obj, mixin) {
					var proto = Object.getPrototypeOf(obj);
					if (!proto.hasOwnProperty('__patchProto')) {
						var patchProto = Object.create(proto);
						patchProto.__sourceProto = proto;
						extend(patchProto, mixin);
						proto.__patchProto = patchProto;
					}
					// old browsers don't have setPrototypeOf
					obj.__proto__ = proto.__patchProto;
				}

				var twiddle = document.createTextNode('');
				var content = 0;
				var queue = [];
				new MutationObserver(function () {
					while (queue.length) {
						// catch errors in user code...
						try {
							queue.shift()();
						} catch (e) {
							// enqueue another record and throw
							twiddle.textContent = content++;
							throw e;
						}
					}
				}).observe(twiddle, { characterData: true });

				// use MutationObserver to get microtask async timing.
				function microtask(callback) {
					queue.push(callback);
					twiddle.textContent = content++;
				}

				/***/
			},
			/* 53 */
			/***/function (module, exports, __webpack_require__) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});
				exports.enqueue = enqueue;
				exports.flush = flush;

				var _utils = __webpack_require__(52);

				var utils = _interopRequireWildcard(_utils);

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					} else {
						var newObj = {};if (obj != null) {
							for (var key in obj) {
								if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
							}
						}newObj.default = obj;return newObj;
					}
				}

				// render enqueuer/flusher
				var flushList = [];
				var scheduled = void 0;
				function enqueue(callback) {
					if (!scheduled) {
						scheduled = true;
						utils.microtask(flush);
					}
					flushList.push(callback);
				}

				function flush() {
					scheduled = false;
					var didFlush = Boolean(flushList.length);
					while (flushList.length) {
						flushList.shift()();
					}
					return didFlush;
				}

				flush.list = flushList;

				/***/
			},
			/* 54 */
			/***/function (module, exports, __webpack_require__) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});
				exports.unobserveChildren = exports.observeChildren = undefined;

				var _createClass = function () {
					function defineProperties(target, props) {
						for (var i = 0; i < props.length; i++) {
							var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
						}
					}return function (Constructor, protoProps, staticProps) {
						if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
					};
				}();

				exports.filterMutations = filterMutations;

				var _utils = __webpack_require__(52);

				var utils = _interopRequireWildcard(_utils);

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					} else {
						var newObj = {};if (obj != null) {
							for (var key in obj) {
								if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
							}
						}newObj.default = obj;return newObj;
					}
				}

				function _classCallCheck(instance, Constructor) {
					if (!(instance instanceof Constructor)) {
						throw new TypeError("Cannot call a class as a function");
					}
				}

				var AsyncObserver = function () {
					function AsyncObserver() {
						_classCallCheck(this, AsyncObserver);

						this._scheduled = false;
						this.addedNodes = [];
						this.removedNodes = [];
						this.callbacks = new Set();
					}

					_createClass(AsyncObserver, [{
						key: 'schedule',
						value: function schedule() {
							var _this = this;

							if (!this._scheduled) {
								this._scheduled = true;
								utils.microtask(function () {
									_this.flush();
								});
							}
						}
					}, {
						key: 'flush',
						value: function flush() {
							var _this2 = this;

							if (this._scheduled) {
								(function () {
									_this2._scheduled = false;
									var mutations = _this2.takeRecords();
									if (mutations.length) {
										_this2.callbacks.forEach(function (cb) {
											cb(mutations);
										});
									}
								})();
							}
						}
					}, {
						key: 'takeRecords',
						value: function takeRecords() {
							if (this.addedNodes.length || this.removedNodes.length) {
								var mutations = [{
									addedNodes: this.addedNodes,
									removedNodes: this.removedNodes
								}];
								this.addedNodes = [];
								this.removedNodes = [];
								return mutations;
							}
							return [];
						}
					}]);

					return AsyncObserver;
				}();

				// TODO(sorvell): consider instead polyfilling MutationObserver
				// directly so that users do not have to fork their code.
				// Supporting the entire api may be challenging: e.g. filtering out
				// removed nodes in the wrong scope and seeing non-distributing
				// subtree child mutations.


				var observeChildren = exports.observeChildren = function observeChildren(node, callback) {
					node.__shady = node.__shady || {};
					if (!node.__shady.observer) {
						node.__shady.observer = new AsyncObserver();
					}
					node.__shady.observer.callbacks.add(callback);
					var observer = node.__shady.observer;
					return {
						_callback: callback,
						_observer: observer,
						_node: node,
						takeRecords: function takeRecords() {
							return observer.takeRecords();
						}
					};
				};

				var unobserveChildren = exports.unobserveChildren = function unobserveChildren(handle) {
					var observer = handle && handle._observer;
					if (observer) {
						observer.callbacks.delete(handle._callback);
						if (!observer.callbacks.size) {
							handle._node.__shady.observer = null;
						}
					}
				};

				function filterMutations(mutations, target) {
					var targetRootNode = target.getRootNode();
					return mutations.map(function (mutation) {
						var mutationInScope = targetRootNode === mutation.target.getRootNode();
						if (mutationInScope && mutation.addedNodes) {
							var nodes = Array.from(mutation.addedNodes).filter(function (n) {
								return targetRootNode === n.getRootNode();
							});
							if (nodes.length) {
								mutation = Object.create(mutation);
								Object.defineProperty(mutation, 'addedNodes', {
									value: nodes,
									configurable: true
								});
								return mutation;
							}
						} else if (mutationInScope) {
							return mutation;
						}
					}).filter(function (m) {
						return m;
					});
				}

				/***/
			},
			/* 55 */
			/***/function (module, exports) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});
				var appendChild = exports.appendChild = Element.prototype.appendChild;
				var insertBefore = exports.insertBefore = Element.prototype.insertBefore;
				var removeChild = exports.removeChild = Element.prototype.removeChild;
				var setAttribute = exports.setAttribute = Element.prototype.setAttribute;
				var removeAttribute = exports.removeAttribute = Element.prototype.removeAttribute;
				var cloneNode = exports.cloneNode = Element.prototype.cloneNode;
				var importNode = exports.importNode = Document.prototype.importNode;
				var addEventListener = exports.addEventListener = Element.prototype.addEventListener;
				var removeEventListener = exports.removeEventListener = Element.prototype.removeEventListener;

				/***/
			},
			/* 56 */
			/***/function (module, exports, __webpack_require__) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});
				exports.parentNode = parentNode;
				exports.firstChild = firstChild;
				exports.lastChild = lastChild;
				exports.previousSibling = previousSibling;
				exports.nextSibling = nextSibling;
				exports.childNodes = childNodes;
				exports.parentElement = parentElement;
				exports.firstElementChild = firstElementChild;
				exports.lastElementChild = lastElementChild;
				exports.previousElementSibling = previousElementSibling;
				exports.nextElementSibling = nextElementSibling;
				exports.children = children;
				exports.innerHTML = innerHTML;
				exports.textContent = textContent;

				var _innerHTML = __webpack_require__(57);

				var nodeWalker = document.createTreeWalker(document, NodeFilter.SHOW_ALL, null, false);

				var elementWalker = document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT, null, false);

				function parentNode(node) {
					nodeWalker.currentNode = node;
					return nodeWalker.parentNode();
				}

				function firstChild(node) {
					nodeWalker.currentNode = node;
					return nodeWalker.firstChild();
				}

				function lastChild(node) {
					nodeWalker.currentNode = node;
					return nodeWalker.lastChild();
				}

				function previousSibling(node) {
					nodeWalker.currentNode = node;
					return nodeWalker.previousSibling();
				}

				function nextSibling(node) {
					nodeWalker.currentNode = node;
					return nodeWalker.nextSibling();
				}

				function childNodes(node) {
					var nodes = [];
					nodeWalker.currentNode = node;
					var n = nodeWalker.firstChild();
					while (n) {
						nodes.push(n);
						n = nodeWalker.nextSibling();
					}
					return nodes;
				}

				function parentElement(node) {
					elementWalker.currentNode = node;
					return elementWalker.parentNode();
				}

				function firstElementChild(node) {
					elementWalker.currentNode = node;
					return elementWalker.firstChild();
				}

				function lastElementChild(node) {
					elementWalker.currentNode = node;
					return elementWalker.lastChild();
				}

				function previousElementSibling(node) {
					elementWalker.currentNode = node;
					return elementWalker.previousSibling();
				}

				function nextElementSibling(node) {
					elementWalker.currentNode = node;
					return elementWalker.nextSibling();
				}

				function children(node) {
					var nodes = [];
					elementWalker.currentNode = node;
					var n = elementWalker.firstChild();
					while (n) {
						nodes.push(n);
						n = elementWalker.nextSibling();
					}
					return nodes;
				}

				function innerHTML(node) {
					return (0, _innerHTML.getInnerHTML)(node, function (n) {
						return childNodes(n);
					});
				}

				function textContent(node) {
					if (node.nodeType !== Node.ELEMENT_NODE) {
						return node.nodeValue;
					}
					var textWalker = document.createTreeWalker(node, NodeFilter.SHOW_TEXT, null, false);
					var content = '',
					    n = void 0;
					while (n = textWalker.nextNode()) {
						// TODO(sorvell): can't use textContent since we patch it on Node.prototype!
						// However, should probably patch it only on element.
						content += n.nodeValue;
					}
					return content;
				}

				/***/
			},
			/* 57 */
			/***/function (module, exports) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				'use strict';

				// Cribbed from ShadowDOM polyfill
				// https://github.com/webcomponents/webcomponentsjs/blob/master/src/ShadowDOM/wrappers/HTMLElement.js#L28
				/////////////////////////////////////////////////////////////////////////////
				// innerHTML and outerHTML

				// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString

				Object.defineProperty(exports, "__esModule", {
					value: true
				});
				exports.getOuterHTML = getOuterHTML;
				exports.getInnerHTML = getInnerHTML;
				var escapeAttrRegExp = /[&\u00A0"]/g;
				var escapeDataRegExp = /[&\u00A0<>]/g;

				function escapeReplace(c) {
					switch (c) {
						case '&':
							return '&amp;';
						case '<':
							return '&lt;';
						case '>':
							return '&gt;';
						case '"':
							return '&quot;';
						case '\xA0':
							return '&nbsp;';
					}
				}

				function escapeAttr(s) {
					return s.replace(escapeAttrRegExp, escapeReplace);
				}

				function escapeData(s) {
					return s.replace(escapeDataRegExp, escapeReplace);
				}

				function makeSet(arr) {
					var set = {};
					for (var i = 0; i < arr.length; i++) {
						set[arr[i]] = true;
					}
					return set;
				}

				// http://www.whatwg.org/specs/web-apps/current-work/#void-elements
				var voidElements = makeSet(['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr']);

				var plaintextParents = makeSet(['style', 'script', 'xmp', 'iframe', 'noembed', 'noframes', 'plaintext', 'noscript']);

				function getOuterHTML(node, parentNode, composed) {
					switch (node.nodeType) {
						case Node.ELEMENT_NODE:
							{
								var tagName = node.localName;
								var s = '<' + tagName;
								var attrs = node.attributes;
								for (var i = 0, attr; attr = attrs[i]; i++) {
									s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
								}
								s += '>';
								if (voidElements[tagName]) {
									return s;
								}
								return s + getInnerHTML(node, composed) + '</' + tagName + '>';
							}
						case Node.TEXT_NODE:
							{
								var data = node.data;
								if (parentNode && plaintextParents[parentNode.localName]) {
									return data;
								}
								return escapeData(data);
							}
						case Node.COMMENT_NODE:
							{
								return '<!--' + node.data + '-->';
							}
						default:
							{
								window.console.error(node);
								throw new Error('not implemented');
							}
					}
				}

				function getInnerHTML(node, composed) {
					if (node.localName === 'template') {
						node = node.content;
					}
					var s = '';
					var c$ = composed ? composed(node) : node.childNodes;
					for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
						s += getOuterHTML(child, node, composed);
					}
					return s;
				}

				/***/
			},
			/* 58 */
			/***/function (module, exports, __webpack_require__) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});
				exports.patchBuiltins = patchBuiltins;

				var _utils = __webpack_require__(52);

				var utils = _interopRequireWildcard(_utils);

				var _logicalMutation = __webpack_require__(59);

				var mutation = _interopRequireWildcard(_logicalMutation);

				var _patchAccessors = __webpack_require__(62);

				var _logicalProperties = __webpack_require__(60);

				var _patchEvents = __webpack_require__(63);

				var _attachShadow2 = __webpack_require__(64);

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					} else {
						var newObj = {};if (obj != null) {
							for (var key in obj) {
								if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
							}
						}newObj.default = obj;return newObj;
					}
				}

				function getAssignedSlot(node) {
					mutation.renderRootNode(node);
					return (0, _logicalProperties.getProperty)(node, 'assignedSlot') || null;
				}

				var nodeMixin = {

					addEventListener: _patchEvents.addEventListener,

					removeEventListener: _patchEvents.removeEventListener,

					appendChild: function appendChild(node) {
						return mutation.insertBefore(this, node);
					},
					insertBefore: function insertBefore(node, ref_node) {
						return mutation.insertBefore(this, node, ref_node);
					},
					removeChild: function removeChild(node) {
						return mutation.removeChild(this, node);
					},
					replaceChild: function replaceChild(node, ref_node) {
						this.insertBefore(node, ref_node);
						this.removeChild(ref_node);
						return node;
					},
					cloneNode: function cloneNode(deep) {
						return mutation.cloneNode(this, deep);
					},
					getRootNode: function getRootNode(options) {
						return mutation.getRootNode(this, options);
					},

					get isConnected() {
						// Fast path for distributed nodes.
						var ownerDocument = this.ownerDocument;
						if (ownerDocument && ownerDocument.contains && ownerDocument.contains(this)) return true;
						var ownerDocumentElement = ownerDocument.documentElement;
						if (ownerDocumentElement && ownerDocumentElement.contains && ownerDocumentElement.contains(this)) return true;

						var node = this;
						while (node && !(node instanceof Document)) {
							node = node.parentNode || (node instanceof _attachShadow2.ShadyRoot ? node.host : undefined);
						}
						return !!(node && node instanceof Document);
					}

				};

				// NOTE: For some reason `Text` redefines `assignedSlot`
				var textMixin = {
					get assignedSlot() {
						return getAssignedSlot(this);
					}
				};

				var fragmentMixin = {

					// TODO(sorvell): consider doing native QSA and filtering results.
					querySelector: function querySelector(selector) {
						// match selector and halt on first result.
						var result = mutation.query(this, function (n) {
							return utils.matchesSelector(n, selector);
						}, function (n) {
							return Boolean(n);
						})[0];
						return result || null;
					},
					querySelectorAll: function querySelectorAll(selector) {
						return mutation.query(this, function (n) {
							return utils.matchesSelector(n, selector);
						});
					}
				};

				var slotMixin = {
					assignedNodes: function assignedNodes(options) {
						if (this.localName === 'slot') {
							mutation.renderRootNode(this);
							return this.__shady ? (options && options.flatten ? this.__shady.distributedNodes : this.__shady.assignedNodes) || [] : [];
						}
					}
				};

				var elementMixin = utils.extendAll({
					setAttribute: function setAttribute(name, value) {
						mutation.setAttribute(this, name, value);
					},
					removeAttribute: function removeAttribute(name) {
						mutation.removeAttribute(this, name);
					},
					attachShadow: function attachShadow(options) {
						return (0, _attachShadow2.attachShadow)(this, options);
					},

					get slot() {
						return this.getAttribute('slot');
					},

					set slot(value) {
						this.setAttribute('slot', value);
					},

					get assignedSlot() {
						return getAssignedSlot(this);
					}

				}, fragmentMixin, slotMixin);

				Object.defineProperties(elementMixin, _patchAccessors.ShadowRootAccessor);

				var documentMixin = utils.extendAll({
					importNode: function importNode(node, deep) {
						return mutation.importNode(node, deep);
					}
				}, fragmentMixin);

				Object.defineProperties(documentMixin, {
					_activeElement: _patchAccessors.ActiveElementAccessor.activeElement
				});

				function patchBuiltin(proto, obj) {
					var n$ = Object.getOwnPropertyNames(obj);
					for (var i = 0; i < n$.length; i++) {
						var n = n$[i];
						var d = Object.getOwnPropertyDescriptor(obj, n);
						// NOTE: we prefer writing directly here because some browsers
						// have descriptors that are writable but not configurable (e.g.
						// `appendChild` on older browsers)
						if (d.value) {
							proto[n] = d.value;
						} else {
							Object.defineProperty(proto, n, d);
						}
					}
				}

				// Apply patches to builtins (e.g. Element.prototype). Some of these patches
				// can be done unconditionally (mostly methods like
				// `Element.prototype.appendChild`) and some can only be done when the browser
				// has proper descriptors on the builtin prototype
				// (e.g. `Element.prototype.firstChild`)`. When descriptors are not available,
				// elements are individually patched when needed (see e.g.
				// `patchInside/OutsideElementAccessors` in `patch-accessors.js`).
				function patchBuiltins() {
					// These patches can always be done, for all supported browsers.
					patchBuiltin(window.Node.prototype, nodeMixin);
					patchBuiltin(window.Text.prototype, textMixin);
					patchBuiltin(window.DocumentFragment.prototype, fragmentMixin);
					patchBuiltin(window.Element.prototype, elementMixin);
					patchBuiltin(window.Document.prototype, documentMixin);
					if (window.HTMLSlotElement) {
						patchBuiltin(window.HTMLSlotElement.prototype, slotMixin);
					}
					// These patches can *only* be done
					// on browsers that have proper property descriptors on builtin prototypes.
					// This includes: IE11, Edge, Chrome >= 4?; Safari >= 10, Firefox
					// On older browsers (Chrome <= 4?, Safari 9), a per element patching
					// strategy is used for patching accessors.
					if (utils.settings.hasDescriptors) {
						(0, _patchAccessors.patchAccessors)(window.Node.prototype);
						(0, _patchAccessors.patchAccessors)(window.Text.prototype);
						(0, _patchAccessors.patchAccessors)(window.DocumentFragment.prototype);
						(0, _patchAccessors.patchAccessors)(window.Element.prototype);
						var nativeHTMLElement = window.customElements && customElements.nativeHTMLElement || HTMLElement;
						(0, _patchAccessors.patchAccessors)(nativeHTMLElement.prototype);
						(0, _patchAccessors.patchAccessors)(window.Document.prototype);
						if (window.HTMLSlotElement) {
							(0, _patchAccessors.patchAccessors)(window.HTMLSlotElement.prototype);
						}
					}
				}

				/***/
			},
			/* 59 */
			/***/function (module, exports, __webpack_require__) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});
				exports.getRootNode = getRootNode;
				exports.query = query;
				exports.renderRootNode = renderRootNode;
				exports.setAttribute = setAttribute;
				exports.removeAttribute = removeAttribute;
				exports.insertBefore = insertBefore;
				exports.removeChild = removeChild;
				exports.cloneNode = cloneNode;
				exports.importNode = importNode;

				var _utils = __webpack_require__(52);

				var utils = _interopRequireWildcard(_utils);

				var _logicalProperties = __webpack_require__(60);

				var _logicalTree = __webpack_require__(61);

				var logicalTree = _interopRequireWildcard(_logicalTree);

				var _nativeMethods = __webpack_require__(55);

				var nativeMethods = _interopRequireWildcard(_nativeMethods);

				var _nativeTree = __webpack_require__(56);

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					} else {
						var newObj = {};if (obj != null) {
							for (var key in obj) {
								if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
							}
						}newObj.default = obj;return newObj;
					}
				}

				// Try to add node. Record logical info, track insertion points, perform
				// distribution iff needed. Return true if the add is handled.
				function addNode(container, node, ref_node) {
					var ownerRoot = utils.ownerShadyRootForNode(container);
					var ipAdded = void 0;
					if (ownerRoot) {
						// optimization: special insertion point tracking
						// TODO(sorvell): verify that the renderPending check here should not be needed.
						if (node.__noInsertionPoint && !ownerRoot._changePending) {
							ownerRoot._skipUpdateInsertionPoints = true;
						}
						// note: we always need to see if an insertion point is added
						// since this saves logical tree info; however, invalidation state
						// needs
						ipAdded = _maybeAddInsertionPoint(node, container, ownerRoot);
						// invalidate insertion points IFF not already invalid!
						if (ipAdded) {
							ownerRoot._skipUpdateInsertionPoints = false;
						}
					}
					if ((0, _logicalProperties.hasProperty)(container, 'firstChild')) {
						logicalTree.recordInsertBefore(node, container, ref_node);
					}
					// if not distributing and not adding to host, do a fast path addition
					// TODO(sorvell): revisit flow since `ipAdded` needed here if
					// node is a fragment that has a patched QSA.
					var handled = _maybeDistribute(node, container, ownerRoot, ipAdded) || container.shadyRoot;
					return handled;
				}

				// Try to remove node: update logical info and perform distribution iff
				// needed. Return true if the removal has been handled.
				// note that it's possible for both the node's host and its parent
				// to require distribution... both cases are handled here.
				function removeNode(node) {
					// important that we want to do this only if the node has a logical parent
					var logicalParent = (0, _logicalProperties.hasProperty)(node, 'parentNode') && (0, _logicalProperties.getProperty)(node, 'parentNode');
					var distributed = void 0;
					var ownerRoot = utils.ownerShadyRootForNode(node);
					if (logicalParent || ownerRoot) {
						// distribute node's parent iff needed
						distributed = maybeDistributeParent(node);
						if (logicalParent) {
							logicalTree.recordRemoveChild(node, logicalParent);
						}
						// remove node from root and distribute it iff needed
						var removedDistributed = ownerRoot && _removeDistributedChildren(ownerRoot, node);
						var addedInsertionPoint = logicalParent && ownerRoot && logicalParent.localName === ownerRoot.getInsertionPointTag();
						if (removedDistributed || addedInsertionPoint) {
							ownerRoot._skipUpdateInsertionPoints = false;
							updateRootViaContentChange(ownerRoot);
						}
					}
					_removeOwnerShadyRoot(node);
					return distributed;
				}

				function _scheduleObserver(node, addedNode, removedNode) {
					var observer = node.__shady && node.__shady.observer;
					if (observer) {
						if (addedNode) {
							observer.addedNodes.push(addedNode);
						}
						if (removedNode) {
							observer.removedNodes.push(removedNode);
						}
						observer.schedule();
					}
				}

				function removeNodeFromParent(node, logicalParent) {
					if (logicalParent) {
						_scheduleObserver(logicalParent, null, node);
						return removeNode(node);
					} else {
						// composed but not logical parent
						if (node.parentNode) {
							nativeMethods.removeChild.call(node.parentNode, node);
						}
						_removeOwnerShadyRoot(node);
					}
				}

				function _hasCachedOwnerRoot(node) {
					return Boolean(node.__ownerShadyRoot !== undefined);
				}

				function getRootNode(node) {
					if (!node || !node.nodeType) {
						return;
					}
					var root = node.__ownerShadyRoot;
					if (root === undefined) {
						if (utils.isShadyRoot(node)) {
							root = node;
						} else {
							var parent = node.parentNode;
							root = parent ? getRootNode(parent) : node;
						}
						// memo-ize result for performance but only memo-ize
						// result if node is in the document. This avoids a problem where a root
						// can be cached while an element is inside a fragment.
						// If this happens and we cache the result, the value can become stale
						// because for perf we avoid processing the subtree of added fragments.
						if (document.documentElement.contains(node)) {
							node.__ownerShadyRoot = root;
						}
					}
					return root;
				}

				function _maybeDistribute(node, container, ownerRoot, ipAdded) {
					// TODO(sorvell): technically we should check non-fragment nodes for
					// <content> children but since this case is assumed to be exceedingly
					// rare, we avoid the cost and will address with some specific api
					// when the need arises.  For now, the user must call
					// distributeContent(true), which updates insertion points manually
					// and forces distribution.
					var insertionPointTag = ownerRoot && ownerRoot.getInsertionPointTag() || '';
					var fragContent = node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noInsertionPoint && insertionPointTag && node.querySelector(insertionPointTag);
					var wrappedContent = fragContent && fragContent.parentNode.nodeType !== Node.DOCUMENT_FRAGMENT_NODE;
					var hasContent = fragContent || node.localName === insertionPointTag;
					// There are 3 possible cases where a distribution may need to occur:
					// 1. <content> being inserted (the host of the shady root where
					//    content is inserted needs distribution)
					// 2. children being inserted into parent with a shady root (parent
					//    needs distribution)
					// 3. container is an insertionPoint
					if (hasContent || container.localName === insertionPointTag || ipAdded) {
						if (ownerRoot) {
							// note, insertion point list update is handled after node
							// mutations are complete
							updateRootViaContentChange(ownerRoot);
						}
					}
					var needsDist = _nodeNeedsDistribution(container);
					if (needsDist) {
						updateRootViaContentChange(container.shadyRoot);
					}
					// Return true when distribution will fully handle the composition
					// Note that if a content was being inserted that was wrapped by a node,
					// and the parent does not need distribution, return false to allow
					// the nodes to be added directly, after which children may be
					// distributed and composed into the wrapping node(s)
					return needsDist || hasContent && !wrappedContent;
				}

				/* note: parent argument is required since node may have an out
    of date parent at this point; returns true if a <content> is being added */
				function _maybeAddInsertionPoint(node, parent, root) {
					var added = void 0;
					var insertionPointTag = root.getInsertionPointTag();
					if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noInsertionPoint) {
						var c$ = node.querySelectorAll(insertionPointTag);
						for (var i = 0, n, np, na; i < c$.length && (n = c$[i]); i++) {
							np = n.parentNode;
							// don't allow node's parent to be fragment itself
							if (np === node) {
								np = parent;
							}
							na = _maybeAddInsertionPoint(n, np, root);
							added = added || na;
						}
					} else if (node.localName === insertionPointTag) {
						logicalTree.recordChildNodes(parent);
						logicalTree.recordChildNodes(node);
						added = true;
					}
					return added;
				}

				function _nodeNeedsDistribution(node) {
					return node && node.shadyRoot && node.shadyRoot.hasInsertionPoint();
				}

				function _removeDistributedChildren(root, container) {
					var hostNeedsDist = void 0;
					var ip$ = root._insertionPoints;
					for (var i = 0; i < ip$.length; i++) {
						var insertionPoint = ip$[i];
						if (_contains(container, insertionPoint)) {
							var dc$ = insertionPoint.assignedNodes({ flatten: true });
							for (var j = 0; j < dc$.length; j++) {
								hostNeedsDist = true;
								var node = dc$[j];
								var parent = (0, _nativeTree.parentNode)(node);
								if (parent) {
									nativeMethods.removeChild.call(parent, node);
								}
							}
						}
					}
					return hostNeedsDist;
				}

				function _contains(container, node) {
					while (node) {
						if (node == container) {
							return true;
						}
						node = node.parentNode;
					}
				}

				function _removeOwnerShadyRoot(node) {
					// optimization: only reset the tree if node is actually in a root
					if (_hasCachedOwnerRoot(node)) {
						var c$ = node.childNodes;
						for (var i = 0, l = c$.length, n; i < l && (n = c$[i]); i++) {
							_removeOwnerShadyRoot(n);
						}
					}
					node.__ownerShadyRoot = undefined;
				}

				// TODO(sorvell): This will fail if distribution that affects this
				// question is pending; this is expected to be exceedingly rare, but if
				// the issue comes up, we can force a flush in this case.
				function firstComposedNode(insertionPoint) {
					var n$ = insertionPoint.assignedNodes({ flatten: true });
					var root = getRootNode(insertionPoint);
					for (var i = 0, l = n$.length, n; i < l && (n = n$[i]); i++) {
						// means that we're composed to this spot.
						if (root.isFinalDestination(insertionPoint, n)) {
							return n;
						}
					}
				}

				function maybeDistributeParent(node) {
					var parent = node.parentNode;
					if (_nodeNeedsDistribution(parent)) {
						updateRootViaContentChange(parent.shadyRoot);
						return true;
					}
				}

				function updateRootViaContentChange(root) {
					// mark root as mutation based on a mutation
					root._changePending = true;
					root.update();
				}

				function distributeAttributeChange(node, name) {
					if (name === 'slot') {
						maybeDistributeParent(node);
					} else if (node.localName === 'slot' && name === 'name') {
						var root = utils.ownerShadyRootForNode(node);
						if (root) {
							root.update();
						}
					}
				}

				// NOTE: `query` is used primarily for ShadyDOM's querySelector impl,
				// but it's also generally useful to recurse through the element tree
				// and is used by Polymer's styling system.
				function query(node, matcher, halter) {
					var list = [];
					_queryElements(node.childNodes, matcher, halter, list);
					return list;
				}

				function _queryElements(elements, matcher, halter, list) {
					for (var i = 0, l = elements.length, c; i < l && (c = elements[i]); i++) {
						if (c.nodeType === Node.ELEMENT_NODE && _queryElement(c, matcher, halter, list)) {
							return true;
						}
					}
				}

				function _queryElement(node, matcher, halter, list) {
					var result = matcher(node);
					if (result) {
						list.push(node);
					}
					if (halter && halter(result)) {
						return result;
					}
					_queryElements(node.childNodes, matcher, halter, list);
				}

				function renderRootNode(element) {
					var root = element.getRootNode();
					if (utils.isShadyRoot(root)) {
						root.render();
					}
				}

				var scopingShim = null;

				function setAttribute(node, attr, value) {
					if (!scopingShim) {
						scopingShim = window.ShadyCSS && window.ShadyCSS.ScopingShim;
					}
					// avoid scoping elements in non-main document to avoid template documents
					if (scopingShim && attr === 'class' && node.ownerDocument === document) {
						scopingShim.setElementClass(node, value);
					} else {
						nativeMethods.setAttribute.call(node, attr, value);
						distributeAttributeChange(node, attr);
					}
				}

				function removeAttribute(node, attr) {
					nativeMethods.removeAttribute.call(node, attr);
					distributeAttributeChange(node, attr);
				}

				// cases in which we may not be able to just do standard native call
				// 1. container has a shadyRoot (needsDistribution IFF the shadyRoot
				// has an insertion point)
				// 2. container is a shadyRoot (don't distribute, instead set
				// container to container.host.
				// 3. node is <content> (host of container needs distribution)
				function insertBefore(parent, node, ref_node) {
					if (ref_node) {
						var p = (0, _logicalProperties.getProperty)(ref_node, 'parentNode');
						if (p !== undefined && p !== parent) {
							throw Error('The ref_node to be inserted before is not a child ' + 'of this node');
						}
					}
					// remove node from its current position iff it's in a tree.
					if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
						var _parent = (0, _logicalProperties.getProperty)(node, 'parentNode');
						removeNodeFromParent(node, _parent);
					}
					if (!addNode(parent, node, ref_node)) {
						if (ref_node) {
							// if ref_node is an insertion point replace with first distributed node
							var root = utils.ownerShadyRootForNode(ref_node);
							if (root) {
								ref_node = ref_node.localName === root.getInsertionPointTag() ? firstComposedNode(ref_node) : ref_node;
							}
						}
						// if adding to a shadyRoot, add to host instead
						var container = utils.isShadyRoot(parent) ? parent.host : parent;
						if (ref_node) {
							nativeMethods.insertBefore.call(container, node, ref_node);
						} else {
							nativeMethods.appendChild.call(container, node);
						}
					}
					_scheduleObserver(parent, node);
					return node;
				}

				/**
      Removes the given `node` from the element's `lightChildren`.
      This method also performs dom composition.
    */
				function removeChild(parent, node) {
					if (node.parentNode !== parent) {
						throw Error('The node to be removed is not a child of this node: ' + node);
					}
					if (!removeNode(node)) {
						// if removing from a shadyRoot, remove form host instead
						var container = utils.isShadyRoot(parent) ? parent.host : parent;
						// not guaranteed to physically be in container; e.g.
						// undistributed nodes.
						var nativeParent = (0, _nativeTree.parentNode)(node);
						if (container === nativeParent) {
							nativeMethods.removeChild.call(container, node);
						}
					}
					_scheduleObserver(parent, null, node);
					return node;
				}

				function cloneNode(node, deep) {
					if (node.localName == 'template') {
						return nativeMethods.cloneNode.call(node, deep);
					} else {
						var n = nativeMethods.cloneNode.call(node, false);
						if (deep) {
							var c$ = node.childNodes;
							for (var i = 0, nc; i < c$.length; i++) {
								nc = c$[i].cloneNode(true);
								n.appendChild(nc);
							}
						}
						return n;
					}
				}

				// note: Though not technically correct, we fast path `importNode`
				// when called on a node not owned by the main document.
				// This allows, for example, elements that cannot
				// contain custom elements and are therefore not likely to contain shadowRoots
				// to cloned natively. This is a fairly significant performance win.
				function importNode(node, deep) {
					if (node.ownerDocument !== document) {
						return nativeMethods.importNode.call(document, node, deep);
					}
					var n = nativeMethods.importNode.call(document, node, false);
					if (deep) {
						var c$ = node.childNodes;
						for (var i = 0, nc; i < c$.length; i++) {
							nc = importNode(c$[i], true);
							n.appendChild(nc);
						}
					}
					return n;
				}

				/***/
			},
			/* 60 */
			/***/function (module, exports) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});
				exports.getProperty = getProperty;
				exports.hasProperty = hasProperty;
				function getProperty(node, prop) {
					return node.__shady && node.__shady[prop];
				}

				function hasProperty(node, prop) {
					return getProperty(node, prop) !== undefined;
				}

				/***/
			},
			/* 61 */
			/***/function (module, exports, __webpack_require__) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});
				exports.recordChildNodes = undefined;
				exports.recordInsertBefore = recordInsertBefore;
				exports.recordRemoveChild = recordRemoveChild;

				var _logicalProperties = __webpack_require__(60);

				var _patchAccessors = __webpack_require__(62);

				var _nativeTree = __webpack_require__(56);

				function recordInsertBefore(node, container, ref_node) {
					(0, _patchAccessors.patchInsideElementAccessors)(container);
					container.__shady = container.__shady || {};
					if ((0, _logicalProperties.hasProperty)(container, 'firstChild')) {
						container.__shady.childNodes = null;
					}
					// handle document fragments
					if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
						var c$ = node.childNodes;
						for (var i = 0; i < c$.length; i++) {
							linkNode(c$[i], container, ref_node);
						}
						// cleanup logical dom in doc fragment.
						node.__shady = node.__shady || {};
						var resetTo = (0, _logicalProperties.hasProperty)(node, 'firstChild') ? null : undefined;
						node.__shady.firstChild = node.__shady.lastChild = resetTo;
						node.__shady.childNodes = resetTo;
					} else {
						linkNode(node, container, ref_node);
					}
				}

				function linkNode(node, container, ref_node) {
					(0, _patchAccessors.patchOutsideElementAccessors)(node);
					ref_node = ref_node || null;
					node.__shady = node.__shady || {};
					container.__shady = container.__shady || {};
					if (ref_node) {
						ref_node.__shady = ref_node.__shady || {};
					}
					// update ref_node.previousSibling <-> node
					node.__shady.previousSibling = ref_node ? ref_node.__shady.previousSibling : container.lastChild;
					var ps = node.__shady.previousSibling;
					if (ps && ps.__shady) {
						ps.__shady.nextSibling = node;
					}
					// update node <-> ref_node
					var ns = node.__shady.nextSibling = ref_node;
					if (ns && ns.__shady) {
						ns.__shady.previousSibling = node;
					}
					// update node <-> container
					node.__shady.parentNode = container;
					if (ref_node) {
						if (ref_node === container.__shady.firstChild) {
							container.__shady.firstChild = node;
						}
					} else {
						container.__shady.lastChild = node;
						if (!container.__shady.firstChild) {
							container.__shady.firstChild = node;
						}
					}
					// remove caching of childNodes
					container.__shady.childNodes = null;
				}

				function recordRemoveChild(node, container) {
					node.__shady = node.__shady || {};
					container.__shady = container.__shady || {};
					if (node === container.__shady.firstChild) {
						container.__shady.firstChild = node.__shady.nextSibling;
					}
					if (node === container.__shady.lastChild) {
						container.__shady.lastChild = node.__shady.previousSibling;
					}
					var p = node.__shady.previousSibling;
					var n = node.__shady.nextSibling;
					if (p) {
						p.__shady = p.__shady || {};
						p.__shady.nextSibling = n;
					}
					if (n) {
						n.__shady = n.__shady || {};
						n.__shady.previousSibling = p;
					}
					// When an element is removed, logical data is no longer tracked.
					// Explicitly set `undefined` here to indicate this. This is disginguished
					// from `null` which is set if info is null.
					node.__shady.parentNode = node.__shady.previousSibling = node.__shady.nextSibling = undefined;
					if ((0, _logicalProperties.hasProperty)(container, 'childNodes')) {
						// remove caching of childNodes
						container.__shady.childNodes = null;
					}
				}

				var recordChildNodes = exports.recordChildNodes = function recordChildNodes(node) {
					if (!(0, _logicalProperties.hasProperty)(node, 'firstChild')) {
						node.__shady = node.__shady || {};
						node.__shady.firstChild = (0, _nativeTree.firstChild)(node);
						node.__shady.lastChild = (0, _nativeTree.lastChild)(node);
						(0, _patchAccessors.patchInsideElementAccessors)(node);
						var c$ = node.__shady.childNodes = (0, _nativeTree.childNodes)(node);
						for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
							n.__shady = n.__shady || {};
							n.__shady.parentNode = node;
							n.__shady.nextSibling = c$[i + 1] || null;
							n.__shady.previousSibling = c$[i - 1] || null;
							(0, _patchAccessors.patchOutsideElementAccessors)(n);
						}
					}
				};

				/***/
			},
			/* 62 */
			/***/function (module, exports, __webpack_require__) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});
				exports.patchInsideElementAccessors = exports.patchOutsideElementAccessors = exports.ActiveElementAccessor = exports.ShadowRootAccessor = undefined;
				exports.patchAccessors = patchAccessors;
				exports.patchShadowRootAccessors = patchShadowRootAccessors;

				var _utils = __webpack_require__(52);

				var utils = _interopRequireWildcard(_utils);

				var _innerHTML = __webpack_require__(57);

				var _logicalProperties = __webpack_require__(60);

				var _nativeTree = __webpack_require__(56);

				var nativeTree = _interopRequireWildcard(_nativeTree);

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					} else {
						var newObj = {};if (obj != null) {
							for (var key in obj) {
								if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
							}
						}newObj.default = obj;return newObj;
					}
				}

				function generateSimpleDescriptor(prop) {
					return {
						get: function get() {
							var l = (0, _logicalProperties.getProperty)(this, prop);
							return l !== undefined ? l : nativeTree[prop](this);
						},

						configurable: true
					};
				}

				function clearNode(node) {
					while (node.firstChild) {
						node.removeChild(node.firstChild);
					}
				}

				var nativeInnerHTMLDesc = Object.getOwnPropertyDescriptor(Element.prototype, 'innerHTML') || Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'innerHTML');

				var inertDoc = document.implementation.createHTMLDocument('inert');
				var htmlContainer = inertDoc.createElement('div');

				var nativeActiveElementDescriptor = Object.getOwnPropertyDescriptor(Document.prototype, 'activeElement');
				function getDocumentActiveElement() {
					if (nativeActiveElementDescriptor && nativeActiveElementDescriptor.get) {
						return nativeActiveElementDescriptor.get.call(document);
					} else if (!utils.settings.hasDescriptors) {
						return document.activeElement;
					}
				}

				function activeElementForNode(node) {
					var active = getDocumentActiveElement();
					// In IE11, activeElement might be an empty object if the document is
					// contained in an iframe.
					// https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10998788/
					if (!active || !active.nodeType) {
						return null;
					}
					var isShadyRoot = !!utils.isShadyRoot(node);
					if (node !== document) {
						// If this node isn't a document or shady root, then it doesn't have
						// an active element.
						if (!isShadyRoot) {
							return null;
						}
						// If this shady root's host is the active element or the active
						// element is not a descendant of the host (in the composed tree),
						// then it doesn't have an active element.
						if (node.host === active || !node.host.contains(active)) {
							return null;
						}
					}
					// This node is either the document or a shady root of which the active
					// element is a (composed) descendant of its host; iterate upwards to
					// find the active element's most shallow host within it.
					var activeRoot = utils.ownerShadyRootForNode(active);
					while (activeRoot && activeRoot !== node) {
						active = activeRoot.host;
						activeRoot = utils.ownerShadyRootForNode(active);
					}
					if (node === document) {
						// This node is the document, so activeRoot should be null.
						return activeRoot ? null : active;
					} else {
						// This node is a non-document shady root, and it should be
						// activeRoot.
						return activeRoot === node ? active : null;
					}
				}

				var OutsideAccessors = {
					// node...
					parentElement: generateSimpleDescriptor('parentElement'),

					parentNode: generateSimpleDescriptor('parentNode'),

					nextSibling: generateSimpleDescriptor('nextSibling'),

					previousSibling: generateSimpleDescriptor('previousSibling'),

					className: {
						get: function get() {
							return this.getAttribute('class');
						},
						set: function set(value) {
							this.setAttribute('class', value);
						},

						configurable: true
					},

					// fragment, element, document
					nextElementSibling: {
						get: function get() {
							if ((0, _logicalProperties.hasProperty)(this, 'nextSibling')) {
								var n = this.nextSibling;
								while (n && n.nodeType !== Node.ELEMENT_NODE) {
									n = n.nextSibling;
								}
								return n;
							} else {
								return nativeTree.nextElementSibling(this);
							}
						},

						configurable: true
					},

					previousElementSibling: {
						get: function get() {
							if ((0, _logicalProperties.hasProperty)(this, 'previousSibling')) {
								var n = this.previousSibling;
								while (n && n.nodeType !== Node.ELEMENT_NODE) {
									n = n.previousSibling;
								}
								return n;
							} else {
								return nativeTree.previousElementSibling(this);
							}
						},

						configurable: true
					}

				};

				var InsideAccessors = {

					childNodes: {
						get: function get() {
							if ((0, _logicalProperties.hasProperty)(this, 'firstChild')) {
								if (!this.__shady.childNodes) {
									this.__shady.childNodes = [];
									for (var n = this.firstChild; n; n = n.nextSibling) {
										this.__shady.childNodes.push(n);
									}
								}
								return this.__shady.childNodes;
							} else {
								return nativeTree.childNodes(this);
							}
						},

						configurable: true
					},

					firstChild: generateSimpleDescriptor('firstChild'),

					lastChild: generateSimpleDescriptor('lastChild'),

					textContent: {
						get: function get() {
							if ((0, _logicalProperties.hasProperty)(this, 'firstChild')) {
								var tc = [];
								for (var i = 0, cn = this.childNodes, c; c = cn[i]; i++) {
									if (c.nodeType !== Node.COMMENT_NODE) {
										tc.push(c.textContent);
									}
								}
								return tc.join('');
							} else {
								return nativeTree.textContent(this);
							}
						},
						set: function set(text) {
							if (this.nodeType !== Node.ELEMENT_NODE) {
								// TODO(sorvell): can't do this if patch nodeValue.
								this.nodeValue = text;
							} else {
								clearNode(this);
								if (text) {
									this.appendChild(document.createTextNode(text));
								}
							}
						},

						configurable: true
					},

					// fragment, element, document
					firstElementChild: {
						get: function get() {
							if ((0, _logicalProperties.hasProperty)(this, 'firstChild')) {
								var n = this.firstChild;
								while (n && n.nodeType !== Node.ELEMENT_NODE) {
									n = n.nextSibling;
								}
								return n;
							} else {
								return nativeTree.firstElementChild(this);
							}
						},

						configurable: true
					},

					lastElementChild: {
						get: function get() {
							if ((0, _logicalProperties.hasProperty)(this, 'lastChild')) {
								var n = this.lastChild;
								while (n && n.nodeType !== Node.ELEMENT_NODE) {
									n = n.previousSibling;
								}
								return n;
							} else {
								return nativeTree.lastElementChild(this);
							}
						},

						configurable: true
					},

					children: {
						get: function get() {
							if ((0, _logicalProperties.hasProperty)(this, 'firstChild')) {
								return Array.prototype.filter.call(this.childNodes, function (n) {
									return n.nodeType === Node.ELEMENT_NODE;
								});
							} else {
								return nativeTree.children(this);
							}
						},

						configurable: true
					},

					// element (HTMLElement on IE11)
					innerHTML: {
						get: function get() {
							var content = this.localName === 'template' ? this.content : this;
							if ((0, _logicalProperties.hasProperty)(this, 'firstChild')) {
								return (0, _innerHTML.getInnerHTML)(content);
							} else {
								return nativeTree.innerHTML(content);
							}
						},
						set: function set(text) {
							var content = this.localName === 'template' ? this.content : this;
							clearNode(content);
							if (nativeInnerHTMLDesc && nativeInnerHTMLDesc.set) {
								nativeInnerHTMLDesc.set.call(htmlContainer, text);
							} else {
								htmlContainer.innerHTML = text;
							}
							while (htmlContainer.firstChild) {
								content.appendChild(htmlContainer.firstChild);
							}
						},

						configurable: true
					}

				};

				// Note: Can be patched on element prototype on all browsers.
				// Must be patched on instance on browsers that support native Shadow DOM
				// but do not have builtin accessors (old Chrome).
				var ShadowRootAccessor = exports.ShadowRootAccessor = {
					shadowRoot: {
						get: function get() {
							return this.shadyRoot;
						},
						set: function set(value) {
							this.shadyRoot = value;
						},

						configurable: true
					}
				};

				// Note: Can be patched on document prototype on browsers with builtin accessors.
				// Must be patched separately on simulated ShadowRoot.
				// Must be patched as `_activeElement` on browsers without builtin accessors.
				var ActiveElementAccessor = exports.ActiveElementAccessor = {

					activeElement: {
						get: function get() {
							return activeElementForNode(this);
						},
						set: function set() {},

						configurable: true
					}

				};

				// patch a group of descriptors on an object only if it exists or if the `force`
				// argument is true.
				function patchAccessorGroup(obj, descriptors, force) {
					for (var p in descriptors) {
						var objDesc = Object.getOwnPropertyDescriptor(obj, p);
						if (objDesc && objDesc.configurable || !objDesc && force) {
							Object.defineProperty(obj, p, descriptors[p]);
						} else if (force) {
							console.warn('Could not define', p, 'on', obj);
						}
					}
				}

				// patch dom accessors on proto where they exist
				function patchAccessors(proto) {
					patchAccessorGroup(proto, OutsideAccessors);
					patchAccessorGroup(proto, InsideAccessors);
					patchAccessorGroup(proto, ActiveElementAccessor);
				}

				// ensure element descriptors (IE/Edge don't have em)
				function patchShadowRootAccessors(proto) {
					patchAccessorGroup(proto, InsideAccessors, true);
					patchAccessorGroup(proto, ActiveElementAccessor, true);
				}

				// ensure an element has patched "outside" accessors; no-op when not needed
				var patchOutsideElementAccessors = exports.patchOutsideElementAccessors = utils.settings.hasDescriptors ? function () {} : function (element) {
					if (!(element.__shady && element.__shady.__outsideAccessors)) {
						element.__shady = element.__shady || {};
						element.__shady.__outsideAccessors = true;
						patchAccessorGroup(element, OutsideAccessors, true);
					}
				};

				// ensure an element has patched "inside" accessors; no-op when not needed
				var patchInsideElementAccessors = exports.patchInsideElementAccessors = utils.settings.hasDescriptors ? function () {} : function (element) {
					if (!(element.__shady && element.__shady.__insideAccessors)) {
						element.__shady = element.__shady || {};
						element.__shady.__insideAccessors = true;
						patchAccessorGroup(element, InsideAccessors, true);
						patchAccessorGroup(element, ShadowRootAccessor, true);
					}
				};

				/***/
			},
			/* 63 */
			/***/function (module, exports, __webpack_require__) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});

				var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
					return typeof obj;
				} : function (obj) {
					return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
				};

				exports.addEventListener = addEventListener;
				exports.removeEventListener = removeEventListener;
				exports.patchEvents = patchEvents;

				var _utils = __webpack_require__(52);

				var utils = _interopRequireWildcard(_utils);

				var _nativeMethods = __webpack_require__(55);

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					} else {
						var newObj = {};if (obj != null) {
							for (var key in obj) {
								if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
							}
						}newObj.default = obj;return newObj;
					}
				}

				// https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937
				var alwaysComposed = {
					blur: true,
					focus: true,
					focusin: true,
					focusout: true,
					click: true,
					dblclick: true,
					mousedown: true,
					mouseenter: true,
					mouseleave: true,
					mousemove: true,
					mouseout: true,
					mouseover: true,
					mouseup: true,
					wheel: true,
					beforeinput: true,
					input: true,
					keydown: true,
					keyup: true,
					compositionstart: true,
					compositionupdate: true,
					compositionend: true,
					touchstart: true,
					touchend: true,
					touchmove: true,
					touchcancel: true,
					pointerover: true,
					pointerenter: true,
					pointerdown: true,
					pointermove: true,
					pointerup: true,
					pointercancel: true,
					pointerout: true,
					pointerleave: true,
					gotpointercapture: true,
					lostpointercapture: true,
					dragstart: true,
					drag: true,
					dragenter: true,
					dragleave: true,
					dragover: true,
					drop: true,
					dragend: true,
					DOMActivate: true,
					DOMFocusIn: true,
					DOMFocusOut: true,
					keypress: true
				};

				function pathComposer(startNode, composed) {
					var composedPath = [];
					var current = startNode;
					var startRoot = startNode === window ? window : startNode.getRootNode();
					while (current) {
						composedPath.push(current);
						if (current.assignedSlot) {
							current = current.assignedSlot;
						} else if (current.nodeType === Node.DOCUMENT_FRAGMENT_NODE && current.host && (composed || current !== startRoot)) {
							current = current.host;
						} else {
							current = current.parentNode;
						}
					}
					// event composedPath includes window when startNode's ownerRoot is document
					if (composedPath[composedPath.length - 1] === document) {
						composedPath.push(window);
					}
					return composedPath;
				}

				function retarget(refNode, path) {
					if (!utils.isShadyRoot) {
						return refNode;
					}
					// If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's
					// shadow-including inclusive ancestor, return ANCESTOR.
					var refNodePath = pathComposer(refNode, true);
					var p$ = path;
					for (var i = 0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {
						ancestor = p$[i];
						root = ancestor === window ? window : ancestor.getRootNode();
						if (root !== lastRoot) {
							rootIdx = refNodePath.indexOf(root);
							lastRoot = root;
						}
						if (!utils.isShadyRoot(root) || rootIdx > -1) {
							return ancestor;
						}
					}
				}

				var eventMixin = {

					get composed() {
						if (this.isTrusted && this.__composed === undefined) {
							this.__composed = alwaysComposed[this.type];
						}
						return this.__composed || false;
					},

					composedPath: function composedPath() {
						if (!this.__composedPath) {
							this.__composedPath = pathComposer(this.__target, this.composed);
						}
						return this.__composedPath;
					},

					get target() {
						return retarget(this.currentTarget, this.composedPath());
					},

					// http://w3c.github.io/webcomponents/spec/shadow/#event-relatedtarget-retargeting
					get relatedTarget() {
						if (!this.__relatedTarget) {
							return null;
						}
						if (!this.__relatedTargetComposedPath) {
							this.__relatedTargetComposedPath = pathComposer(this.__relatedTarget, true);
						}
						// find the deepest node in relatedTarget composed path that is in the same root with the currentTarget
						return retarget(this.currentTarget, this.__relatedTargetComposedPath);
					},
					stopPropagation: function stopPropagation() {
						Event.prototype.stopPropagation.call(this);
						this.__propagationStopped = true;
					},
					stopImmediatePropagation: function stopImmediatePropagation() {
						Event.prototype.stopImmediatePropagation.call(this);
						this.__immediatePropagationStopped = true;
						this.__propagationStopped = true;
					}
				};

				function mixinComposedFlag(Base) {
					// NOTE: avoiding use of `class` here so that transpiled output does not
					// try to do `Base.call` with a dom construtor.
					var klazz = function klazz(type, options) {
						var event = new Base(type, options);
						event.__composed = options && Boolean(options.composed);
						return event;
					};
					// put constructor properties on subclass
					utils.mixin(klazz, Base);
					klazz.prototype = Base.prototype;
					return klazz;
				}

				var nonBubblingEventsToRetarget = {
					focus: true,
					blur: true
				};

				function fireHandlers(event, node, phase) {
					var hs = node.__handlers && node.__handlers[event.type] && node.__handlers[event.type][phase];
					if (hs) {
						for (var i = 0, fn; fn = hs[i]; i++) {
							fn.call(node, event);
							if (event.__immediatePropagationStopped) {
								return;
							}
						}
					}
				}

				function retargetNonBubblingEvent(e) {
					var path = e.composedPath();
					var node = void 0;
					// override `currentTarget` to let patched `target` calculate correctly
					Object.defineProperty(e, 'currentTarget', {
						get: function get() {
							return node;
						},
						configurable: true
					});
					for (var i = path.length - 1; i >= 0; i--) {
						node = path[i];
						// capture phase fires all capture handlers
						fireHandlers(e, node, 'capture');
						if (e.__propagationStopped) {
							return;
						}
					}

					// set the event phase to `AT_TARGET` as in spec
					Object.defineProperty(e, 'eventPhase', { value: Event.AT_TARGET });

					// the event only needs to be fired when owner roots change when iterating the event path
					// keep track of the last seen owner root
					var lastFiredRoot = void 0;
					for (var _i = 0; _i < path.length; _i++) {
						node = path[_i];
						if (_i === 0 || node.shadowRoot && node.shadowRoot === lastFiredRoot) {
							fireHandlers(e, node, 'bubble');
							// don't bother with window, it doesn't have `getRootNode` and will be last in the path anyway
							if (node !== window) {
								lastFiredRoot = node.getRootNode();
							}
							if (e.__propagationStopped) {
								return;
							}
						}
					}
				}

				function addEventListener(type, fn, optionsOrCapture) {
					if (!fn) {
						return;
					}

					// The callback `fn` might be used for multiple nodes/events. Since we generate
					// a wrapper function, we need to keep track of it when we remove the listener.
					// It's more efficient to store the node/type/options information as Array in
					// `fn` itself rather than the node (we assume that the same callback is used
					// for few nodes at most, whereas a node will likely have many event listeners).
					// NOTE(valdrin) invoking external functions is costly, inline has better perf.
					var capture = void 0,
					    once = void 0,
					    passive = void 0;
					if ((typeof optionsOrCapture === 'undefined' ? 'undefined' : _typeof(optionsOrCapture)) === 'object') {
						capture = Boolean(optionsOrCapture.capture);
						once = Boolean(optionsOrCapture.once);
						passive = Boolean(optionsOrCapture.passive);
					} else {
						capture = Boolean(optionsOrCapture);
						once = false;
						passive = false;
					}
					if (fn.__eventWrappers) {
						// Stop if the wrapper function has already been created.
						for (var i = 0; i < fn.__eventWrappers.length; i++) {
							if (fn.__eventWrappers[i].node === this && fn.__eventWrappers[i].type === type && fn.__eventWrappers[i].capture === capture && fn.__eventWrappers[i].once === once && fn.__eventWrappers[i].passive === passive) {
								return;
							}
						}
					} else {
						fn.__eventWrappers = [];
					}

					var wrapperFn = function wrapperFn(e) {
						// Support `once` option.
						if (once) {
							this.removeEventListener(type, fn, optionsOrCapture);
						}
						if (!e.__target) {
							patchEvent(e);
						}
						// There are two critera that should stop events from firing on this node
						// 1. the event is not composed and the current node is not in the same root as the target
						// 2. when bubbling, if after retargeting, relatedTarget and target point to the same node
						if (e.composed || e.composedPath().indexOf(this) > -1) {
							if (e.eventPhase === Event.BUBBLING_PHASE) {
								if (e.target === e.relatedTarget) {
									e.stopImmediatePropagation();
									return;
								}
							}
							return fn(e);
						}
					};
					// Store the wrapper information.
					fn.__eventWrappers.push({
						node: this,
						type: type,
						capture: capture,
						once: once,
						passive: passive,
						wrapperFn: wrapperFn
					});

					if (nonBubblingEventsToRetarget[type]) {
						this.__handlers = this.__handlers || {};
						this.__handlers[type] = this.__handlers[type] || { capture: [], bubble: [] };
						this.__handlers[type][capture ? 'capture' : 'bubble'].push(wrapperFn);
					} else {
						_nativeMethods.addEventListener.call(this, type, wrapperFn, optionsOrCapture);
					}
				}

				function removeEventListener(type, fn, optionsOrCapture) {
					if (!fn) {
						return;
					}

					// NOTE(valdrin) invoking external functions is costly, inline has better perf.
					var capture = void 0,
					    once = void 0,
					    passive = void 0;
					if ((typeof optionsOrCapture === 'undefined' ? 'undefined' : _typeof(optionsOrCapture)) === 'object') {
						capture = Boolean(optionsOrCapture.capture);
						once = Boolean(optionsOrCapture.once);
						passive = Boolean(optionsOrCapture.passive);
					} else {
						capture = Boolean(optionsOrCapture);
						once = false;
						passive = false;
					}
					// Search the wrapped function.
					var wrapperFn = undefined;
					if (fn.__eventWrappers) {
						for (var i = 0; i < fn.__eventWrappers.length; i++) {
							if (fn.__eventWrappers[i].node === this && fn.__eventWrappers[i].type === type && fn.__eventWrappers[i].capture === capture && fn.__eventWrappers[i].once === once && fn.__eventWrappers[i].passive === passive) {
								wrapperFn = fn.__eventWrappers.splice(i, 1)[0].wrapperFn;
								// Cleanup.
								if (!fn.__eventWrappers.length) {
									fn.__eventWrappers = undefined;
								}
								break;
							}
						}
					}

					_nativeMethods.removeEventListener.call(this, type, wrapperFn || fn, optionsOrCapture);
					if (wrapperFn && nonBubblingEventsToRetarget[type] && this.__handlers && this.__handlers[type]) {
						var arr = this.__handlers[type][capture ? 'capture' : 'bubble'];
						var idx = arr.indexOf(wrapperFn);
						if (idx > -1) {
							arr.splice(idx, 1);
						}
					}
				}

				function activateFocusEventOverrides() {
					for (var ev in nonBubblingEventsToRetarget) {
						window.addEventListener(ev, function (e) {
							if (!e.__target) {
								patchEvent(e);
								retargetNonBubblingEvent(e);
								e.stopImmediatePropagation();
							}
						}, true);
					}
				}

				function patchEvent(event) {
					event.__target = event.target;
					event.__relatedTarget = event.relatedTarget;
					// patch event prototype if we can
					if (utils.settings.hasDescriptors) {
						utils.patchPrototype(event, eventMixin);
						// and fallback to patching instance
					} else {
						utils.extend(event, eventMixin);
					}
				}

				var PatchedEvent = mixinComposedFlag(window.Event);
				var PatchedCustomEvent = mixinComposedFlag(window.CustomEvent);
				var PatchedMouseEvent = mixinComposedFlag(window.MouseEvent);

				function patchEvents() {
					window.Event = PatchedEvent;
					window.CustomEvent = PatchedCustomEvent;
					window.MouseEvent = PatchedMouseEvent;
					activateFocusEventOverrides();
				}

				/***/
			},
			/* 64 */
			/***/function (module, exports, __webpack_require__) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});
				exports.ShadyRoot = undefined;
				exports.attachShadow = attachShadow;

				var _arraySplice = __webpack_require__(65);

				var _utils = __webpack_require__(52);

				var utils = _interopRequireWildcard(_utils);

				var _flush = __webpack_require__(53);

				var _logicalTree = __webpack_require__(61);

				var _nativeMethods = __webpack_require__(55);

				var _nativeTree = __webpack_require__(56);

				var _patchAccessors = __webpack_require__(62);

				var _distributor = __webpack_require__(66);

				var _distributor2 = _interopRequireDefault(_distributor);

				function _interopRequireDefault(obj) {
					return obj && obj.__esModule ? obj : { default: obj };
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					} else {
						var newObj = {};if (obj != null) {
							for (var key in obj) {
								if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
							}
						}newObj.default = obj;return newObj;
					}
				}

				// Do not export this object. It must be passed as the first argument to the
				// ShadyRoot constructor in `attachShadow` to prevent the constructor from
				// throwing. This prevents the user from being able to manually construct a
				// ShadyRoot (i.e. `new ShadowRoot()`).
				var ShadyRootConstructionToken = {};

				var ShadyRoot = exports.ShadyRoot = function ShadyRoot(token, host) {
					if (token !== ShadyRootConstructionToken) {
						throw new TypeError('Illegal constructor');
					}
					// NOTE: this strange construction is necessary because
					// DocumentFragment cannot be subclassed on older browsers.
					var shadowRoot = document.createDocumentFragment();
					shadowRoot.__proto__ = ShadyRoot.prototype;
					shadowRoot._init(host);
					return shadowRoot;
				};

				ShadyRoot.prototype = Object.create(DocumentFragment.prototype);
				utils.extendAll(ShadyRoot.prototype, {
					_init: function _init(host) {
						// NOTE: set a fake local name so this element can be
						// distinguished from a DocumentFragment when patching.
						// FF doesn't allow this to be `localName`
						this.__localName = 'ShadyRoot';
						// logical dom setup
						(0, _logicalTree.recordChildNodes)(host);
						(0, _logicalTree.recordChildNodes)(this);
						// root <=> host
						host.shadowRoot = this;
						this.host = host;
						// state flags
						this._renderPending = false;
						this._hasRendered = false;
						this._changePending = false;
						this._distributor = new _distributor2.default(this);
						this.update();
					},

					// async render
					update: function update() {
						var _this = this;

						if (!this._renderPending) {
							this._renderPending = true;
							(0, _flush.enqueue)(function () {
								return _this.render();
							});
						}
					},

					// returns the oldest renderPending ancestor root.
					_getRenderRoot: function _getRenderRoot() {
						var renderRoot = this;
						var root = this;
						while (root) {
							if (root._renderPending) {
								renderRoot = root;
							}
							root = root._rendererForHost();
						}
						return renderRoot;
					},

					// Returns the shadyRoot `this.host` if `this.host`
					// has children that require distribution.
					_rendererForHost: function _rendererForHost() {
						var root = this.host.getRootNode();
						if (utils.isShadyRoot(root)) {
							var c$ = this.host.childNodes;
							for (var i = 0, c; i < c$.length; i++) {
								c = c$[i];
								if (this._distributor.isInsertionPoint(c)) {
									return root;
								}
							}
						}
					},
					render: function render() {
						if (this._renderPending) {
							this._getRenderRoot()._render();
						}
					},
					_render: function _render() {
						this._renderPending = false;
						this._changePending = false;
						if (!this._skipUpdateInsertionPoints) {
							this.updateInsertionPoints();
						} else if (!this._hasRendered) {
							this._insertionPoints = [];
						}
						this._skipUpdateInsertionPoints = false;
						// TODO(sorvell): can add a first render optimization here
						// to use if there are no insertion points
						// 1. clear host node of composed children
						// 2. appendChild the shadowRoot itself or (more robust) its logical children
						// NOTE: this didn't seem worth it in perf testing
						// but not ready to delete this info.
						// logical
						this.distribute();
						// physical
						this.compose();
						this._hasRendered = true;
					},
					forceRender: function forceRender() {
						this._renderPending = true;
						this.render();
					},
					distribute: function distribute() {
						var dirtyRoots = this._distributor.distribute();
						for (var i = 0; i < dirtyRoots.length; i++) {
							dirtyRoots[i]._render();
						}
					},
					updateInsertionPoints: function updateInsertionPoints() {
						var i$ = this.__insertionPoints;
						// if any insertion points have been removed, clear their distribution info
						if (i$) {
							for (var i = 0, c; i < i$.length; i++) {
								c = i$[i];
								if (c.getRootNode() !== this) {
									this._distributor.clearAssignedSlots(c);
								}
							}
						}
						i$ = this._insertionPoints = this._distributor.getInsertionPoints();
						// ensure insertionPoints's and their parents have logical dom info.
						// save logical tree info
						// a. for shadyRoot
						// b. for insertion points (fallback)
						// c. for parents of insertion points
						for (var _i = 0, _c; _i < i$.length; _i++) {
							_c = i$[_i];
							_c.__shady = _c.__shady || {};
							(0, _logicalTree.recordChildNodes)(_c);
							(0, _logicalTree.recordChildNodes)(_c.parentNode);
						}
					},

					get _insertionPoints() {
						if (!this.__insertionPoints) {
							this.updateInsertionPoints();
						}
						return this.__insertionPoints || (this.__insertionPoints = []);
					},

					set _insertionPoints(insertionPoints) {
						this.__insertionPoints = insertionPoints;
					},

					hasInsertionPoint: function hasInsertionPoint() {
						return this._distributor.hasInsertionPoint();
					},
					compose: function compose() {
						// compose self
						// note: it's important to mark this clean before distribution
						// so that attachment that provokes additional distribution (e.g.
						// adding something to your parentNode) works
						this._composeTree();
						// TODO(sorvell): See fast paths here in Polymer v1
						// (these seem unnecessary)
					},

					// Reify dom such that it is at its correct rendering position
					// based on logical distribution.
					_composeTree: function _composeTree() {
						this._updateChildNodes(this.host, this._composeNode(this.host));
						var p$ = this._insertionPoints || [];
						for (var i = 0, l = p$.length, p, parent; i < l && (p = p$[i]); i++) {
							parent = p.parentNode;
							if (parent !== this.host && parent !== this) {
								this._updateChildNodes(parent, this._composeNode(parent));
							}
						}
					},

					// Returns the list of nodes which should be rendered inside `node`.
					_composeNode: function _composeNode(node) {
						var children = [];
						var c$ = (node.shadyRoot || node).childNodes;
						for (var i = 0; i < c$.length; i++) {
							var child = c$[i];
							if (this._distributor.isInsertionPoint(child)) {
								var distributedNodes = child.__shady.distributedNodes || (child.__shady.distributedNodes = []);
								for (var j = 0; j < distributedNodes.length; j++) {
									var distributedNode = distributedNodes[j];
									if (this.isFinalDestination(child, distributedNode)) {
										children.push(distributedNode);
									}
								}
							} else {
								children.push(child);
							}
						}
						return children;
					},
					isFinalDestination: function isFinalDestination(insertionPoint, node) {
						return this._distributor.isFinalDestination(insertionPoint, node);
					},

					// Ensures that the rendered node list inside `container` is `children`.
					_updateChildNodes: function _updateChildNodes(container, children) {
						var composed = (0, _nativeTree.childNodes)(container);
						var splices = (0, _arraySplice.calculateSplices)(children, composed);
						// process removals
						for (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {
							for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
								// check if the node is still where we expect it is before trying
								// to remove it; this can happen if we move a node and
								// then schedule its previous host for distribution resulting in
								// the node being removed here.
								if ((0, _nativeTree.parentNode)(n) === container) {
									_nativeMethods.removeChild.call(container, n);
								}
								composed.splice(s.index + d, 1);
							}
							d -= s.addedCount;
						}
						// process adds
						for (var _i2 = 0, _s, next; _i2 < splices.length && (_s = splices[_i2]); _i2++) {
							//eslint-disable-line no-redeclare
							next = composed[_s.index];
							for (var _j = _s.index, _n; _j < _s.index + _s.addedCount; _j++) {
								_n = children[_j];
								_nativeMethods.insertBefore.call(container, _n, next);
								// TODO(sorvell): is this splice strictly needed?
								composed.splice(_j, 0, _n);
							}
						}
					},
					getInsertionPointTag: function getInsertionPointTag() {
						return this._distributor.insertionPointTag;
					}
				});

				/**
      Implements a pared down version of ShadowDOM's scoping, which is easy to
      polyfill across browsers.
    */
				function attachShadow(host, options) {
					if (!host) {
						throw 'Must provide a host.';
					}
					if (!options) {
						throw 'Not enough arguments.';
					}
					return new ShadyRoot(ShadyRootConstructionToken, host);
				}

				(0, _patchAccessors.patchShadowRootAccessors)(ShadyRoot.prototype);

				/***/
			},
			/* 65 */
			/***/function (module, exports) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});
				function newSplice(index, removed, addedCount) {
					return {
						index: index,
						removed: removed,
						addedCount: addedCount
					};
				}

				var EDIT_LEAVE = 0;
				var EDIT_UPDATE = 1;
				var EDIT_ADD = 2;
				var EDIT_DELETE = 3;

				var ArraySplice = {

					// Note: This function is *based* on the computation of the Levenshtein
					// "edit" distance. The one change is that "updates" are treated as two
					// edits - not one. With Array splices, an update is really a delete
					// followed by an add. By retaining this, we optimize for "keeping" the
					// maximum array items in the original array. For example:
					//
					//   'xxxx123' -> '123yyyy'
					//
					// With 1-edit updates, the shortest path would be just to update all seven
					// characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
					// leaves the substring '123' intact.
					calcEditDistances: function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
						// "Deletion" columns
						var rowCount = oldEnd - oldStart + 1;
						var columnCount = currentEnd - currentStart + 1;
						var distances = new Array(rowCount);

						// "Addition" rows. Initialize null column.
						for (var i = 0; i < rowCount; i++) {
							distances[i] = new Array(columnCount);
							distances[i][0] = i;
						}

						// Initialize null row
						for (var j = 0; j < columnCount; j++) {
							distances[0][j] = j;
						}for (var _i = 1; _i < rowCount; _i++) {
							for (var _j = 1; _j < columnCount; _j++) {
								if (this.equals(current[currentStart + _j - 1], old[oldStart + _i - 1])) distances[_i][_j] = distances[_i - 1][_j - 1];else {
									var north = distances[_i - 1][_j] + 1;
									var west = distances[_i][_j - 1] + 1;
									distances[_i][_j] = north < west ? north : west;
								}
							}
						}

						return distances;
					},

					// This starts at the final weight, and walks "backward" by finding
					// the minimum previous weight recursively until the origin of the weight
					// matrix.
					spliceOperationsFromEditDistances: function spliceOperationsFromEditDistances(distances) {
						var i = distances.length - 1;
						var j = distances[0].length - 1;
						var current = distances[i][j];
						var edits = [];
						while (i > 0 || j > 0) {
							if (i == 0) {
								edits.push(EDIT_ADD);
								j--;
								continue;
							}
							if (j == 0) {
								edits.push(EDIT_DELETE);
								i--;
								continue;
							}
							var northWest = distances[i - 1][j - 1];
							var west = distances[i - 1][j];
							var north = distances[i][j - 1];

							var min = void 0;
							if (west < north) min = west < northWest ? west : northWest;else min = north < northWest ? north : northWest;

							if (min == northWest) {
								if (northWest == current) {
									edits.push(EDIT_LEAVE);
								} else {
									edits.push(EDIT_UPDATE);
									current = northWest;
								}
								i--;
								j--;
							} else if (min == west) {
								edits.push(EDIT_DELETE);
								i--;
								current = west;
							} else {
								edits.push(EDIT_ADD);
								j--;
								current = north;
							}
						}

						edits.reverse();
						return edits;
					},

					/**
      * Splice Projection functions:
      *
      * A splice map is a representation of how a previous array of items
      * was transformed into a new array of items. Conceptually it is a list of
      * tuples of
      *
      *   <index, removed, addedCount>
      *
      * which are kept in ascending index order of. The tuple represents that at
      * the |index|, |removed| sequence of items were removed, and counting forward
      * from |index|, |addedCount| items were added.
      */

					/**
      * Lacking individual splice mutation information, the minimal set of
      * splices can be synthesized given the previous state and final state of an
      * array. The basic approach is to calculate the edit distance matrix and
      * choose the shortest path through it.
      *
      * Complexity: O(l * p)
      *   l: The length of the current array
      *   p: The length of the old array
      */
					calcSplices: function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
						var prefixCount = 0;
						var suffixCount = 0;
						var splice = void 0;

						var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
						if (currentStart == 0 && oldStart == 0) prefixCount = this.sharedPrefix(current, old, minLength);

						if (currentEnd == current.length && oldEnd == old.length) suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);

						currentStart += prefixCount;
						oldStart += prefixCount;
						currentEnd -= suffixCount;
						oldEnd -= suffixCount;

						if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];

						if (currentStart == currentEnd) {
							splice = newSplice(currentStart, [], 0);
							while (oldStart < oldEnd) {
								splice.removed.push(old[oldStart++]);
							}return [splice];
						} else if (oldStart == oldEnd) return [newSplice(currentStart, [], currentEnd - currentStart)];

						var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));

						splice = undefined;
						var splices = [];
						var index = currentStart;
						var oldIndex = oldStart;
						for (var i = 0; i < ops.length; i++) {
							switch (ops[i]) {
								case EDIT_LEAVE:
									if (splice) {
										splices.push(splice);
										splice = undefined;
									}

									index++;
									oldIndex++;
									break;
								case EDIT_UPDATE:
									if (!splice) splice = newSplice(index, [], 0);

									splice.addedCount++;
									index++;

									splice.removed.push(old[oldIndex]);
									oldIndex++;
									break;
								case EDIT_ADD:
									if (!splice) splice = newSplice(index, [], 0);

									splice.addedCount++;
									index++;
									break;
								case EDIT_DELETE:
									if (!splice) splice = newSplice(index, [], 0);

									splice.removed.push(old[oldIndex]);
									oldIndex++;
									break;
							}
						}

						if (splice) {
							splices.push(splice);
						}
						return splices;
					},
					sharedPrefix: function sharedPrefix(current, old, searchLength) {
						for (var i = 0; i < searchLength; i++) {
							if (!this.equals(current[i], old[i])) return i;
						}return searchLength;
					},
					sharedSuffix: function sharedSuffix(current, old, searchLength) {
						var index1 = current.length;
						var index2 = old.length;
						var count = 0;
						while (count < searchLength && this.equals(current[--index1], old[--index2])) {
							count++;
						}return count;
					},
					calculateSplices: function calculateSplices(current, previous) {
						return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
					},
					equals: function equals(currentValue, previousValue) {
						return currentValue === previousValue;
					}
				};

				var calculateSplices = exports.calculateSplices = function calculateSplices(current, previous) {
					return ArraySplice.calculateSplices(current, previous);
				};

				/***/
			},
			/* 66 */
			/***/function (module, exports, __webpack_require__) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});

				var _createClass = function () {
					function defineProperties(target, props) {
						for (var i = 0; i < props.length; i++) {
							var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
						}
					}return function (Constructor, protoProps, staticProps) {
						if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
					};
				}();

				var _nativeMethods = __webpack_require__(55);

				var _nativeTree = __webpack_require__(56);

				function _classCallCheck(instance, Constructor) {
					if (!(instance instanceof Constructor)) {
						throw new TypeError("Cannot call a class as a function");
					}
				}

				// NOTE: normalize event contruction where necessary (IE11)
				var NormalizedEvent = typeof Event === 'function' ? Event : function (inType, params) {
					params = params || {};
					var e = document.createEvent('Event');
					e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));
					return e;
				};

				var _class = function () {
					function _class(root) {
						_classCallCheck(this, _class);

						this.root = root;
						this.insertionPointTag = 'slot';
					}

					_createClass(_class, [{
						key: 'getInsertionPoints',
						value: function getInsertionPoints() {
							return this.root.querySelectorAll(this.insertionPointTag);
						}
					}, {
						key: 'hasInsertionPoint',
						value: function hasInsertionPoint() {
							return Boolean(this.root._insertionPoints && this.root._insertionPoints.length);
						}
					}, {
						key: 'isInsertionPoint',
						value: function isInsertionPoint(node) {
							return node.localName && node.localName == this.insertionPointTag;
						}
					}, {
						key: 'distribute',
						value: function distribute() {
							if (this.hasInsertionPoint()) {
								return this.distributePool(this.root, this.collectPool());
							}
							return [];
						}

						// Gather the pool of nodes that should be distributed. We will combine
						// these with the "content root" to arrive at the composed tree.

					}, {
						key: 'collectPool',
						value: function collectPool() {
							var host = this.root.host;
							var pool = [],
							    i = 0;
							for (var n = host.firstChild; n; n = n.nextSibling) {
								pool[i++] = n;
							}
							return pool;
						}

						// perform "logical" distribution; note, no actual dom is moved here,
						// instead elements are distributed into storage
						// array where applicable.

					}, {
						key: 'distributePool',
						value: function distributePool(node, pool) {
							var dirtyRoots = [];
							var p$ = this.root._insertionPoints;
							for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
								this.distributeInsertionPoint(p, pool);
								// provoke redistribution on insertion point parents
								// must do this on all candidate hosts since distribution in this
								// scope invalidates their distribution.
								// only get logical parent.
								var parent = p.parentNode;
								if (parent && parent.shadyRoot && this.hasInsertionPoint(parent.shadyRoot)) {
									dirtyRoots.push(parent.shadyRoot);
								}
							}
							for (var _i = 0; _i < pool.length; _i++) {
								var _p = pool[_i];
								if (_p) {
									_p.__shady = _p.__shady || {};
									_p.__shady.assignedSlot = undefined;
									// remove undistributed elements from physical dom.
									var _parent = (0, _nativeTree.parentNode)(_p);
									if (_parent) {
										_nativeMethods.removeChild.call(_parent, _p);
									}
								}
							}
							return dirtyRoots;
						}
					}, {
						key: 'distributeInsertionPoint',
						value: function distributeInsertionPoint(insertionPoint, pool) {
							var prevAssignedNodes = insertionPoint.__shady.assignedNodes;
							if (prevAssignedNodes) {
								this.clearAssignedSlots(insertionPoint, true);
							}
							insertionPoint.__shady.assignedNodes = [];
							var needsSlotChange = false;
							// distribute nodes from the pool that this selector matches
							var anyDistributed = false;
							for (var i = 0, l = pool.length, node; i < l; i++) {
								node = pool[i];
								// skip nodes that were already used
								if (!node) {
									continue;
								}
								// distribute this node if it matches
								if (this.matchesInsertionPoint(node, insertionPoint)) {
									if (node.__shady._prevAssignedSlot != insertionPoint) {
										needsSlotChange = true;
									}
									this.distributeNodeInto(node, insertionPoint);
									// remove this node from the pool
									pool[i] = undefined;
									// since at least one node matched, we won't need fallback content
									anyDistributed = true;
								}
							}
							// Fallback content if nothing was distributed here
							if (!anyDistributed) {
								var children = insertionPoint.childNodes;
								for (var j = 0, _node; j < children.length; j++) {
									_node = children[j];
									if (_node.__shady._prevAssignedSlot != insertionPoint) {
										needsSlotChange = true;
									}
									this.distributeNodeInto(_node, insertionPoint);
								}
							}
							// we're already dirty if a node was newly added to the slot
							// and we're also dirty if the assigned count decreased.
							if (prevAssignedNodes) {
								// TODO(sorvell): the tracking of previously assigned slots
								// could instead by done with a Set and then we could
								// avoid needing to iterate here to clear the info.
								for (var _i2 = 0; _i2 < prevAssignedNodes.length; _i2++) {
									prevAssignedNodes[_i2].__shady._prevAssignedSlot = null;
								}
								if (insertionPoint.__shady.assignedNodes.length < prevAssignedNodes.length) {
									needsSlotChange = true;
								}
							}
							this.setDistributedNodesOnInsertionPoint(insertionPoint);
							if (needsSlotChange) {
								this._fireSlotChange(insertionPoint);
							}
						}
					}, {
						key: 'clearAssignedSlots',
						value: function clearAssignedSlots(slot, savePrevious) {
							var n$ = slot.__shady.assignedNodes;
							if (n$) {
								for (var i = 0; i < n$.length; i++) {
									var n = n$[i];
									if (savePrevious) {
										n.__shady._prevAssignedSlot = n.__shady.assignedSlot;
									}
									// only clear if it was previously set to this slot;
									// this helps ensure that if the node has otherwise been distributed
									// ignore it.
									if (n.__shady.assignedSlot === slot) {
										n.__shady.assignedSlot = null;
									}
								}
							}
						}
					}, {
						key: 'matchesInsertionPoint',
						value: function matchesInsertionPoint(node, insertionPoint) {
							var slotName = insertionPoint.getAttribute('name');
							slotName = slotName ? slotName.trim() : '';
							var slot = node.getAttribute && node.getAttribute('slot');
							slot = slot ? slot.trim() : '';
							return slot == slotName;
						}
					}, {
						key: 'distributeNodeInto',
						value: function distributeNodeInto(child, insertionPoint) {
							insertionPoint.__shady.assignedNodes.push(child);
							child.__shady.assignedSlot = insertionPoint;
						}
					}, {
						key: 'setDistributedNodesOnInsertionPoint',
						value: function setDistributedNodesOnInsertionPoint(insertionPoint) {
							var n$ = insertionPoint.__shady.assignedNodes;
							insertionPoint.__shady.distributedNodes = [];
							for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
								if (this.isInsertionPoint(n)) {
									var d$ = n.__shady.distributedNodes;
									if (d$) {
										for (var j = 0; j < d$.length; j++) {
											insertionPoint.__shady.distributedNodes.push(d$[j]);
										}
									}
								} else {
									insertionPoint.__shady.distributedNodes.push(n$[i]);
								}
							}
						}
					}, {
						key: '_fireSlotChange',
						value: function _fireSlotChange(insertionPoint) {
							// NOTE: cannot bubble correctly here so not setting bubbles: true
							// Safari tech preview does not bubble but chrome does
							// Spec says it bubbles (https://dom.spec.whatwg.org/#mutation-observers)
							insertionPoint.dispatchEvent(new NormalizedEvent('slotchange'));
							if (insertionPoint.__shady.assignedSlot) {
								this._fireSlotChange(insertionPoint.__shady.assignedSlot);
							}
						}
					}, {
						key: 'isFinalDestination',
						value: function isFinalDestination(insertionPoint) {
							return !insertionPoint.__shady.assignedSlot;
						}
					}]);

					return _class;
				}();

				exports.default = _class;

				/***/
			},
			/* 67 */
			/***/function (module, exports, __webpack_require__) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */
				'use strict';

				/*
    Small module to load ShadyCSS and CustomStyle together
    */

				__webpack_require__(68);

				__webpack_require__(80);

				/***/
			},
			/* 68 */
			/***/function (module, exports, __webpack_require__) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				'use strict';

				var _createClass = function () {
					function defineProperties(target, props) {
						for (var i = 0; i < props.length; i++) {
							var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
						}
					}return function (Constructor, protoProps, staticProps) {
						if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
					};
				}();

				// TODO(dfreedm): consider spliting into separate global


				var _cssParse = __webpack_require__(69);

				var _styleSettings = __webpack_require__(70);

				var _styleTransformer = __webpack_require__(71);

				var _styleTransformer2 = _interopRequireDefault(_styleTransformer);

				var _styleUtil = __webpack_require__(72);

				var StyleUtil = _interopRequireWildcard(_styleUtil);

				var _styleProperties = __webpack_require__(73);

				var _styleProperties2 = _interopRequireDefault(_styleProperties);

				var _templateMap = __webpack_require__(75);

				var _templateMap2 = _interopRequireDefault(_templateMap);

				var _stylePlaceholder = __webpack_require__(76);

				var _stylePlaceholder2 = _interopRequireDefault(_stylePlaceholder);

				var _styleInfo = __webpack_require__(74);

				var _styleInfo2 = _interopRequireDefault(_styleInfo);

				var _styleCache = __webpack_require__(77);

				var _styleCache2 = _interopRequireDefault(_styleCache);

				var _applyShim = __webpack_require__(78);

				var _applyShim2 = _interopRequireDefault(_applyShim);

				var _documentWatcher = __webpack_require__(79);

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					} else {
						var newObj = {};if (obj != null) {
							for (var key in obj) {
								if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
							}
						}newObj.default = obj;return newObj;
					}
				}

				function _interopRequireDefault(obj) {
					return obj && obj.__esModule ? obj : { default: obj };
				}

				function _classCallCheck(instance, Constructor) {
					if (!(instance instanceof Constructor)) {
						throw new TypeError("Cannot call a class as a function");
					}
				}

				var styleCache = new _styleCache2.default();

				var ShadyCSS = function () {
					function ShadyCSS() {
						_classCallCheck(this, ShadyCSS);

						this._scopeCounter = {};
						this._documentOwner = document.documentElement;
						this._documentOwnerStyleInfo = _styleInfo2.default.set(document.documentElement, new _styleInfo2.default({ rules: [] }));
						this._elementsHaveApplied = false;
					}

					_createClass(ShadyCSS, [{
						key: 'flush',
						value: function flush() {
							(0, _documentWatcher.flush)();
						}
					}, {
						key: '_generateScopeSelector',
						value: function _generateScopeSelector(name) {
							var id = this._scopeCounter[name] = (this._scopeCounter[name] || 0) + 1;
							return name + '-' + id;
						}
					}, {
						key: 'getStyleAst',
						value: function getStyleAst(style) {
							return StyleUtil.rulesForStyle(style);
						}
					}, {
						key: 'styleAstToString',
						value: function styleAstToString(ast) {
							return StyleUtil.toCssText(ast);
						}
					}, {
						key: '_gatherStyles',
						value: function _gatherStyles(template) {
							var styles = template.content.querySelectorAll('style');
							var cssText = [];
							for (var i = 0; i < styles.length; i++) {
								var s = styles[i];
								cssText.push(s.textContent);
								s.parentNode.removeChild(s);
							}
							return cssText.join('').trim();
						}
					}, {
						key: '_getCssBuild',
						value: function _getCssBuild(template) {
							var style = template.content.querySelector('style');
							if (!style) {
								return '';
							}
							return style.getAttribute('css-build') || '';
						}
					}, {
						key: 'prepareTemplate',
						value: function prepareTemplate(template, elementName, typeExtension) {
							if (template._prepared) {
								return;
							}
							template._prepared = true;
							template.name = elementName;
							template.extends = typeExtension;
							_templateMap2.default[elementName] = template;
							var cssBuild = this._getCssBuild(template);
							var cssText = this._gatherStyles(template);
							var info = {
								is: elementName,
								extends: typeExtension,
								__cssBuild: cssBuild
							};
							if (!this.nativeShadow) {
								_styleTransformer2.default.dom(template.content, elementName);
							}
							// check if the styling has mixin definitions or uses
							var hasMixins = _applyShim2.default.detectMixin(cssText);
							var ast = (0, _cssParse.parse)(cssText);
							// only run the applyshim transforms if there is a mixin involved
							if (hasMixins && this.nativeCss && !this.nativeCssApply) {
								_applyShim2.default.transformRules(ast, elementName);
							}
							template._styleAst = ast;

							var ownPropertyNames = [];
							if (!this.nativeCss) {
								ownPropertyNames = _styleProperties2.default.decorateStyles(template._styleAst, info);
							}
							if (!ownPropertyNames.length || this.nativeCss) {
								var root = this.nativeShadow ? template.content : null;
								var placeholder = _stylePlaceholder2.default[elementName];
								var style = this._generateStaticStyle(info, template._styleAst, root, placeholder);
								template._style = style;
							}
							template._ownPropertyNames = ownPropertyNames;
						}
					}, {
						key: '_generateStaticStyle',
						value: function _generateStaticStyle(info, rules, shadowroot, placeholder) {
							var cssText = _styleTransformer2.default.elementStyles(info, rules);
							if (cssText.length) {
								return StyleUtil.applyCss(cssText, info.is, shadowroot, placeholder);
							}
						}
					}, {
						key: '_prepareHost',
						value: function _prepareHost(host) {
							var is = host.getAttribute('is') || host.localName;
							var typeExtension = void 0;
							if (is !== host.localName) {
								typeExtension = host.localName;
							}
							var placeholder = _stylePlaceholder2.default[is];
							var template = _templateMap2.default[is];
							var ast = void 0;
							var ownStylePropertyNames = void 0;
							var cssBuild = void 0;
							if (template) {
								ast = template._styleAst;
								ownStylePropertyNames = template._ownPropertyNames;
								cssBuild = template._cssBuild;
							}
							return _styleInfo2.default.set(host, new _styleInfo2.default(ast, placeholder, ownStylePropertyNames, is, typeExtension, cssBuild));
						}
					}, {
						key: 'applyStyle',
						value: function applyStyle(host, overrideProps) {
							var is = host.getAttribute('is') || host.localName;
							var styleInfo = _styleInfo2.default.get(host);
							var hasApplied = Boolean(styleInfo);
							if (!styleInfo) {
								styleInfo = this._prepareHost(host);
							}
							// Only trip the `elementsHaveApplied` flag if a node other that the root document has `applyStyle` called
							if (!this._isRootOwner(host)) {
								this._elementsHaveApplied = true;
							}
							if (window.CustomStyle) {
								var CS = window.CustomStyle;
								if (CS._documentDirty) {
									CS.findStyles();
									if (!this.nativeCss) {
										this._updateProperties(this._documentOwner, this._documentOwnerStyleInfo);
									} else if (!this.nativeCssApply) {
										CS._revalidateApplyShim();
									}
									CS.applyStyles();
									// if no elements have booted yet, we can just update the document and be done
									if (!this._elementsHaveApplied) {
										return;
									}
									// if no native css custom properties, we must recalculate the whole tree
									if (!this.nativeCss) {
										this.updateStyles();
										/*
          When updateStyles() runs, this element may not have a shadowroot yet.
          If not, we need to make sure that this element runs `applyStyle` on itself at least once to generate a style
          */
										if (hasApplied) {
											return;
										}
									}
								}
							}
							if (overrideProps) {
								styleInfo.overrideStyleProperties = styleInfo.overrideStyleProperties || {};
								Object.assign(styleInfo.overrideStyleProperties, overrideProps);
							}
							if (this.nativeCss) {
								if (styleInfo.overrideStyleProperties) {
									this._updateNativeProperties(host, styleInfo.overrideStyleProperties);
								}
								var template = _templateMap2.default[is];
								// bail early if there is no shadowroot for this element
								if (!template && !this._isRootOwner(host)) {
									return;
								}
								if (template && template._applyShimInvalid && template._style) {
									// update template
									if (!template._validating) {
										_applyShim2.default.transformRules(template._styleAst, is);
										template._style.textContent = _styleTransformer2.default.elementStyles(host, styleInfo.styleRules);
										_styleInfo2.default.startValidating(is);
									}
									// update instance if native shadowdom
									if (this.nativeShadow) {
										var root = host.shadowRoot;
										if (root) {
											var style = root.querySelector('style');
											style.textContent = _styleTransformer2.default.elementStyles(host, styleInfo.styleRules);
										}
									}
									styleInfo.styleRules = template._styleAst;
								}
							} else {
								this._updateProperties(host, styleInfo);
								if (styleInfo.ownStylePropertyNames && styleInfo.ownStylePropertyNames.length) {
									this._applyStyleProperties(host, styleInfo);
								}
							}
							if (hasApplied) {
								var _root = this._isRootOwner(host) ? host : host.shadowRoot;
								// note: some elements may not have a root!
								if (_root) {
									this._applyToDescendants(_root);
								}
							}
						}
					}, {
						key: '_applyToDescendants',
						value: function _applyToDescendants(root) {
							var c$ = root.children;
							for (var i = 0, c; i < c$.length; i++) {
								c = c$[i];
								if (c.shadowRoot) {
									this.applyStyle(c);
								}
								this._applyToDescendants(c);
							}
						}
					}, {
						key: '_styleOwnerForNode',
						value: function _styleOwnerForNode(node) {
							var root = node.getRootNode();
							var host = root.host;
							if (host) {
								if (_styleInfo2.default.get(host)) {
									return host;
								} else {
									return this._styleOwnerForNode(host);
								}
							}
							return this._documentOwner;
						}
					}, {
						key: '_isRootOwner',
						value: function _isRootOwner(node) {
							return node === this._documentOwner;
						}
					}, {
						key: '_applyStyleProperties',
						value: function _applyStyleProperties(host, styleInfo) {
							var is = host.getAttribute('is') || host.localName;
							var cacheEntry = styleCache.fetch(is, styleInfo.styleProperties, styleInfo.ownStylePropertyNames);
							var cachedScopeSelector = cacheEntry && cacheEntry.scopeSelector;
							var cachedStyle = cacheEntry ? cacheEntry.styleElement : null;
							var oldScopeSelector = styleInfo.scopeSelector;
							// only generate new scope if cached style is not found
							styleInfo.scopeSelector = cachedScopeSelector || this._generateScopeSelector(is);
							var style = _styleProperties2.default.applyElementStyle(host, styleInfo.styleProperties, styleInfo.scopeSelector, cachedStyle);
							if (!this.nativeShadow) {
								_styleProperties2.default.applyElementScopeSelector(host, styleInfo.scopeSelector, oldScopeSelector);
							}
							if (!cacheEntry) {
								styleCache.store(is, styleInfo.styleProperties, style, styleInfo.scopeSelector);
							}
							return style;
						}
					}, {
						key: '_updateProperties',
						value: function _updateProperties(host, styleInfo) {
							var owner = this._styleOwnerForNode(host);
							var ownerStyleInfo = _styleInfo2.default.get(owner);
							var ownerProperties = ownerStyleInfo.styleProperties;
							var props = Object.create(ownerProperties || null);
							var hostAndRootProps = _styleProperties2.default.hostAndRootPropertiesForScope(host, styleInfo.styleRules);
							var propertyData = _styleProperties2.default.propertyDataFromStyles(ownerStyleInfo.styleRules, host);
							var propertiesMatchingHost = propertyData.properties;
							Object.assign(props, hostAndRootProps.hostProps, propertiesMatchingHost, hostAndRootProps.rootProps);
							this._mixinOverrideStyles(props, styleInfo.overrideStyleProperties);
							_styleProperties2.default.reify(props);
							styleInfo.styleProperties = props;
						}
					}, {
						key: '_mixinOverrideStyles',
						value: function _mixinOverrideStyles(props, overrides) {
							for (var p in overrides) {
								var v = overrides[p];
								// skip override props if they are not truthy or 0
								// in order to fall back to inherited values
								if (v || v === 0) {
									props[p] = v;
								}
							}
						}
					}, {
						key: '_updateNativeProperties',
						value: function _updateNativeProperties(element, properties) {
							// remove previous properties
							for (var p in properties) {
								// NOTE: for bc with shim, don't apply null values.
								if (p === null) {
									element.style.removeProperty(p);
								} else {
									element.style.setProperty(p, properties[p]);
								}
							}
						}
					}, {
						key: 'updateStyles',
						value: function updateStyles(properties) {
							this.applyStyle(this._documentOwner, properties);
						}
						/* Custom Style operations */

					}, {
						key: '_transformCustomStyleForDocument',
						value: function _transformCustomStyleForDocument(style) {
							var _this = this;

							var ast = StyleUtil.rulesForStyle(style);
							StyleUtil.forEachRule(ast, function (rule) {
								if (_styleSettings.nativeShadow) {
									_styleTransformer2.default.normalizeRootSelector(rule);
								} else {
									_styleTransformer2.default.documentRule(rule);
								}
								if (_this.nativeCss && !_this.nativeCssApply) {
									_applyShim2.default.transformRule(rule);
								}
							});
							if (this.nativeCss) {
								style.textContent = StyleUtil.toCssText(ast);
							} else {
								this._documentOwnerStyleInfo.styleRules.rules.push(ast);
							}
						}
					}, {
						key: '_revalidateApplyShim',
						value: function _revalidateApplyShim(style) {
							if (this.nativeCss && !this.nativeCssApply) {
								var ast = StyleUtil.rulesForStyle(style);
								_applyShim2.default.transformRules(ast);
								style.textContent = StyleUtil.toCssText(ast);
							}
						}
					}, {
						key: '_applyCustomStyleToDocument',
						value: function _applyCustomStyleToDocument(style) {
							if (!this.nativeCss) {
								_styleProperties2.default.applyCustomStyle(style, this._documentOwnerStyleInfo.styleProperties);
							}
						}
					}, {
						key: 'getComputedStyleValue',
						value: function getComputedStyleValue(element, property) {
							var value = void 0;
							if (!this.nativeCss) {
								// element is either a style host, or an ancestor of a style host
								var styleInfo = _styleInfo2.default.get(element) || _styleInfo2.default.get(this._styleOwnerForNode(element));
								value = styleInfo.styleProperties[property];
							}
							// fall back to the property value from the computed styling
							value = value || window.getComputedStyle(element).getPropertyValue(property);
							// trim whitespace that can come after the `:` in css
							// example: padding: 2px -> " 2px"
							return value.trim();
						}
						// given an element and a classString, replaces
						// the element's class with the provided classString and adds
						// any necessary ShadyCSS static and property based scoping selectors

					}, {
						key: 'setElementClass',
						value: function setElementClass(element, classString) {
							var root = element.getRootNode();
							var classes = classString ? classString.split(/\s/) : [];
							var scopeName = root.host && root.host.localName;
							// If no scope, try to discover scope name from existing class.
							// This can occur if, for example, a template stamped element that
							// has been scoped is manipulated when not in a root.
							if (!scopeName) {
								var classAttr = element.getAttribute('class');
								if (classAttr) {
									var k$ = classAttr.split(/\s/);
									for (var i = 0; i < k$.length; i++) {
										if (k$[i] === _styleTransformer2.default.SCOPE_NAME) {
											scopeName = k$[i + 1];
											break;
										}
									}
								}
							}
							if (scopeName) {
								classes.push(_styleTransformer2.default.SCOPE_NAME, scopeName);
							}
							if (!this.nativeCss) {
								var styleInfo = _styleInfo2.default.get(element);
								if (styleInfo && styleInfo.scopeSelector) {
									classes.push(_styleProperties2.default.XSCOPE_NAME, styleInfo.scopeSelector);
								}
							}
							StyleUtil.setElementClassRaw(element, classes.join(' '));
						}
					}, {
						key: '_styleInfoForNode',
						value: function _styleInfoForNode(node) {
							return _styleInfo2.default.get(node);
						}
					}, {
						key: 'nativeShadow',
						get: function get() {
							return _styleSettings.nativeShadow;
						}
					}, {
						key: 'nativeCss',
						get: function get() {
							return _styleSettings.nativeCssVariables;
						}
					}, {
						key: 'nativeCssApply',
						get: function get() {
							return _styleSettings.nativeCssApply;
						}
					}]);

					return ShadyCSS;
				}();

				window['ShadyCSS'] = new ShadyCSS();

				/***/
			},
			/* 69 */
			/***/function (module, exports) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				/*
    Extremely simple css parser. Intended to be not more than what we need
    and definitely not necessarily correct =).
    */

				'use strict';

				// given a string of css, return a simple rule tree

				Object.defineProperty(exports, "__esModule", {
					value: true
				});
				exports.parse = parse;
				exports.stringify = stringify;
				exports.removeCustomPropAssignment = removeCustomPropAssignment;
				function parse(text) {
					text = clean(text);
					return parseCss(lex(text), text);
				}

				// remove stuff we don't care about that may hinder parsing
				function clean(cssText) {
					return cssText.replace(RX.comments, '').replace(RX.port, '');
				}

				// super simple {...} lexer that returns a node tree
				function lex(text) {
					var root = {
						start: 0,
						end: text.length
					};
					var n = root;
					for (var i = 0, l = text.length; i < l; i++) {
						if (text[i] === OPEN_BRACE) {
							if (!n.rules) {
								n.rules = [];
							}
							var p = n;
							var previous = p.rules[p.rules.length - 1];
							n = {
								start: i + 1,
								parent: p,
								previous: previous
							};
							p.rules.push(n);
						} else if (text[i] === CLOSE_BRACE) {
							n.end = i + 1;
							n = n.parent || root;
						}
					}
					return root;
				}

				// add selectors/cssText to node tree
				function parseCss(node, text) {
					var t = text.substring(node.start, node.end - 1);
					node.parsedCssText = node.cssText = t.trim();
					if (node.parent) {
						var ss = node.previous ? node.previous.end : node.parent.start;
						t = text.substring(ss, node.start - 1);
						t = _expandUnicodeEscapes(t);
						t = t.replace(RX.multipleSpaces, ' ');
						// TODO(sorvell): ad hoc; make selector include only after last ;
						// helps with mixin syntax
						t = t.substring(t.lastIndexOf(';') + 1);
						var s = node.parsedSelector = node.selector = t.trim();
						node.atRule = s.indexOf(AT_START) === 0;
						// note, support a subset of rule types...
						if (node.atRule) {
							if (s.indexOf(MEDIA_START) === 0) {
								node.type = types.MEDIA_RULE;
							} else if (s.match(RX.keyframesRule)) {
								node.type = types.KEYFRAMES_RULE;
								node.keyframesName = node.selector.split(RX.multipleSpaces).pop();
							}
						} else {
							if (s.indexOf(VAR_START) === 0) {
								node.type = types.MIXIN_RULE;
							} else {
								node.type = types.STYLE_RULE;
							}
						}
					}
					var r$ = node.rules;
					if (r$) {
						for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
							parseCss(r, text);
						}
					}
					return node;
				}

				// conversion of sort unicode escapes with spaces like `\33 ` (and longer) into
				// expanded form that doesn't require trailing space `\000033`
				function _expandUnicodeEscapes(s) {
					return s.replace(/\\([0-9a-f]{1,6})\s/gi, function () {
						var code = arguments[1],
						    repeat = 6 - code.length;
						while (repeat--) {
							code = '0' + code;
						}
						return '\\' + code;
					});
				}

				// stringify parsed css.
				function stringify(node, preserveProperties, text) {
					text = text || '';
					// calc rule cssText
					var cssText = '';
					if (node.cssText || node.rules) {
						var r$ = node.rules;
						if (r$ && !_hasMixinRules(r$)) {
							for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
								cssText = stringify(r, preserveProperties, cssText);
							}
						} else {
							cssText = preserveProperties ? node.cssText : removeCustomProps(node.cssText);
							cssText = cssText.trim();
							if (cssText) {
								cssText = '  ' + cssText + '\n';
							}
						}
					}
					// emit rule if there is cssText
					if (cssText) {
						if (node.selector) {
							text += node.selector + ' ' + OPEN_BRACE + '\n';
						}
						text += cssText;
						if (node.selector) {
							text += CLOSE_BRACE + '\n\n';
						}
					}
					return text;
				}

				function _hasMixinRules(rules) {
					return rules[0].selector.indexOf(VAR_START) === 0;
				}

				function removeCustomProps(cssText) {
					cssText = removeCustomPropAssignment(cssText);
					return removeCustomPropApply(cssText);
				}

				function removeCustomPropAssignment(cssText) {
					return cssText.replace(RX.customProp, '').replace(RX.mixinProp, '');
				}

				function removeCustomPropApply(cssText) {
					return cssText.replace(RX.mixinApply, '').replace(RX.varApply, '');
				}

				var types = exports.types = {
					STYLE_RULE: 1,
					KEYFRAMES_RULE: 7,
					MEDIA_RULE: 4,
					MIXIN_RULE: 1000
				};

				var OPEN_BRACE = '{';
				var CLOSE_BRACE = '}';

				// helper regexp's
				var RX = {
					comments: /\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,
					port: /@import[^;]*;/gim,
					customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
					mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
					mixinApply: /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
					varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
					keyframesRule: /^@[^\s]*keyframes/,
					multipleSpaces: /\s+/g
				};

				var VAR_START = '--';
				var MEDIA_START = '@media';
				var AT_START = '@';

				/***/
			},
			/* 70 */
			/***/function (module, exports) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});
				var nativeShadow = exports.nativeShadow = !(window.ShadyDOM && window.ShadyDOM.inUse);
				// chrome 49 has semi-working css vars, check if box-shadow works
				// safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782
				var nativeCssVariables = exports.nativeCssVariables = !navigator.userAgent.match('AppleWebKit/601') && window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)');

				// experimental support for native @apply
				function detectNativeApply() {
					var style = document.createElement('style');
					style.textContent = '.foo { @apply --foo }';
					document.head.appendChild(style);
					var nativeCssApply = style.sheet.cssRules[0].cssText.indexOf('apply') >= 0;
					document.head.removeChild(style);
					return nativeCssApply;
				}

				var nativeCssApply = exports.nativeCssApply = false && detectNativeApply();

				function parseSettings(settings) {
					if (settings) {
						exports.nativeCssVariables = nativeCssVariables = nativeCssVariables && !settings.shimcssproperties;
						exports.nativeShadow = nativeShadow = nativeShadow && !settings.shimshadow;
					}
				}

				if (window.ShadyCSS) {
					parseSettings(window.ShadyCSS);
				} else if (window.WebComponents) {
					parseSettings(window.WebComponents.flags);
				}

				/***/
			},
			/* 71 */
			/***/function (module, exports, __webpack_require__) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});

				var _createClass = function () {
					function defineProperties(target, props) {
						for (var i = 0; i < props.length; i++) {
							var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
						}
					}return function (Constructor, protoProps, staticProps) {
						if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
					};
				}();

				var _styleUtil = __webpack_require__(72);

				var StyleUtil = _interopRequireWildcard(_styleUtil);

				var _styleSettings = __webpack_require__(70);

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					} else {
						var newObj = {};if (obj != null) {
							for (var key in obj) {
								if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
							}
						}newObj.default = obj;return newObj;
					}
				}

				function _classCallCheck(instance, Constructor) {
					if (!(instance instanceof Constructor)) {
						throw new TypeError("Cannot call a class as a function");
					}
				}

				/* Transforms ShadowDOM styling into ShadyDOM styling
    
    * scoping:
    
      * elements in scope get scoping selector class="x-foo-scope"
      * selectors re-written as follows:
    
        div button -> div.x-foo-scope button.x-foo-scope
    
    * :host -> scopeName
    
    * :host(...) -> scopeName...
    
    * ::slotted(...) -> scopeName > ...
    
    * ...:dir(ltr|rtl) -> [dir="ltr|rtl"] ..., ...[dir="ltr|rtl"]
    
    * :host(:dir[rtl]) -> scopeName:dir(rtl) -> [dir="rtl"] scopeName, scopeName[dir="rtl"]
    
    */
				var SCOPE_NAME = 'style-scope';

				var StyleTransformer = function () {
					function StyleTransformer() {
						_classCallCheck(this, StyleTransformer);
					}

					_createClass(StyleTransformer, [{
						key: 'dom',

						// Given a node and scope name, add a scoping class to each node
						// in the tree. This facilitates transforming css into scoped rules.
						value: function dom(node, scope, shouldRemoveScope) {
							// one time optimization to skip scoping...
							if (node.__styleScoped) {
								node.__styleScoped = null;
							} else {
								this._transformDom(node, scope || '', shouldRemoveScope);
							}
						}
					}, {
						key: '_transformDom',
						value: function _transformDom(node, selector, shouldRemoveScope) {
							if (node.nodeType === Node.ELEMENT_NODE) {
								this.element(node, selector, shouldRemoveScope);
							}
							var c$ = node.localName === 'template' ? (node.content || node._content).childNodes : node.children || node.childNodes;
							if (c$) {
								for (var i = 0; i < c$.length; i++) {
									this._transformDom(c$[i], selector, shouldRemoveScope);
								}
							}
						}
					}, {
						key: 'element',
						value: function element(_element, scope, shouldRemoveScope) {
							// note: if using classes, we add both the general 'style-scope' class
							// as well as the specific scope. This enables easy filtering of all
							// `style-scope` elements
							if (scope) {
								// note: svg on IE does not have classList so fallback to class
								if (_element.classList) {
									if (shouldRemoveScope) {
										_element.classList.remove(SCOPE_NAME);
										_element.classList.remove(scope);
									} else {
										_element.classList.add(SCOPE_NAME);
										_element.classList.add(scope);
									}
								} else if (_element.getAttribute) {
									var c = _element.getAttribute(CLASS);
									if (shouldRemoveScope) {
										if (c) {
											var newValue = c.replace(SCOPE_NAME, '').replace(scope, '');
											StyleUtil.setElementClassRaw(_element, newValue);
										}
									} else {
										var _newValue = (c ? c + ' ' : '') + SCOPE_NAME + ' ' + scope;
										StyleUtil.setElementClassRaw(_element, _newValue);
									}
								}
							}
						}
					}, {
						key: 'elementStyles',
						value: function elementStyles(element, styleRules, callback) {
							var cssBuildType = element.__cssBuild;
							// no need to shim selectors if settings.useNativeShadow, also
							// a shady css build will already have transformed selectors
							// NOTE: This method may be called as part of static or property shimming.
							// When there is a targeted build it will not be called for static shimming,
							// but when the property shim is used it is called and should opt out of
							// static shimming work when a proper build exists.
							var cssText = _styleSettings.nativeShadow || cssBuildType === 'shady' ? StyleUtil.toCssText(styleRules, callback) : this.css(styleRules, element.is, element.extends, callback) + '\n\n';
							return cssText.trim();
						}

						// Given a string of cssText and a scoping string (scope), returns
						// a string of scoped css where each selector is transformed to include
						// a class created from the scope. ShadowDOM selectors are also transformed
						// (e.g. :host) to use the scoping selector.

					}, {
						key: 'css',
						value: function css(rules, scope, ext, callback) {
							var hostScope = this._calcHostScope(scope, ext);
							scope = this._calcElementScope(scope);
							var self = this;
							return StyleUtil.toCssText(rules, function (rule) {
								if (!rule.isScoped) {
									self.rule(rule, scope, hostScope);
									rule.isScoped = true;
								}
								if (callback) {
									callback(rule, scope, hostScope);
								}
							});
						}
					}, {
						key: '_calcElementScope',
						value: function _calcElementScope(scope) {
							if (scope) {
								return CSS_CLASS_PREFIX + scope;
							} else {
								return '';
							}
						}
					}, {
						key: '_calcHostScope',
						value: function _calcHostScope(scope, ext) {
							return ext ? '[is=' + scope + ']' : scope;
						}
					}, {
						key: 'rule',
						value: function rule(_rule, scope, hostScope) {
							this._transformRule(_rule, this._transformComplexSelector, scope, hostScope);
						}

						// transforms a css rule to a scoped rule.

					}, {
						key: '_transformRule',
						value: function _transformRule(rule, transformer, scope, hostScope) {
							// NOTE: save transformedSelector for subsequent matching of elements
							// against selectors (e.g. when calculating style properties)
							rule.selector = rule.transformedSelector = this._transformRuleCss(rule, transformer, scope, hostScope);
						}
					}, {
						key: '_transformRuleCss',
						value: function _transformRuleCss(rule, transformer, scope, hostScope) {
							var p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);
							// we want to skip transformation of rules that appear in keyframes,
							// because they are keyframe selectors, not element selectors.
							if (!StyleUtil.isKeyframesSelector(rule)) {
								for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
									p$[i] = transformer.call(this, p, scope, hostScope);
								}
							}
							return p$.join(COMPLEX_SELECTOR_SEP);
						}
					}, {
						key: '_transformComplexSelector',
						value: function _transformComplexSelector(selector, scope, hostScope) {
							var _this = this;

							var stop = false;
							selector = selector.trim();
							// Remove spaces inside of selectors like `:nth-of-type` because it confuses SIMPLE_SELECTOR_SEP
							selector = selector.replace(NTH, function (m, type, inner) {
								return ':' + type + '(' + inner.replace(/\s/g, '') + ')';
							});
							selector = selector.replace(SLOTTED_START, HOST + ' $1');
							selector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {
								if (!stop) {
									var info = _this._transformCompoundSelector(s, c, scope, hostScope);
									stop = stop || info.stop;
									c = info.combinator;
									s = info.value;
								}
								return c + s;
							});
							return selector;
						}
					}, {
						key: '_transformCompoundSelector',
						value: function _transformCompoundSelector(selector, combinator, scope, hostScope) {
							// replace :host with host scoping class
							var slottedIndex = selector.indexOf(SLOTTED);
							if (selector.indexOf(HOST) >= 0) {
								selector = this._transformHostSelector(selector, hostScope);
								// replace other selectors with scoping class
							} else if (slottedIndex !== 0) {
								selector = scope ? this._transformSimpleSelector(selector, scope) : selector;
							}
							// mark ::slotted() scope jump to replace with descendant selector + arg
							// also ignore left-side combinator
							var slotted = false;
							if (slottedIndex >= 0) {
								combinator = '';
								slotted = true;
							}
							// process scope jumping selectors up to the scope jump and then stop
							var stop = void 0;
							if (slotted) {
								stop = true;
								if (slotted) {
									// .zonk ::slotted(.foo) -> .zonk.scope > .foo
									selector = selector.replace(SLOTTED_PAREN, function (m, paren) {
										return ' > ' + paren;
									});
								}
							}
							selector = selector.replace(DIR_PAREN, function (m, before, dir) {
								return '[dir="' + dir + '"] ' + before + ', ' + before + '[dir="' + dir + '"]';
							});
							return { value: selector, combinator: combinator, stop: stop };
						}
					}, {
						key: '_transformSimpleSelector',
						value: function _transformSimpleSelector(selector, scope) {
							var p$ = selector.split(PSEUDO_PREFIX);
							p$[0] += scope;
							return p$.join(PSEUDO_PREFIX);
						}

						// :host(...) -> scopeName...

					}, {
						key: '_transformHostSelector',
						value: function _transformHostSelector(selector, hostScope) {
							var m = selector.match(HOST_PAREN);
							var paren = m && m[2].trim() || '';
							if (paren) {
								if (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {
									// paren starts with a type selector
									var typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0];
									// if the type selector is our hostScope then avoid pre-pending it
									if (typeSelector === hostScope) {
										return paren;
										// otherwise, this selector should not match in this scope so
										// output a bogus selector.
									} else {
										return SELECTOR_NO_MATCH;
									}
								} else {
									// make sure to do a replace here to catch selectors like:
									// `:host(.foo)::before`
									return selector.replace(HOST_PAREN, function (m, host, paren) {
										return hostScope + paren;
									});
								}
								// if no paren, do a straight :host replacement.
								// TODO(sorvell): this should not strictly be necessary but
								// it's needed to maintain support for `:host[foo]` type selectors
								// which have been improperly used under Shady DOM. This should be
								// deprecated.
							} else {
								return selector.replace(HOST, hostScope);
							}
						}
					}, {
						key: 'documentRule',
						value: function documentRule(rule) {
							// reset selector in case this is redone.
							rule.selector = rule.parsedSelector;
							this.normalizeRootSelector(rule);
							this._transformRule(rule, this._transformDocumentSelector);
						}
					}, {
						key: 'normalizeRootSelector',
						value: function normalizeRootSelector(rule) {
							if (rule.selector === ROOT) {
								rule.selector = 'html';
							}
						}
					}, {
						key: '_transformDocumentSelector',
						value: function _transformDocumentSelector(selector) {
							return selector.match(SLOTTED) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);
						}
					}, {
						key: 'SCOPE_NAME',
						get: function get() {
							return SCOPE_NAME;
						}
					}]);

					return StyleTransformer;
				}();

				var NTH = /:(nth[-\w]+)\(([^)]+)\)/;
				var SCOPE_DOC_SELECTOR = ':not(.' + SCOPE_NAME + ')';
				var COMPLEX_SELECTOR_SEP = ',';
				var SIMPLE_SELECTOR_SEP = /(^|[\s>+~]+)((?:\[.+?\]|[^\s>+~=\[])+)/g;
				var SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;
				var HOST = ':host';
				var ROOT = ':root';
				var SLOTTED = '::slotted';
				var SLOTTED_START = new RegExp('^(' + SLOTTED + ')');
				// NOTE: this supports 1 nested () pair for things like
				// :host(:not([selected]), more general support requires
				// parsing which seems like overkill
				var HOST_PAREN = /(:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/;
				// similar to HOST_PAREN
				var SLOTTED_PAREN = /(?:::slotted)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/;
				var DIR_PAREN = /(.*):dir\((?:(ltr|rtl))\)/;
				var CSS_CLASS_PREFIX = '.';
				var PSEUDO_PREFIX = ':';
				var CLASS = 'class';
				var SELECTOR_NO_MATCH = 'should_not_match';

				exports.default = new StyleTransformer();

				/***/
			},
			/* 72 */
			/***/function (module, exports, __webpack_require__) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});
				exports.rx = undefined;
				exports.toCssText = toCssText;
				exports.rulesForStyle = rulesForStyle;
				exports.isKeyframesSelector = isKeyframesSelector;
				exports.forEachRule = forEachRule;
				exports.applyCss = applyCss;
				exports.applyStyle = applyStyle;
				exports.createScopeStyle = createScopeStyle;
				exports.applyStylePlaceHolder = applyStylePlaceHolder;
				exports.isTargetedBuild = isTargetedBuild;
				exports.getCssBuildType = getCssBuildType;
				exports.processVariableAndFallback = processVariableAndFallback;
				exports.setElementClassRaw = setElementClassRaw;

				var _styleSettings = __webpack_require__(70);

				var _cssParse = __webpack_require__(69);

				function toCssText(rules, callback) {
					if (typeof rules === 'string') {
						rules = (0, _cssParse.parse)(rules);
					}
					if (callback) {
						forEachRule(rules, callback);
					}
					return (0, _cssParse.stringify)(rules, _styleSettings.nativeCssVariables);
				}

				function rulesForStyle(style) {
					if (!style.__cssRules && style.textContent) {
						style.__cssRules = (0, _cssParse.parse)(style.textContent);
					}
					return style.__cssRules;
				}

				// Tests if a rule is a keyframes selector, which looks almost exactly
				// like a normal selector but is not (it has nothing to do with scoping
				// for example).
				function isKeyframesSelector(rule) {
					return rule.parent && rule.parent.type === _cssParse.types.KEYFRAMES_RULE;
				}

				function forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
					if (!node) {
						return;
					}
					var skipRules = false;
					if (onlyActiveRules) {
						if (node.type === _cssParse.types.MEDIA_RULE) {
							var matchMedia = node.selector.match(rx.MEDIA_MATCH);
							if (matchMedia) {
								// if rule is a non matching @media rule, skip subrules
								if (!window.matchMedia(matchMedia[1]).matches) {
									skipRules = true;
								}
							}
						}
					}
					if (node.type === _cssParse.types.STYLE_RULE) {
						styleRuleCallback(node);
					} else if (keyframesRuleCallback && node.type === _cssParse.types.KEYFRAMES_RULE) {
						keyframesRuleCallback(node);
					} else if (node.type === _cssParse.types.MIXIN_RULE) {
						skipRules = true;
					}
					var r$ = node.rules;
					if (r$ && !skipRules) {
						for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
							forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);
						}
					}
				}

				// add a string of cssText to the document.
				function applyCss(cssText, moniker, target, contextNode) {
					var style = createScopeStyle(cssText, moniker);
					return applyStyle(style, target, contextNode);
				}

				function applyStyle(style, target, contextNode) {
					target = target || document.head;
					var after = contextNode && contextNode.nextSibling || target.firstChild;
					lastHeadApplyNode = style;
					return target.insertBefore(style, after);
				}

				function createScopeStyle(cssText, moniker) {
					var style = document.createElement('style');
					if (moniker) {
						style.setAttribute('scope', moniker);
					}
					style.textContent = cssText;
					return style;
				}

				var lastHeadApplyNode = null;

				// insert a comment node as a styling position placeholder.
				function applyStylePlaceHolder(moniker) {
					var placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');
					var after = lastHeadApplyNode ? lastHeadApplyNode.nextSibling : null;
					var scope = document.head;
					scope.insertBefore(placeHolder, after || scope.firstChild);
					lastHeadApplyNode = placeHolder;
					return placeHolder;
				}

				function isTargetedBuild(buildType) {
					return _styleSettings.nativeShadow ? buildType === 'shadow' : buildType === 'shady';
				}

				// cssBuildTypeForModule: function (module) {
				//   let dm = Polymer.DomModule.import(module);
				//   if (dm) {
				//     return getCssBuildType(dm);
				//   }
				// },
				//
				function getCssBuildType(element) {
					return element.getAttribute('css-build');
				}

				// Walk from text[start] matching parens
				// returns position of the outer end paren
				function findMatchingParen(text, start) {
					var level = 0;
					for (var i = start, l = text.length; i < l; i++) {
						if (text[i] === '(') {
							level++;
						} else if (text[i] === ')') {
							if (--level === 0) {
								return i;
							}
						}
					}
					return -1;
				}

				function processVariableAndFallback(str, callback) {
					// find 'var('
					var start = str.indexOf('var(');
					if (start === -1) {
						// no var?, everything is prefix
						return callback(str, '', '', '');
					}
					//${prefix}var(${inner})${suffix}
					var end = findMatchingParen(str, start + 3);
					var inner = str.substring(start + 4, end);
					var prefix = str.substring(0, start);
					// suffix may have other variables
					var suffix = processVariableAndFallback(str.substring(end + 1), callback);
					var comma = inner.indexOf(',');
					// value and fallback args should be trimmed to match in property lookup
					if (comma === -1) {
						// variable, no fallback
						return callback(prefix, inner.trim(), '', suffix);
					}
					// var(${value},${fallback})
					var value = inner.substring(0, comma).trim();
					var fallback = inner.substring(comma + 1).trim();
					return callback(prefix, value, fallback, suffix);
				}

				function setElementClassRaw(element, value) {
					// use native setAttribute provided by ShadyDOM when setAttribute is patched
					if (window.ShadyDOM) {
						window.ShadyDOM.nativeMethods.setAttribute.call(element, 'class', value);
					} else {
						element.setAttribute('class', value);
					}
				}

				var rx = exports.rx = {
					VAR_ASSIGN: /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\s}])|$)/gi,
					MIXIN_MATCH: /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,
					VAR_CONSUMED: /(--[\w-]+)\s*([:,;)]|$)/gi,
					ANIMATION_MATCH: /(animation\s*:)|(animation-name\s*:)/,
					MEDIA_MATCH: /@media[^(]*(\([^)]*\))/,
					IS_VAR: /^--/,
					BRACKETED: /\{[^}]*\}/g,
					HOST_PREFIX: '(?:^|[^.#[:])',
					HOST_SUFFIX: '($|[.:[\\s>+~])'
				};

				/***/
			},
			/* 73 */
			/***/function (module, exports, __webpack_require__) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});

				var _createClass = function () {
					function defineProperties(target, props) {
						for (var i = 0; i < props.length; i++) {
							var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
						}
					}return function (Constructor, protoProps, staticProps) {
						if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
					};
				}();

				var _cssParse = __webpack_require__(69);

				var _styleSettings = __webpack_require__(70);

				var _styleTransformer = __webpack_require__(71);

				var _styleTransformer2 = _interopRequireDefault(_styleTransformer);

				var _styleUtil = __webpack_require__(72);

				var StyleUtil = _interopRequireWildcard(_styleUtil);

				var _styleInfo = __webpack_require__(74);

				var _styleInfo2 = _interopRequireDefault(_styleInfo);

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					} else {
						var newObj = {};if (obj != null) {
							for (var key in obj) {
								if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
							}
						}newObj.default = obj;return newObj;
					}
				}

				function _interopRequireDefault(obj) {
					return obj && obj.__esModule ? obj : { default: obj };
				}

				function _classCallCheck(instance, Constructor) {
					if (!(instance instanceof Constructor)) {
						throw new TypeError("Cannot call a class as a function");
					}
				}

				// TODO: dedupe with shady
				var p = window.Element.prototype;
				var matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;

				var IS_IE = navigator.userAgent.match('Trident');

				var XSCOPE_NAME = 'x-scope';

				var StyleProperties = function () {
					function StyleProperties() {
						_classCallCheck(this, StyleProperties);
					}

					_createClass(StyleProperties, [{
						key: 'decorateStyles',

						// decorates styles with rule info and returns an array of used style
						// property names
						value: function decorateStyles(rules) {
							var self = this,
							    props = {},
							    keyframes = [],
							    ruleIndex = 0;
							StyleUtil.forEachRule(rules, function (rule) {
								self.decorateRule(rule);
								// mark in-order position of ast rule in styles block, used for cache key
								rule.index = ruleIndex++;
								self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);
							}, function onKeyframesRule(rule) {
								keyframes.push(rule);
							});
							// Cache all found keyframes rules for later reference:
							rules._keyframes = keyframes;
							// return this list of property names *consumes* in these styles.
							var names = [];
							for (var i in props) {
								names.push(i);
							}
							return names;
						}

						// decorate a single rule with property info

					}, {
						key: 'decorateRule',
						value: function decorateRule(rule) {
							if (rule.propertyInfo) {
								return rule.propertyInfo;
							}
							var info = {},
							    properties = {};
							var hasProperties = this.collectProperties(rule, properties);
							if (hasProperties) {
								info.properties = properties;
								// TODO(sorvell): workaround parser seeing mixins as additional rules
								rule.rules = null;
							}
							info.cssText = this.collectCssText(rule);
							rule.propertyInfo = info;
							return info;
						}

						// collects the custom properties from a rule's cssText

					}, {
						key: 'collectProperties',
						value: function collectProperties(rule, properties) {
							var info = rule.propertyInfo;
							if (info) {
								if (info.properties) {
									Object.assign(properties, info.properties);
									return true;
								}
							} else {
								var m = void 0,
								    rx = StyleUtil.rx.VAR_ASSIGN;
								var cssText = rule.parsedCssText;
								var value = void 0;
								var any = void 0;
								while (m = rx.exec(cssText)) {
									// note: group 2 is var, 3 is mixin
									value = (m[2] || m[3]).trim();
									// value of 'inherit' or 'unset' is equivalent to not setting the property here
									if (value !== 'inherit' || value !== 'unset') {
										properties[m[1].trim()] = value;
									}
									any = true;
								}
								return any;
							}
						}

						// returns cssText of properties that consume variables/mixins

					}, {
						key: 'collectCssText',
						value: function collectCssText(rule) {
							return this.collectConsumingCssText(rule.parsedCssText);
						}

						// NOTE: we support consumption inside mixin assignment
						// but not production, so strip out {...}

					}, {
						key: 'collectConsumingCssText',
						value: function collectConsumingCssText(cssText) {
							return cssText.replace(StyleUtil.rx.BRACKETED, '').replace(StyleUtil.rx.VAR_ASSIGN, '');
						}
					}, {
						key: 'collectPropertiesInCssText',
						value: function collectPropertiesInCssText(cssText, props) {
							var m = void 0;
							while (m = StyleUtil.rx.VAR_CONSUMED.exec(cssText)) {
								var name = m[1];
								// This regex catches all variable names, and following non-whitespace char
								// If next char is not ':', then variable is a consumer
								if (m[2] !== ':') {
									props[name] = true;
								}
							}
						}

						// turns custom properties into realized values.

					}, {
						key: 'reify',
						value: function reify(props) {
							// big perf optimization here: reify only *own* properties
							// since this object has __proto__ of the element's scope properties
							var names = Object.getOwnPropertyNames(props);
							for (var i = 0, n; i < names.length; i++) {
								n = names[i];
								props[n] = this.valueForProperty(props[n], props);
							}
						}

						// given a property value, returns the reified value
						// a property value may be:
						// (1) a literal value like: red or 5px;
						// (2) a variable value like: var(--a), var(--a, red), or var(--a, --b) or
						// var(--a, var(--b));
						// (3) a literal mixin value like { properties }. Each of these properties
						// can have values that are: (a) literal, (b) variables, (c) @apply mixins.

					}, {
						key: 'valueForProperty',
						value: function valueForProperty(property, props) {
							var _this = this;

							// case (1) default
							// case (3) defines a mixin and we have to reify the internals
							if (property) {
								if (property.indexOf(';') >= 0) {
									property = this.valueForProperties(property, props);
								} else {
									(function () {
										// case (2) variable
										var self = _this;
										var fn = function fn(prefix, value, fallback, suffix) {
											if (!value) {
												return prefix + suffix;
											}
											var propertyValue = self.valueForProperty(props[value], props);
											// if value is "initial", then the variable should be treated as unset
											if (!propertyValue || propertyValue === 'initial') {
												// fallback may be --a or var(--a) or literal
												propertyValue = self.valueForProperty(props[fallback] || fallback, props) || fallback;
											} else if (propertyValue === 'apply-shim-inherit') {
												// CSS build will replace `inherit` with `apply-shim-inherit`
												// for use with native css variables.
												// Since we have full control, we can use `inherit` directly.
												propertyValue = 'inherit';
											}
											return prefix + (propertyValue || '') + suffix;
										};
										property = StyleUtil.processVariableAndFallback(property, fn);
									})();
								}
							}
							return property && property.trim() || '';
						}

						// note: we do not yet support mixin within mixin

					}, {
						key: 'valueForProperties',
						value: function valueForProperties(property, props) {
							var parts = property.split(';');
							for (var i = 0, _p, m; i < parts.length; i++) {
								if (_p = parts[i]) {
									StyleUtil.rx.MIXIN_MATCH.lastIndex = 0;
									m = StyleUtil.rx.MIXIN_MATCH.exec(_p);
									if (m) {
										_p = this.valueForProperty(props[m[1]], props);
									} else {
										var colon = _p.indexOf(':');
										if (colon !== -1) {
											var pp = _p.substring(colon);
											pp = pp.trim();
											pp = this.valueForProperty(pp, props) || pp;
											_p = _p.substring(0, colon) + pp;
										}
									}
									parts[i] = _p && _p.lastIndexOf(';') === _p.length - 1 ?
									// strip trailing ;
									_p.slice(0, -1) : _p || '';
								}
							}
							return parts.join(';');
						}
					}, {
						key: 'applyProperties',
						value: function applyProperties(rule, props) {
							var output = '';
							// dynamically added sheets may not be decorated so ensure they are.
							if (!rule.propertyInfo) {
								this.decorateRule(rule);
							}
							if (rule.propertyInfo.cssText) {
								output = this.valueForProperties(rule.propertyInfo.cssText, props);
							}
							rule.cssText = output;
						}

						// Apply keyframe transformations to the cssText of a given rule. The
						// keyframeTransforms object is a map of keyframe names to transformer
						// functions which take in cssText and spit out transformed cssText.

					}, {
						key: 'applyKeyframeTransforms',
						value: function applyKeyframeTransforms(rule, keyframeTransforms) {
							var input = rule.cssText;
							var output = rule.cssText;
							if (rule.hasAnimations == null) {
								// Cache whether or not the rule has any animations to begin with:
								rule.hasAnimations = StyleUtil.rx.ANIMATION_MATCH.test(input);
							}
							// If there are no animations referenced, we can skip transforms:
							if (rule.hasAnimations) {
								var transform = void 0;
								// If we haven't transformed this rule before, we iterate over all
								// transforms:
								if (rule.keyframeNamesToTransform == null) {
									rule.keyframeNamesToTransform = [];
									for (var keyframe in keyframeTransforms) {
										transform = keyframeTransforms[keyframe];
										output = transform(input);
										// If the transform actually changed the CSS text, we cache the
										// transform name for future use:
										if (input !== output) {
											input = output;
											rule.keyframeNamesToTransform.push(keyframe);
										}
									}
								} else {
									// If we already have a list of keyframe names that apply to this
									// rule, we apply only those keyframe name transforms:
									for (var i = 0; i < rule.keyframeNamesToTransform.length; ++i) {
										transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];
										input = transform(input);
									}
									output = input;
								}
							}
							rule.cssText = output;
						}

						// Test if the rules in these styles matches the given `element` and if so,
						// collect any custom properties into `props`.

					}, {
						key: 'propertyDataFromStyles',
						value: function propertyDataFromStyles(rules, element) {
							var props = {},
							    self = this;
							// generates a unique key for these matches
							var o = [];
							// note: active rules excludes non-matching @media rules
							StyleUtil.forEachRule(rules, function (rule) {
								// TODO(sorvell): we could trim the set of rules at declaration
								// time to only include ones that have properties
								if (!rule.propertyInfo) {
									self.decorateRule(rule);
								}
								// match element against transformedSelector: selector may contain
								// unwanted uniquification and parsedSelector does not directly match
								// for :host selectors.
								var selectorToMatch = rule.transformedSelector || rule.parsedSelector;
								if (element && rule.propertyInfo.properties && selectorToMatch) {
									if (matchesSelector.call(element, selectorToMatch)) {
										self.collectProperties(rule, props);
										// produce numeric key for these matches for lookup
										addToBitMask(rule.index, o);
									}
								}
							}, null, true);
							return { properties: props, key: o };
						}
					}, {
						key: 'whenHostOrRootRule',
						value: function whenHostOrRootRule(scope, rule, cssBuild, callback) {
							if (!rule.propertyInfo) {
								this.decorateRule(rule);
							}
							if (!rule.propertyInfo.properties) {
								return;
							}
							var hostScope = scope.is ? _styleTransformer2.default._calcHostScope(scope.is, scope.extends) : 'html';
							var parsedSelector = rule.parsedSelector;
							var isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';
							var isHost = parsedSelector.indexOf(':host') === 0 && !isRoot;
							// build info is either in scope (when scope is an element) or in the style
							// when scope is the default scope; note: this allows default scope to have
							// mixed mode built and unbuilt styles.
							if (cssBuild === 'shady') {
								// :root -> x-foo > *.x-foo for elements and html for custom-style
								isRoot = parsedSelector === hostScope + ' > *.' + hostScope || parsedSelector.indexOf('html') !== -1;
								// :host -> x-foo for elements, but sub-rules have .x-foo in them
								isHost = !isRoot && parsedSelector.indexOf(hostScope) === 0;
							}
							if (cssBuild === 'shadow') {
								isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';
								isHost = isHost && !isRoot;
							}
							if (!isRoot && !isHost) {
								return;
							}
							var selectorToMatch = hostScope;
							if (isHost) {
								// need to transform :host under ShadowDOM because `:host` does not work with `matches`
								if (_styleSettings.nativeShadow && !rule.transformedSelector) {
									// transform :host into a matchable selector
									rule.transformedSelector = _styleTransformer2.default._transformRuleCss(rule, _styleTransformer2.default._transformComplexSelector, _styleTransformer2.default._calcElementScope(scope.is), hostScope);
								}
								selectorToMatch = rule.transformedSelector || hostScope;
							}
							callback({
								selector: selectorToMatch,
								isHost: isHost,
								isRoot: isRoot
							});
						}
					}, {
						key: 'hostAndRootPropertiesForScope',
						value: function hostAndRootPropertiesForScope(scope, rules) {
							var hostProps = {},
							    rootProps = {},
							    self = this;
							// note: active rules excludes non-matching @media rules
							var cssBuild = rules && rules.__cssBuild;
							StyleUtil.forEachRule(rules, function (rule) {
								// if scope is StyleDefaults, use _element for matchesSelector
								self.whenHostOrRootRule(scope, rule, cssBuild, function (info) {
									var element = scope._element || scope;
									if (matchesSelector.call(element, info.selector)) {
										if (info.isHost) {
											self.collectProperties(rule, hostProps);
										} else {
											self.collectProperties(rule, rootProps);
										}
									}
								});
							}, null, true);
							return { rootProps: rootProps, hostProps: hostProps };
						}
					}, {
						key: 'transformStyles',
						value: function transformStyles(element, properties, scopeSelector) {
							var self = this;
							var hostSelector = _styleTransformer2.default._calcHostScope(element.is, element.extends);
							var rxHostSelector = element.extends ? '\\' + hostSelector.slice(0, -1) + '\\]' : hostSelector;
							var hostRx = new RegExp(StyleUtil.rx.HOST_PREFIX + rxHostSelector + StyleUtil.rx.HOST_SUFFIX);
							var rules = _styleInfo2.default.get(element).styleRules;
							var keyframeTransforms = this._elementKeyframeTransforms(element, rules, scopeSelector);
							return _styleTransformer2.default.elementStyles(element, rules, function (rule) {
								self.applyProperties(rule, properties);
								if (!_styleSettings.nativeShadow && !StyleUtil.isKeyframesSelector(rule) && rule.cssText) {
									// NOTE: keyframe transforms only scope munge animation names, so it
									// is not necessary to apply them in ShadowDOM.
									self.applyKeyframeTransforms(rule, keyframeTransforms);
									self._scopeSelector(rule, hostRx, hostSelector, scopeSelector);
								}
							});
						}
					}, {
						key: '_elementKeyframeTransforms',
						value: function _elementKeyframeTransforms(element, rules, scopeSelector) {
							var keyframesRules = rules._keyframes;
							var keyframeTransforms = {};
							if (!_styleSettings.nativeShadow && keyframesRules) {
								// For non-ShadowDOM, we transform all known keyframes rules in
								// advance for the current scope. This allows us to catch keyframes
								// rules that appear anywhere in the stylesheet:
								for (var i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {
									this._scopeKeyframes(keyframesRule, scopeSelector);
									keyframeTransforms[keyframesRule.keyframesName] = this._keyframesRuleTransformer(keyframesRule);
								}
							}
							return keyframeTransforms;
						}

						// Generate a factory for transforming a chunk of CSS text to handle a
						// particular scoped keyframes rule.

					}, {
						key: '_keyframesRuleTransformer',
						value: function _keyframesRuleTransformer(keyframesRule) {
							return function (cssText) {
								return cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName);
							};
						}

						// Transforms `@keyframes` names to be unique for the current host.
						// Example: @keyframes foo-anim -> @keyframes foo-anim-x-foo-0

					}, {
						key: '_scopeKeyframes',
						value: function _scopeKeyframes(rule, scopeId) {
							rule.keyframesNameRx = new RegExp(rule.keyframesName, 'g');
							rule.transformedKeyframesName = rule.keyframesName + '-' + scopeId;
							rule.transformedSelector = rule.transformedSelector || rule.selector;
							rule.selector = rule.transformedSelector.replace(rule.keyframesName, rule.transformedKeyframesName);
						}

						// Strategy: x scope shim a selector e.g. to scope `.x-foo-42` (via classes):
						// non-host selector: .a.x-foo -> .x-foo-42 .a.x-foo
						// host selector: x-foo.wide -> .x-foo-42.wide
						// note: we use only the scope class (.x-foo-42) and not the hostSelector
						// (x-foo) to scope :host rules; this helps make property host rules
						// have low specificity. They are overrideable by class selectors but,
						// unfortunately, not by type selectors (e.g. overriding via
						// `.special` is ok, but not by `x-foo`).

					}, {
						key: '_scopeSelector',
						value: function _scopeSelector(rule, hostRx, hostSelector, scopeId) {
							rule.transformedSelector = rule.transformedSelector || rule.selector;
							var selector = rule.transformedSelector;
							var scope = '.' + scopeId;
							var parts = selector.split(',');
							for (var i = 0, l = parts.length, _p2; i < l && (_p2 = parts[i]); i++) {
								parts[i] = _p2.match(hostRx) ? _p2.replace(hostSelector, scope) : scope + ' ' + _p2;
							}
							rule.selector = parts.join(',');
						}
					}, {
						key: 'applyElementScopeSelector',
						value: function applyElementScopeSelector(element, selector, old) {
							var c = element.getAttribute('class') || '';
							var v = c;
							if (old) {
								v = c.replace(new RegExp('\\s*' + XSCOPE_NAME + '\\s*' + old + '\\s*', 'g'), ' ');
							}
							v += (v ? ' ' : '') + XSCOPE_NAME + ' ' + selector;
							if (c !== v) {
								StyleUtil.setElementClassRaw(element, v);
							}
						}
					}, {
						key: 'applyElementStyle',
						value: function applyElementStyle(element, properties, selector, style) {
							// calculate cssText to apply
							var cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);
							// if shady and we have a cached style that is not style, decrement
							var styleInfo = _styleInfo2.default.get(element);
							var s = styleInfo.customStyle;
							if (s && !_styleSettings.nativeShadow && s !== style) {
								s._useCount--;
								if (s._useCount <= 0 && s.parentNode) {
									s.parentNode.removeChild(s);
								}
							}
							// apply styling always under native or if we generated style
							// or the cached style is not in document(!)
							if (_styleSettings.nativeShadow) {
								// update existing style only under native
								if (styleInfo.customStyle) {
									styleInfo.customStyle.textContent = cssText;
									style = styleInfo.customStyle;
									// otherwise, if we have css to apply, do so
								} else if (cssText) {
									// apply css after the scope style of the element to help with
									// style precedence rules.
									style = StyleUtil.applyCss(cssText, selector, element.shadowRoot, styleInfo.placeholder);
								}
							} else {
								// shady and no cache hit
								if (!style) {
									// apply css after the scope style of the element to help with
									// style precedence rules.
									if (cssText) {
										style = StyleUtil.applyCss(cssText, selector, null, styleInfo.placeholder);
									}
									// shady and cache hit but not in document
								} else if (!style.parentNode) {
									StyleUtil.applyStyle(style, null, styleInfo.placeholder);
								}
							}
							// ensure this style is our custom style and increment its use count.
							if (style) {
								style._useCount = style._useCount || 0;
								// increment use count if we changed styles
								if (styleInfo.customStyle != style) {
									style._useCount++;
								}
								styleInfo.customStyle = style;
							}
							// @media rules may be stale in IE 10 and 11
							if (IS_IE) {
								style.textContent = style.textContent;
							}
							return style;
						}
					}, {
						key: 'applyCustomStyle',
						value: function applyCustomStyle(style, properties) {
							var rules = StyleUtil.rulesForStyle(style);
							var self = this;
							style.textContent = StyleUtil.toCssText(rules, function (rule) {
								var css = rule.cssText = rule.parsedCssText;
								if (rule.propertyInfo && rule.propertyInfo.cssText) {
									// remove property assignments
									// so next function isn't confused
									// NOTE: we have 3 categories of css:
									// (1) normal properties,
									// (2) custom property assignments (--foo: red;),
									// (3) custom property usage: border: var(--foo); @apply(--foo);
									// In elements, 1 and 3 are separated for efficiency; here they
									// are not and this makes this case unique.
									css = (0, _cssParse.removeCustomPropAssignment)(css);
									// replace with reified properties, scenario is same as mixin
									rule.cssText = self.valueForProperties(css, properties);
								}
							});
						}
					}, {
						key: 'XSCOPE_NAME',
						get: function get() {
							return XSCOPE_NAME;
						}
					}]);

					return StyleProperties;
				}();

				function addToBitMask(n, bits) {
					var o = parseInt(n / 32);
					var v = 1 << n % 32;
					bits[o] = (bits[o] || 0) | v;
				}

				exports.default = new StyleProperties();

				/***/
			},
			/* 74 */
			/***/function (module, exports, __webpack_require__) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});

				var _createClass = function () {
					function defineProperties(target, props) {
						for (var i = 0; i < props.length; i++) {
							var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
						}
					}return function (Constructor, protoProps, staticProps) {
						if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
					};
				}();

				var _templateMap = __webpack_require__(75);

				var _templateMap2 = _interopRequireDefault(_templateMap);

				function _interopRequireDefault(obj) {
					return obj && obj.__esModule ? obj : { default: obj };
				}

				function _classCallCheck(instance, Constructor) {
					if (!(instance instanceof Constructor)) {
						throw new TypeError("Cannot call a class as a function");
					}
				}

				var promise = Promise.resolve();

				var StyleInfo = function () {
					_createClass(StyleInfo, null, [{
						key: 'get',
						value: function get(node) {
							return node.__styleInfo;
						}
					}, {
						key: 'set',
						value: function set(node, styleInfo) {
							node.__styleInfo = styleInfo;
							return styleInfo;
						}
					}, {
						key: 'invalidate',
						value: function invalidate(elementName) {
							if (_templateMap2.default[elementName]) {
								_templateMap2.default[elementName]._applyShimInvalid = true;
							}
						}
						/*
      the template is marked as `validating` for one microtask so that all instances
      found in the tree crawl of `applyStyle` will update themselves,
      but the template will only be updated once.
      */

					}, {
						key: 'startValidating',
						value: function startValidating(elementName) {
							var template = _templateMap2.default[elementName];
							if (!template._validating) {
								template._validating = true;
								promise.then(function () {
									template._applyShimInvalid = false;
									template._validating = false;
								});
							}
						}
					}]);

					function StyleInfo(ast, placeholder, ownStylePropertyNames, elementName, typeExtension, cssBuild) {
						_classCallCheck(this, StyleInfo);

						this.styleRules = ast || null;
						this.placeholder = placeholder || null;
						this.ownStylePropertyNames = ownStylePropertyNames || [];
						this.overrideStyleProperties = null;
						this.elementName = elementName || '';
						this.cssBuild = cssBuild || '';
						this.typeExtension = typeExtension || '';
						this.styleProperties = null;
						this.scopeSelector = null;
						this.customStyle = null;
					}

					return StyleInfo;
				}();

				exports.default = StyleInfo;

				/***/
			},
			/* 75 */
			/***/function (module, exports) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});
				exports.default = {};

				/***/
			},
			/* 76 */
			/***/function (module, exports, __webpack_require__) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});

				var _styleUtil = __webpack_require__(72);

				var _styleSettings = __webpack_require__(70);

				var placeholderMap = {};

				var ce = window.customElements;
				if (ce && !_styleSettings.nativeShadow) {
					(function () {
						var origDefine = ce.define;
						ce.define = function (name, clazz, options) {
							placeholderMap[name] = (0, _styleUtil.applyStylePlaceHolder)(name);
							return origDefine.call(ce, name, clazz, options);
						};
					})();
				}

				exports.default = placeholderMap;

				/***/
			},
			/* 77 */
			/***/function (module, exports) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */
				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});

				var _createClass = function () {
					function defineProperties(target, props) {
						for (var i = 0; i < props.length; i++) {
							var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
						}
					}return function (Constructor, protoProps, staticProps) {
						if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
					};
				}();

				function _classCallCheck(instance, Constructor) {
					if (!(instance instanceof Constructor)) {
						throw new TypeError("Cannot call a class as a function");
					}
				}

				var StyleCache = function () {
					function StyleCache() {
						var typeMax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;

						_classCallCheck(this, StyleCache);

						// map element name -> [{properties, styleElement, scopeSelector}]
						this.cache = {};
						this.typeMax = typeMax;
					}

					_createClass(StyleCache, [{
						key: '_validate',
						value: function _validate(cacheEntry, properties, ownPropertyNames) {
							for (var idx = 0; idx < ownPropertyNames.length; idx++) {
								var pn = ownPropertyNames[idx];
								if (cacheEntry.properties[pn] !== properties[pn]) {
									return false;
								}
							}
							return true;
						}
					}, {
						key: 'store',
						value: function store(tagname, properties, styleElement, scopeSelector) {
							var list = this.cache[tagname] || [];
							list.push({ properties: properties, styleElement: styleElement, scopeSelector: scopeSelector });
							if (list.length > this.typeMax) {
								list.shift();
							}
							this.cache[tagname] = list;
						}
					}, {
						key: 'fetch',
						value: function fetch(tagname, properties, ownPropertyNames) {
							var list = this.cache[tagname];
							if (!list) {
								return;
							}
							// reverse list for most-recent lookups
							for (var idx = list.length - 1; idx >= 0; idx--) {
								var entry = list[idx];
								if (this._validate(entry, properties, ownPropertyNames)) {
									return entry;
								}
							}
						}
					}]);

					return StyleCache;
				}();

				exports.default = StyleCache;

				/***/
			},
			/* 78 */
			/***/function (module, exports, __webpack_require__) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */
				/**
     * The apply shim simulates the behavior of `@apply` proposed at
     * https://tabatkins.github.io/specs/css-apply-rule/.
     * The approach is to convert a property like this:
     *
     *    --foo: {color: red; background: blue;}
     *
     * to this:
     *
     *    --foo_-_color: red;
     *    --foo_-_background: blue;
     *
     * Then where `@apply --foo` is used, that is converted to:
     *
     *    color: var(--foo_-_color);
     *    background: var(--foo_-_background);
     *
     * This approach generally works but there are some issues and limitations.
     * Consider, for example, that somewhere *between* where `--foo` is set and used,
     * another element sets it to:
     *
     *    --foo: { border: 2px solid red; }
     *
     * We must now ensure that the color and background from the previous setting
     * do not apply. This is accomplished by changing the property set to this:
     *
     *    --foo_-_border: 2px solid red;
     *    --foo_-_color: initial;
     *    --foo_-_background: initial;
     *
     * This works but introduces one new issue.
     * Consider this setup at the point where the `@apply` is used:
     *
     *    background: orange;
     *    @apply --foo;
     *
     * In this case the background will be unset (initial) rather than the desired
     * `orange`. We address this by altering the property set to use a fallback
     * value like this:
     *
     *    color: var(--foo_-_color);
     *    background: var(--foo_-_background, orange);
     *    border: var(--foo_-_border);
     *
     * Note that the default is retained in the property set and the `background` is
     * the desired `orange`. This leads us to a limitation.
     *
     * Limitation 1:
    
     * Only properties in the rule where the `@apply`
     * is used are considered as default values.
     * If another rule matches the element and sets `background` with
     * less specificity than the rule in which `@apply` appears,
     * the `background` will not be set.
     *
     * Limitation 2:
     *
     * When using Polymer's `updateStyles` api, new properties may not be set for
     * `@apply` properties.
    
    */

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});

				var _createClass = function () {
					function defineProperties(target, props) {
						for (var i = 0; i < props.length; i++) {
							var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
						}
					}return function (Constructor, protoProps, staticProps) {
						if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
					};
				}();

				var _styleUtil = __webpack_require__(72);

				var _templateMap = __webpack_require__(75);

				var _templateMap2 = _interopRequireDefault(_templateMap);

				var _styleInfo = __webpack_require__(74);

				var _styleInfo2 = _interopRequireDefault(_styleInfo);

				function _interopRequireDefault(obj) {
					return obj && obj.__esModule ? obj : { default: obj };
				}

				function _classCallCheck(instance, Constructor) {
					if (!(instance instanceof Constructor)) {
						throw new TypeError("Cannot call a class as a function");
					}
				}

				var MIXIN_MATCH = _styleUtil.rx.MIXIN_MATCH;
				var VAR_ASSIGN = _styleUtil.rx.VAR_ASSIGN;

				var APPLY_NAME_CLEAN = /;\s*/m;
				var INITIAL_INHERIT = /^\s*(initial)|(inherit)\s*$/;

				// separator used between mixin-name and mixin-property-name when producing properties
				// NOTE: plain '-' may cause collisions in user styles
				var MIXIN_VAR_SEP = '_-_';

				// map of mixin to property names
				// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}

				var MixinMap = function () {
					function MixinMap() {
						_classCallCheck(this, MixinMap);

						this._map = {};
					}

					_createClass(MixinMap, [{
						key: 'set',
						value: function set(name, props) {
							name = name.trim();
							this._map[name] = {
								properties: props,
								dependants: {}
							};
						}
					}, {
						key: 'get',
						value: function get(name) {
							name = name.trim();
							return this._map[name];
						}
					}]);

					return MixinMap;
				}();

				var ApplyShim = function () {
					function ApplyShim() {
						var _this = this;

						_classCallCheck(this, ApplyShim);

						this._currentTemplate = null;
						this._measureElement = null;
						this._map = new MixinMap();
						this._separator = MIXIN_VAR_SEP;
						this._boundProduceCssProperties = function (matchText, propertyName, valueProperty, valueMixin) {
							return _this._produceCssProperties(matchText, propertyName, valueProperty, valueMixin);
						};
					}
					// return true if `cssText` contains a mixin definition or consumption


					_createClass(ApplyShim, [{
						key: 'detectMixin',
						value: function detectMixin(cssText) {
							var has = MIXIN_MATCH.test(cssText) || VAR_ASSIGN.test(cssText);
							// reset state of the regexes
							MIXIN_MATCH.lastIndex = 0;
							VAR_ASSIGN.lastIndex = 0;
							return has;
						}
					}, {
						key: 'transformStyle',
						value: function transformStyle(style, elementName) {
							var ast = (0, _styleUtil.rulesForStyle)(style);
							this.transformRules(ast, elementName);
							return ast;
						}
					}, {
						key: 'transformRules',
						value: function transformRules(rules, elementName) {
							var _this2 = this;

							this._currentTemplate = _templateMap2.default[elementName];
							(0, _styleUtil.forEachRule)(rules, function (r) {
								_this2.transformRule(r);
							});
							this._currentTemplate = null;
						}
					}, {
						key: 'transformRule',
						value: function transformRule(rule) {
							rule.cssText = this.transformCssText(rule.parsedCssText);
							// :root was only used for variable assignment in property shim,
							// but generates invalid selectors with real properties.
							// replace with `:host > *`, which serves the same effect
							if (rule.selector === ':root') {
								rule.selector = ':host > *';
							}
						}
					}, {
						key: 'transformCssText',
						value: function transformCssText(cssText) {
							// produce variables
							cssText = cssText.replace(VAR_ASSIGN, this._boundProduceCssProperties);
							// consume mixins
							return this._consumeCssProperties(cssText);
						}
					}, {
						key: '_getInitialValueForProperty',
						value: function _getInitialValueForProperty(property) {
							if (!this._measureElement) {
								this._measureElement = document.createElement('meta');
								this._measureElement.style.all = 'initial';
								document.head.appendChild(this._measureElement);
							}
							return window.getComputedStyle(this._measureElement).getPropertyValue(property);
						}
						// replace mixin consumption with variable consumption

					}, {
						key: '_consumeCssProperties',
						value: function _consumeCssProperties(text) {
							var m = void 0;
							// loop over text until all mixins with defintions have been applied
							while (m = MIXIN_MATCH.exec(text)) {
								var matchText = m[0];
								var mixinName = m[1];
								var idx = m.index;
								// collect properties before apply to be "defaults" if mixin might override them
								// match includes a "prefix", so find the start and end positions of @apply
								var applyPos = idx + matchText.indexOf('@apply');
								var afterApplyPos = idx + matchText.length;
								// find props defined before this @apply
								var textBeforeApply = text.slice(0, applyPos);
								var textAfterApply = text.slice(afterApplyPos);
								var defaults = this._cssTextToMap(textBeforeApply);
								var replacement = this._atApplyToCssProperties(mixinName, defaults);
								// use regex match position to replace mixin, keep linear processing time
								text = [textBeforeApply, replacement, textAfterApply].join('');
								// move regex search to _after_ replacement
								MIXIN_MATCH.lastIndex = idx + replacement.length;
							}
							return text;
						}
						// produce variable consumption at the site of mixin consumption
						// @apply --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))
						// Example:
						// border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)

					}, {
						key: '_atApplyToCssProperties',
						value: function _atApplyToCssProperties(mixinName, fallbacks) {
							mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');
							var vars = [];
							var mixinEntry = this._map.get(mixinName);
							// if we depend on a mixin before it is created
							// make a sentinel entry in the map to add this element as a dependency for when it is defined.
							if (!mixinEntry) {
								this._map.set(mixinName, {});
								mixinEntry = this._map.get(mixinName);
							}
							if (mixinEntry) {
								if (this._currentTemplate) {
									mixinEntry.dependants[this._currentTemplate.name] = this._currentTemplate;
								}
								var p = void 0,
								    parts = void 0,
								    f = void 0;
								for (p in mixinEntry.properties) {
									f = fallbacks && fallbacks[p];
									parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];
									if (f) {
										parts.push(',', f);
									}
									parts.push(')');
									vars.push(parts.join(''));
								}
							}
							return vars.join('; ');
						}
					}, {
						key: '_replaceInitialOrInherit',
						value: function _replaceInitialOrInherit(property, value) {
							var match = INITIAL_INHERIT.exec(value);
							if (match) {
								if (match[1]) {
									// initial
									// replace `initial` with the concrete initial value for this property
									value = ApplyShim._getInitialValueForProperty(property);
								} else {
									// inherit
									// with this purposfully illegal value, the variable will be invalid at
									// compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)
									// and for inheriting values, will behave similarly
									// we cannot support the same behavior for non inheriting values like 'border'
									value = 'apply-shim-inherit';
								}
							}
							return value;
						}

						// "parse" a mixin definition into a map of properties and values
						// cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')

					}, {
						key: '_cssTextToMap',
						value: function _cssTextToMap(text) {
							var props = text.split(';');
							var property = void 0,
							    value = void 0;
							var out = {};
							for (var i = 0, p, sp; i < props.length; i++) {
								p = props[i];
								if (p) {
									sp = p.split(':');
									// ignore lines that aren't definitions like @media
									if (sp.length > 1) {
										property = sp[0].trim();
										// some properties may have ':' in the value, like data urls
										value = this._replaceInitialOrInherit(property, sp.slice(1).join(':'));
										out[property] = value;
									}
								}
							}
							return out;
						}
					}, {
						key: '_invalidateMixinEntry',
						value: function _invalidateMixinEntry(mixinEntry) {
							for (var elementName in mixinEntry.dependants) {
								if (!this._currentTemplate || elementName !== this._currentTemplate.name) {
									_styleInfo2.default.invalidate(elementName);
								}
							}
						}
					}, {
						key: '_produceCssProperties',
						value: function _produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {
							var _this3 = this;

							// handle case where property value is a mixin
							if (valueProperty) {
								// form: --mixin2: var(--mixin1), where --mixin1 is in the map
								(0, _styleUtil.processVariableAndFallback)(valueProperty, function (prefix, value) {
									if (value && _this3._map.get(value)) {
										valueMixin = '@apply ' + value + ';';
									}
								});
							}
							if (!valueMixin) {
								return matchText;
							}
							var mixinAsProperties = this._consumeCssProperties(valueMixin);
							var prefix = matchText.slice(0, matchText.indexOf('--'));
							var mixinValues = this._cssTextToMap(mixinAsProperties);
							var combinedProps = mixinValues;
							var mixinEntry = this._map.get(propertyName);
							var oldProps = mixinEntry && mixinEntry.properties;
							if (oldProps) {
								// NOTE: since we use mixin, the map of properties is updated here
								// and this is what we want.
								combinedProps = Object.assign(Object.create(oldProps), mixinValues);
							} else {
								this._map.set(propertyName, combinedProps);
							}
							var out = [];
							var p = void 0,
							    v = void 0;
							// set variables defined by current mixin
							var needToInvalidate = false;
							for (p in combinedProps) {
								v = mixinValues[p];
								// if property not defined by current mixin, set initial
								if (v === undefined) {
									v = 'initial';
								}
								if (oldProps && !(p in oldProps)) {
									needToInvalidate = true;
								}
								out.push(propertyName + MIXIN_VAR_SEP + p + ': ' + v);
							}
							if (needToInvalidate) {
								this._invalidateMixinEntry(mixinEntry);
							}
							if (mixinEntry) {
								mixinEntry.properties = combinedProps;
							}
							// because the mixinMap is global, the mixin might conflict with
							// a different scope's simple variable definition:
							// Example:
							// some style somewhere:
							// --mixin1:{ ... }
							// --mixin2: var(--mixin1);
							// some other element:
							// --mixin1: 10px solid red;
							// --foo: var(--mixin1);
							// In this case, we leave the original variable definition in place.
							if (valueProperty) {
								prefix = matchText + ';' + prefix;
							}
							return prefix + out.join('; ') + ';';
						}
					}]);

					return ApplyShim;
				}();

				var applyShim = new ApplyShim();
				window['ApplyShim'] = applyShim;
				exports.default = applyShim;

				/***/
			},
			/* 79 */
			/***/function (module, exports, __webpack_require__) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				'use strict';

				Object.defineProperty(exports, "__esModule", {
					value: true
				});
				exports.flush = undefined;

				var _styleSettings = __webpack_require__(70);

				var _styleTransformer = __webpack_require__(71);

				var _styleTransformer2 = _interopRequireDefault(_styleTransformer);

				function _interopRequireDefault(obj) {
					return obj && obj.__esModule ? obj : { default: obj };
				}

				var flush = exports.flush = function flush() {};

				if (!_styleSettings.nativeShadow) {
					(function () {
						var elementNeedsScoping = function elementNeedsScoping(element) {
							return element.classList && !element.classList.contains(_styleTransformer2.default.SCOPE_NAME) ||
							// note: necessary for IE11
							element instanceof SVGElement && (!element.hasAttribute('class') || element.getAttribute('class').indexOf(_styleTransformer2.default.SCOPE_NAME) < 0);
						};

						var handler = function handler(mxns) {
							for (var x = 0; x < mxns.length; x++) {
								var mxn = mxns[x];
								if (mxn.target === document.documentElement || mxn.target === document.head) {
									continue;
								}
								for (var i = 0; i < mxn.addedNodes.length; i++) {
									var n = mxn.addedNodes[i];
									if (elementNeedsScoping(n)) {
										var root = n.getRootNode();
										if (root.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
											// may no longer be in a shadowroot
											var host = root.host;
											if (host) {
												var scope = host.is || host.localName;
												_styleTransformer2.default.dom(n, scope);
											}
										}
									}
								}
								for (var _i = 0; _i < mxn.removedNodes.length; _i++) {
									var _n = mxn.removedNodes[_i];
									if (_n.nodeType === Node.ELEMENT_NODE) {
										var classes = undefined;
										if (_n.classList) {
											classes = Array.from(_n.classList);
										} else if (_n.hasAttribute('class')) {
											classes = _n.getAttribute('class').split(/\s+/);
										}
										if (classes !== undefined) {
											// NOTE: relies on the scoping class always being adjacent to the
											// SCOPE_NAME class.
											var classIdx = classes.indexOf(_styleTransformer2.default.SCOPE_NAME);
											if (classIdx >= 0) {
												var _scope = classes[classIdx + 1];
												if (_scope) {
													_styleTransformer2.default.dom(_n, _scope, true);
												}
											}
										}
									}
								}
							}
						};

						var observer = new MutationObserver(handler);
						var start = function start(node) {
							observer.observe(node, { childList: true, subtree: true });
						};
						var nativeCustomElements = window.customElements && !window.customElements.flush;
						// need to start immediately with native custom elements
						// TODO(dfreedm): with polyfilled HTMLImports and native custom elements
						// excessive mutations may be observed; this can be optimized via cooperation
						// with the HTMLImports polyfill.
						if (nativeCustomElements) {
							start(document);
						} else {
							(function () {
								var delayedStart = function delayedStart() {
									start(document.body);
								};
								// use polyfill timing if it's available
								if (window.HTMLImports) {
									window.HTMLImports.whenReady(delayedStart);
									// otherwise push beyond native imports being ready
									// which requires RAF + readystate interactive.
								} else {
									requestAnimationFrame(function () {
										if (document.readyState === 'loading') {
											(function () {
												var listener = function listener() {
													delayedStart();
													document.removeEventListener('readystatechange', listener);
												};
												document.addEventListener('readystatechange', listener);
											})();
										} else {
											delayedStart();
										}
									});
								}
							})();
						}

						exports.flush = flush = function flush() {
							handler(observer.takeRecords());
						};
					})();
				}

				/***/
			},
			/* 80 */
			/***/function (module, exports) {

				/**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

				/*
    Wrapper over <style> elements to co-operate with ShadyCSS
    
    Example:
    <custom-style>
      <style>
      ...
      </style>
    </custom-style>
    */

				'use strict';

				var _createClass = function () {
					function defineProperties(target, props) {
						for (var i = 0; i < props.length; i++) {
							var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
						}
					}return function (Constructor, protoProps, staticProps) {
						if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
					};
				}();

				function _classCallCheck(instance, Constructor) {
					if (!(instance instanceof Constructor)) {
						throw new TypeError("Cannot call a class as a function");
					}
				}

				function _possibleConstructorReturn(self, call) {
					if (!self) {
						throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
					}return call && (typeof call === "object" || typeof call === "function") ? call : self;
				}

				function _inherits(subClass, superClass) {
					if (typeof superClass !== "function" && superClass !== null) {
						throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
					}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
				}

				var ShadyCSS = window.ShadyCSS;

				var enqueued = false;

				var customStyles = [];

				var hookFn = null;

				/*
    If a page only has <custom-style> elements, it will flash unstyled content,
    as all the instances will boot asynchronously after page load.
    
    Calling ShadyCSS.updateStyles() will force the work to happen synchronously
    */
				function enqueueDocumentValidation() {
					if (enqueued) {
						return;
					}
					enqueued = true;
					if (window.HTMLImports) {
						window.HTMLImports.whenReady(validateDocument);
					} else if (document.readyState === 'complete') {
						validateDocument();
					} else {
						document.addEventListener('readystatechange', function () {
							if (document.readyState === 'complete') {
								validateDocument();
							}
						});
					}
				}

				function validateDocument() {
					requestAnimationFrame(function () {
						if (enqueued || ShadyCSS._elementsHaveApplied) {
							ShadyCSS.updateStyles();
						}
						enqueued = false;
					});
				}

				var CustomStyle = function (_HTMLElement) {
					_inherits(CustomStyle, _HTMLElement);

					_createClass(CustomStyle, null, [{
						key: 'findStyles',
						value: function findStyles() {
							for (var i = 0; i < customStyles.length; i++) {
								var c = customStyles[i];
								if (!c._style) {
									var style = c.querySelector('style');
									if (!style) {
										continue;
									}
									// HTMLImports polyfill may have cloned the style into the main document,
									// which is referenced with __appliedElement.
									// Also, we must copy over the attributes.
									if (style.__appliedElement) {
										for (var _i = 0; _i < style.attributes.length; _i++) {
											var attr = style.attributes[_i];
											style.__appliedElement.setAttribute(attr.name, attr.value);
										}
									}
									c._style = style.__appliedElement || style;
									if (hookFn) {
										hookFn(c._style);
									}
									ShadyCSS._transformCustomStyleForDocument(c._style);
								}
							}
						}
					}, {
						key: '_revalidateApplyShim',
						value: function _revalidateApplyShim() {
							for (var i = 0; i < customStyles.length; i++) {
								var c = customStyles[i];
								if (c._style) {
									ShadyCSS._revalidateApplyShim(c._style);
								}
							}
						}
					}, {
						key: 'applyStyles',
						value: function applyStyles() {
							for (var i = 0; i < customStyles.length; i++) {
								var c = customStyles[i];
								if (c._style) {
									ShadyCSS._applyCustomStyleToDocument(c._style);
								}
							}
							enqueued = false;
						}
					}, {
						key: '_customStyles',
						get: function get() {
							return customStyles;
						}
					}, {
						key: 'processHook',
						get: function get() {
							return hookFn;
						},
						set: function set(fn) {
							hookFn = fn;
						}
					}, {
						key: '_documentDirty',
						get: function get() {
							return enqueued;
						}
					}]);

					function CustomStyle() {
						_classCallCheck(this, CustomStyle);

						var _this = _possibleConstructorReturn(this, (CustomStyle.__proto__ || Object.getPrototypeOf(CustomStyle)).call(this));

						customStyles.push(_this);
						enqueueDocumentValidation();
						return _this;
					}

					return CustomStyle;
				}(HTMLElement);

				window['CustomStyle'] = CustomStyle;
				window.customElements.define('custom-style', CustomStyle);

				/***/
			}
			/******/])
		);
	});
	
	
});

function getElementClass() {
  if (typeof HTMLElement !== 'function') {
    // case of Safari
    const BaseElement = () => {};
    BaseElement.prototype = document.createElement('div');
    return BaseElement;
  } else {
    return HTMLElement;
  }
}

class Base$1 extends getElementClass() {
  constructor() {
    super();
  }
  getDefaultStyle() {
    const defaultTheme = document.styleSheets;
    console.log('default themes! ', defaultTheme);
  }
}

class Button$1 extends Base$1 {
  constructor() {
    super();
    // creates a shadow root
    const shadow = this.attachShadow({ mode: 'open' });
    // Create a standard img element and set it's attributes.
    const button = document.createElement('button');
    button.innerText = 'BUTTOlol';
    shadow.appendChild(button);
    this.getDefaultStyle();
  }
}

customElements.define('mui-button', Button$1);

/**
 * @license
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A cached reference to the hasOwnProperty function.
 */

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * A cached reference to the create function.
 */
var create = Object.create;

/**
 * Used to prevent property collisions between our "map" and its prototype.
 * @param {!Object<string, *>} map The map to check.
 * @param {string} property The property to check.
 * @return {boolean} Whether map has property.
 */
var has = function (map, property) {
  return hasOwnProperty.call(map, property);
};

/**
 * Creates an map object without a prototype.
 * @return {!Object}
 */
var createMap = function () {
  return create(null);
};

/**
 * Keeps track of information needed to perform diffs for a given DOM node.
 * @param {!string} nodeName
 * @param {?string=} key
 * @constructor
 */
function NodeData(nodeName, key) {
  /**
   * The attributes and their values.
   * @const {!Object<string, *>}
   */
  this.attrs = createMap();

  /**
   * An array of attribute name/value pairs, used for quickly diffing the
   * incomming attributes to see if the DOM node's attributes need to be
   * updated.
   * @const {Array<*>}
   */
  this.attrsArr = [];

  /**
   * The incoming attributes for this Node, before they are updated.
   * @const {!Object<string, *>}
   */
  this.newAttrs = createMap();

  /**
   * The key used to identify this node, used to preserve DOM nodes when they
   * move within their parent.
   * @const
   */
  this.key = key;

  /**
   * Keeps track of children within this node by their key.
   * {?Object<string, !Element>}
   */
  this.keyMap = null;

  /**
   * Whether or not the keyMap is currently valid.
   * {boolean}
   */
  this.keyMapValid = true;

  /**
   * The node name for this node.
   * @const {string}
   */
  this.nodeName = nodeName;

  /**
   * @type {?string}
   */
  this.text = null;
}

/**
 * Initializes a NodeData object for a Node.
 *
 * @param {Node} node The node to initialize data for.
 * @param {string} nodeName The node name of node.
 * @param {?string=} key The key that identifies the node.
 * @return {!NodeData} The newly initialized data object
 */
var initData = function (node, nodeName, key) {
  var data = new NodeData(nodeName, key);
  node['__incrementalDOMData'] = data;
  return data;
};

/**
 * Retrieves the NodeData object for a Node, creating it if necessary.
 *
 * @param {Node} node The node to retrieve the data for.
 * @return {!NodeData} The NodeData for this Node.
 */
var getData = function (node) {
  var data = node['__incrementalDOMData'];

  if (!data) {
    var nodeName = node.nodeName.toLowerCase();
    var key = null;

    if (node instanceof Element) {
      key = node.getAttribute('key');
    }

    data = initData(node, nodeName, key);
  }

  return data;
};

/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @const */
var symbols = {
  default: '__default',

  placeholder: '__placeholder'
};

/**
 * @param {string} name
 * @return {string|undefined} The namespace to use for the attribute.
 */
var getNamespace = function (name) {
  if (name.lastIndexOf('xml:', 0) === 0) {
    return 'http://www.w3.org/XML/1998/namespace';
  }

  if (name.lastIndexOf('xlink:', 0) === 0) {
    return 'http://www.w3.org/1999/xlink';
  }
};

/**
 * Applies an attribute or property to a given Element. If the value is null
 * or undefined, it is removed from the Element. Otherwise, the value is set
 * as an attribute.
 * @param {!Element} el
 * @param {string} name The attribute's name.
 * @param {?(boolean|number|string)=} value The attribute's value.
 */
var applyAttr = function (el, name, value) {
  if (value == null) {
    el.removeAttribute(name);
  } else {
    var attrNS = getNamespace(name);
    if (attrNS) {
      el.setAttributeNS(attrNS, name, value);
    } else {
      el.setAttribute(name, value);
    }
  }
};

/**
 * Applies a property to a given Element.
 * @param {!Element} el
 * @param {string} name The property's name.
 * @param {*} value The property's value.
 */
var applyProp = function (el, name, value) {
  el[name] = value;
};

/**
 * Applies a style to an Element. No vendor prefix expansion is done for
 * property names/values.
 * @param {!Element} el
 * @param {string} name The attribute's name.
 * @param {*} style The style to set. Either a string of css or an object
 *     containing property-value pairs.
 */
var applyStyle = function (el, name, style) {
  if (typeof style === 'string') {
    el.style.cssText = style;
  } else {
    el.style.cssText = '';
    var elStyle = el.style;
    var obj = /** @type {!Object<string,string>} */style;

    for (var prop in obj) {
      if (has(obj, prop)) {
        elStyle[prop] = obj[prop];
      }
    }
  }
};

/**
 * Updates a single attribute on an Element.
 * @param {!Element} el
 * @param {string} name The attribute's name.
 * @param {*} value The attribute's value. If the value is an object or
 *     function it is set on the Element, otherwise, it is set as an HTML
 *     attribute.
 */
var applyAttributeTyped = function (el, name, value) {
  var type = typeof value;

  if (type === 'object' || type === 'function') {
    applyProp(el, name, value);
  } else {
    applyAttr(el, name, /** @type {?(boolean|number|string)} */value);
  }
};

/**
 * Calls the appropriate attribute mutator for this attribute.
 * @param {!Element} el
 * @param {string} name The attribute's name.
 * @param {*} value The attribute's value.
 */
var updateAttribute = function (el, name, value) {
  var data = getData(el);
  var attrs = data.attrs;

  if (attrs[name] === value) {
    return;
  }

  var mutator = attributes[name] || attributes[symbols.default];
  mutator(el, name, value);

  attrs[name] = value;
};

/**
 * A publicly mutable object to provide custom mutators for attributes.
 * @const {!Object<string, function(!Element, string, *)>}
 */
var attributes = createMap();

// Special generic mutator that's called for any attribute that does not
// have a specific mutator.
attributes[symbols.default] = applyAttributeTyped;

attributes[symbols.placeholder] = function () {};

attributes['style'] = applyStyle;

/**
 * Gets the namespace to create an element (of a given tag) in.
 * @param {string} tag The tag to get the namespace for.
 * @param {?Node} parent
 * @return {?string} The namespace to create the tag in.
 */
var getNamespaceForTag = function (tag, parent) {
  if (tag === 'svg') {
    return 'http://www.w3.org/2000/svg';
  }

  if (getData(parent).nodeName === 'foreignObject') {
    return null;
  }

  return parent.namespaceURI;
};

/**
 * Creates an Element.
 * @param {Document} doc The document with which to create the Element.
 * @param {?Node} parent
 * @param {string} tag The tag for the Element.
 * @param {?string=} key A key to identify the Element.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element.
 * @return {!Element}
 */
var createElement = function (doc, parent, tag, key, statics) {
  var namespace = getNamespaceForTag(tag, parent);
  var el = undefined;

  if (namespace) {
    el = doc.createElementNS(namespace, tag);
  } else {
    el = doc.createElement(tag);
  }

  initData(el, tag, key);

  if (statics) {
    for (var i = 0; i < statics.length; i += 2) {
      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);
    }
  }

  return el;
};

/**
 * Creates a Text Node.
 * @param {Document} doc The document with which to create the Element.
 * @return {!Text}
 */
var createText = function (doc) {
  var node = doc.createTextNode('');
  initData(node, '#text', null);
  return node;
};

/**
 * Creates a mapping that can be used to look up children using a key.
 * @param {?Node} el
 * @return {!Object<string, !Element>} A mapping of keys to the children of the
 *     Element.
 */
var createKeyMap = function (el) {
  var map = createMap();
  var child = el.firstElementChild;

  while (child) {
    var key = getData(child).key;

    if (key) {
      map[key] = child;
    }

    child = child.nextElementSibling;
  }

  return map;
};

/**
 * Retrieves the mapping of key to child node for a given Element, creating it
 * if necessary.
 * @param {?Node} el
 * @return {!Object<string, !Node>} A mapping of keys to child Elements
 */
var getKeyMap = function (el) {
  var data = getData(el);

  if (!data.keyMap) {
    data.keyMap = createKeyMap(el);
  }

  return data.keyMap;
};

/**
 * Retrieves a child from the parent with the given key.
 * @param {?Node} parent
 * @param {?string=} key
 * @return {?Node} The child corresponding to the key.
 */
var getChild = function (parent, key) {
  return key ? getKeyMap(parent)[key] : null;
};

/**
 * Registers an element as being a child. The parent will keep track of the
 * child using the key. The child can be retrieved using the same key using
 * getKeyMap. The provided key should be unique within the parent Element.
 * @param {?Node} parent The parent of child.
 * @param {string} key A key to identify the child with.
 * @param {!Node} child The child to register.
 */
var registerChild = function (parent, key, child) {
  getKeyMap(parent)[key] = child;
};

/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @const */
var notifications = {
  /**
   * Called after patch has compleated with any Nodes that have been created
   * and added to the DOM.
   * @type {?function(Array<!Node>)}
   */
  nodesCreated: null,

  /**
   * Called after patch has compleated with any Nodes that have been removed
   * from the DOM.
   * Note it's an applications responsibility to handle any childNodes.
   * @type {?function(Array<!Node>)}
   */
  nodesDeleted: null
};

/**
 * Keeps track of the state of a patch.
 * @constructor
 */
function Context() {
  /**
   * @type {(Array<!Node>|undefined)}
   */
  this.created = notifications.nodesCreated && [];

  /**
   * @type {(Array<!Node>|undefined)}
   */
  this.deleted = notifications.nodesDeleted && [];
}

/**
 * @param {!Node} node
 */
Context.prototype.markCreated = function (node) {
  if (this.created) {
    this.created.push(node);
  }
};

/**
 * @param {!Node} node
 */
Context.prototype.markDeleted = function (node) {
  if (this.deleted) {
    this.deleted.push(node);
  }
};

/**
 * Notifies about nodes that were created during the patch opearation.
 */
Context.prototype.notifyChanges = function () {
  if (this.created && this.created.length > 0) {
    notifications.nodesCreated(this.created);
  }

  if (this.deleted && this.deleted.length > 0) {
    notifications.nodesDeleted(this.deleted);
  }
};

/**
* Makes sure that keyed Element matches the tag name provided.
* @param {!string} nodeName The nodeName of the node that is being matched.
* @param {string=} tag The tag name of the Element.
* @param {?string=} key The key of the Element.
*/
var assertKeyedTagMatches = function (nodeName, tag, key) {
  if (nodeName !== tag) {
    throw new Error('Was expecting node with key "' + key + '" to be a ' + tag + ', not a ' + nodeName + '.');
  }
};

/** @type {?Context} */
var context = null;

/** @type {?Node} */
var currentNode = null;

/** @type {?Node} */
var currentParent = null;

/** @type {?Element|?DocumentFragment} */
var root = null;

/** @type {?Document} */
var doc = null;

/**
 * Returns a patcher function that sets up and restores a patch context,
 * running the run function with the provided data.
 * @param {function((!Element|!DocumentFragment),!function(T),T=)} run
 * @return {function((!Element|!DocumentFragment),!function(T),T=)}
 * @template T
 */
var patchFactory = function (run) {
  /**
   * TODO(moz): These annotations won't be necessary once we switch to Closure
   * Compiler's new type inference. Remove these once the switch is done.
   *
   * @param {(!Element|!DocumentFragment)} node
   * @param {!function(T)} fn
   * @param {T=} data
   * @template T
   */
  var f = function (node, fn, data) {
    var prevContext = context;
    var prevRoot = root;
    var prevDoc = doc;
    var prevCurrentNode = currentNode;
    var prevCurrentParent = currentParent;
    var previousInAttributes = false;
    var previousInSkip = false;

    context = new Context();
    root = node;
    doc = node.ownerDocument;
    currentParent = node.parentNode;

    run(node, fn, data);

    context.notifyChanges();

    context = prevContext;
    root = prevRoot;
    doc = prevDoc;
    currentNode = prevCurrentNode;
    currentParent = prevCurrentParent;
  };
  return f;
};

/**
 * Patches the document starting at node with the provided function. This
 * function may be called during an existing patch operation.
 * @param {!Element|!DocumentFragment} node The Element or Document
 *     to patch.
 * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.
 *     calls that describe the DOM.
 * @param {T=} data An argument passed to fn to represent DOM state.
 * @template T
 */
var patchInner = patchFactory(function (node, fn, data) {
  currentNode = node;

  enterNode();
  fn(data);
  exitNode();

  
});

/**
 * Patches an Element with the the provided function. Exactly one top level
 * element call should be made corresponding to `node`.
 * @param {!Element} node The Element where the patch should start.
 * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.
 *     calls that describe the DOM. This should have at most one top level
 *     element call.
 * @param {T=} data An argument passed to fn to represent DOM state.
 * @template T
 */
var patchOuter = patchFactory(function (node, fn, data) {
  currentNode = /** @type {!Element} */{ nextSibling: node };

  fn(data);

  
});

/**
 * Checks whether or not the current node matches the specified nodeName and
 * key.
 *
 * @param {?string} nodeName The nodeName for this node.
 * @param {?string=} key An optional key that identifies a node.
 * @return {boolean} True if the node matches, false otherwise.
 */
var matches = function (nodeName, key) {
  var data = getData(currentNode);

  // Key check is done using double equals as we want to treat a null key the
  // same as undefined. This should be okay as the only values allowed are
  // strings, null and undefined so the == semantics are not too weird.
  return nodeName === data.nodeName && key == data.key;
};

/**
 * Aligns the virtual Element definition with the actual DOM, moving the
 * corresponding DOM node to the correct location or creating it if necessary.
 * @param {string} nodeName For an Element, this should be a valid tag string.
 *     For a Text, this should be #text.
 * @param {?string=} key The key used to identify this element.
 * @param {?Array<*>=} statics For an Element, this should be an array of
 *     name-value pairs.
 */
var alignWithDOM = function (nodeName, key, statics) {
  if (currentNode && matches(nodeName, key)) {
    return;
  }

  var node = undefined;

  // Check to see if the node has moved within the parent.
  if (key) {
    node = getChild(currentParent, key);
    if (node && 'production' !== 'production') {
      assertKeyedTagMatches(getData(node).nodeName, nodeName, key);
    }
  }

  // Create the node if it doesn't exist.
  if (!node) {
    if (nodeName === '#text') {
      node = createText(doc);
    } else {
      node = createElement(doc, currentParent, nodeName, key, statics);
    }

    if (key) {
      registerChild(currentParent, key, node);
    }

    context.markCreated(node);
  }

  // If the node has a key, remove it from the DOM to prevent a large number
  // of re-orders in the case that it moved far or was completely removed.
  // Since we hold on to a reference through the keyMap, we can always add it
  // back.
  if (currentNode && getData(currentNode).key) {
    currentParent.replaceChild(node, currentNode);
    getData(currentParent).keyMapValid = false;
  } else {
    currentParent.insertBefore(node, currentNode);
  }

  currentNode = node;
};

/**
 * Clears out any unvisited Nodes, as the corresponding virtual element
 * functions were never called for them.
 */
var clearUnvisitedDOM = function () {
  var node = currentParent;
  var data = getData(node);
  var keyMap = data.keyMap;
  var keyMapValid = data.keyMapValid;
  var child = node.lastChild;
  var key = undefined;

  if (child === currentNode && keyMapValid) {
    return;
  }

  if (data.attrs[symbols.placeholder] && node !== root) {
    return;
  }

  while (child !== currentNode) {
    node.removeChild(child);
    context.markDeleted( /** @type {!Node}*/child);

    key = getData(child).key;
    if (key) {
      delete keyMap[key];
    }
    child = node.lastChild;
  }

  // Clean the keyMap, removing any unusued keys.
  if (!keyMapValid) {
    for (key in keyMap) {
      child = keyMap[key];
      if (child.parentNode !== node) {
        context.markDeleted(child);
        delete keyMap[key];
      }
    }

    data.keyMapValid = true;
  }
};

/**
 * Changes to the first child of the current node.
 */
var enterNode = function () {
  currentParent = currentNode;
  currentNode = null;
};

/**
 * Changes to the next sibling of the current node.
 */
var nextNode = function () {
  if (currentNode) {
    currentNode = currentNode.nextSibling;
  } else {
    currentNode = currentParent.firstChild;
  }
};

/**
 * Changes to the parent of the current node, removing any unvisited children.
 */
var exitNode = function () {
  clearUnvisitedDOM();

  currentNode = currentParent;
  currentParent = currentParent.parentNode;
};

/**
 * Makes sure that the current node is an Element with a matching tagName and
 * key.
 *
 * @param {string} tag The element's tag.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 * @return {!Element} The corresponding Element.
 */
var coreElementOpen = function (tag, key, statics) {
  nextNode();
  alignWithDOM(tag, key, statics);
  enterNode();
  return (/** @type {!Element} */currentParent
  );
};

/**
 * Closes the currently open Element, removing any unvisited children if
 * necessary.
 *
 * @return {!Element} The corresponding Element.
 */
var coreElementClose = function () {
  exitNode();
  return (/** @type {!Element} */currentNode
  );
};

/**
 * Makes sure the current node is a Text node and creates a Text node if it is
 * not.
 *
 * @return {!Text} The corresponding Text Node.
 */
var coreText = function () {
  nextNode();
  alignWithDOM('#text', null, null);
  return (/** @type {!Text} */currentNode
  );
};

/**
 * Gets the current Element being patched.
 * @return {!Element}
 */
var currentElement = function () {
  return (/** @type {!Element} */currentParent
  );
};

/**
 * Skips the children in a subtree, allowing an Element to be closed without
 * clearing out the children.
 */
var skip = function () {
  currentNode = currentParent.lastChild;
};

/**
 * The offset in the virtual element declaration where the attributes are
 * specified.
 * @const
 */
var ATTRIBUTES_OFFSET = 3;

/**
 * Builds an array of arguments for use with elementOpenStart, attr and
 * elementOpenEnd.
 * @const {Array<*>}
 */
var argsBuilder = [];

/**
 * @param {string} tag The element's tag.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 * @param {...*} const_args Attribute name/value pairs of the dynamic attributes
 *     for the Element.
 * @return {!Element} The corresponding Element.
 */
var elementOpen = function (tag, key, statics, const_args) {
  var node = coreElementOpen(tag, key, statics);
  var data = getData(node);

  /*
   * Checks to see if one or more attributes have changed for a given Element.
   * When no attributes have changed, this is much faster than checking each
   * individual argument. When attributes have changed, the overhead of this is
   * minimal.
   */
  var attrsArr = data.attrsArr;
  var newAttrs = data.newAttrs;
  var attrsChanged = false;
  var i = ATTRIBUTES_OFFSET;
  var j = 0;

  for (; i < arguments.length; i += 1, j += 1) {
    if (attrsArr[j] !== arguments[i]) {
      attrsChanged = true;
      break;
    }
  }

  for (; i < arguments.length; i += 1, j += 1) {
    attrsArr[j] = arguments[i];
  }

  if (j < attrsArr.length) {
    attrsChanged = true;
    attrsArr.length = j;
  }

  /*
   * Actually perform the attribute update.
   */
  if (attrsChanged) {
    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {
      newAttrs[arguments[i]] = arguments[i + 1];
    }

    for (var _attr in newAttrs) {
      updateAttribute(node, _attr, newAttrs[_attr]);
      newAttrs[_attr] = undefined;
    }
  }

  return node;
};

/**
 * Declares a virtual Element at the current location in the document. This
 * corresponds to an opening tag and a elementClose tag is required. This is
 * like elementOpen, but the attributes are defined using the attr function
 * rather than being passed as arguments. Must be folllowed by 0 or more calls
 * to attr, then a call to elementOpenEnd.
 * @param {string} tag The element's tag.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 */
var elementOpenStart = function (tag, key, statics) {
  argsBuilder[0] = tag;
  argsBuilder[1] = key;
  argsBuilder[2] = statics;
};

/***
 * Defines a virtual attribute at this point of the DOM. This is only valid
 * when called between elementOpenStart and elementOpenEnd.
 *
 * @param {string} name
 * @param {*} value
 */
var attr = function (name, value) {
  argsBuilder.push(name, value);
};

/**
 * Closes an open tag started with elementOpenStart.
 * @return {!Element} The corresponding Element.
 */
var elementOpenEnd = function () {
  var node = elementOpen.apply(null, argsBuilder);
  argsBuilder.length = 0;
  return node;
};

/**
 * Closes an open virtual Element.
 *
 * @param {string} tag The element's tag.
 * @return {!Element} The corresponding Element.
 */
var elementClose = function (tag) {
  var node = coreElementClose();

  return node;
};

/**
 * Declares a virtual Element at the current location in the document that has
 * no children.
 * @param {string} tag The element's tag.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 * @param {...*} const_args Attribute name/value pairs of the dynamic attributes
 *     for the Element.
 * @return {!Element} The corresponding Element.
 */
var elementVoid = function (tag, key, statics, const_args) {
  elementOpen.apply(null, arguments);
  return elementClose(tag);
};

/**
 * Declares a virtual Element at the current location in the document that is a
 * placeholder element. Children of this Element can be manually managed and
 * will not be cleared by the library.
 *
 * A key must be specified to make sure that this node is correctly preserved
 * across all conditionals.
 *
 * @param {string} tag The element's tag.
 * @param {string} key The key used to identify this element.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 * @param {...*} const_args Attribute name/value pairs of the dynamic attributes
 *     for the Element.
 * @return {!Element} The corresponding Element.
 */
var elementPlaceholder = function (tag, key, statics, const_args) {
  elementOpen.apply(null, arguments);
  skip();
  return elementClose(tag);
};

/**
 * Declares a virtual Text at this point in the document.
 *
 * @param {string|number|boolean} value The value of the Text.
 * @param {...(function((string|number|boolean)):string)} const_args
 *     Functions to format the value which are called only when the value has
 *     changed.
 * @return {!Text} The corresponding text node.
 */
var text = function (value, const_args) {
  var node = coreText();
  var data = getData(node);

  if (data.text !== value) {
    data.text = /** @type {string} */value;

    var formatted = value;
    for (var i = 1; i < arguments.length; i += 1) {
      /*
       * Call the formatter function directly to prevent leaking arguments.
       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574
       */
      var fn = arguments[i];
      formatted = fn(formatted);
    }

    node.data = formatted;
  }

  return node;
};

var patch = patchInner;
var patchInner_1 = patchInner;
var patchOuter_1 = patchOuter;
var currentElement_1 = currentElement;
var skip_1 = skip;
var elementVoid_1 = elementVoid;
var elementOpenStart_1 = elementOpenStart;
var elementOpenEnd_1 = elementOpenEnd;
var elementOpen_1 = elementOpen;
var elementClose_1 = elementClose;
var elementPlaceholder_1 = elementPlaceholder;
var text_1 = text;
var attr_1 = attr;
var symbols_1 = symbols;
var attributes_1 = attributes;
var applyAttr_1 = applyAttr;
var applyProp_1 = applyProp;
var notifications_1 = notifications;



var incrementalDomCjs = {
  patch: patch,
  patchInner: patchInner_1,
  patchOuter: patchOuter_1,
  currentElement: currentElement_1,
  skip: skip_1,
  elementVoid: elementVoid_1,
  elementOpenStart: elementOpenStart_1,
  elementOpenEnd: elementOpenEnd_1,
  elementOpen: elementOpen_1,
  elementClose: elementClose_1,
  elementPlaceholder: elementPlaceholder_1,
  text: text_1,
  attr: attr_1,
  symbols: symbols_1,
  attributes: attributes_1,
  applyAttr: applyAttr_1,
  applyProp: applyProp_1,
  notifications: notifications_1
};

var index$2 = createCommonjsModule(function (module, exports) {
  (function webpackUniversalModuleDefinition(root, factory) {
    module.exports = factory(incrementalDomCjs);
  })(commonjsGlobal, function (__WEBPACK_EXTERNAL_MODULE_14__) {
    return (/******/function (modules) {
        // webpackBootstrap
        /******/ // The module cache
        /******/var installedModules = {};

        /******/ // The require function
        /******/function __webpack_require__(moduleId) {

          /******/ // Check if module is in cache
          /******/if (installedModules[moduleId])
            /******/return installedModules[moduleId].exports;

          /******/ // Create a new module (and put it into the cache)
          /******/var module = installedModules[moduleId] = {
            /******/i: moduleId,
            /******/l: false,
            /******/exports: {}
            /******/ };

          /******/ // Execute the module function
          /******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

          /******/ // Flag the module as loaded
          /******/module.l = true;

          /******/ // Return the exports of the module
          /******/return module.exports;
          /******/
        }

        /******/ // expose the modules object (__webpack_modules__)
        /******/__webpack_require__.m = modules;

        /******/ // expose the module cache
        /******/__webpack_require__.c = installedModules;

        /******/ // identity function for calling harmony imports with the correct context
        /******/__webpack_require__.i = function (value) {
          return value;
        };

        /******/ // define getter function for harmony exports
        /******/__webpack_require__.d = function (exports, name, getter) {
          /******/if (!__webpack_require__.o(exports, name)) {
            /******/Object.defineProperty(exports, name, {
              /******/configurable: false,
              /******/enumerable: true,
              /******/get: getter
              /******/ });
            /******/
          }
          /******/
        };

        /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/__webpack_require__.n = function (module) {
          /******/var getter = module && module.__esModule ?
          /******/function getDefault() {
            return module['default'];
          } :
          /******/function getModuleExports() {
            return module;
          };
          /******/__webpack_require__.d(getter, 'a', getter);
          /******/return getter;
          /******/
        };

        /******/ // Object.prototype.hasOwnProperty.call
        /******/__webpack_require__.o = function (object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };

        /******/ // __webpack_public_path__
        /******/__webpack_require__.p = "";

        /******/ // Load entry module and return exports
        /******/return __webpack_require__(__webpack_require__.s = 38);
        /******/
      }(
      /************************************************************************/
      /******/[
      /* 0 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony export (binding) */
        __webpack_require__.d(__webpack_exports__, "j", function () {
          return connected;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "c", function () {
          return created;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "b", function () {
          return name;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "h", function () {
          return ctorCreateInitProps;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "f", function () {
          return ctorObservedAttributes;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "g", function () {
          return ctorProps;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "e", function () {
          return ctorPropsMap;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "m", function () {
          return props;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "a", function () {
          return ref;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "d", function () {
          return renderer;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "k", function () {
          return rendering;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "i", function () {
          return rendererDebounced;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "l", function () {
          return updated;
        });
        var connected = '____skate_connected';
        var created = '____skate_created';

        // DEPRECATED
        //
        // This is the only "symbol" that must stay a string. This is because it is
        // relied upon across several versions. We should remove it, but ensure that
        // it's considered a breaking change that whatever version removes it cannot
        // be passed to vdom functions as tag names.
        var name = '____skate_name';

        // Used on the Constructor
        var ctorCreateInitProps = '____skate_ctor_createInitProps';
        var ctorObservedAttributes = '____skate_ctor_observedAttributes';
        var ctorProps = '____skate_ctor_props';
        var ctorPropsMap = '____skate_ctor_propsMap';

        // Used on the Element
        var props = '____skate_props';
        var ref = '____skate_ref';
        var renderer = '____skate_renderer';
        var rendering = '____skate_rendering';
        var rendererDebounced = '____skate_rendererDebounced';
        var updated = '____skate_updated';

        /***/
      },
      /* 1 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__is_type__ = __webpack_require__(2);
        /* harmony export (immutable) */__webpack_exports__["a"] = getPropNamesAndSymbols;

        /**
         * Returns array of owned property names and symbols for the given object
         */
        function getPropNamesAndSymbols() {
          var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          var listOfKeys = Object.getOwnPropertyNames(obj);
          return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__is_type__["a" /* isFunction */])(Object.getOwnPropertySymbols) ? listOfKeys.concat(Object.getOwnPropertySymbols(obj)) : listOfKeys;
        }

        /***/
      },
      /* 2 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony export (binding) */
        __webpack_require__.d(__webpack_exports__, "a", function () {
          return isFunction;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "c", function () {
          return isObject;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "e", function () {
          return isString;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "d", function () {
          return isSymbol;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "b", function () {
          return isUndefined;
        });
        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
          return typeof obj;
        } : function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };

        var isFunction = function isFunction(val) {
          return typeof val === 'function';
        };
        var isObject = function isObject(val) {
          return (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val !== null;
        };
        var isString = function isString(val) {
          return typeof val === 'string';
        };
        var isSymbol = function isSymbol(val) {
          return (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'symbol';
        };
        var isUndefined = function isUndefined(val) {
          return typeof val === 'undefined';
        };

        /***/
      },
      /* 3 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* WEBPACK VAR INJECTION */
        (function (global) {
          /* harmony default export */__webpack_exports__["a"] = typeof window === 'undefined' ? global : window;
          /* WEBPACK VAR INJECTION */
        }).call(__webpack_exports__, __webpack_require__(37));

        /***/
      },
      /* 4 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__get_prop_names_and_symbols__ = __webpack_require__(1);

        // We are not using Object.assign if it is defined since it will cause problems when Symbol is polyfilled.
        // Apparently Object.assign (or any polyfill for this method) does not copy non-native Symbols.
        /* harmony default export */__webpack_exports__["a"] = function (obj) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          args.forEach(function (arg) {
            return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__get_prop_names_and_symbols__["a" /* default */])(arg).forEach(function (nameOrSymbol) {
              return obj[nameOrSymbol] = arg[nameOrSymbol];
            });
          }); // eslint-disable-line no-return-assign
          return obj;
        };

        /***/
      },
      /* 5 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony default export */
        __webpack_exports__["a"] = function (element) {
          var namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

          var data = element.__SKATE_DATA || (element.__SKATE_DATA = {});
          return namespace && (data[namespace] || (data[namespace] = {})) || data; // eslint-disable-line no-mixed-operators
        };

        /***/
      },
      /* 6 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony default export */
        __webpack_exports__["a"] = function (val) {
          return typeof val === 'undefined' || val === null;
        };

        /***/
      },
      /* 7 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__util_symbols__ = __webpack_require__(0);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__util_assign__ = __webpack_require__(4);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__util_get_prop_names_and_symbols__ = __webpack_require__(1);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__util_get_props_map__ = __webpack_require__(10);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__util_is_type__ = __webpack_require__(2);

        function get(elem) {
          var props = {};

          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util_get_prop_names_and_symbols__["a" /* default */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__util_get_props_map__["a" /* default */])(elem.constructor)).forEach(function (nameOrSymbol) {
            props[nameOrSymbol] = elem[nameOrSymbol];
          });

          return props;
        }

        function set(elem, newProps) {
          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util_assign__["a" /* default */])(elem, newProps);
          if (elem[__WEBPACK_IMPORTED_MODULE_0__util_symbols__["d" /* renderer */]]) {
            elem[__WEBPACK_IMPORTED_MODULE_0__util_symbols__["d" /* renderer */]]();
          }
        }

        /* harmony default export */__webpack_exports__["a"] = function (elem, newProps) {
          return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__util_is_type__["b" /* isUndefined */])(newProps) ? get(elem) : set(elem, newProps);
        };

        /***/
      },
      /* 8 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* WEBPACK VAR INJECTION */
        (function (process) {
          /* harmony import */var __WEBPACK_IMPORTED_MODULE_0_incremental_dom__ = __webpack_require__(14);
          /* harmony import */var __WEBPACK_IMPORTED_MODULE_0_incremental_dom___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_incremental_dom__);
          /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__util_symbols__ = __webpack_require__(0);
          /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__util_assign__ = __webpack_require__(4);
          /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__util_create_symbol__ = __webpack_require__(25);
          /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__util_data__ = __webpack_require__(5);
          /* harmony import */var __WEBPACK_IMPORTED_MODULE_5__util_debounce__ = __webpack_require__(27);
          /* harmony import */var __WEBPACK_IMPORTED_MODULE_6__util_attributes_manager__ = __webpack_require__(9);
          /* harmony import */var __WEBPACK_IMPORTED_MODULE_7__util_get_own_property_descriptors__ = __webpack_require__(31);
          /* harmony import */var __WEBPACK_IMPORTED_MODULE_8__util_get_prop_names_and_symbols__ = __webpack_require__(1);
          /* harmony import */var __WEBPACK_IMPORTED_MODULE_9__util_get_props_map__ = __webpack_require__(10);
          /* harmony import */var __WEBPACK_IMPORTED_MODULE_10__props__ = __webpack_require__(7);
          /* harmony import */var __WEBPACK_IMPORTED_MODULE_11__lifecycle_props_init__ = __webpack_require__(23);
          /* harmony import */var __WEBPACK_IMPORTED_MODULE_12__util_is_type__ = __webpack_require__(2);
          /* harmony import */var __WEBPACK_IMPORTED_MODULE_13__polyfills_object_is__ = __webpack_require__(24);
          /* harmony import */var __WEBPACK_IMPORTED_MODULE_14__util_set_ctor_native_property__ = __webpack_require__(11);
          /* harmony import */var __WEBPACK_IMPORTED_MODULE_15__util_root__ = __webpack_require__(3);
          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
              }
            }return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
            };
          }();

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;if (getter === undefined) {
                return undefined;
              }return getter.call(receiver);
            }
          };

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          var HTMLElement = __WEBPACK_IMPORTED_MODULE_15__util_root__["a" /* default */].HTMLElement || function () {
            function _class() {
              _classCallCheck(this, _class);
            }

            return _class;
          }();
          var _prevName = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__util_create_symbol__["a" /* default */])('prevName');
          var _prevOldValue = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__util_create_symbol__["a" /* default */])('prevOldValue');
          var _prevNewValue = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__util_create_symbol__["a" /* default */])('prevNewValue');

          // TEMPORARY: Once deprecations in this file are removed, this can be removed.
          function deprecated(elem, oldUsage, newUsage) {
            if (process.env.NODE_ENV !== 'production') {
              var ownerName = elem.localName ? elem.localName : String(elem);
              console.warn(ownerName + ' ' + oldUsage + ' is deprecated. Use ' + newUsage + '.');
            }
          }

          function preventDoubleCalling(elem, name, oldValue, newValue) {
            return name === elem[_prevName] && oldValue === elem[_prevOldValue] && newValue === elem[_prevNewValue];
          }

          // TODO remove when not catering to Safari < 10.
          function createNativePropertyDescriptors(Ctor) {
            var propDefs = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__util_get_props_map__["a" /* default */])(Ctor);
            return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__util_get_prop_names_and_symbols__["a" /* default */])(propDefs).reduce(function (propDescriptors, nameOrSymbol) {
              propDescriptors[nameOrSymbol] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11__lifecycle_props_init__["a" /* createNativePropertyDescriptor */])(propDefs[nameOrSymbol]);
              return propDescriptors;
            }, {});
          }

          // TODO refactor when not catering to Safari < 10.
          //
          // We should be able to simplify this where all we do is Object.defineProperty().
          function createInitProps(Ctor) {
            var propDescriptors = createNativePropertyDescriptors(Ctor);

            return function (elem) {
              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__util_get_prop_names_and_symbols__["a" /* default */])(propDescriptors).forEach(function (nameOrSymbol) {
                var propDescriptor = propDescriptors[nameOrSymbol];
                propDescriptor.beforeDefineProperty(elem);

                // We check here before defining to see if the prop was specified prior
                // to upgrading.
                var hasPropBeforeUpgrading = nameOrSymbol in elem;

                // This is saved prior to defining so that we can set it after it it was
                // defined prior to upgrading. We don't want to invoke the getter if we
                // don't need to, so we only get the value if we need to re-sync.
                var valueBeforeUpgrading = hasPropBeforeUpgrading && elem[nameOrSymbol];

                // https://bugs.webkit.org/show_bug.cgi?id=49739
                //
                // When Webkit fixes that bug so that native property accessors can be
                // retrieved, we can move defining the property to the prototype and away
                // from having to do if for every instance as all other browsers support
                // this.
                Object.defineProperty(elem, nameOrSymbol, propDescriptor);

                // DEPRECATED
                //
                // We'll be removing get / set callbacks on properties. Use the
                // updatedCallback() instead.
                //
                // We re-set the prop if it was specified prior to upgrading because we
                // need to ensure set() is triggered both in polyfilled environments and
                // in native where the definition may be registerd after elements it
                // represents have already been created.
                if (hasPropBeforeUpgrading) {
                  elem[nameOrSymbol] = valueBeforeUpgrading;
                }
              });
            };
          }

          var _class2 = function (_HTMLElement) {
            _inherits(_class2, _HTMLElement);

            _createClass(_class2, null, [{
              key: 'observedAttributes',

              /**
               * Returns unique attribute names configured with props and
               * those set on the Component constructor if any
               */
              get: function get() {
                var attrsOnCtor = this.hasOwnProperty(__WEBPACK_IMPORTED_MODULE_1__util_symbols__["f" /* ctorObservedAttributes */]) ? this[__WEBPACK_IMPORTED_MODULE_1__util_symbols__["f" /* ctorObservedAttributes */]] : [];
                var propDefs = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__util_get_props_map__["a" /* default */])(this);

                // Use Object.keys to skips symbol props since they have no linked attributes
                var attrsFromLinkedProps = Object.keys(propDefs).map(function (propName) {
                  return propDefs[propName].attrSource;
                }).filter(Boolean);

                var all = attrsFromLinkedProps.concat(attrsOnCtor).concat(_get(_class2.__proto__ || Object.getPrototypeOf(_class2), 'observedAttributes', this));
                return all.filter(function (item, index) {
                  return all.indexOf(item) === index;
                });
              },
              set: function set(value) {
                value = Array.isArray(value) ? value : [];
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__util_set_ctor_native_property__["a" /* default */])(this, 'observedAttributes', value);
              }

              // Returns superclass props overwritten with this Component props

            }, {
              key: 'props',
              get: function get() {
                return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util_assign__["a" /* default */])({}, _get(_class2.__proto__ || Object.getPrototypeOf(_class2), 'props', this), this[__WEBPACK_IMPORTED_MODULE_1__util_symbols__["g" /* ctorProps */]]);
              },
              set: function set(value) {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__util_set_ctor_native_property__["a" /* default */])(this, __WEBPACK_IMPORTED_MODULE_1__util_symbols__["g" /* ctorProps */], value);
              }

              // Passing args is designed to work with document-register-element. It's not
              // necessary for the webcomponents/custom-element polyfill.

            }]);

            function _class2() {
              var _ref;

              _classCallCheck(this, _class2);

              for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              var _this = _possibleConstructorReturn(this, (_ref = _class2.__proto__ || Object.getPrototypeOf(_class2)).call.apply(_ref, [this].concat(args)));

              var constructor = _this.constructor;

              // Used for the ready() function so it knows when it can call its callback.

              _this[__WEBPACK_IMPORTED_MODULE_1__util_symbols__["c" /* created */]] = true;

              // TODO refactor to not cater to Safari < 10. This means we can depend on
              // built-in property descriptors.
              // Must be defined on constructor and not from a superclass
              if (!constructor.hasOwnProperty(__WEBPACK_IMPORTED_MODULE_1__util_symbols__["h" /* ctorCreateInitProps */])) {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__util_set_ctor_native_property__["a" /* default */])(constructor, __WEBPACK_IMPORTED_MODULE_1__util_symbols__["h" /* ctorCreateInitProps */], createInitProps(constructor));
              }

              // Set up a renderer that is debounced for property sets to call directly.
              _this[__WEBPACK_IMPORTED_MODULE_1__util_symbols__["i" /* rendererDebounced */]] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__util_debounce__["a" /* default */])(_this[__WEBPACK_IMPORTED_MODULE_1__util_symbols__["d" /* renderer */]].bind(_this));

              // Set up property lifecycle.
              var propDefsCount = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__util_get_prop_names_and_symbols__["a" /* default */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__util_get_props_map__["a" /* default */])(constructor)).length;
              if (propDefsCount && constructor[__WEBPACK_IMPORTED_MODULE_1__util_symbols__["h" /* ctorCreateInitProps */]]) {
                constructor[__WEBPACK_IMPORTED_MODULE_1__util_symbols__["h" /* ctorCreateInitProps */]](_this);
              }

              // DEPRECATED
              //
              // static render()
              // Note that renderCallback is an optional method!
              if (!_this.renderCallback && constructor.render) {
                deprecated(_this, 'static render', 'renderCallback');
                _this.renderCallback = constructor.render.bind(constructor, _this);
              }

              // DEPRECATED
              //
              // static created()
              //
              // Props should be set up before calling this.
              var created = constructor.created;

              if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12__util_is_type__["a" /* isFunction */])(created)) {
                deprecated(_this, 'static created', 'constructor');
                created(_this);
              }

              // DEPRECATED
              //
              // Feature has rarely been used.
              //
              // Created should be set before invoking the ready listeners.
              var elemData = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__util_data__["a" /* default */])(_this);
              var readyCallbacks = elemData.readyCallbacks;
              if (readyCallbacks) {
                readyCallbacks.forEach(function (cb) {
                  return cb(_this);
                });
                delete elemData.readyCallbacks;
              }
              return _this;
            }

            // Custom Elements v1


            _createClass(_class2, [{
              key: 'connectedCallback',
              value: function connectedCallback() {
                // Reflect attributes pending values
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__util_attributes_manager__["a" /* default */])(this).resumeAttributesUpdates();

                // Used to check whether or not the component can render.
                this[__WEBPACK_IMPORTED_MODULE_1__util_symbols__["j" /* connected */]] = true;

                // Render!
                this[__WEBPACK_IMPORTED_MODULE_1__util_symbols__["i" /* rendererDebounced */]]();

                // DEPRECATED
                //
                // static attached()
                var attached = this.constructor.attached;

                if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12__util_is_type__["a" /* isFunction */])(attached)) {
                  deprecated(this, 'static attached', 'connectedCallback');
                  attached(this);
                }

                // DEPRECATED
                //
                // We can remove this once all browsers support :defined.
                this.setAttribute('defined', '');
              }

              // Custom Elements v1

            }, {
              key: 'disconnectedCallback',
              value: function disconnectedCallback() {
                // Suspend updating attributes until re-connected
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__util_attributes_manager__["a" /* default */])(this).suspendAttributesUpdates();

                // Ensures the component can't be rendered while disconnected.
                this[__WEBPACK_IMPORTED_MODULE_1__util_symbols__["j" /* connected */]] = false;

                // DEPRECATED
                //
                // static detached()
                var detached = this.constructor.detached;

                if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12__util_is_type__["a" /* isFunction */])(detached)) {
                  deprecated(this, 'static detached', 'disconnectedCallback');
                  detached(this);
                }
              }

              // Custom Elements v1

            }, {
              key: 'attributeChangedCallback',
              value: function attributeChangedCallback(name, oldValue, newValue) {
                // Polyfill calls this twice.
                if (preventDoubleCalling(this, name, oldValue, newValue)) {
                  return;
                }

                // Set data so we can prevent double calling if the polyfill.
                this[_prevName] = name;
                this[_prevOldValue] = oldValue;
                this[_prevNewValue] = newValue;

                var propNameOrSymbol = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__util_data__["a" /* default */])(this, 'attrSourceLinks')[name];
                if (propNameOrSymbol) {
                  var changedExternally = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__util_attributes_manager__["a" /* default */])(this).onAttributeChanged(name, newValue);
                  if (changedExternally) {
                    // Sync up the property.
                    var propDef = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__util_get_props_map__["a" /* default */])(this.constructor)[propNameOrSymbol];
                    var newPropVal = newValue !== null && propDef.deserialize ? propDef.deserialize(newValue) : newValue;

                    var propData = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__util_data__["a" /* default */])(this, 'props')[propNameOrSymbol];
                    propData.settingPropFromAttrSource = true;
                    this[propNameOrSymbol] = newPropVal;
                    propData.settingPropFromAttrSource = false;
                  }
                }

                // DEPRECATED
                //
                // static attributeChanged()
                var attributeChanged = this.constructor.attributeChanged;

                if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12__util_is_type__["a" /* isFunction */])(attributeChanged)) {
                  deprecated(this, 'static attributeChanged', 'attributeChangedCallback');
                  attributeChanged(this, { name: name, newValue: newValue, oldValue: oldValue });
                }
              }

              // Skate

            }, {
              key: 'updatedCallback',
              value: function updatedCallback(prevProps) {
                if (this.constructor.hasOwnProperty('updated')) {
                  deprecated(this, 'static updated', 'updatedCallback');
                }
                return this.constructor.updated(this, prevProps);
              }

              // Skate

            }, {
              key: 'renderedCallback',
              value: function renderedCallback() {
                if (this.constructor.hasOwnProperty('rendered')) {
                  deprecated(this, 'static rendered', 'renderedCallback');
                }
                return this.constructor.rendered(this);
              }

              // Skate
              //
              // Maps to the static renderer() callback. That logic should be moved here
              // when that is finally removed.
              // TODO: finalize how to support different rendering strategies.

            }, {
              key: 'rendererCallback',
              value: function rendererCallback() {
                // TODO: cannot move code here because tests expects renderer function to still exist on constructor!
                return this.constructor.renderer(this);
              }

              // Skate
              // @internal
              // Invokes the complete render lifecycle.

            }, {
              key: __WEBPACK_IMPORTED_MODULE_1__util_symbols__["d" /* renderer */],
              value: function value() {
                if (this[__WEBPACK_IMPORTED_MODULE_1__util_symbols__["k" /* rendering */]] || !this[__WEBPACK_IMPORTED_MODULE_1__util_symbols__["j" /* connected */]]) {
                  return;
                }

                // Flag as rendering. This prevents anything from trying to render - or
                // queueing a render - while there is a pending render.
                this[__WEBPACK_IMPORTED_MODULE_1__util_symbols__["k" /* rendering */]] = true;
                if (this[__WEBPACK_IMPORTED_MODULE_1__util_symbols__["l" /* updated */]]() && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12__util_is_type__["a" /* isFunction */])(this.renderCallback)) {
                  this.rendererCallback();
                  this.renderedCallback();
                }

                this[__WEBPACK_IMPORTED_MODULE_1__util_symbols__["k" /* rendering */]] = false;
              }

              // Skate
              // @internal
              // Calls the updatedCallback() with previous props.

            }, {
              key: __WEBPACK_IMPORTED_MODULE_1__util_symbols__["l" /* updated */],
              value: function value() {
                var prevProps = this[__WEBPACK_IMPORTED_MODULE_1__util_symbols__["m" /* props */]];
                this[__WEBPACK_IMPORTED_MODULE_1__util_symbols__["m" /* props */]] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10__props__["a" /* default */])(this);
                return this.updatedCallback(prevProps);
              }

              // Skate

            }], [{
              key: 'extend',
              value: function extend() {
                var definition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                var Base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;

                // Create class for the user.
                var Ctor = function (_Base) {
                  _inherits(Ctor, _Base);

                  function Ctor() {
                    _classCallCheck(this, Ctor);

                    return _possibleConstructorReturn(this, (Ctor.__proto__ || Object.getPrototypeOf(Ctor)).apply(this, arguments));
                  }

                  return Ctor;
                }(Base);

                // For inheriting from the object literal.


                var opts = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__util_get_own_property_descriptors__["a" /* default */])(definition);
                var prot = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__util_get_own_property_descriptors__["a" /* default */])(definition.prototype);

                // Prototype is non configurable (but is writable).
                delete opts.prototype;

                // Pass on static and instance members from the definition.
                Object.defineProperties(Ctor, opts);
                Object.defineProperties(Ctor.prototype, prot);

                return Ctor;
              }

              // Skate
              //
              // DEPRECATED
              //
              // Stubbed in case any subclasses are calling it.

            }, {
              key: 'rendered',
              value: function rendered() {}

              // Skate
              //
              // DEPRECATED
              //
              // Move this to rendererCallback() before removing.

            }, {
              key: 'renderer',
              value: function renderer(elem) {
                if (!elem.shadowRoot) {
                  elem.attachShadow({ mode: 'open' });
                }
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_incremental_dom__["patchInner"])(elem.shadowRoot, function () {
                  var possibleFn = elem.renderCallback(elem);
                  if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12__util_is_type__["a" /* isFunction */])(possibleFn)) {
                    possibleFn();
                  } else if (Array.isArray(possibleFn)) {
                    possibleFn.forEach(function (fn) {
                      if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12__util_is_type__["a" /* isFunction */])(fn)) {
                        fn();
                      }
                    });
                  }
                });
              }

              // Skate
              //
              // DEPRECATED
              //
              // Move this to updatedCallback() before removing.

            }, {
              key: 'updated',
              value: function updated(elem, previousProps) {
                // The 'previousProps' will be undefined if it is the initial render.
                if (!previousProps) {
                  return true;
                }

                // The 'previousProps' will always contain all of the keys.
                //
                // Use classic loop because:
                // 'for ... in' skips symbols and 'for ... of' is not working yet with IE!?
                // for (let nameOrSymbol of getPropNamesAndSymbols(previousProps)) {
                var namesAndSymbols = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__util_get_prop_names_and_symbols__["a" /* default */])(previousProps);
                for (var i = 0; i < namesAndSymbols.length; i++) {
                  var nameOrSymbol = namesAndSymbols[i];

                  // With Object.is NaN is equal to NaN
                  if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_13__polyfills_object_is__["a" /* default */])(previousProps[nameOrSymbol], elem[nameOrSymbol])) {
                    return true;
                  }
                }

                return false;
              }
            }]);

            return _class2;
          }(HTMLElement);

          _class2.is = '';
          /* harmony default export */__webpack_exports__["a"] = _class2;
          /* WEBPACK VAR INJECTION */
        }).call(__webpack_exports__, __webpack_require__(13));

        /***/
      },
      /* 9 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__to_null_or_string__ = __webpack_require__(12);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__is_type__ = __webpack_require__(2);
        /* harmony export (immutable) */__webpack_exports__["a"] = getAttrMgr;
        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
          };
        }();

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        /**
         * @internal
         * Attributes Manager
         *
         * Postpones attributes updates until when connected.
         */

        var AttributesManager = function () {
          function AttributesManager(elem) {
            _classCallCheck(this, AttributesManager);

            this.elem = elem;
            this.connected = false;
            this.pendingValues = {};
            this.lastSetValues = {};
          }

          /**
           * Called from disconnectedCallback
           */

          _createClass(AttributesManager, [{
            key: 'suspendAttributesUpdates',
            value: function suspendAttributesUpdates() {
              this.connected = false;
            }

            /**
             * Called from connectedCallback
             */

          }, {
            key: 'resumeAttributesUpdates',
            value: function resumeAttributesUpdates() {
              var _this = this;

              this.connected = true;
              var names = Object.keys(this.pendingValues);
              names.forEach(function (name) {
                var value = _this.pendingValues[name];
                // Skip if already cleared
                if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__is_type__["b" /* isUndefined */])(value)) {
                  delete _this.pendingValues[name];
                  _this._syncAttrValue(name, value);
                }
              });
            }

            /**
             * Returns true if the value is different from the one set internally
             * using setAttrValue()
             */

          }, {
            key: 'onAttributeChanged',
            value: function onAttributeChanged(name, value) {
              value = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__to_null_or_string__["a" /* default */])(value);

              // A new attribute value voids the pending one
              this._clearPendingValue(name);

              var changed = this.lastSetValues[name] !== value;
              this.lastSetValues[name] = value;
              return changed;
            }

            /**
             * Updates or removes the attribute if value === null.
             *
             * When the component is not connected the value is saved and
             * the attribute is only updated when the component is re-connected.
             */

          }, {
            key: 'setAttrValue',
            value: function setAttrValue(name, value) {
              value = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__to_null_or_string__["a" /* default */])(value);

              this.lastSetValues[name] = value;

              if (this.connected) {
                this._clearPendingValue(name);
                this._syncAttrValue(name, value);
              } else {
                this.pendingValues[name] = value;
              }
            }
          }, {
            key: '_syncAttrValue',
            value: function _syncAttrValue(name, value) {
              var currAttrValue = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__to_null_or_string__["a" /* default */])(this.elem.getAttribute(name));
              if (value !== currAttrValue) {
                if (value === null) {
                  this.elem.removeAttribute(name);
                } else {
                  this.elem.setAttribute(name, value);
                }
              }
            }
          }, {
            key: '_clearPendingValue',
            value: function _clearPendingValue(name) {
              if (name in this.pendingValues) {
                delete this.pendingValues[name];
              }
            }
          }]);

          return AttributesManager;
        }();

        // Only used by getAttrMgr


        var $attributesMgr = '____skate_attributesMgr';

        /**
         * @internal
         * Returns attribute manager instance for the given Component
         */
        function getAttrMgr(elem) {
          var mgr = elem[$attributesMgr];
          if (!mgr) {
            mgr = new AttributesManager(elem);
            elem[$attributesMgr] = mgr;
          }
          return mgr;
        }

        /***/
      },
      /* 10 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__symbols__ = __webpack_require__(0);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__get_prop_names_and_symbols__ = __webpack_require__(1);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__prop_definition__ = __webpack_require__(35);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__set_ctor_native_property__ = __webpack_require__(11);
        /* harmony export (immutable) */__webpack_exports__["a"] = getPropsMap;

        /**
         * Memoizes a map of PropDefinition for the given component class.
         * Keys in the map are the properties name which can a string or a symbol.
         *
         * The map is created from the result of: static get props
         */
        function getPropsMap(Ctor) {
          // Must be defined on constructor and not from a superclass
          if (!Ctor.hasOwnProperty(__WEBPACK_IMPORTED_MODULE_0__symbols__["e" /* ctorPropsMap */])) {
            (function () {
              var props = Ctor.props || {};

              var propsMap = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__get_prop_names_and_symbols__["a" /* default */])(props).reduce(function (result, nameOrSymbol) {
                result[nameOrSymbol] = new __WEBPACK_IMPORTED_MODULE_2__prop_definition__["a" /* default */](nameOrSymbol, props[nameOrSymbol]);
                return result;
              }, {});
              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__set_ctor_native_property__["a" /* default */])(Ctor, __WEBPACK_IMPORTED_MODULE_0__symbols__["e" /* ctorPropsMap */], propsMap);
            })();
          }

          return Ctor[__WEBPACK_IMPORTED_MODULE_0__symbols__["e" /* ctorPropsMap */]];
        }

        /***/
      },
      /* 11 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony export (immutable) */
        __webpack_exports__["a"] = setCtorNativeProperty;
        /**
         * This is needed to avoid IE11 "stack size errors" when creating
         * a new property on the constructor of an HTMLElement
         */
        function setCtorNativeProperty(Ctor, propName, value) {
          Object.defineProperty(Ctor, propName, { configurable: true, value: value });
        }

        /***/
      },
      /* 12 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__empty__ = __webpack_require__(6);

        /**
         * Attributes value can only be null or string;
         */
        var toNullOrString = function toNullOrString(val) {
          return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__empty__["a" /* default */])(val) ? null : String(val);
        };

        /* harmony default export */__webpack_exports__["a"] = toNullOrString;

        /***/
      },
      /* 13 */
      /***/function (module, exports) {

        // shim for using process in browser
        var process = module.exports = {};

        // cached from whatever global is present so that test runners that stub it
        // don't break things.  But we need to wrap it in a try catch in case it is
        // wrapped in strict mode code which doesn't define any globals.  It's inside a
        // function because try/catches deoptimize in certain engines.

        var cachedSetTimeout;
        var cachedClearTimeout;

        function defaultSetTimout() {
          throw new Error('setTimeout has not been defined');
        }
        function defaultClearTimeout() {
          throw new Error('clearTimeout has not been defined');
        }
        (function () {
          try {
            if (typeof setTimeout === 'function') {
              cachedSetTimeout = setTimeout;
            } else {
              cachedSetTimeout = defaultSetTimout;
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout;
          }
          try {
            if (typeof clearTimeout === 'function') {
              cachedClearTimeout = clearTimeout;
            } else {
              cachedClearTimeout = defaultClearTimeout;
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
          }
        })();
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
          }
          // if setTimeout wasn't available but was latter defined
          if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
          }
          // if clearTimeout wasn't available but was latter defined
          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
            }
          }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;

        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue = currentQueue.concat(queue);
          } else {
            queueIndex = -1;
          }
          if (queue.length) {
            drainQueue();
          }
        }

        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout = runTimeout(cleanUpNextTick);
          draining = true;

          var len = queue.length;
          while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout);
        }

        process.nextTick = function (fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }
          queue.push(new Item(fun, args));
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };

        // v8 likes predictible objects
        function Item(fun, array) {
          this.fun = fun;
          this.array = array;
        }
        Item.prototype.run = function () {
          this.fun.apply(null, this.array);
        };
        process.title = 'browser';
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = ''; // empty string to avoid regexp issues
        process.versions = {};

        function noop() {}

        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;

        process.binding = function (name) {
          throw new Error('process.binding is not supported');
        };

        process.cwd = function () {
          return '/';
        };
        process.chdir = function (dir) {
          throw new Error('process.chdir is not supported');
        };
        process.umask = function () {
          return 0;
        };

        /***/
      },
      /* 14 */
      /***/function (module, exports) {

        module.exports = __WEBPACK_EXTERNAL_MODULE_14__;

        /***/
      },
      /* 15 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";

        Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__api_prop__ = __webpack_require__(19);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__api_symbols__ = __webpack_require__(21);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__api_vdom__ = __webpack_require__(22);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__api_component__ = __webpack_require__(8);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__api_define__ = __webpack_require__(16);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_5__api_emit__ = __webpack_require__(17);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_6__api_link__ = __webpack_require__(18);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_7__api_props__ = __webpack_require__(7);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_8__api_ready__ = __webpack_require__(20);
        /* harmony reexport (binding) */__webpack_require__.d(__webpack_exports__, "Component", function () {
          return __WEBPACK_IMPORTED_MODULE_3__api_component__["a"];
        });
        /* harmony reexport (binding) */__webpack_require__.d(__webpack_exports__, "define", function () {
          return __WEBPACK_IMPORTED_MODULE_4__api_define__["a"];
        });
        /* harmony reexport (binding) */__webpack_require__.d(__webpack_exports__, "emit", function () {
          return __WEBPACK_IMPORTED_MODULE_5__api_emit__["a"];
        });
        /* harmony reexport (binding) */__webpack_require__.d(__webpack_exports__, "link", function () {
          return __WEBPACK_IMPORTED_MODULE_6__api_link__["a"];
        });
        /* harmony reexport (module object) */__webpack_require__.d(__webpack_exports__, "prop", function () {
          return __WEBPACK_IMPORTED_MODULE_0__api_prop__;
        });
        /* harmony reexport (binding) */__webpack_require__.d(__webpack_exports__, "props", function () {
          return __WEBPACK_IMPORTED_MODULE_7__api_props__["a"];
        });
        /* harmony reexport (binding) */__webpack_require__.d(__webpack_exports__, "ready", function () {
          return __WEBPACK_IMPORTED_MODULE_8__api_ready__["a"];
        });
        /* harmony reexport (module object) */__webpack_require__.d(__webpack_exports__, "symbols", function () {
          return __WEBPACK_IMPORTED_MODULE_1__api_symbols__;
        });
        /* harmony reexport (module object) */__webpack_require__.d(__webpack_exports__, "vdom", function () {
          return __WEBPACK_IMPORTED_MODULE_2__api_vdom__;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "h", function () {
          return h;
        });

        var h = __WEBPACK_IMPORTED_MODULE_2__api_vdom__["builder"]();

        /***/
      },
      /* 16 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* WEBPACK VAR INJECTION */
        (function (process) {
          /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__component__ = __webpack_require__(8);
          /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__util_unique_id__ = __webpack_require__(36);
          /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__util_root__ = __webpack_require__(3);
          var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };

          /* harmony default export */__webpack_exports__["a"] = function () {
            var customElements = __WEBPACK_IMPORTED_MODULE_2__util_root__["a" /* default */].customElements,
                HTMLElement = __WEBPACK_IMPORTED_MODULE_2__util_root__["a" /* default */].HTMLElement;

            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            var name = args[0],
                Ctor = args[1];

            if (!customElements) {
              throw new Error('Skate requires native custom element support or a polyfill.');
            }

            // DEPRECATED remove when removing the "name" argument.
            if (process.env.NODE_ENV !== 'production' && args.length === 2) {
              console.warn('The "name" argument to define() is deprecated. Please define a `static is` property on the constructor instead.');
            }

            // DEPRECATED remove when removing the "name" argument.
            if (args.length === 1) {
              Ctor = name;
              name = null;
            }

            // DEPRECATED Object literals.
            if ((typeof Ctor === 'undefined' ? 'undefined' : _typeof(Ctor)) === 'object') {
              Ctor = __WEBPACK_IMPORTED_MODULE_0__component__["a" /* default */].extend(Ctor);
            }

            // Ensure a custom element is passed.
            if (!(Ctor.prototype instanceof HTMLElement)) {
              throw new Error('You must provide a constructor that extends HTMLElement to define().');
            }

            // DEPRECATED two arguments
            if (args.length === 2) {
              customElements.define(customElements.get(name) ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util_unique_id__["a" /* default */])(name) : name, Ctor);
            } else {
              // We must use hasOwnProperty() because we want to know if it was specified
              // directly on this class, not subclasses, as we don't want to inherit tag
              // names from subclasses.
              if (!Ctor.hasOwnProperty('is')) {
                // If we used defineProperty() then the consumer must also use it and
                // cannot use property initialisers. Instead we just set it so they can
                // use whatever method of overridding that they want.
                Ctor.is = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util_unique_id__["a" /* default */])();
              }
              customElements.define(Ctor.is, Ctor);
            }

            // The spec doesn't return but this allows for a simpler, more concise API.
            return Ctor;
          };
          /* WEBPACK VAR INJECTION */
        }).call(__webpack_exports__, __webpack_require__(13));

        /***/
      },
      /* 17 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__util_root__ = __webpack_require__(3);

        var Event = function (TheEvent) {
          if (TheEvent) {
            try {
              new TheEvent('emit-init'); // eslint-disable-line no-new
            } catch (e) {
              return undefined;
            }
          }
          return TheEvent;
        }(__WEBPACK_IMPORTED_MODULE_0__util_root__["a" /* default */].Event);

        function createCustomEvent(name) {
          var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var detail = opts.detail;

          delete opts.detail;

          var e = void 0;
          if (Event) {
            e = new Event(name, opts);
            Object.defineProperty(e, 'detail', { value: detail });
          } else {
            e = document.createEvent('CustomEvent');
            Object.defineProperty(e, 'composed', { value: opts.composed });
            e.initCustomEvent(name, opts.bubbles, opts.cancelable, detail);
          }
          return e;
        }

        /* harmony default export */__webpack_exports__["a"] = function (elem, name) {
          var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

          if (opts.bubbles === undefined) {
            opts.bubbles = true;
          }
          if (opts.cancelable === undefined) {
            opts.cancelable = true;
          }
          if (opts.composed === undefined) {
            opts.composed = true;
          }
          return elem.dispatchEvent(createCustomEvent(name, opts));
        };

        /***/
      },
      /* 18 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__props__ = __webpack_require__(7);
        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }return obj;
        }

        function getValue(elem) {
          var type = elem.type;
          if (type === 'checkbox' || type === 'radio') {
            return elem.checked ? elem.value || true : false;
          }
          return elem.value;
        }

        /* harmony default export */__webpack_exports__["a"] = function (elem, target) {
          return function (e) {
            // We fallback to checking the composed path. Unfortunately this behaviour
            // is difficult to impossible to reproduce as it seems to be a possible
            // quirk in the shadydom polyfill that incorrectly returns null for the
            // target but has the target as the first point in the path.
            // TODO revisit once all browsers have native support.
            var localTarget = e.target || e.composedPath()[0];
            var value = getValue(localTarget);
            var localTargetName = target || localTarget.name || 'value';

            if (localTargetName.indexOf('.') > -1) {
              var parts = localTargetName.split('.');
              var firstPart = parts[0];
              var propName = parts.pop();
              var obj = parts.reduce(function (prev, curr) {
                return prev && prev[curr];
              }, elem);

              obj[propName || e.target.name] = value;
              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__props__["a" /* default */])(elem, _defineProperty({}, firstPart, elem[firstPart]));
            } else {
              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__props__["a" /* default */])(elem, _defineProperty({}, localTargetName, value));
            }
          };
        };

        /***/
      },
      /* 19 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";

        Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__util_assign__ = __webpack_require__(4);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__util_empty__ = __webpack_require__(6);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__util_to_null_or_string__ = __webpack_require__(12);
        /* harmony export (immutable) */__webpack_exports__["create"] = create;
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "array", function () {
          return array;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "boolean", function () {
          return boolean;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "number", function () {
          return number;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "string", function () {
          return string;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "object", function () {
          return object;
        });

        function create(def) {
          return function () {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            args.unshift({}, def);
            return __WEBPACK_IMPORTED_MODULE_0__util_assign__["a" /* default */].apply(undefined, args);
          };
        }

        var parseIfNotEmpty = function parseIfNotEmpty(val) {
          return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util_empty__["a" /* default */])(val) ? null : JSON.parse(val);
        };

        var array = create({
          coerce: function coerce(val) {
            return Array.isArray(val) ? val : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util_empty__["a" /* default */])(val) ? null : [val];
          },
          default: function _default() {
            return [];
          },
          deserialize: parseIfNotEmpty,
          serialize: JSON.stringify
        });

        var boolean = create({
          coerce: function coerce(val) {
            return !!val;
          },
          default: false,
          // TODO: 'false' string must deserialize to false for angular 1.x to work
          // This breaks one existing test.
          // deserialize: val => !(val === null || val === 'false'),
          deserialize: function deserialize(val) {
            return !(val === null);
          },
          serialize: function serialize(val) {
            return val ? '' : null;
          }
        });

        // defaults empty to 0 and allows NaN
        var zeroIfEmptyOrNumberIncludesNaN = function zeroIfEmptyOrNumberIncludesNaN(val) {
          return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util_empty__["a" /* default */])(val) ? 0 : Number(val);
        };

        var number = create({
          default: 0,
          coerce: zeroIfEmptyOrNumberIncludesNaN,
          deserialize: zeroIfEmptyOrNumberIncludesNaN,
          serialize: __WEBPACK_IMPORTED_MODULE_2__util_to_null_or_string__["a" /* default */]
        });

        var string = create({
          default: '',
          coerce: __WEBPACK_IMPORTED_MODULE_2__util_to_null_or_string__["a" /* default */],
          deserialize: __WEBPACK_IMPORTED_MODULE_2__util_to_null_or_string__["a" /* default */],
          serialize: __WEBPACK_IMPORTED_MODULE_2__util_to_null_or_string__["a" /* default */]
        });

        var object = create({
          default: function _default() {
            return {};
          },
          deserialize: parseIfNotEmpty,
          serialize: JSON.stringify
        });

        /***/
      },
      /* 20 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__util_symbols__ = __webpack_require__(0);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__util_data__ = __webpack_require__(5);

        /* harmony default export */__webpack_exports__["a"] = function (elem, done) {
          var info = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util_data__["a" /* default */])(elem);
          if (elem[__WEBPACK_IMPORTED_MODULE_0__util_symbols__["c" /* created */]]) {
            done(elem);
          } else if (info.readyCallbacks) {
            info.readyCallbacks.push(done);
          } else {
            info.readyCallbacks = [done];
          }
        };

        /***/
      },
      /* 21 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";

        Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__util_symbols__ = __webpack_require__(0);
        /* harmony reexport (binding) */__webpack_require__.d(__webpack_exports__, "name", function () {
          return __WEBPACK_IMPORTED_MODULE_0__util_symbols__["b"];
        });
        // DEPRECTAED
        //
        // We should not be relying on internals for symbols as this creates version
        // coupling. We will move forward with platform agnostic ways of doing this.


        /***/
      },
      /* 22 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";

        Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_0_incremental_dom__ = __webpack_require__(14);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_0_incremental_dom___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_incremental_dom__);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__util_symbols__ = __webpack_require__(0);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__util_prop_context__ = __webpack_require__(34);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__util_root__ = __webpack_require__(3);
        /* harmony export (immutable) */__webpack_exports__["element"] = element;
        /* harmony export (immutable) */__webpack_exports__["builder"] = builder;
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "attr", function () {
          return newAttr;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "elementClose", function () {
          return newElementClose;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "elementOpen", function () {
          return newElementOpen;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "elementOpenEnd", function () {
          return newElementOpenEnd;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "elementOpenStart", function () {
          return newElementOpenStart;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "elementVoid", function () {
          return newElementVoid;
        });
        /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "text", function () {
          return newText;
        });
        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
          return typeof obj;
        } : function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };

        function _toConsumableArray(arr) {
          if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
              arr2[i] = arr[i];
            }return arr2;
          } else {
            return Array.from(arr);
          }
        }

        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }return obj;
        }

        /* eslint no-plusplus: 0 */

        var customElements = __WEBPACK_IMPORTED_MODULE_3__util_root__["a" /* default */].customElements,
            HTMLElement = __WEBPACK_IMPORTED_MODULE_3__util_root__["a" /* default */].HTMLElement;

        var applyDefault = __WEBPACK_IMPORTED_MODULE_0_incremental_dom__["attributes"][__WEBPACK_IMPORTED_MODULE_0_incremental_dom__["symbols"].default];

        // A stack of children that corresponds to the current function helper being
        // executed.
        var stackChren = [];

        var $skip = '__skip';
        var $currentEventHandlers = '__events';
        var $stackCurrentHelperProps = '__props';

        // The current function helper in the stack.
        var stackCurrentHelper = void 0;

        // This is used for the Incremental DOM overrides to keep track of what args
        // to pass the main elementOpen() function.
        var overrideArgs = void 0;

        // The number of levels deep after skipping a tree.
        var skips = 0;

        var noop = function noop() {};

        // Adds or removes an event listener for an element.
        function applyEvent(elem, ename, newFunc) {
          var events = elem[$currentEventHandlers];

          if (!events) {
            events = elem[$currentEventHandlers] = {};
          }

          // Undefined indicates that there is no listener yet.
          if (typeof events[ename] === 'undefined') {
            // We only add a single listener once. Originally this was a workaround for
            // the Webcomponents ShadyDOM polyfill not removing listeners, but it's
            // also a simpler model for binding / unbinding events because you only
            // have a single handler you need to worry about and a single place where
            // you only store one event handler
            elem.addEventListener(ename, function (e) {
              if (events[ename]) {
                events[ename].call(this, e);
              }
            });
          }

          // Not undefined indicates that we have set a listener, so default to null.
          events[ename] = typeof newFunc === 'function' ? newFunc : null;
        }

        var attributesContext = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util_prop_context__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0_incremental_dom__["attributes"], _defineProperty({
          // Attributes that shouldn't be applied to the DOM.
          key: noop,
          statics: noop,

          // Attributes that *must* be set via a property on all elements.
          checked: __WEBPACK_IMPORTED_MODULE_0_incremental_dom__["applyProp"],
          className: __WEBPACK_IMPORTED_MODULE_0_incremental_dom__["applyProp"],
          disabled: __WEBPACK_IMPORTED_MODULE_0_incremental_dom__["applyProp"],
          value: __WEBPACK_IMPORTED_MODULE_0_incremental_dom__["applyProp"],

          // Ref handler.
          ref: function ref(elem, name, value) {
            elem[__WEBPACK_IMPORTED_MODULE_1__util_symbols__["a" /* ref */]] = value;
          },

          // Skip handler.
          skip: function skip(elem, name, value) {
            if (value) {
              elem[$skip] = true;
            } else {
              delete elem[$skip];
            }
          }
        }, __WEBPACK_IMPORTED_MODULE_0_incremental_dom__["symbols"].default, function (elem, name, value) {
          var ce = customElements.get(elem.localName);
          var props = ce && ce.props || {};
          var prototype = ce && ce.prototype || {};

          // TODO when refactoring properties to not have to workaround the old
          // WebKit bug we can remove the "name in props" check below.
          //
          // NOTE: That the "name in elem" check won't work for polyfilled custom
          // elements that set a property that isn't explicitly specified in "props"
          // or "prototype" unless it is added to the element explicitly as a
          // property prior to passing the prop to the vdom function. For example, if
          // it were added in a lifecycle callback because it wouldn't have been
          // upgraded yet.
          //
          // We prefer setting props, so we do this if there's a property matching
          // name that was passed. However, certain props on SVG elements are
          // readonly and error when you try to set them.
          if ((name in props || name in elem || name in prototype) && !('ownerSVGElement' in elem)) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_incremental_dom__["applyProp"])(elem, name, value);
            return;
          }

          // Explicit false removes the attribute.
          if (value === false) {
            applyDefault(elem, name);
            return;
          }

          // Handle built-in and custom events.
          if (name.indexOf('on') === 0) {
            var firstChar = name[2];
            var eventName = void 0;

            if (firstChar === '-') {
              eventName = name.substring(3);
            } else if (firstChar === firstChar.toUpperCase()) {
              eventName = firstChar.toLowerCase() + name.substring(3);
            }

            if (eventName) {
              applyEvent(elem, eventName, value);
              return;
            }
          }

          applyDefault(elem, name, value);
        }));

        function resolveTagName(name) {
          // We return falsy values as some wrapped IDOM functions allow empty values.
          if (!name) {
            return name;
          }

          // We try and return the cached tag name, if one exists. This will work with
          // *any* web component of any version that defines a `static is` property.
          if (name.is) {
            return name.is;
          }

          // Get the name for the custom element by constructing it and using the
          // localName property. Cache it and lookup the cached value for future calls.
          if (name.prototype instanceof HTMLElement) {
            if (name[__WEBPACK_IMPORTED_MODULE_1__util_symbols__["b" /* name */]]) {
              return name[__WEBPACK_IMPORTED_MODULE_1__util_symbols__["b" /* name */]];
            }

            // eslint-disable-next-line
            var elem = new name();
            return elem[__WEBPACK_IMPORTED_MODULE_1__util_symbols__["b" /* name */]] = elem.localName;
          }

          // Pass all other values through so IDOM gets what it's expecting.
          return name;
        }

        // Incremental DOM's elementOpen is where the hooks in `attributes` are applied,
        // so it's the only function we need to execute in the context of our attributes.
        var elementOpen = attributesContext(__WEBPACK_IMPORTED_MODULE_0_incremental_dom__["elementOpen"]);

        function elementOpenStart(tag) {
          var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var statics = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

          overrideArgs = [tag, key, statics];
        }

        function elementOpenEnd() {
          var node = newElementOpen.apply(undefined, _toConsumableArray(overrideArgs)); // eslint-disable-line no-use-before-define
          overrideArgs = null;
          return node;
        }

        function wrapIdomFunc(func) {
          var tnameFuncHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

          return function wrap() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            args[0] = resolveTagName(args[0]);
            stackCurrentHelper = null;
            if (typeof args[0] === 'function') {
              // If we've encountered a function, handle it according to the type of
              // function that is being wrapped.
              stackCurrentHelper = args[0];
              return tnameFuncHandler.apply(undefined, args);
            } else if (stackChren.length) {
              // We pass the wrap() function in here so that when it's called as
              // children, it will queue up for the next stack, if there is one.
              stackChren[stackChren.length - 1].push([wrap, args]);
            } else {
              if (func === elementOpen) {
                if (skips) {
                  return ++skips;
                }

                var elem = func.apply(undefined, args);

                if (elem[$skip]) {
                  ++skips;
                }

                return elem;
              }

              if (func === __WEBPACK_IMPORTED_MODULE_0_incremental_dom__["elementClose"]) {
                if (skips === 1) {
                  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_incremental_dom__["skip"])();
                }

                // We only want to skip closing if it's not the last closing tag in the
                // skipped tree because we keep the element that initiated the skpping.
                if (skips && --skips) {
                  return;
                }

                var _elem = func.apply(undefined, args);
                var ref = _elem[__WEBPACK_IMPORTED_MODULE_1__util_symbols__["a" /* ref */]];

                // We delete so that it isn't called again for the same element. If the
                // ref changes, or the element changes, this will be defined again.
                delete _elem[__WEBPACK_IMPORTED_MODULE_1__util_symbols__["a" /* ref */]];

                // Execute the saved ref after esuring we've cleand up after it.
                if (typeof ref === 'function') {
                  ref(_elem);
                }

                return _elem;
              }

              // We must call elementOpenStart and elementOpenEnd even if we are
              // skipping because they queue up attributes and then call elementClose.
              if (!skips || func === elementOpenStart || func === elementOpenEnd) {
                return func.apply(undefined, args);
              }
            }
          };
        }

        function newAttr() {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          if (stackCurrentHelper) {
            stackCurrentHelper[$stackCurrentHelperProps][args[0]] = args[1];
          } else if (stackChren.length) {
            stackChren[stackChren.length - 1].push([newAttr, args]);
          } else {
            overrideArgs.push(args[0]);
            overrideArgs.push(args[1]);
          }
        }

        function stackOpen(tname, key, statics) {
          var props = { key: key, statics: statics };

          for (var _len3 = arguments.length, attrs = Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {
            attrs[_key3 - 3] = arguments[_key3];
          }

          for (var a = 0; a < attrs.length; a += 2) {
            props[attrs[a]] = attrs[a + 1];
          }
          tname[$stackCurrentHelperProps] = props;
          stackChren.push([]);
        }

        function stackClose(tname) {
          var chren = stackChren.pop();
          var props = tname[$stackCurrentHelperProps];
          delete tname[$stackCurrentHelperProps];
          var elemOrFn = tname(props, function () {
            return chren.forEach(function (args) {
              return args[0].apply(args, _toConsumableArray(args[1]));
            });
          });
          return typeof elemOrFn === 'function' ? elemOrFn() : elemOrFn;
        }

        // Incremental DOM overrides
        // -------------------------

        // We must override internal functions that call internal Incremental DOM
        // functions because we can't override the internal references. This means
        // we must roughly re-implement their behaviour. Luckily, they're fairly
        // simple.
        var newElementOpenStart = wrapIdomFunc(elementOpenStart, stackOpen);
        var newElementOpenEnd = wrapIdomFunc(elementOpenEnd);

        // Standard open / closed overrides don't need to reproduce internal behaviour
        // because they are the ones referenced from *End and *Start.
        var newElementOpen = wrapIdomFunc(elementOpen, stackOpen);
        var newElementClose = wrapIdomFunc(__WEBPACK_IMPORTED_MODULE_0_incremental_dom__["elementClose"], stackClose);

        // Ensure we call our overridden functions instead of the internal ones.
        function newElementVoid(tag) {
          for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            args[_key4 - 1] = arguments[_key4];
          }

          newElementOpen.apply(undefined, [tag].concat(args));
          return newElementClose(tag);
        }

        // Text override ensures their calls can queue if using function helpers.
        var newText = wrapIdomFunc(__WEBPACK_IMPORTED_MODULE_0_incremental_dom__["text"]);

        // Convenience function for declaring an Incremental DOM element using
        // hyperscript-style syntax.
        function element(tname, attrs) {
          var atype = typeof attrs === 'undefined' ? 'undefined' : _typeof(attrs);

          // If attributes are a function, then they should be treated as children.

          for (var _len5 = arguments.length, chren = Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {
            chren[_key5 - 2] = arguments[_key5];
          }

          if (atype === 'function' || atype === 'string' || atype === 'number') {
            chren.unshift(attrs);
          }

          // Ensure the attributes are an object. Null is considered an object so we
          // have to test for this explicitly.
          if (attrs === null || atype !== 'object') {
            attrs = {};
          }

          // We open the element so we can set attrs after.
          newElementOpenStart(tname, attrs.key, attrs.statics);

          // Delete so special attrs don't actually get set.
          delete attrs.key;
          delete attrs.statics;

          // Set attributes.
          Object.keys(attrs).forEach(function (name) {
            return newAttr(name, attrs[name]);
          });

          // Close before we render the descendant tree.
          newElementOpenEnd(tname);

          chren.forEach(function (ch) {
            var ctype = typeof ch === 'undefined' ? 'undefined' : _typeof(ch);
            if (ctype === 'function') {
              ch();
            } else if (ctype === 'string' || ctype === 'number') {
              newText(ch);
            } else if (Array.isArray(ch)) {
              ch.forEach(function (sch) {
                return sch();
              });
            }
          });

          return newElementClose(tname);
        }

        // Even further convenience for building a DSL out of JavaScript functions or hooking into standard
        // transpiles for JSX (React.createElement() / h).
        function builder() {
          for (var _len6 = arguments.length, tags = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
            tags[_key6] = arguments[_key6];
          }

          if (tags.length === 0) {
            return function () {
              for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
                args[_key7] = arguments[_key7];
              }

              return element.bind.apply(element, [null].concat(args));
            };
          }
          return tags.map(function (tag) {
            return function () {
              for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
                args[_key8] = arguments[_key8];
              }

              return element.bind.apply(element, [null, tag].concat(args));
            };
          });
        }

        // We don't have to do anything special for the text function; it's just a
        // straight export from Incremental DOM.


        /***/
      },
      /* 23 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__util_symbols__ = __webpack_require__(0);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__util_data__ = __webpack_require__(5);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__util_empty__ = __webpack_require__(6);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__util_attributes_manager__ = __webpack_require__(9);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__util_get_default_value__ = __webpack_require__(29);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_5__util_get_initial_value__ = __webpack_require__(30);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_6__util_get_prop_data__ = __webpack_require__(32);
        /* harmony export (immutable) */__webpack_exports__["a"] = createNativePropertyDescriptor;

        function createNativePropertyDescriptor(propDef) {
          var nameOrSymbol = propDef.nameOrSymbol;

          var prop = {
            configurable: true,
            enumerable: true
          };

          prop.beforeDefineProperty = function (elem) {
            var propData = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__util_get_prop_data__["a" /* default */])(elem, nameOrSymbol);
            var attrSource = propDef.attrSource;

            // Store attrSource name to property link.
            if (attrSource) {
              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util_data__["a" /* default */])(elem, 'attrSourceLinks')[attrSource] = nameOrSymbol;
            }

            // prop value before upgrading
            var initialValue = elem[nameOrSymbol];

            // Set up initial value if it wasn't specified.
            var valueFromAttrSource = false;
            if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util_empty__["a" /* default */])(initialValue)) {
              if (attrSource && elem.hasAttribute(attrSource)) {
                valueFromAttrSource = true;
                initialValue = propDef.deserialize(elem.getAttribute(attrSource));
              } else if ('initial' in propDef) {
                initialValue = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__util_get_initial_value__["a" /* default */])(elem, propDef);
              } else {
                initialValue = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__util_get_default_value__["a" /* default */])(elem, propDef);
              }
            }

            initialValue = propDef.coerce(initialValue);

            propData.internalValue = initialValue;

            // Reflect to Target Attribute
            var mustReflect = propDef.attrTarget && !__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util_empty__["a" /* default */])(initialValue) && (!valueFromAttrSource || propDef.attrTargetIsNotSource);

            if (mustReflect) {
              var serializedValue = propDef.serialize(initialValue);
              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__util_attributes_manager__["a" /* default */])(elem).setAttrValue(propDef.attrTarget, serializedValue);
            }
          };

          prop.get = function get() {
            var propData = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__util_get_prop_data__["a" /* default */])(this, nameOrSymbol);
            var internalValue = propData.internalValue;

            return propDef.get ? propDef.get(this, { name: nameOrSymbol, internalValue: internalValue }) : internalValue;
          };

          prop.set = function set(newValue) {
            var propData = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__util_get_prop_data__["a" /* default */])(this, nameOrSymbol);

            var useDefaultValue = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util_empty__["a" /* default */])(newValue);
            if (useDefaultValue) {
              newValue = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__util_get_default_value__["a" /* default */])(this, propDef);
            }

            newValue = propDef.coerce(newValue);

            if (propDef.set) {
              var oldValue = propData.oldValue;

              if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util_empty__["a" /* default */])(oldValue)) {
                oldValue = null;
              }
              var changeData = { name: nameOrSymbol, newValue: newValue, oldValue: oldValue };
              propDef.set(this, changeData);
            }

            // Queue a re-render.
            this[__WEBPACK_IMPORTED_MODULE_0__util_symbols__["i" /* rendererDebounced */]](this);

            // Update prop data so we can use it next time.
            propData.internalValue = propData.oldValue = newValue;

            // Reflect to Target attribute.
            var mustReflect = propDef.attrTarget && (propDef.attrTargetIsNotSource || !propData.settingPropFromAttrSource);
            if (mustReflect) {
              // Note: setting the prop to empty implies the default value
              // and therefore no attribute should be present!
              var serializedValue = useDefaultValue ? null : propDef.serialize(newValue);
              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__util_attributes_manager__["a" /* default */])(this).setAttrValue(propDef.attrTarget, serializedValue);
            }
          };

          return prop;
        }

        /***/
      },
      /* 24 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /**
         * Polyfill Object.is for IE
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
         */

        if (!Object.is) {
          Object.is = function (x, y) {
            // SameValue algorithm
            if (x === y) {
              // Steps 1-5, 7-10
              // Steps 6.b-6.e: +0 != -0
              return x !== 0 || 1 / x === 1 / y;
            } else {
              // Step 6.a: NaN == NaN
              return x !== x && y !== y;
            }
          };
        }
        /* harmony default export */__webpack_exports__["a"] = Object.is;

        /***/
      },
      /* 25 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony export (immutable) */
        __webpack_exports__["a"] = createSymbol;
        function createSymbol(description) {
          return typeof Symbol === 'function' ? Symbol(description) : description;
        }

        /***/
      },
      /* 26 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony default export */
        __webpack_exports__["a"] = function (str) {
          return str.split(/([A-Z])/).reduce(function (one, two, idx) {
            var dash = !one || idx % 2 === 0 ? '' : '-';
            return '' + one + dash + two.toLowerCase();
          });
        };

        /***/
      },
      /* 27 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__native__ = __webpack_require__(33);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__root__ = __webpack_require__(3);
        function _toConsumableArray(arr) {
          if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
              arr2[i] = arr[i];
            }return arr2;
          } else {
            return Array.from(arr);
          }
        }

        var MutationObserver = __WEBPACK_IMPORTED_MODULE_1__root__["a" /* default */].MutationObserver;

        function microtaskDebounce(cbFunc) {
          var scheduled = false;
          var i = 0;
          var cbArgs = [];
          var elem = document.createElement('span');
          var observer = new MutationObserver(function () {
            cbFunc.apply(undefined, _toConsumableArray(cbArgs));
            scheduled = false;
            cbArgs = null;
          });

          observer.observe(elem, { childList: true });

          return function () {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            cbArgs = args;
            if (!scheduled) {
              scheduled = true;
              elem.textContent = '' + i;
              i += 1;
            }
          };
        }

        // We have to use setTimeout() for IE9 and 10 because the Mutation Observer
        // polyfill requires that the element be in the document to trigger Mutation
        // Events. Mutation Events are also synchronous and thus wouldn't debounce.
        //
        // The soonest we can set the timeout for in IE is 1 as they have issues when
        // setting to 0.
        function taskDebounce(cbFunc) {
          var scheduled = false;
          var cbArgs = [];
          return function () {
            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            cbArgs = args;
            if (!scheduled) {
              scheduled = true;
              setTimeout(function () {
                scheduled = false;
                cbFunc.apply(undefined, _toConsumableArray(cbArgs));
              }, 1);
            }
          };
        }
        /* harmony default export */__webpack_exports__["a"] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__native__["a" /* default */])(MutationObserver) ? microtaskDebounce : taskDebounce;

        /***/
      },
      /* 28 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony export (immutable) */
        __webpack_exports__["a"] = error;
        function error(message) {
          throw new Error(message);
        }

        /***/
      },
      /* 29 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony export (immutable) */
        __webpack_exports__["a"] = getDefaultValue;
        function getDefaultValue(elem, propDef) {
          return typeof propDef.default === 'function' ? propDef.default(elem, { name: propDef.nameOrSymbol }) : propDef.default;
        }

        /***/
      },
      /* 30 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony export (immutable) */
        __webpack_exports__["a"] = getInitialValue;
        function getInitialValue(elem, propDef) {
          return typeof propDef.initial === 'function' ? propDef.initial(elem, { name: propDef.nameOrSymbol }) : propDef.initial;
        }

        /***/
      },
      /* 31 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__get_prop_names_and_symbols__ = __webpack_require__(1);

        /* harmony default export */__webpack_exports__["a"] = function () {
          var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__get_prop_names_and_symbols__["a" /* default */])(obj).reduce(function (prev, nameOrSymbol) {
            prev[nameOrSymbol] = Object.getOwnPropertyDescriptor(obj, nameOrSymbol);
            return prev;
          }, {});
        };

        /***/
      },
      /* 32 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__data__ = __webpack_require__(5);
        /* harmony export (immutable) */__webpack_exports__["a"] = getPropData;

        function getPropData(elem, name) {
          var elemData = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__data__["a" /* default */])(elem, 'props');
          return elemData[name] || (elemData[name] = {});
        }

        /***/
      },
      /* 33 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";

        var nativeHints = ['native code', '[object MutationObserverConstructor]' // for mobile safari iOS 9.0
        ];
        /* harmony default export */__webpack_exports__["a"] = function (fn) {
          return nativeHints.map(function (hint) {
            return (fn || '').toString().indexOf([hint]) > -1;
          }).reduce(function (a, b) {
            return a || b;
          });
        };

        /***/
      },
      /* 34 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__assign__ = __webpack_require__(4);

        function enter(object, props) {
          var saved = {};
          Object.keys(props).forEach(function (key) {
            saved[key] = object[key];
            object[key] = props[key];
          });
          return saved;
        }

        function exit(object, saved) {
          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__assign__["a" /* default */])(object, saved);
        }

        // Decorates a function with a side effect that changes the properties of an
        // object during its execution, and restores them after. There is no error
        // handling here, if the wrapped function throws an error, properties are not
        // restored and all bets are off.
        /* harmony default export */__webpack_exports__["a"] = function (object, props) {
          return function (func) {
            return function () {
              var saved = enter(object, props);
              var result = func.apply(undefined, arguments);
              exit(object, saved);
              return result;
            };
          };
        };

        /***/
      },
      /* 35 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__dash_case__ = __webpack_require__(26);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__empty__ = __webpack_require__(6);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__error__ = __webpack_require__(28);
        /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__is_type__ = __webpack_require__(2);
        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
          };
        }();

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        /**
         * @internal
         * Property Definition
         *
         * Internal meta data and strategies for a property.
         * Created from the options of a PropOptions config object.
         *
         * Once created a PropDefinition should be treated as immutable and final.
         * 'getPropsMap' function memoizes PropDefinitions by Component's Class.
         *
         * The 'attribute' option is normalized to 'attrSource' and 'attrTarget' properties.
         */

        var PropDefinition = function () {
          function PropDefinition(nameOrSymbol, propOptions) {
            var _this = this;

            _classCallCheck(this, PropDefinition);

            this._nameOrSymbol = nameOrSymbol;

            propOptions = propOptions || {};

            // default 'attrSource': no observed source attribute (name)
            this.attrSource = null;

            // default 'attrTarget': no reflected target attribute (name)
            this.attrTarget = null;

            // default 'attrTargetIsNotSource'
            this.attrTargetIsNotSource = false;

            // default 'coerce': identity function
            this.coerce = function (value) {
              return value;
            };

            // default 'default': set prop to 'null'
            this.default = null;

            // default 'deserialize': return attribute's value (string or null)
            this.deserialize = function (value) {
              return value;
            };

            // default 'get': no function
            this.get = null;

            // 'initial' default: unspecified
            // 'initial' option is truly optional and it cannot be initialized.
            // Its presence is tested using: ('initial' in propDef)

            // 'serialize' default: return string value or null
            this.serialize = function (value) {
              return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__empty__["a" /* default */])(value) ? null : String(value);
            };

            // default 'set': no function
            this.set = null;

            // Note: option key is always a string (no symbols here)
            Object.keys(propOptions).forEach(function (option) {
              var optVal = propOptions[option];

              // Only accept documented options and perform minimal input validation.
              switch (option) {
                case 'attribute':
                  if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__is_type__["c" /* isObject */])(optVal)) {
                    _this.attrSource = _this.attrTarget = resolveAttrName(optVal, nameOrSymbol);
                  } else {
                    var source = optVal.source,
                        target = optVal.target;

                    if (!source && !target) {
                      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__error__["a" /* default */])(option + ' \'source\' or \'target\' is missing.');
                    }
                    _this.attrSource = resolveAttrName(source, nameOrSymbol);
                    _this.attrTarget = resolveAttrName(target, nameOrSymbol);
                    _this.attrTargetIsNotSource = _this.attrTarget !== _this.attrSource;
                  }
                  break;
                case 'coerce':
                case 'deserialize':
                case 'get':
                case 'serialize':
                case 'set':
                  if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__is_type__["a" /* isFunction */])(optVal)) {
                    _this[option] = optVal;
                  } else {
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__error__["a" /* default */])(option + ' must be a function.');
                  }
                  break;
                case 'default':
                case 'initial':
                  _this[option] = optVal;
                  break;
                default:
                  // TODO: undocumented options?
                  _this[option] = optVal;
                  break;
              }
            });
          }

          _createClass(PropDefinition, [{
            key: 'nameOrSymbol',
            get: function get() {
              return this._nameOrSymbol;
            }
          }]);

          return PropDefinition;
        }();

        /* harmony default export */__webpack_exports__["a"] = PropDefinition;

        function resolveAttrName(attrOption, nameOrSymbol) {
          if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__is_type__["d" /* isSymbol */])(nameOrSymbol)) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__error__["a" /* default */])(nameOrSymbol.toString() + ' symbol property cannot have an attribute.');
          } else {
            if (attrOption === true) {
              return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__dash_case__["a" /* default */])(String(nameOrSymbol));
            }
            if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__is_type__["e" /* isString */])(attrOption)) {
              return attrOption;
            }
          }
          return null;
        }

        /***/
      },
      /* 36 */
      /***/function (module, __webpack_exports__, __webpack_require__) {

        "use strict";
        /* harmony export (immutable) */
        __webpack_exports__["a"] = uniqueId;
        // DEPRECATED prefix when we deprecated the name argument to define()
        function uniqueId(prefix) {
          // http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript/2117523#2117523
          var rand = 'xxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = Math.random() * 16 | 0;
            // eslint-disable-next-line no-mixed-operators
            var v = c === 'x' ? r : r & 0x3 | 0x8;
            return v.toString(16);
          });
          return (prefix || 'x') + '-' + rand;
        }

        /***/
      },
      /* 37 */
      /***/function (module, exports) {

        var g;

        // This works in non-strict mode
        g = function () {
          return this;
        }();

        try {
          // This works if eval is allowed (see CSP)
          g = g || Function("return this")() || (1, eval)("this");
        } catch (e) {
          // This works if the window reference is available
          if (typeof window === "object") g = window;
        }

        // g can still be undefined, but nothing to do about it...
        // We return undefined, instead of nothing here, so it's
        // easier to handle this case. if(!global) { ...}

        module.exports = g;

        /***/
      },
      /* 38 */
      /***/function (module, exports, __webpack_require__) {

        module.exports = __webpack_require__(15);

        /***/
      }])
    );
  });
  
});

class Input$1 extends Component {
  renderCallback() {
    return React.createElement(
      'span',
      null,
      'testing bro!'
    );
  }
}

customElements.define('mui-input', Input$1);

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbIi4uL25vZGVfbW9kdWxlcy9za2F0ZWpzLXdlYi1jb21wb25lbnRzL2Rpc3QvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvaW5jcmVtZW50YWwtZG9tL2Rpc3QvaW5jcmVtZW50YWwtZG9tLWNqcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9za2F0ZWpzL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wic2thdGVqc1dlYkNvbXBvbmVudHNcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wic2thdGVqc1dlYkNvbXBvbmVudHNcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8vIE5PVEUhISFcblx0Ly9cblx0Ly8gV2UgaGF2ZSB0byBsb2FkIHBvbHlmaWxscyBkaXJlY3RseSBmcm9tIHNvdXJjZSBhcyBub24tbWluaWZpZWQgZmlsZXMgYXJlIG5vdFxuXHQvLyBwdWJsaXNoZWQgYnkgdGhlIHBvbHlmaWxscy4gQW4gaXNzdWUgd2FzIHJhaXNlZCB0byBkaXNjdXNzIHRoaXMgcHJvYmxlbSBhbmRcblx0Ly8gdG8gc2VlIGlmIGl0IGNhbiBiZSByZXNvbHZlZC5cblx0Ly9cblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL2N1c3RvbS1lbGVtZW50cy9pc3N1ZXMvNDVcblx0XG5cdC8vIEVTMjAxNSBwb2x5ZmlsbHMgcmVxdWlyZWQgZm9yIHRoZSBwb2x5ZmlsbHMgdG8gd29yayBpbiBvbGRlciBicm93c2Vycy5cblx0X193ZWJwYWNrX3JlcXVpcmVfXygxKS5zaGltKCk7XG5cdF9fd2VicGFja19yZXF1aXJlX18oMjYpLnNoaW0oKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXygzMSkucG9seWZpbGwoKTtcblx0XG5cdC8vIFdlIGhhdmUgdG8gaW5jbHVkZSB0aGlzIGZpcnN0IHNvIHRoYXQgaXQgY2FuIHBhdGNoIG5hdGl2ZS4gVGhpcyBtdXN0IGJlIGRvbmVcblx0Ly8gYmVmb3JlIGFueSBwb2x5ZmlsbHMgYXJlIGxvYWRlZC5cblx0X193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG5cdFxuXHQvLyBUZW1wbGF0ZSBwb2x5ZmlsbCBpcyBuZWNlc3NhcnkgdG8gdXNlIHNoYWR5Y3NzIGluIElFMTFcblx0Ly8gdGhpcyBjb21lcyBiZWZvcmUgY3VzdG9tIGVsZW1lbnRzIGJlY2F1c2Ugb2Zcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3dlYmNvbXBvbmVudHMvdGVtcGxhdGUvYmxvYi9tYXN0ZXIvdGVtcGxhdGUuanMjTDM5XG5cdF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xuXHRcblx0Ly8gVGhpcyBjb21lcyBhZnRlciB0aGUgbmF0aXZlIHNoaW0gYmVjYXVzZSBpdCByZXF1cmllcyBpdCB0byBiZSBwYXRjaGVkIGZpcnN0LlxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcblx0XG5cdC8vIEZvcmNlIHRoZSBwb2x5ZmlsbCBpbiBTYWZhcmkgMTAuMC4wIGFuZCAxMC4wLjEuXG5cdHZhciBfd2luZG93ID0gd2luZG93LFxuXHQgICAgbmF2aWdhdG9yID0gX3dpbmRvdy5uYXZpZ2F0b3I7XG5cdHZhciB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuXHRcblx0dmFyIHNhZmFyaSA9IHVzZXJBZ2VudC5pbmRleE9mKCdTYWZhcmkvNjAnKSAhPT0gLTE7XG5cdHZhciBzYWZhcmlWZXJzaW9uID0gc2FmYXJpICYmIHVzZXJBZ2VudC5tYXRjaCgvVmVyc2lvblxcLyhbXlxcc10rKS8pWzFdO1xuXHR2YXIgc2FmYXJpVmVyc2lvbnMgPSBbMCwgMV0ubWFwKGZ1bmN0aW9uICh2KSB7XG5cdCAgcmV0dXJuICcxMC4wLicgKyB2O1xuXHR9KS5jb25jYXQoWycxMC4wJ10pO1xuXHRcblx0aWYgKHNhZmFyaSAmJiBzYWZhcmlWZXJzaW9ucy5pbmRleE9mKHNhZmFyaVZlcnNpb24pID4gLTEpIHtcblx0ICB3aW5kb3cuU2hhZHlET00gPSB7IGZvcmNlOiB0cnVlIH07XG5cdH1cblx0XG5cdC8vIFNoYWR5RE9NIGNvbWVzIGZpcnN0LiBCb3RoIGJlY2F1c2UgaXQgbWF5IG5lZWQgdG8gYmUgZm9yY2VkIGFuZCB0aGVcblx0Ly8gU2hhZHlDU1MgcG9seWZpbGwgcmVxdWlyZXMgaXQgdG8gZnVuY3Rpb24uXG5cdF9fd2VicGFja19yZXF1aXJlX18oNTEpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KTtcblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciBkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHRcblx0dmFyIGltcGxlbWVudGF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0dmFyIGdldFBvbHlmaWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cdHZhciBzaGltID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5cdFxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblx0dmFyIGJvdW5kRnJvbVNoaW0gPSBmdW5jdGlvbiBmcm9tKGFycmF5KSB7XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWludmFsaWQtdGhpc1xuXHRcdHJldHVybiBpbXBsZW1lbnRhdGlvbi5hcHBseSh0aGlzIHx8IEFycmF5LCBhcmd1bWVudHMpO1xuXHR9O1xuXHRcblx0ZGVmaW5lKGJvdW5kRnJvbVNoaW0sIHtcblx0XHQnZ2V0UG9seWZpbGwnOiBnZXRQb2x5ZmlsbCxcblx0XHQnaW1wbGVtZW50YXRpb24nOiBpbXBsZW1lbnRhdGlvbixcblx0XHQnc2hpbSc6IHNoaW1cblx0fSk7XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IGJvdW5kRnJvbVNoaW07XG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cdFxuXHR2YXIga2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdHZhciBmb3JlYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0dmFyIGhhc1N5bWJvbHMgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIF90eXBlb2YoU3ltYm9sKCkpID09PSAnc3ltYm9sJztcblx0XG5cdHZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cdFxuXHR2YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24oZm4pIHtcblx0XHRyZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHRvU3RyLmNhbGwoZm4pID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHR9O1xuXHRcblx0dmFyIGFyZVByb3BlcnR5RGVzY3JpcHRvcnNTdXBwb3J0ZWQgPSBmdW5jdGlvbiBhcmVQcm9wZXJ0eURlc2NyaXB0b3JzU3VwcG9ydGVkKCkge1xuXHRcdHZhciBvYmogPSB7fTtcblx0XHR0cnkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgJ3gnLCB7IGVudW1lcmFibGU6IGZhbHNlLCB2YWx1ZTogb2JqIH0pO1xuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIG5vLXJlc3RyaWN0ZWQtc3ludGF4ICovXG5cdFx0XHRmb3IgKHZhciBfIGluIG9iaikge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzLCBuby1yZXN0cmljdGVkLXN5bnRheCAqL1xuXHRcdFx0cmV0dXJuIG9iai54ID09PSBvYmo7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0LyogdGhpcyBpcyBJRSA4LiAqL1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcblx0dmFyIHN1cHBvcnRzRGVzY3JpcHRvcnMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgYXJlUHJvcGVydHlEZXNjcmlwdG9yc1N1cHBvcnRlZCgpO1xuXHRcblx0dmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB2YWx1ZSwgcHJlZGljYXRlKSB7XG5cdFx0aWYgKG5hbWUgaW4gb2JqZWN0ICYmICghaXNGdW5jdGlvbihwcmVkaWNhdGUpIHx8ICFwcmVkaWNhdGUoKSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9iamVjdFtuYW1lXSA9IHZhbHVlO1xuXHRcdH1cblx0fTtcblx0XG5cdHZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhvYmplY3QsIG1hcCkge1xuXHRcdHZhciBwcmVkaWNhdGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB7fTtcblx0XHR2YXIgcHJvcHMgPSBrZXlzKG1hcCk7XG5cdFx0aWYgKGhhc1N5bWJvbHMpIHtcblx0XHRcdHByb3BzID0gcHJvcHMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobWFwKSk7XG5cdFx0fVxuXHRcdGZvcmVhY2gocHJvcHMsIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIG1hcFtuYW1lXSwgcHJlZGljYXRlc1tuYW1lXSk7XG5cdFx0fSk7XG5cdH07XG5cdFxuXHRkZWZpbmVQcm9wZXJ0aWVzLnN1cHBvcnRzRGVzY3JpcHRvcnMgPSAhIXN1cHBvcnRzRGVzY3JpcHRvcnM7XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnRpZXM7XG5cbi8qKiovIH0sXG4vKiAzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHQvLyBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxuXHRcblx0dmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXHRcblx0dmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cdHZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cdHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblx0dmFyIGlzQXJncyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdHZhciBpc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXHR2YXIgaGFzRG9udEVudW1CdWcgPSAhaXNFbnVtZXJhYmxlLmNhbGwoeyB0b1N0cmluZzogbnVsbCB9LCAndG9TdHJpbmcnKTtcblx0dmFyIGhhc1Byb3RvRW51bUJ1ZyA9IGlzRW51bWVyYWJsZS5jYWxsKGZ1bmN0aW9uICgpIHt9LCAncHJvdG90eXBlJyk7XG5cdHZhciBkb250RW51bXMgPSBbJ3RvU3RyaW5nJywgJ3RvTG9jYWxlU3RyaW5nJywgJ3ZhbHVlT2YnLCAnaGFzT3duUHJvcGVydHknLCAnaXNQcm90b3R5cGVPZicsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdjb25zdHJ1Y3RvciddO1xuXHR2YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUgPSBmdW5jdGlvbiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKSB7XG5cdFx0dmFyIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiBjdG9yICYmIGN0b3IucHJvdG90eXBlID09PSBvO1xuXHR9O1xuXHR2YXIgZXhjbHVkZWRLZXlzID0ge1xuXHRcdCRjb25zb2xlOiB0cnVlLFxuXHRcdCRleHRlcm5hbDogdHJ1ZSxcblx0XHQkZnJhbWU6IHRydWUsXG5cdFx0JGZyYW1lRWxlbWVudDogdHJ1ZSxcblx0XHQkZnJhbWVzOiB0cnVlLFxuXHRcdCRpbm5lckhlaWdodDogdHJ1ZSxcblx0XHQkaW5uZXJXaWR0aDogdHJ1ZSxcblx0XHQkb3V0ZXJIZWlnaHQ6IHRydWUsXG5cdFx0JG91dGVyV2lkdGg6IHRydWUsXG5cdFx0JHBhZ2VYT2Zmc2V0OiB0cnVlLFxuXHRcdCRwYWdlWU9mZnNldDogdHJ1ZSxcblx0XHQkcGFyZW50OiB0cnVlLFxuXHRcdCRzY3JvbGxMZWZ0OiB0cnVlLFxuXHRcdCRzY3JvbGxUb3A6IHRydWUsXG5cdFx0JHNjcm9sbFg6IHRydWUsXG5cdFx0JHNjcm9sbFk6IHRydWUsXG5cdFx0JHNlbGY6IHRydWUsXG5cdFx0JHdlYmtpdEluZGV4ZWREQjogdHJ1ZSxcblx0XHQkd2Via2l0U3RvcmFnZUluZm86IHRydWUsXG5cdFx0JHdpbmRvdzogdHJ1ZVxuXHR9O1xuXHR2YXIgaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnID0gZnVuY3Rpb24gKCkge1xuXHRcdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgayBpbiB3aW5kb3cpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghZXhjbHVkZWRLZXlzWyckJyArIGtdICYmIGhhcy5jYWxsKHdpbmRvdywgaykgJiYgd2luZG93W2tdICE9PSBudWxsICYmIF90eXBlb2Yod2luZG93W2tdKSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0ZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUod2luZG93W2tdKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSgpO1xuXHR2YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5ID0gZnVuY3Rpb24gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5KG8pIHtcblx0XHQvKiBnbG9iYWwgd2luZG93ICovXG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcpIHtcblx0XHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXHRcblx0dmFyIGtleXNTaGltID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcblx0XHR2YXIgaXNPYmplY3QgPSBvYmplY3QgIT09IG51bGwgJiYgKHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iamVjdCkpID09PSAnb2JqZWN0Jztcblx0XHR2YXIgaXNGdW5jdGlvbiA9IHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0XHR2YXIgaXNBcmd1bWVudHMgPSBpc0FyZ3Mob2JqZWN0KTtcblx0XHR2YXIgaXNTdHJpbmcgPSBpc09iamVjdCAmJiB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuXHRcdHZhciB0aGVLZXlzID0gW107XG5cdFxuXHRcdGlmICghaXNPYmplY3QgJiYgIWlzRnVuY3Rpb24gJiYgIWlzQXJndW1lbnRzKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gYSBub24tb2JqZWN0Jyk7XG5cdFx0fVxuXHRcblx0XHR2YXIgc2tpcFByb3RvID0gaGFzUHJvdG9FbnVtQnVnICYmIGlzRnVuY3Rpb247XG5cdFx0aWYgKGlzU3RyaW5nICYmIG9iamVjdC5sZW5ndGggPiAwICYmICFoYXMuY2FsbChvYmplY3QsIDApKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGkpKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdGlmIChpc0FyZ3VtZW50cyAmJiBvYmplY3QubGVuZ3RoID4gMCkge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBvYmplY3QubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhqKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdGlmICghKHNraXBQcm90byAmJiBuYW1lID09PSAncHJvdG90eXBlJykgJiYgaGFzLmNhbGwob2JqZWN0LCBuYW1lKSkge1xuXHRcdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcobmFtZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRpZiAoaGFzRG9udEVudW1CdWcpIHtcblx0XHRcdHZhciBza2lwQ29uc3RydWN0b3IgPSBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kob2JqZWN0KTtcblx0XG5cdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IGRvbnRFbnVtcy5sZW5ndGg7ICsraykge1xuXHRcdFx0XHRpZiAoIShza2lwQ29uc3RydWN0b3IgJiYgZG9udEVudW1zW2tdID09PSAnY29uc3RydWN0b3InKSAmJiBoYXMuY2FsbChvYmplY3QsIGRvbnRFbnVtc1trXSkpIHtcblx0XHRcdFx0XHR0aGVLZXlzLnB1c2goZG9udEVudW1zW2tdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhlS2V5cztcblx0fTtcblx0XG5cdGtleXNTaGltLnNoaW0gPSBmdW5jdGlvbiBzaGltT2JqZWN0S2V5cygpIHtcblx0XHRpZiAoT2JqZWN0LmtleXMpIHtcblx0XHRcdHZhciBrZXlzV29ya3NXaXRoQXJndW1lbnRzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvLyBTYWZhcmkgNS4wIGJ1Z1xuXHRcdFx0XHRyZXR1cm4gKE9iamVjdC5rZXlzKGFyZ3VtZW50cykgfHwgJycpLmxlbmd0aCA9PT0gMjtcblx0XHRcdH0oMSwgMik7XG5cdFx0XHRpZiAoIWtleXNXb3Jrc1dpdGhBcmd1bWVudHMpIHtcblx0XHRcdFx0dmFyIG9yaWdpbmFsS2V5cyA9IE9iamVjdC5rZXlzO1xuXHRcdFx0XHRPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG5cdFx0XHRcdFx0aWYgKGlzQXJncyhvYmplY3QpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKHNsaWNlLmNhbGwob2JqZWN0KSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBvcmlnaW5hbEtleXMob2JqZWN0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdE9iamVjdC5rZXlzID0ga2V5c1NoaW07XG5cdFx0fVxuXHRcdHJldHVybiBPYmplY3Qua2V5cyB8fCBrZXlzU2hpbTtcblx0fTtcblx0XG5cdG1vZHVsZS5leHBvcnRzID0ga2V5c1NoaW07XG5cbi8qKiovIH0sXG4vKiA0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cdFxuXHR2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRcdHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0XHR2YXIgaXNBcmdzID0gc3RyID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcblx0XHRpZiAoIWlzQXJncykge1xuXHRcdFx0aXNBcmdzID0gc3RyICE9PSAnW29iamVjdCBBcnJheV0nICYmIHZhbHVlICE9PSBudWxsICYmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmIHZhbHVlLmxlbmd0aCA+PSAwICYmIHRvU3RyLmNhbGwodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0XHR9XG5cdFx0cmV0dXJuIGlzQXJncztcblx0fTtcblxuLyoqKi8gfSxcbi8qIDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHR2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4sIGN0eCkge1xuXHQgICAgaWYgKHRvU3RyaW5nLmNhbGwoZm4pICE9PSAnW29iamVjdCBGdW5jdGlvbl0nKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cdCAgICB9XG5cdCAgICB2YXIgbCA9IG9iai5sZW5ndGg7XG5cdCAgICBpZiAobCA9PT0gK2wpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuXHQgICAgICAgICAgICBmbi5jYWxsKGN0eCwgb2JqW2ldLCBpLCBvYmopO1xuXHQgICAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcblx0ICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKG9iaiwgaykpIHtcblx0ICAgICAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpba10sIGssIG9iaik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdH07XG5cbi8qKiovIH0sXG4vKiA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgRVMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXHR2YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oMikuc3VwcG9ydHNEZXNjcmlwdG9ycztcblx0XG5cdC8qISBodHRwczovL210aHMuYmUvYXJyYXktZnJvbSB2MC4yLjAgYnkgQG1hdGhpYXMgKi9cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZSkge1xuXHRcdHZhciBkZWZpbmVQcm9wZXJ0eSA9IHN1cHBvcnRzRGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBwdXQob2JqZWN0LCBrZXksIGRlc2NyaXB0b3IpIHtcblx0XHRcdG9iamVjdFtrZXldID0gZGVzY3JpcHRvci52YWx1ZTtcblx0XHR9O1xuXHRcdHZhciBDID0gdGhpcztcblx0XHRpZiAoYXJyYXlMaWtlID09PSBudWxsIHx8IHR5cGVvZiBhcnJheUxpa2UgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdgQXJyYXkuZnJvbWAgcmVxdWlyZXMgYW4gYXJyYXktbGlrZSBvYmplY3QsIG5vdCBgbnVsbGAgb3IgYHVuZGVmaW5lZGAnKTtcblx0XHR9XG5cdFx0dmFyIGl0ZW1zID0gRVMuVG9PYmplY3QoYXJyYXlMaWtlKTtcblx0XG5cdFx0dmFyIG1hcEZuLCBUO1xuXHRcdGlmICh0eXBlb2YgYXJndW1lbnRzWzFdICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0bWFwRm4gPSBhcmd1bWVudHNbMV07XG5cdFx0XHRpZiAoIUVTLklzQ2FsbGFibGUobWFwRm4pKSB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1doZW4gcHJvdmlkZWQsIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYEFycmF5LmZyb21gIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG5cdFx0XHRcdFQgPSBhcmd1bWVudHNbMl07XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHR2YXIgbGVuID0gRVMuVG9MZW5ndGgoaXRlbXMubGVuZ3RoKTtcblx0XHR2YXIgQSA9IEVTLklzQ2FsbGFibGUoQykgPyBFUy5Ub09iamVjdChuZXcgQyhsZW4pKSA6IG5ldyBBcnJheShsZW4pO1xuXHRcdHZhciBrID0gMDtcblx0XHR2YXIga1ZhbHVlLCBtYXBwZWRWYWx1ZTtcblx0XHR3aGlsZSAoayA8IGxlbikge1xuXHRcdFx0a1ZhbHVlID0gaXRlbXNba107XG5cdFx0XHRpZiAobWFwRm4pIHtcblx0XHRcdFx0bWFwcGVkVmFsdWUgPSB0eXBlb2YgVCA9PT0gJ3VuZGVmaW5lZCcgPyBtYXBGbihrVmFsdWUsIGspIDogRVMuQ2FsbChtYXBGbiwgVCwgW2tWYWx1ZSwga10pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWFwcGVkVmFsdWUgPSBrVmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRkZWZpbmVQcm9wZXJ0eShBLCBrLCB7XG5cdFx0XHRcdCdjb25maWd1cmFibGUnOiB0cnVlLFxuXHRcdFx0XHQnZW51bWVyYWJsZSc6IHRydWUsXG5cdFx0XHRcdCd2YWx1ZSc6IG1hcHBlZFZhbHVlLFxuXHRcdFx0XHQnd3JpdGFibGUnOiB0cnVlXG5cdFx0XHR9KTtcblx0XHRcdGsgKz0gMTtcblx0XHR9XG5cdFx0QS5sZW5ndGggPSBsZW47XG5cdFx0cmV0dXJuIEE7XG5cdH07XG5cbi8qKiovIH0sXG4vKiA3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cdFxuXHR2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHR2YXIgaGFzU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgX3R5cGVvZihTeW1ib2wuaXRlcmF0b3IpID09PSAnc3ltYm9sJztcblx0dmFyIHN5bWJvbFRvU3RyID0gaGFzU3ltYm9scyA/IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgOiB0b1N0cjtcblx0XG5cdHZhciAkaXNOYU4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXHR2YXIgJGlzRmluaXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0dmFyIE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCBNYXRoLnBvdygyLCA1MykgLSAxO1xuXHRcblx0dmFyIGFzc2lnbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXHR2YXIgc2lnbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXHR2YXIgbW9kID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cdHZhciBpc1ByaW1pdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXHR2YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblx0dmFyIHBhcnNlSW50ZWdlciA9IHBhcnNlSW50O1xuXHR2YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXHR2YXIgc3RyU2xpY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5zbGljZSk7XG5cdHZhciBpc0JpbmFyeSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBSZWdFeHAucHJvdG90eXBlLnRlc3QsIC9eMGJbMDFdKyQvaSk7XG5cdHZhciBpc09jdGFsID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFJlZ0V4cC5wcm90b3R5cGUudGVzdCwgL14wb1swLTddKyQvaSk7XG5cdHZhciBub25XUyA9IFsnXFx4ODUnLCAnXFx1MjAwQicsICdcXHVGRkZFJ10uam9pbignJyk7XG5cdHZhciBub25XU3JlZ2V4ID0gbmV3IFJlZ0V4cCgnWycgKyBub25XUyArICddJywgJ2cnKTtcblx0dmFyIGhhc05vbldTID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFJlZ0V4cC5wcm90b3R5cGUudGVzdCwgbm9uV1NyZWdleCk7XG5cdHZhciBpbnZhbGlkSGV4TGl0ZXJhbCA9IC9eW1xcLVxcK10weFswLTlhLWZdKyQvaTtcblx0dmFyIGlzSW52YWxpZEhleExpdGVyYWwgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgUmVnRXhwLnByb3RvdHlwZS50ZXN0LCBpbnZhbGlkSGV4TGl0ZXJhbCk7XG5cdFxuXHQvLyB3aGl0ZXNwYWNlIGZyb206IGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuNS40LjIwXG5cdC8vIGltcGxlbWVudGF0aW9uIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2Jsb2IvdjMuNC4wL2VzNS1zaGltLmpzI0wxMzA0LUwxMzI0XG5cdHZhciB3cyA9IFsnXFx0XFxuXFx4MEJcXGZcXHIgXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnLCAnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjgnLCAnXFx1MjAyOVxcdUZFRkYnXS5qb2luKCcnKTtcblx0dmFyIHRyaW1SZWdleCA9IG5ldyBSZWdFeHAoJyheWycgKyB3cyArICddKyl8KFsnICsgd3MgKyAnXSskKScsICdnJyk7XG5cdHZhciByZXBsYWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG5cdHZhciB0cmltID0gZnVuY3Rpb24gdHJpbSh2YWx1ZSkge1xuXHRcdHJldHVybiByZXBsYWNlKHZhbHVlLCB0cmltUmVnZXgsICcnKTtcblx0fTtcblx0XG5cdHZhciBFUzUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcblx0XG5cdHZhciBoYXNSZWdFeHBNYXRjaGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cdFxuXHQvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtYWJzdHJhY3Qtb3BlcmF0aW9uc1xuXHR2YXIgRVM2ID0gYXNzaWduKGFzc2lnbih7fSwgRVM1KSwge1xuXHRcblx0XHQvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtY2FsbC1mLXYtYXJnc1xuXHRcdENhbGw6IGZ1bmN0aW9uIENhbGwoRiwgVikge1xuXHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IFtdO1xuXHRcdFx0aWYgKCF0aGlzLklzQ2FsbGFibGUoRikpIHtcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihGICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIEYuYXBwbHkoViwgYXJncyk7XG5cdFx0fSxcblx0XG5cdFx0Ly8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvcHJpbWl0aXZlXG5cdFx0VG9QcmltaXRpdmU6IHRvUHJpbWl0aXZlLFxuXHRcblx0XHQvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9ib29sZWFuXG5cdFx0Ly8gVG9Cb29sZWFuOiBFUzUuVG9Cb29sZWFuLFxuXHRcblx0XHQvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9udW1iZXJcblx0XHRUb051bWJlcjogZnVuY3Rpb24gVG9OdW1iZXIoYXJndW1lbnQpIHtcblx0XHRcdHZhciB2YWx1ZSA9IGlzUHJpbWl0aXZlKGFyZ3VtZW50KSA/IGFyZ3VtZW50IDogdG9QcmltaXRpdmUoYXJndW1lbnQsICdudW1iZXInKTtcblx0XHRcdGlmICgodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpID09PSAnc3ltYm9sJykge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBhIFN5bWJvbCB2YWx1ZSB0byBhIG51bWJlcicpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0aWYgKGlzQmluYXJ5KHZhbHVlKSkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLlRvTnVtYmVyKHBhcnNlSW50ZWdlcihzdHJTbGljZSh2YWx1ZSwgMiksIDIpKTtcblx0XHRcdFx0fSBlbHNlIGlmIChpc09jdGFsKHZhbHVlKSkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLlRvTnVtYmVyKHBhcnNlSW50ZWdlcihzdHJTbGljZSh2YWx1ZSwgMiksIDgpKTtcblx0XHRcdFx0fSBlbHNlIGlmIChoYXNOb25XUyh2YWx1ZSkgfHwgaXNJbnZhbGlkSGV4TGl0ZXJhbCh2YWx1ZSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gTmFOO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciB0cmltbWVkID0gdHJpbSh2YWx1ZSk7XG5cdFx0XHRcdFx0aWYgKHRyaW1tZWQgIT09IHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5Ub051bWJlcih0cmltbWVkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBOdW1iZXIodmFsdWUpO1xuXHRcdH0sXG5cdFxuXHRcdC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2ludGVnZXJcblx0XHQvLyBUb0ludGVnZXI6IEVTNS5Ub051bWJlcixcblx0XG5cdFx0Ly8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvaW50MzJcblx0XHQvLyBUb0ludDMyOiBFUzUuVG9JbnQzMixcblx0XG5cdFx0Ly8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvdWludDMyXG5cdFx0Ly8gVG9VaW50MzI6IEVTNS5Ub1VpbnQzMixcblx0XG5cdFx0Ly8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvaW50MTZcblx0XHRUb0ludDE2OiBmdW5jdGlvbiBUb0ludDE2KGFyZ3VtZW50KSB7XG5cdFx0XHR2YXIgaW50MTZiaXQgPSB0aGlzLlRvVWludDE2KGFyZ3VtZW50KTtcblx0XHRcdHJldHVybiBpbnQxNmJpdCA+PSAweDgwMDAgPyBpbnQxNmJpdCAtIDB4MTAwMDAgOiBpbnQxNmJpdDtcblx0XHR9LFxuXHRcblx0XHQvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG91aW50MTZcblx0XHQvLyBUb1VpbnQxNjogRVM1LlRvVWludDE2LFxuXHRcblx0XHQvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9pbnQ4XG5cdFx0VG9JbnQ4OiBmdW5jdGlvbiBUb0ludDgoYXJndW1lbnQpIHtcblx0XHRcdHZhciBpbnQ4Yml0ID0gdGhpcy5Ub1VpbnQ4KGFyZ3VtZW50KTtcblx0XHRcdHJldHVybiBpbnQ4Yml0ID49IDB4ODAgPyBpbnQ4Yml0IC0gMHgxMDAgOiBpbnQ4Yml0O1xuXHRcdH0sXG5cdFxuXHRcdC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b3VpbnQ4XG5cdFx0VG9VaW50ODogZnVuY3Rpb24gVG9VaW50OChhcmd1bWVudCkge1xuXHRcdFx0dmFyIG51bWJlciA9IHRoaXMuVG9OdW1iZXIoYXJndW1lbnQpO1xuXHRcdFx0aWYgKCRpc05hTihudW1iZXIpIHx8IG51bWJlciA9PT0gMCB8fCAhJGlzRmluaXRlKG51bWJlcikpIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cdFx0XHR2YXIgcG9zSW50ID0gc2lnbihudW1iZXIpICogTWF0aC5mbG9vcihNYXRoLmFicyhudW1iZXIpKTtcblx0XHRcdHJldHVybiBtb2QocG9zSW50LCAweDEwMCk7XG5cdFx0fSxcblx0XG5cdFx0Ly8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvdWludDhjbGFtcFxuXHRcdFRvVWludDhDbGFtcDogZnVuY3Rpb24gVG9VaW50OENsYW1wKGFyZ3VtZW50KSB7XG5cdFx0XHR2YXIgbnVtYmVyID0gdGhpcy5Ub051bWJlcihhcmd1bWVudCk7XG5cdFx0XHRpZiAoJGlzTmFOKG51bWJlcikgfHwgbnVtYmVyIDw9IDApIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAobnVtYmVyID49IDB4RkYpIHtcblx0XHRcdFx0cmV0dXJuIDB4RkY7XG5cdFx0XHR9XG5cdFx0XHR2YXIgZiA9IE1hdGguZmxvb3IoYXJndW1lbnQpO1xuXHRcdFx0aWYgKGYgKyAwLjUgPCBudW1iZXIpIHtcblx0XHRcdFx0cmV0dXJuIGYgKyAxO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG51bWJlciA8IGYgKyAwLjUpIHtcblx0XHRcdFx0cmV0dXJuIGY7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZiAlIDIgIT09IDApIHtcblx0XHRcdFx0cmV0dXJuIGYgKyAxO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGY7XG5cdFx0fSxcblx0XG5cdFx0Ly8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvc3RyaW5nXG5cdFx0VG9TdHJpbmc6IGZ1bmN0aW9uIFRvU3RyaW5nKGFyZ3VtZW50KSB7XG5cdFx0XHRpZiAoKHR5cGVvZiBhcmd1bWVudCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYXJndW1lbnQpKSA9PT0gJ3N5bWJvbCcpIHtcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBTdHJpbmcoYXJndW1lbnQpO1xuXHRcdH0sXG5cdFxuXHRcdC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b29iamVjdFxuXHRcdFRvT2JqZWN0OiBmdW5jdGlvbiBUb09iamVjdCh2YWx1ZSkge1xuXHRcdFx0dGhpcy5SZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHZhbHVlKTtcblx0XHRcdHJldHVybiBPYmplY3QodmFsdWUpO1xuXHRcdH0sXG5cdFxuXHRcdC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b3Byb3BlcnR5a2V5XG5cdFx0VG9Qcm9wZXJ0eUtleTogZnVuY3Rpb24gVG9Qcm9wZXJ0eUtleShhcmd1bWVudCkge1xuXHRcdFx0dmFyIGtleSA9IHRoaXMuVG9QcmltaXRpdmUoYXJndW1lbnQsIFN0cmluZyk7XG5cdFx0XHRyZXR1cm4gKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGtleSkpID09PSAnc3ltYm9sJyA/IHN5bWJvbFRvU3RyLmNhbGwoa2V5KSA6IHRoaXMuVG9TdHJpbmcoa2V5KTtcblx0XHR9LFxuXHRcblx0XHQvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGhcblx0XHRUb0xlbmd0aDogZnVuY3Rpb24gVG9MZW5ndGgoYXJndW1lbnQpIHtcblx0XHRcdHZhciBsZW4gPSB0aGlzLlRvSW50ZWdlcihhcmd1bWVudCk7XG5cdFx0XHRpZiAobGVuIDw9IDApIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9IC8vIGluY2x1ZGVzIGNvbnZlcnRpbmcgLTAgdG8gKzBcblx0XHRcdGlmIChsZW4gPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG5cdFx0XHRcdHJldHVybiBNQVhfU0FGRV9JTlRFR0VSO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGxlbjtcblx0XHR9LFxuXHRcblx0XHQvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtY2Fub25pY2FsbnVtZXJpY2luZGV4c3RyaW5nXG5cdFx0Q2Fub25pY2FsTnVtZXJpY0luZGV4U3RyaW5nOiBmdW5jdGlvbiBDYW5vbmljYWxOdW1lcmljSW5kZXhTdHJpbmcoYXJndW1lbnQpIHtcblx0XHRcdGlmICh0b1N0ci5jYWxsKGFyZ3VtZW50KSAhPT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBiZSBhIHN0cmluZycpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3VtZW50ID09PSAnLTAnKSB7XG5cdFx0XHRcdHJldHVybiAtMDtcblx0XHRcdH1cblx0XHRcdHZhciBuID0gdGhpcy5Ub051bWJlcihhcmd1bWVudCk7XG5cdFx0XHRpZiAodGhpcy5TYW1lVmFsdWUodGhpcy5Ub1N0cmluZyhuKSwgYXJndW1lbnQpKSB7XG5cdFx0XHRcdHJldHVybiBuO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZvaWQgMDtcblx0XHR9LFxuXHRcblx0XHQvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtcmVxdWlyZW9iamVjdGNvZXJjaWJsZVxuXHRcdFJlcXVpcmVPYmplY3RDb2VyY2libGU6IEVTNS5DaGVja09iamVjdENvZXJjaWJsZSxcblx0XG5cdFx0Ly8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWlzYXJyYXlcblx0XHRJc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIElzQXJyYXkoYXJndW1lbnQpIHtcblx0XHRcdHJldHVybiB0b1N0ci5jYWxsKGFyZ3VtZW50KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcblx0XHR9LFxuXHRcblx0XHQvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtaXNjYWxsYWJsZVxuXHRcdC8vIElzQ2FsbGFibGU6IEVTNS5Jc0NhbGxhYmxlLFxuXHRcblx0XHQvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtaXNjb25zdHJ1Y3RvclxuXHRcdElzQ29uc3RydWN0b3I6IGZ1bmN0aW9uIElzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcblx0XHRcdHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT09ICdmdW5jdGlvbicgJiYgISFhcmd1bWVudC5wcm90b3R5cGU7IC8vIHVuZm9ydHVuYXRlbHkgdGhlcmUncyBubyB3YXkgdG8gdHJ1bHkgY2hlY2sgdGhpcyB3aXRob3V0IHRyeS9jYXRjaCBgbmV3IGFyZ3VtZW50YFxuXHRcdH0sXG5cdFxuXHRcdC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1pc2V4dGVuc2libGUtb1xuXHRcdElzRXh0ZW5zaWJsZTogZnVuY3Rpb24gSXNFeHRlbnNpYmxlKG9iaikge1xuXHRcdFx0aWYgKCFPYmplY3QucHJldmVudEV4dGVuc2lvbnMpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXNQcmltaXRpdmUob2JqKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmlzRXh0ZW5zaWJsZShvYmopO1xuXHRcdH0sXG5cdFxuXHRcdC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1pc2ludGVnZXJcblx0XHRJc0ludGVnZXI6IGZ1bmN0aW9uIElzSW50ZWdlcihhcmd1bWVudCkge1xuXHRcdFx0aWYgKHR5cGVvZiBhcmd1bWVudCAhPT0gJ251bWJlcicgfHwgJGlzTmFOKGFyZ3VtZW50KSB8fCAhJGlzRmluaXRlKGFyZ3VtZW50KSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgYWJzID0gTWF0aC5hYnMoYXJndW1lbnQpO1xuXHRcdFx0cmV0dXJuIE1hdGguZmxvb3IoYWJzKSA9PT0gYWJzO1xuXHRcdH0sXG5cdFxuXHRcdC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1pc3Byb3BlcnR5a2V5XG5cdFx0SXNQcm9wZXJ0eUtleTogZnVuY3Rpb24gSXNQcm9wZXJ0eUtleShhcmd1bWVudCkge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PT0gJ3N0cmluZycgfHwgKHR5cGVvZiBhcmd1bWVudCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYXJndW1lbnQpKSA9PT0gJ3N5bWJvbCc7XG5cdFx0fSxcblx0XG5cdFx0Ly8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWlzcmVnZXhwXG5cdFx0SXNSZWdFeHA6IGZ1bmN0aW9uIElzUmVnRXhwKGFyZ3VtZW50KSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50IHx8ICh0eXBlb2YgYXJndW1lbnQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGFyZ3VtZW50KSkgIT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmIChoYXNTeW1ib2xzKSB7XG5cdFx0XHRcdHZhciBpc1JlZ0V4cCA9IGFyZ3VtZW50W1N5bWJvbC5tYXRjaF07XG5cdFx0XHRcdGlmICh0eXBlb2YgaXNSZWdFeHAgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0cmV0dXJuIEVTNS5Ub0Jvb2xlYW4oaXNSZWdFeHApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaGFzUmVnRXhwTWF0Y2hlcihhcmd1bWVudCk7XG5cdFx0fSxcblx0XG5cdFx0Ly8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXNhbWV2YWx1ZVxuXHRcdC8vIFNhbWVWYWx1ZTogRVM1LlNhbWVWYWx1ZSxcblx0XG5cdFx0Ly8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXNhbWV2YWx1ZXplcm9cblx0XHRTYW1lVmFsdWVaZXJvOiBmdW5jdGlvbiBTYW1lVmFsdWVaZXJvKHgsIHkpIHtcblx0XHRcdHJldHVybiB4ID09PSB5IHx8ICRpc05hTih4KSAmJiAkaXNOYU4oeSk7XG5cdFx0fSxcblx0XG5cdFx0VHlwZTogZnVuY3Rpb24gVHlwZSh4KSB7XG5cdFx0XHRpZiAoKHR5cGVvZiB4ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih4KSkgPT09ICdzeW1ib2wnKSB7XG5cdFx0XHRcdHJldHVybiAnU3ltYm9sJztcblx0XHRcdH1cblx0XHRcdHJldHVybiBFUzUuVHlwZSh4KTtcblx0XHR9LFxuXHRcblx0XHQvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc3BlY2llc2NvbnN0cnVjdG9yXG5cdFx0U3BlY2llc0NvbnN0cnVjdG9yOiBmdW5jdGlvbiBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKSB7XG5cdFx0XHRpZiAodGhpcy5UeXBlKE8pICE9PSAnT2JqZWN0Jykge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdBc3NlcnRpb24gZmFpbGVkOiBUeXBlKE8pIGlzIG5vdCBPYmplY3QnKTtcblx0XHRcdH1cblx0XHRcdHZhciBDID0gTy5jb25zdHJ1Y3Rvcjtcblx0XHRcdGlmICh0eXBlb2YgQyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0cmV0dXJuIGRlZmF1bHRDb25zdHJ1Y3Rvcjtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLlR5cGUoQykgIT09ICdPYmplY3QnKSB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ08uY29uc3RydWN0b3IgaXMgbm90IGFuIE9iamVjdCcpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIFMgPSBoYXNTeW1ib2xzICYmIFN5bWJvbC5zcGVjaWVzID8gQ1tTeW1ib2wuc3BlY2llc10gOiB1bmRlZmluZWQ7XG5cdFx0XHRpZiAoUyA9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBkZWZhdWx0Q29uc3RydWN0b3I7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5Jc0NvbnN0cnVjdG9yKFMpKSB7XG5cdFx0XHRcdHJldHVybiBTO1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignbm8gY29uc3RydWN0b3IgZm91bmQnKTtcblx0XHR9XG5cdH0pO1xuXHRcblx0ZGVsZXRlIEVTNi5DaGVja09iamVjdENvZXJjaWJsZTsgLy8gcmVuYW1lZCBpbiBFUzYgdG8gUmVxdWlyZU9iamVjdENvZXJjaWJsZVxuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBFUzY7XG5cbi8qKiovIH0sXG4vKiA4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIGlzTmFOKGEpIHtcblx0XHRyZXR1cm4gYSAhPT0gYTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciAkaXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gKGEpIHtcblx0ICByZXR1cm4gYSAhPT0gYTtcblx0fTtcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gTnVtYmVyLmlzRmluaXRlIHx8IGZ1bmN0aW9uICh4KSB7XG5cdCAgcmV0dXJuIHR5cGVvZiB4ID09PSAnbnVtYmVyJyAmJiAhJGlzTmFOKHgpICYmIHggIT09IEluZmluaXR5ICYmIHggIT09IC1JbmZpbml0eTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDEwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cdHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHRtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuXHRcdFx0aWYgKGhhcy5jYWxsKHNvdXJjZSwga2V5KSkge1xuXHRcdFx0XHR0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMTEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaWduKG51bWJlcikge1xuXHRcdHJldHVybiBudW1iZXIgPj0gMCA/IDEgOiAtMTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDEyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbW9kKG51bWJlciwgbW9kdWxvKSB7XG5cdFx0dmFyIHJlbWFpbiA9IG51bWJlciAlIG1vZHVsbztcblx0XHRyZXR1cm4gTWF0aC5mbG9vcihyZW1haW4gPj0gMCA/IHJlbWFpbiA6IHJlbWFpbiArIG1vZHVsbyk7XG5cdH07XG5cbi8qKiovIH0sXG4vKiAxMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWx1ZSkge1xuXHRcdHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSAhPT0gJ29iamVjdCc7XG5cdH07XG5cbi8qKiovIH0sXG4vKiAxNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXHRcblx0dmFyIGhhc1N5bWJvbHMgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIF90eXBlb2YoU3ltYm9sLml0ZXJhdG9yKSA9PT0gJ3N5bWJvbCc7XG5cdFxuXHR2YXIgaXNQcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblx0dmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblx0dmFyIGlzRGF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXHR2YXIgaXNTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblx0XG5cdHZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gZnVuY3Rpb24gT3JkaW5hcnlUb1ByaW1pdGl2ZShPLCBoaW50KSB7XG5cdFx0aWYgKHR5cGVvZiBPID09PSAndW5kZWZpbmVkJyB8fCBPID09PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBtZXRob2Qgb24gJyArIE8pO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIGhpbnQgIT09ICdzdHJpbmcnIHx8IGhpbnQgIT09ICdudW1iZXInICYmIGhpbnQgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdoaW50IG11c3QgYmUgXCJzdHJpbmdcIiBvciBcIm51bWJlclwiJyk7XG5cdFx0fVxuXHRcdHZhciBtZXRob2ROYW1lcyA9IGhpbnQgPT09ICdzdHJpbmcnID8gWyd0b1N0cmluZycsICd2YWx1ZU9mJ10gOiBbJ3ZhbHVlT2YnLCAndG9TdHJpbmcnXTtcblx0XHR2YXIgbWV0aG9kLCByZXN1bHQsIGk7XG5cdFx0Zm9yIChpID0gMDsgaSA8IG1ldGhvZE5hbWVzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRtZXRob2QgPSBPW21ldGhvZE5hbWVzW2ldXTtcblx0XHRcdGlmIChpc0NhbGxhYmxlKG1ldGhvZCkpIHtcblx0XHRcdFx0cmVzdWx0ID0gbWV0aG9kLmNhbGwoTyk7XG5cdFx0XHRcdGlmIChpc1ByaW1pdGl2ZShyZXN1bHQpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdObyBkZWZhdWx0IHZhbHVlJyk7XG5cdH07XG5cdFxuXHR2YXIgR2V0TWV0aG9kID0gZnVuY3Rpb24gR2V0TWV0aG9kKE8sIFApIHtcblx0XHR2YXIgZnVuYyA9IE9bUF07XG5cdFx0aWYgKGZ1bmMgIT09IG51bGwgJiYgdHlwZW9mIGZ1bmMgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRpZiAoIWlzQ2FsbGFibGUoZnVuYykpIHtcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihmdW5jICsgJyByZXR1cm5lZCBmb3IgcHJvcGVydHkgJyArIFAgKyAnIG9mIG9iamVjdCAnICsgTyArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmdW5jO1xuXHRcdH1cblx0fTtcblx0XG5cdC8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b3ByaW1pdGl2ZVxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvUHJpbWl0aXZlKGlucHV0LCBQcmVmZXJyZWRUeXBlKSB7XG5cdFx0aWYgKGlzUHJpbWl0aXZlKGlucHV0KSkge1xuXHRcdFx0cmV0dXJuIGlucHV0O1xuXHRcdH1cblx0XHR2YXIgaGludCA9ICdkZWZhdWx0Jztcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdGlmIChQcmVmZXJyZWRUeXBlID09PSBTdHJpbmcpIHtcblx0XHRcdFx0aGludCA9ICdzdHJpbmcnO1xuXHRcdFx0fSBlbHNlIGlmIChQcmVmZXJyZWRUeXBlID09PSBOdW1iZXIpIHtcblx0XHRcdFx0aGludCA9ICdudW1iZXInO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0dmFyIGV4b3RpY1RvUHJpbTtcblx0XHRpZiAoaGFzU3ltYm9scykge1xuXHRcdFx0aWYgKFN5bWJvbC50b1ByaW1pdGl2ZSkge1xuXHRcdFx0XHRleG90aWNUb1ByaW0gPSBHZXRNZXRob2QoaW5wdXQsIFN5bWJvbC50b1ByaW1pdGl2ZSk7XG5cdFx0XHR9IGVsc2UgaWYgKGlzU3ltYm9sKGlucHV0KSkge1xuXHRcdFx0XHRleG90aWNUb1ByaW0gPSBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2Y7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgZXhvdGljVG9QcmltICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dmFyIHJlc3VsdCA9IGV4b3RpY1RvUHJpbS5jYWxsKGlucHV0LCBoaW50KTtcblx0XHRcdGlmIChpc1ByaW1pdGl2ZShyZXN1bHQpKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmFibGUgdG8gY29udmVydCBleG90aWMgb2JqZWN0IHRvIHByaW1pdGl2ZScpO1xuXHRcdH1cblx0XHRpZiAoaGludCA9PT0gJ2RlZmF1bHQnICYmIChpc0RhdGUoaW5wdXQpIHx8IGlzU3ltYm9sKGlucHV0KSkpIHtcblx0XHRcdGhpbnQgPSAnc3RyaW5nJztcblx0XHR9XG5cdFx0cmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIGhpbnQgPT09ICdkZWZhdWx0JyA/ICdudW1iZXInIDogaGludCk7XG5cdH07XG5cbi8qKiovIH0sXG4vKiAxNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWx1ZSkge1xuXHRcdHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSAhPT0gJ29iamVjdCc7XG5cdH07XG5cbi8qKiovIH0sXG4vKiAxNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXHRcblx0dmFyIGZuVG9TdHIgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cdFxuXHR2YXIgY29uc3RydWN0b3JSZWdleCA9IC9eXFxzKmNsYXNzIC87XG5cdHZhciBpc0VTNkNsYXNzRm4gPSBmdW5jdGlvbiBpc0VTNkNsYXNzRm4odmFsdWUpIHtcblx0XHR0cnkge1xuXHRcdFx0dmFyIGZuU3RyID0gZm5Ub1N0ci5jYWxsKHZhbHVlKTtcblx0XHRcdHZhciBzaW5nbGVTdHJpcHBlZCA9IGZuU3RyLnJlcGxhY2UoL1xcL1xcLy4qXFxuL2csICcnKTtcblx0XHRcdHZhciBtdWx0aVN0cmlwcGVkID0gc2luZ2xlU3RyaXBwZWQucmVwbGFjZSgvXFwvXFwqWy5cXHNcXFNdKlxcKlxcLy9nLCAnJyk7XG5cdFx0XHR2YXIgc3BhY2VTdHJpcHBlZCA9IG11bHRpU3RyaXBwZWQucmVwbGFjZSgvXFxuL21nLCAnICcpLnJlcGxhY2UoLyB7Mn0vZywgJyAnKTtcblx0XHRcdHJldHVybiBjb25zdHJ1Y3RvclJlZ2V4LnRlc3Qoc3BhY2VTdHJpcHBlZCk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlOyAvLyBub3QgYSBmdW5jdGlvblxuXHRcdH1cblx0fTtcblx0XG5cdHZhciB0cnlGdW5jdGlvbk9iamVjdCA9IGZ1bmN0aW9uIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGZuVG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXHR2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHR2YXIgZm5DbGFzcyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdHZhciBnZW5DbGFzcyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG5cdHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgX3R5cGVvZihTeW1ib2wudG9TdHJpbmdUYWcpID09PSAnc3ltYm9sJztcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNDYWxsYWJsZSh2YWx1ZSkge1xuXHRcdGlmICghdmFsdWUpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpZiAoaGFzVG9TdHJpbmdUYWcpIHtcblx0XHRcdHJldHVybiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSk7XG5cdFx0fVxuXHRcdGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHZhciBzdHJDbGFzcyA9IHRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiBzdHJDbGFzcyA9PT0gZm5DbGFzcyB8fCBzdHJDbGFzcyA9PT0gZ2VuQ2xhc3M7XG5cdH07XG5cbi8qKiovIH0sXG4vKiAxNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXHRcblx0dmFyIGdldERheSA9IERhdGUucHJvdG90eXBlLmdldERheTtcblx0dmFyIHRyeURhdGVPYmplY3QgPSBmdW5jdGlvbiB0cnlEYXRlT2JqZWN0KHZhbHVlKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGdldERheS5jYWxsKHZhbHVlKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG5cdFxuXHR2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHR2YXIgZGF0ZUNsYXNzID0gJ1tvYmplY3QgRGF0ZV0nO1xuXHR2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIF90eXBlb2YoU3ltYm9sLnRvU3RyaW5nVGFnKSA9PT0gJ3N5bWJvbCc7XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzRGF0ZU9iamVjdCh2YWx1ZSkge1xuXHRcdGlmICgodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gaGFzVG9TdHJpbmdUYWcgPyB0cnlEYXRlT2JqZWN0KHZhbHVlKSA6IHRvU3RyLmNhbGwodmFsdWUpID09PSBkYXRlQ2xhc3M7XG5cdH07XG5cbi8qKiovIH0sXG4vKiAxOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXHRcblx0dmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0dmFyIGhhc1N5bWJvbHMgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIF90eXBlb2YoU3ltYm9sKCkpID09PSAnc3ltYm9sJztcblx0XG5cdGlmIChoYXNTeW1ib2xzKSB7XG5cdFx0dmFyIHN5bVRvU3RyID0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZztcblx0XHR2YXIgc3ltU3RyaW5nUmVnZXggPSAvXlN5bWJvbFxcKC4qXFwpJC87XG5cdFx0dmFyIGlzU3ltYm9sT2JqZWN0ID0gZnVuY3Rpb24gaXNTeW1ib2xPYmplY3QodmFsdWUpIHtcblx0XHRcdGlmIChfdHlwZW9mKHZhbHVlLnZhbHVlT2YoKSkgIT09ICdzeW1ib2wnKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzeW1TdHJpbmdSZWdleC50ZXN0KHN5bVRvU3RyLmNhbGwodmFsdWUpKTtcblx0XHR9O1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcblx0XHRcdGlmICgodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpID09PSAnc3ltYm9sJykge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmICh0b1N0ci5jYWxsKHZhbHVlKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmV0dXJuIGlzU3ltYm9sT2JqZWN0KHZhbHVlKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuXHRcdFx0Ly8gdGhpcyBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IFN5bWJvbHMuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0fVxuXG4vKioqLyB9LFxuLyogMTkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciBpbXBsZW1lbnRhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBpbXBsZW1lbnRhdGlvbjtcblxuLyoqKi8gfSxcbi8qIDIwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgRVJST1JfTUVTU0FHRSA9ICdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICc7XG5cdHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblx0dmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0dmFyIGZ1bmNUeXBlID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZCh0aGF0KSB7XG5cdCAgICB2YXIgdGFyZ2V0ID0gdGhpcztcblx0ICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHRvU3RyLmNhbGwodGFyZ2V0KSAhPT0gZnVuY1R5cGUpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUk9SX01FU1NBR0UgKyB0YXJnZXQpO1xuXHQgICAgfVxuXHQgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdFxuXHQgICAgdmFyIGJvdW5kO1xuXHQgICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uIGJpbmRlcigpIHtcblx0ICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkodGhpcywgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG5cdCAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhhdCwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0XG5cdCAgICB2YXIgYm91bmRMZW5ndGggPSBNYXRoLm1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuXHQgICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgYm91bmRBcmdzLnB1c2goJyQnICsgaSk7XG5cdCAgICB9XG5cdFxuXHQgICAgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXHRcblx0ICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG5cdCAgICAgICAgdmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkoKSB7fTtcblx0ICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuXHQgICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuXHQgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG5cdCAgICB9XG5cdFxuXHQgICAgcmV0dXJuIGJvdW5kO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMjEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblx0XG5cdHZhciAkaXNOYU4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXHR2YXIgJGlzRmluaXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0XG5cdHZhciBzaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cdHZhciBtb2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblx0XG5cdHZhciBJc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cdHZhciB0b1ByaW1pdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuXHRcblx0Ly8gaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OVxuXHR2YXIgRVM1ID0ge1xuXHRcdFRvUHJpbWl0aXZlOiB0b1ByaW1pdGl2ZSxcblx0XG5cdFx0VG9Cb29sZWFuOiBmdW5jdGlvbiBUb0Jvb2xlYW4odmFsdWUpIHtcblx0XHRcdHJldHVybiBCb29sZWFuKHZhbHVlKTtcblx0XHR9LFxuXHRcdFRvTnVtYmVyOiBmdW5jdGlvbiBUb051bWJlcih2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIE51bWJlcih2YWx1ZSk7XG5cdFx0fSxcblx0XHRUb0ludGVnZXI6IGZ1bmN0aW9uIFRvSW50ZWdlcih2YWx1ZSkge1xuXHRcdFx0dmFyIG51bWJlciA9IHRoaXMuVG9OdW1iZXIodmFsdWUpO1xuXHRcdFx0aWYgKCRpc05hTihudW1iZXIpKSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG51bWJlciA9PT0gMCB8fCAhJGlzRmluaXRlKG51bWJlcikpIHtcblx0XHRcdFx0cmV0dXJuIG51bWJlcjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzaWduKG51bWJlcikgKiBNYXRoLmZsb29yKE1hdGguYWJzKG51bWJlcikpO1xuXHRcdH0sXG5cdFx0VG9JbnQzMjogZnVuY3Rpb24gVG9JbnQzMih4KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5Ub051bWJlcih4KSA+PiAwO1xuXHRcdH0sXG5cdFx0VG9VaW50MzI6IGZ1bmN0aW9uIFRvVWludDMyKHgpIHtcblx0XHRcdHJldHVybiB0aGlzLlRvTnVtYmVyKHgpID4+PiAwO1xuXHRcdH0sXG5cdFx0VG9VaW50MTY6IGZ1bmN0aW9uIFRvVWludDE2KHZhbHVlKSB7XG5cdFx0XHR2YXIgbnVtYmVyID0gdGhpcy5Ub051bWJlcih2YWx1ZSk7XG5cdFx0XHRpZiAoJGlzTmFOKG51bWJlcikgfHwgbnVtYmVyID09PSAwIHx8ICEkaXNGaW5pdGUobnVtYmVyKSkge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblx0XHRcdHZhciBwb3NJbnQgPSBzaWduKG51bWJlcikgKiBNYXRoLmZsb29yKE1hdGguYWJzKG51bWJlcikpO1xuXHRcdFx0cmV0dXJuIG1vZChwb3NJbnQsIDB4MTAwMDApO1xuXHRcdH0sXG5cdFx0VG9TdHJpbmc6IGZ1bmN0aW9uIFRvU3RyaW5nKHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gU3RyaW5nKHZhbHVlKTtcblx0XHR9LFxuXHRcdFRvT2JqZWN0OiBmdW5jdGlvbiBUb09iamVjdCh2YWx1ZSkge1xuXHRcdFx0dGhpcy5DaGVja09iamVjdENvZXJjaWJsZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gT2JqZWN0KHZhbHVlKTtcblx0XHR9LFxuXHRcdENoZWNrT2JqZWN0Q29lcmNpYmxlOiBmdW5jdGlvbiBDaGVja09iamVjdENvZXJjaWJsZSh2YWx1ZSwgb3B0TWVzc2FnZSkge1xuXHRcdFx0LyoganNoaW50IGVxbnVsbDp0cnVlICovXG5cdFx0XHRpZiAodmFsdWUgPT0gbnVsbCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKG9wdE1lc3NhZ2UgfHwgJ0Nhbm5vdCBjYWxsIG1ldGhvZCBvbiAnICsgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH0sXG5cdFx0SXNDYWxsYWJsZTogSXNDYWxsYWJsZSxcblx0XHRTYW1lVmFsdWU6IGZ1bmN0aW9uIFNhbWVWYWx1ZSh4LCB5KSB7XG5cdFx0XHRpZiAoeCA9PT0geSkge1xuXHRcdFx0XHQvLyAwID09PSAtMCwgYnV0IHRoZXkgYXJlIG5vdCBpZGVudGljYWwuXG5cdFx0XHRcdGlmICh4ID09PSAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIDEgLyB4ID09PSAxIC8geTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAkaXNOYU4oeCkgJiYgJGlzTmFOKHkpO1xuXHRcdH0sXG5cdFxuXHRcdC8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy04XG5cdFx0VHlwZTogZnVuY3Rpb24gVHlwZSh4KSB7XG5cdFx0XHRpZiAoeCA9PT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gJ051bGwnO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiB4ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRyZXR1cm4gJ1VuZGVmaW5lZCc7XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIHggPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiB4ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih4KSkgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHJldHVybiAnT2JqZWN0Jztcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0cmV0dXJuICdOdW1iZXInO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiB4ID09PSAnYm9vbGVhbicpIHtcblx0XHRcdFx0cmV0dXJuICdCb29sZWFuJztcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0cmV0dXJuICdTdHJpbmcnO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gRVM1O1xuXG4vKioqLyB9LFxuLyogMjIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cdFxuXHR2YXIgaXNQcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblx0XG5cdHZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cdFxuXHQvLyBodHRwczovL2VzNS5naXRodWIuaW8vI3g4LjEyXG5cdHZhciBFUzVpbnRlcm5hbFNsb3RzID0ge1xuXHRcdCdbW0RlZmF1bHRWYWx1ZV1dJzogZnVuY3Rpb24gRGVmYXVsdFZhbHVlKE8sIGhpbnQpIHtcblx0XHRcdHZhciBhY3R1YWxIaW50ID0gaGludCB8fCAodG9TdHIuY2FsbChPKSA9PT0gJ1tvYmplY3QgRGF0ZV0nID8gU3RyaW5nIDogTnVtYmVyKTtcblx0XG5cdFx0XHRpZiAoYWN0dWFsSGludCA9PT0gU3RyaW5nIHx8IGFjdHVhbEhpbnQgPT09IE51bWJlcikge1xuXHRcdFx0XHR2YXIgbWV0aG9kcyA9IGFjdHVhbEhpbnQgPT09IFN0cmluZyA/IFsndG9TdHJpbmcnLCAndmFsdWVPZiddIDogWyd2YWx1ZU9mJywgJ3RvU3RyaW5nJ107XG5cdFx0XHRcdHZhciB2YWx1ZSwgaTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHRpZiAoaXNDYWxsYWJsZShPW21ldGhvZHNbaV1dKSkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSBPW21ldGhvZHNbaV1dKCk7XG5cdFx0XHRcdFx0XHRpZiAoaXNQcmltaXRpdmUodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignTm8gZGVmYXVsdCB2YWx1ZScpO1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBbW0RlZmF1bHRWYWx1ZV1dIGhpbnQgc3VwcGxpZWQnKTtcblx0XHR9XG5cdH07XG5cdFxuXHQvLyBodHRwczovL2VzNS5naXRodWIuaW8vI3g5XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gVG9QcmltaXRpdmUoaW5wdXQsIFByZWZlcnJlZFR5cGUpIHtcblx0XHRpZiAoaXNQcmltaXRpdmUoaW5wdXQpKSB7XG5cdFx0XHRyZXR1cm4gaW5wdXQ7XG5cdFx0fVxuXHRcdHJldHVybiBFUzVpbnRlcm5hbFNsb3RzWydbW0RlZmF1bHRWYWx1ZV1dJ10oaW5wdXQsIFByZWZlcnJlZFR5cGUpO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMjMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblx0XG5cdHZhciByZWdleEV4ZWMgPSBSZWdFeHAucHJvdG90eXBlLmV4ZWM7XG5cdHZhciB0cnlSZWdleEV4ZWMgPSBmdW5jdGlvbiB0cnlSZWdleEV4ZWModmFsdWUpIHtcblx0XHR0cnkge1xuXHRcdFx0cmVnZXhFeGVjLmNhbGwodmFsdWUpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcblx0dmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0dmFyIHJlZ2V4Q2xhc3MgPSAnW29iamVjdCBSZWdFeHBdJztcblx0dmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBfdHlwZW9mKFN5bWJvbC50b1N0cmluZ1RhZykgPT09ICdzeW1ib2wnO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1JlZ2V4KHZhbHVlKSB7XG5cdFx0aWYgKCh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKSkgIT09ICdvYmplY3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiBoYXNUb1N0cmluZ1RhZyA/IHRyeVJlZ2V4RXhlYyh2YWx1ZSkgOiB0b1N0ci5jYWxsKHZhbHVlKSA9PT0gcmVnZXhDbGFzcztcblx0fTtcblxuLyoqKi8gfSxcbi8qIDI0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgRVMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXHR2YXIgaW1wbGVtZW50YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHRcblx0dmFyIHRyeUNhbGwgPSBmdW5jdGlvbiB0cnlDYWxsKGZuKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGZuKCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcblx0XHR2YXIgaW1wbGVtZW50ZWQgPSBFUy5Jc0NhbGxhYmxlKEFycmF5LmZyb20pICYmIHRyeUNhbGwoZnVuY3Rpb24gKCkge1xuXHRcdFx0QXJyYXkuZnJvbSh7ICdsZW5ndGgnOiAtSW5maW5pdHkgfSk7XG5cdFx0fSkgJiYgIXRyeUNhbGwoZnVuY3Rpb24gKCkge1xuXHRcdFx0QXJyYXkuZnJvbShbXSwgdW5kZWZpbmVkKTtcblx0XHR9KTtcblx0XG5cdFx0cmV0dXJuIGltcGxlbWVudGVkID8gQXJyYXkuZnJvbSA6IGltcGxlbWVudGF0aW9uO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMjUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciBkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHR2YXIgZ2V0UG9seWZpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbUFycmF5RnJvbSgpIHtcblx0XHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRcblx0XHRkZWZpbmUoQXJyYXksIHsgJ2Zyb20nOiBwb2x5ZmlsbCB9LCB7XG5cdFx0XHQnZnJvbSc6IGZ1bmN0aW9uIGZyb20oKSB7XG5cdFx0XHRcdHJldHVybiBBcnJheS5mcm9tICE9PSBwb2x5ZmlsbDtcblx0XHRcdH1cblx0XHR9KTtcblx0XG5cdFx0cmV0dXJuIHBvbHlmaWxsO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMjYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciBkZWZpbmVQcm9wZXJ0aWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0XG5cdHZhciBpbXBsZW1lbnRhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuXHR2YXIgZ2V0UG9seWZpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcblx0dmFyIHNoaW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcblx0XG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdFxuXHRkZWZpbmVQcm9wZXJ0aWVzKHBvbHlmaWxsLCB7XG5cdFx0aW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uLFxuXHRcdGdldFBvbHlmaWxsOiBnZXRQb2x5ZmlsbCxcblx0XHRzaGltOiBzaGltXG5cdH0pO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBwb2x5ZmlsbDtcblxuLyoqKi8gfSxcbi8qIDI3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHQvLyBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczYtc2hpbVxuXHRcblx0dmFyIGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHR2YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXHR2YXIgY2FuQmVPYmplY3QgPSBmdW5jdGlvbiBjYW5CZU9iamVjdChvYmopIHtcblx0XHRyZXR1cm4gdHlwZW9mIG9iaiAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqICE9PSBudWxsO1xuXHR9O1xuXHR2YXIgaGFzU3ltYm9scyA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpKCk7XG5cdHZhciB0b09iamVjdCA9IE9iamVjdDtcblx0dmFyIHB1c2ggPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuXHR2YXIgcHJvcElzRW51bWVyYWJsZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlKTtcblx0dmFyIG9yaWdpbmFsR2V0U3ltYm9scyA9IGhhc1N5bWJvbHMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzIDogbnVsbDtcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlMSkge1xuXHRcdGlmICghY2FuQmVPYmplY3QodGFyZ2V0KSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcigndGFyZ2V0IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG5cdFx0fVxuXHRcdHZhciBvYmpUYXJnZXQgPSB0b09iamVjdCh0YXJnZXQpO1xuXHRcdHZhciBzLCBzb3VyY2UsIGksIHByb3BzLCBzeW1zLCB2YWx1ZSwga2V5O1xuXHRcdGZvciAocyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyArK3MpIHtcblx0XHRcdHNvdXJjZSA9IHRvT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cdFx0XHRwcm9wcyA9IGtleXMoc291cmNlKTtcblx0XHRcdHZhciBnZXRTeW1ib2xzID0gaGFzU3ltYm9scyAmJiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyB8fCBvcmlnaW5hbEdldFN5bWJvbHMpO1xuXHRcdFx0aWYgKGdldFN5bWJvbHMpIHtcblx0XHRcdFx0c3ltcyA9IGdldFN5bWJvbHMoc291cmNlKTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHN5bXMubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHRrZXkgPSBzeW1zW2ldO1xuXHRcdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlKHNvdXJjZSwga2V5KSkge1xuXHRcdFx0XHRcdFx0cHVzaChwcm9wcywga2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRrZXkgPSBwcm9wc1tpXTtcblx0XHRcdFx0dmFsdWUgPSBzb3VyY2Vba2V5XTtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUoc291cmNlLCBrZXkpKSB7XG5cdFx0XHRcdFx0b2JqVGFyZ2V0W2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb2JqVGFyZ2V0O1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMjggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblx0XG5cdHZhciBrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzU3ltYm9scygpIHtcblx0XHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpZiAoX3R5cGVvZihTeW1ib2wuaXRlcmF0b3IpID09PSAnc3ltYm9sJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcblx0XHR2YXIgb2JqID0ge307XG5cdFx0dmFyIHN5bSA9IFN5bWJvbCgndGVzdCcpO1xuXHRcdHZhciBzeW1PYmogPSBPYmplY3Qoc3ltKTtcblx0XHRpZiAodHlwZW9mIHN5bSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFxuXHRcdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW1PYmopICE9PSAnW29iamVjdCBTeW1ib2xdJykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XG5cdFx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9vYmplY3QuYXNzaWduL2lzc3Vlcy8xN1xuXHRcdC8vIGlmIChzeW0gaW5zdGFuY2VvZiBTeW1ib2wpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzL2lzc3Vlcy80XG5cdFx0Ly8gaWYgKCEoc3ltT2JqIGluc3RhbmNlb2YgU3ltYm9sKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XG5cdFx0dmFyIHN5bVZhbCA9IDQyO1xuXHRcdG9ialtzeW1dID0gc3ltVmFsO1xuXHRcdGZvciAoc3ltIGluIG9iaikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpZiAoa2V5cyhvYmopLmxlbmd0aCAhPT0gMCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoICE9PSAwKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcblx0XHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoICE9PSAwKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcblx0XHR2YXIgc3ltcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcblx0XHRpZiAoc3ltcy5sZW5ndGggIT09IDEgfHwgc3ltc1swXSAhPT0gc3ltKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcblx0XHRpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHN5bSkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFxuXHRcdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgc3ltKTtcblx0XHRcdGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBzeW1WYWwgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlICE9PSB0cnVlKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMjkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciBpbXBsZW1lbnRhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuXHRcblx0dmFyIGxhY2tzUHJvcGVyRW51bWVyYXRpb25PcmRlciA9IGZ1bmN0aW9uIGxhY2tzUHJvcGVyRW51bWVyYXRpb25PcmRlcigpIHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0Ly8gdjgsIHNwZWNpZmljYWxseSBpbiBub2RlIDQueCwgaGFzIGEgYnVnIHdpdGggaW5jb3JyZWN0IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyXG5cdFx0Ly8gbm90ZTogdGhpcyBkb2VzIG5vdCBkZXRlY3QgdGhlIGJ1ZyB1bmxlc3MgdGhlcmUncyAyMCBjaGFyYWN0ZXJzXG5cdFx0dmFyIHN0ciA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG5cdFx0dmFyIGxldHRlcnMgPSBzdHIuc3BsaXQoJycpO1xuXHRcdHZhciBtYXAgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxldHRlcnMubGVuZ3RoOyArK2kpIHtcblx0XHRcdG1hcFtsZXR0ZXJzW2ldXSA9IGxldHRlcnNbaV07XG5cdFx0fVxuXHRcdHZhciBvYmogPSBPYmplY3QuYXNzaWduKHt9LCBtYXApO1xuXHRcdHZhciBhY3R1YWwgPSAnJztcblx0XHRmb3IgKHZhciBrIGluIG9iaikge1xuXHRcdFx0YWN0dWFsICs9IGs7XG5cdFx0fVxuXHRcdHJldHVybiBzdHIgIT09IGFjdHVhbDtcblx0fTtcblx0XG5cdHZhciBhc3NpZ25IYXNQZW5kaW5nRXhjZXB0aW9ucyA9IGZ1bmN0aW9uIGFzc2lnbkhhc1BlbmRpbmdFeGNlcHRpb25zKCkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbiB8fCAhT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdC8vIEZpcmVmb3ggMzcgc3RpbGwgaGFzIFwicGVuZGluZyBleGNlcHRpb25cIiBsb2dpYyBpbiBpdHMgT2JqZWN0LmFzc2lnbiBpbXBsZW1lbnRhdGlvbixcblx0XHQvLyB3aGljaCBpcyA3MiUgc2xvd2VyIHRoYW4gb3VyIHNoaW0sIGFuZCBGaXJlZm94IDQwJ3MgbmF0aXZlIGltcGxlbWVudGF0aW9uLlxuXHRcdHZhciB0aHJvd2VyID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHsgMTogMiB9KTtcblx0XHR0cnkge1xuXHRcdFx0T2JqZWN0LmFzc2lnbih0aHJvd2VyLCAneHknKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gdGhyb3dlclsxXSA9PT0gJ3knO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xuXHRcdH1cblx0XHRpZiAobGFja3NQcm9wZXJFbnVtZXJhdGlvbk9yZGVyKCkpIHtcblx0XHRcdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcblx0XHR9XG5cdFx0aWYgKGFzc2lnbkhhc1BlbmRpbmdFeGNlcHRpb25zKCkpIHtcblx0XHRcdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcblx0XHR9XG5cdFx0cmV0dXJuIE9iamVjdC5hc3NpZ247XG5cdH07XG5cbi8qKiovIH0sXG4vKiAzMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIGRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdHZhciBnZXRQb2x5ZmlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltQXNzaWduKCkge1xuXHRcdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdFx0ZGVmaW5lKE9iamVjdCwgeyBhc3NpZ246IHBvbHlmaWxsIH0sIHsgYXNzaWduOiBmdW5jdGlvbiBhc3NpZ24oKSB7XG5cdFx0XHRcdHJldHVybiBPYmplY3QuYXNzaWduICE9PSBwb2x5ZmlsbDtcblx0XHRcdH0gfSk7XG5cdFx0cmV0dXJuIHBvbHlmaWxsO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMzEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciByZXF1aXJlO3ZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzLCBnbG9iYWwpIHsndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cdFxuXHQvKiFcblx0ICogQG92ZXJ2aWV3IGVzNi1wcm9taXNlIC0gYSB0aW55IGltcGxlbWVudGF0aW9uIG9mIFByb21pc2VzL0ErLlxuXHQgKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCBZZWh1ZGEgS2F0eiwgVG9tIERhbGUsIFN0ZWZhbiBQZW5uZXIgYW5kIGNvbnRyaWJ1dG9ycyAoQ29udmVyc2lvbiB0byBFUzYgQVBJIGJ5IEpha2UgQXJjaGliYWxkKVxuXHQgKiBAbGljZW5zZSAgIExpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG5cdCAqICAgICAgICAgICAgU2VlIGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9zdGVmYW5wZW5uZXIvZXM2LXByb21pc2UvbWFzdGVyL0xJQ0VOU0Vcblx0ICogQHZlcnNpb24gICA0LjAuNVxuXHQgKi9cblx0XG5cdChmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdCAgKCBmYWxzZSA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihleHBvcnRzKSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOiAgdHJ1ZSA/ICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKGZhY3RvcnkpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID8gKF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSkpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpIDogZ2xvYmFsLkVTNlByb21pc2UgPSBmYWN0b3J5KCk7XG5cdH0pKHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkge1xuXHQgICd1c2Ugc3RyaWN0Jztcblx0XG5cdCAgZnVuY3Rpb24gb2JqZWN0T3JGdW5jdGlvbih4KSB7XG5cdCAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiB4ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih4KSkgPT09ICdvYmplY3QnICYmIHggIT09IG51bGw7XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHgpIHtcblx0ICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcblx0ICB9XG5cdFxuXHQgIHZhciBfaXNBcnJheSA9IHVuZGVmaW5lZDtcblx0ICBpZiAoIUFycmF5LmlzQXJyYXkpIHtcblx0ICAgIF9pc0FycmF5ID0gZnVuY3Rpb24gX2lzQXJyYXkoeCkge1xuXHQgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xuXHQgICAgfTtcblx0ICB9IGVsc2Uge1xuXHQgICAgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXHQgIH1cblx0XG5cdCAgdmFyIGlzQXJyYXkgPSBfaXNBcnJheTtcblx0XG5cdCAgdmFyIGxlbiA9IDA7XG5cdCAgdmFyIHZlcnR4TmV4dCA9IHVuZGVmaW5lZDtcblx0ICB2YXIgY3VzdG9tU2NoZWR1bGVyRm4gPSB1bmRlZmluZWQ7XG5cdFxuXHQgIHZhciBhc2FwID0gZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgYXJnKSB7XG5cdCAgICBxdWV1ZVtsZW5dID0gY2FsbGJhY2s7XG5cdCAgICBxdWV1ZVtsZW4gKyAxXSA9IGFyZztcblx0ICAgIGxlbiArPSAyO1xuXHQgICAgaWYgKGxlbiA9PT0gMikge1xuXHQgICAgICAvLyBJZiBsZW4gaXMgMiwgdGhhdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gc2NoZWR1bGUgYW4gYXN5bmMgZmx1c2guXG5cdCAgICAgIC8vIElmIGFkZGl0aW9uYWwgY2FsbGJhY2tzIGFyZSBxdWV1ZWQgYmVmb3JlIHRoZSBxdWV1ZSBpcyBmbHVzaGVkLCB0aGV5XG5cdCAgICAgIC8vIHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IHRoaXMgZmx1c2ggdGhhdCB3ZSBhcmUgc2NoZWR1bGluZy5cblx0ICAgICAgaWYgKGN1c3RvbVNjaGVkdWxlckZuKSB7XG5cdCAgICAgICAgY3VzdG9tU2NoZWR1bGVyRm4oZmx1c2gpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHNjaGVkdWxlRmx1c2goKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIGZ1bmN0aW9uIHNldFNjaGVkdWxlcihzY2hlZHVsZUZuKSB7XG5cdCAgICBjdXN0b21TY2hlZHVsZXJGbiA9IHNjaGVkdWxlRm47XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBzZXRBc2FwKGFzYXBGbikge1xuXHQgICAgYXNhcCA9IGFzYXBGbjtcblx0ICB9XG5cdFxuXHQgIHZhciBicm93c2VyV2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG5cdCAgdmFyIGJyb3dzZXJHbG9iYWwgPSBicm93c2VyV2luZG93IHx8IHt9O1xuXHQgIHZhciBCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9IGJyb3dzZXJHbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBicm93c2VyR2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG5cdCAgdmFyIGlzTm9kZSA9IHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYge30udG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuXHRcblx0ICAvLyB0ZXN0IGZvciB3ZWIgd29ya2VyIGJ1dCBub3QgaW4gSUUxMFxuXHQgIHZhciBpc1dvcmtlciA9IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGltcG9ydFNjcmlwdHMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCc7XG5cdFxuXHQgIC8vIG5vZGVcblx0ICBmdW5jdGlvbiB1c2VOZXh0VGljaygpIHtcblx0ICAgIC8vIG5vZGUgdmVyc2lvbiAwLjEwLnggZGlzcGxheXMgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHdoZW4gbmV4dFRpY2sgaXMgdXNlZCByZWN1cnNpdmVseVxuXHQgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jdWpvanMvd2hlbi9pc3N1ZXMvNDEwIGZvciBkZXRhaWxzXG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG5cdCAgICB9O1xuXHQgIH1cblx0XG5cdCAgLy8gdmVydHhcblx0ICBmdW5jdGlvbiB1c2VWZXJ0eFRpbWVyKCkge1xuXHQgICAgaWYgKHR5cGVvZiB2ZXJ0eE5leHQgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmVydHhOZXh0KGZsdXNoKTtcblx0ICAgICAgfTtcblx0ICAgIH1cblx0XG5cdCAgICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gdXNlTXV0YXRpb25PYnNlcnZlcigpIHtcblx0ICAgIHZhciBpdGVyYXRpb25zID0gMDtcblx0ICAgIHZhciBvYnNlcnZlciA9IG5ldyBCcm93c2VyTXV0YXRpb25PYnNlcnZlcihmbHVzaCk7XG5cdCAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcblx0ICAgIG9ic2VydmVyLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuXHRcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIG5vZGUuZGF0YSA9IGl0ZXJhdGlvbnMgPSArK2l0ZXJhdGlvbnMgJSAyO1xuXHQgICAgfTtcblx0ICB9XG5cdFxuXHQgIC8vIHdlYiB3b3JrZXJcblx0ICBmdW5jdGlvbiB1c2VNZXNzYWdlQ2hhbm5lbCgpIHtcblx0ICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG5cdCAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoO1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG5cdCAgICB9O1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gdXNlU2V0VGltZW91dCgpIHtcblx0ICAgIC8vIFN0b3JlIHNldFRpbWVvdXQgcmVmZXJlbmNlIHNvIGVzNi1wcm9taXNlIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuXHQgICAgLy8gb3RoZXIgY29kZSBtb2RpZnlpbmcgc2V0VGltZW91dCAobGlrZSBzaW5vbi51c2VGYWtlVGltZXJzKCkpXG5cdCAgICB2YXIgZ2xvYmFsU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gZ2xvYmFsU2V0VGltZW91dChmbHVzaCwgMSk7XG5cdCAgICB9O1xuXHQgIH1cblx0XG5cdCAgdmFyIHF1ZXVlID0gbmV3IEFycmF5KDEwMDApO1xuXHQgIGZ1bmN0aW9uIGZsdXNoKCkge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBxdWV1ZVtpXTtcblx0ICAgICAgdmFyIGFyZyA9IHF1ZXVlW2kgKyAxXTtcblx0XG5cdCAgICAgIGNhbGxiYWNrKGFyZyk7XG5cdFxuXHQgICAgICBxdWV1ZVtpXSA9IHVuZGVmaW5lZDtcblx0ICAgICAgcXVldWVbaSArIDFdID0gdW5kZWZpbmVkO1xuXHQgICAgfVxuXHRcblx0ICAgIGxlbiA9IDA7XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBhdHRlbXB0VmVydHgoKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICB2YXIgciA9IHJlcXVpcmU7XG5cdCAgICAgIHZhciB2ZXJ0eCA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xuXHQgICAgICB2ZXJ0eE5leHQgPSB2ZXJ0eC5ydW5Pbkxvb3AgfHwgdmVydHgucnVuT25Db250ZXh0O1xuXHQgICAgICByZXR1cm4gdXNlVmVydHhUaW1lcigpO1xuXHQgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xuXHQgICAgfVxuXHQgIH1cblx0XG5cdCAgdmFyIHNjaGVkdWxlRmx1c2ggPSB1bmRlZmluZWQ7XG5cdCAgLy8gRGVjaWRlIHdoYXQgYXN5bmMgbWV0aG9kIHRvIHVzZSB0byB0cmlnZ2VyaW5nIHByb2Nlc3Npbmcgb2YgcXVldWVkIGNhbGxiYWNrczpcblx0ICBpZiAoaXNOb2RlKSB7XG5cdCAgICBzY2hlZHVsZUZsdXNoID0gdXNlTmV4dFRpY2soKTtcblx0ICB9IGVsc2UgaWYgKEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG5cdCAgICBzY2hlZHVsZUZsdXNoID0gdXNlTXV0YXRpb25PYnNlcnZlcigpO1xuXHQgIH0gZWxzZSBpZiAoaXNXb3JrZXIpIHtcblx0ICAgIHNjaGVkdWxlRmx1c2ggPSB1c2VNZXNzYWdlQ2hhbm5lbCgpO1xuXHQgIH0gZWxzZSBpZiAoYnJvd3NlcldpbmRvdyA9PT0gdW5kZWZpbmVkICYmIFwiZnVuY3Rpb25cIiA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgc2NoZWR1bGVGbHVzaCA9IGF0dGVtcHRWZXJ0eCgpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBzY2hlZHVsZUZsdXNoID0gdXNlU2V0VGltZW91dCgpO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuXHQgICAgdmFyIF9hcmd1bWVudHMgPSBhcmd1bWVudHM7XG5cdFxuXHQgICAgdmFyIHBhcmVudCA9IHRoaXM7XG5cdFxuXHQgICAgdmFyIGNoaWxkID0gbmV3IHRoaXMuY29uc3RydWN0b3Iobm9vcCk7XG5cdFxuXHQgICAgaWYgKGNoaWxkW1BST01JU0VfSURdID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgbWFrZVByb21pc2UoY2hpbGQpO1xuXHQgICAgfVxuXHRcblx0ICAgIHZhciBfc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXHRcblx0ICAgIGlmIChfc3RhdGUpIHtcblx0ICAgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgY2FsbGJhY2sgPSBfYXJndW1lbnRzW19zdGF0ZSAtIDFdO1xuXHQgICAgICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgcmV0dXJuIGludm9rZUNhbGxiYWNrKF9zdGF0ZSwgY2hpbGQsIGNhbGxiYWNrLCBwYXJlbnQuX3Jlc3VsdCk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH0pKCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuXHQgICAgfVxuXHRcblx0ICAgIHJldHVybiBjaGlsZDtcblx0ICB9XG5cdFxuXHQgIC8qKlxuXHQgICAgYFByb21pc2UucmVzb2x2ZWAgcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSByZXNvbHZlZCB3aXRoIHRoZVxuXHQgICAgcGFzc2VkIGB2YWx1ZWAuIEl0IGlzIHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblx0ICBcblx0ICAgIGBgYGphdmFzY3JpcHRcblx0ICAgIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcblx0ICAgICAgcmVzb2x2ZSgxKTtcblx0ICAgIH0pO1xuXHQgIFxuXHQgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcblx0ICAgICAgLy8gdmFsdWUgPT09IDFcblx0ICAgIH0pO1xuXHQgICAgYGBgXG5cdCAgXG5cdCAgICBJbnN0ZWFkIG9mIHdyaXRpbmcgdGhlIGFib3ZlLCB5b3VyIGNvZGUgbm93IHNpbXBseSBiZWNvbWVzIHRoZSBmb2xsb3dpbmc6XG5cdCAgXG5cdCAgICBgYGBqYXZhc2NyaXB0XG5cdCAgICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgxKTtcblx0ICBcblx0ICAgIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG5cdCAgICAgIC8vIHZhbHVlID09PSAxXG5cdCAgICB9KTtcblx0ICAgIGBgYFxuXHQgIFxuXHQgICAgQG1ldGhvZCByZXNvbHZlXG5cdCAgICBAc3RhdGljXG5cdCAgICBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkIHdpdGhcblx0ICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cblx0ICAgIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIGZ1bGZpbGxlZCB3aXRoIHRoZSBnaXZlblxuXHQgICAgYHZhbHVlYFxuXHQgICovXG5cdCAgZnVuY3Rpb24gcmVzb2x2ZShvYmplY3QpIHtcblx0ICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG5cdCAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXHRcblx0ICAgIGlmIChvYmplY3QgJiYgKHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iamVjdCkpID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG5cdCAgICAgIHJldHVybiBvYmplY3Q7XG5cdCAgICB9XG5cdFxuXHQgICAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG5cdCAgICBfcmVzb2x2ZShwcm9taXNlLCBvYmplY3QpO1xuXHQgICAgcmV0dXJuIHByb21pc2U7XG5cdCAgfVxuXHRcblx0ICB2YXIgUFJPTUlTRV9JRCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygxNik7XG5cdFxuXHQgIGZ1bmN0aW9uIG5vb3AoKSB7fVxuXHRcblx0ICB2YXIgUEVORElORyA9IHZvaWQgMDtcblx0ICB2YXIgRlVMRklMTEVEID0gMTtcblx0ICB2YXIgUkVKRUNURUQgPSAyO1xuXHRcblx0ICB2YXIgR0VUX1RIRU5fRVJST1IgPSBuZXcgRXJyb3JPYmplY3QoKTtcblx0XG5cdCAgZnVuY3Rpb24gc2VsZkZ1bGZpbGxtZW50KCkge1xuXHQgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJZb3UgY2Fubm90IHJlc29sdmUgYSBwcm9taXNlIHdpdGggaXRzZWxmXCIpO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gY2Fubm90UmV0dXJuT3duKCkge1xuXHQgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGF0IHNhbWUgcHJvbWlzZS4nKTtcblx0ICB9XG5cdFxuXHQgIGZ1bmN0aW9uIGdldFRoZW4ocHJvbWlzZSkge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgcmV0dXJuIHByb21pc2UudGhlbjtcblx0ICAgIH0gY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgIEdFVF9USEVOX0VSUk9SLmVycm9yID0gZXJyb3I7XG5cdCAgICAgIHJldHVybiBHRVRfVEhFTl9FUlJPUjtcblx0ICAgIH1cblx0ICB9XG5cdFxuXHQgIGZ1bmN0aW9uIHRyeVRoZW4odGhlbiwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgdGhlbi5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuXHQgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICByZXR1cm4gZTtcblx0ICAgIH1cblx0ICB9XG5cdFxuXHQgIGZ1bmN0aW9uIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSwgdGhlbikge1xuXHQgICAgYXNhcChmdW5jdGlvbiAocHJvbWlzZSkge1xuXHQgICAgICB2YXIgc2VhbGVkID0gZmFsc2U7XG5cdCAgICAgIHZhciBlcnJvciA9IHRyeVRoZW4odGhlbiwgdGhlbmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIGlmIChzZWFsZWQpIHtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgc2VhbGVkID0gdHJ1ZTtcblx0ICAgICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG5cdCAgICAgICAgICBfcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuXHQgICAgICAgIGlmIChzZWFsZWQpIHtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgc2VhbGVkID0gdHJ1ZTtcblx0XG5cdCAgICAgICAgX3JlamVjdChwcm9taXNlLCByZWFzb24pO1xuXHQgICAgICB9LCAnU2V0dGxlOiAnICsgKHByb21pc2UuX2xhYmVsIHx8ICcgdW5rbm93biBwcm9taXNlJykpO1xuXHRcblx0ICAgICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcblx0ICAgICAgICBzZWFsZWQgPSB0cnVlO1xuXHQgICAgICAgIF9yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuXHQgICAgICB9XG5cdCAgICB9LCBwcm9taXNlKTtcblx0ICB9XG5cdFxuXHQgIGZ1bmN0aW9uIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlKSB7XG5cdCAgICBpZiAodGhlbmFibGUuX3N0YXRlID09PSBGVUxGSUxMRUQpIHtcblx0ICAgICAgZnVsZmlsbChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcblx0ICAgIH0gZWxzZSBpZiAodGhlbmFibGUuX3N0YXRlID09PSBSRUpFQ1RFRCkge1xuXHQgICAgICBfcmVqZWN0KHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgc3Vic2NyaWJlKHRoZW5hYmxlLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiBfcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG5cdCAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcblx0ICAgICAgICByZXR1cm4gX3JlamVjdChwcm9taXNlLCByZWFzb24pO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9XG5cdFxuXHQgIGZ1bmN0aW9uIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkKSB7XG5cdCAgICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3RvciAmJiB0aGVuJCQgPT09IHRoZW4gJiYgbWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3Rvci5yZXNvbHZlID09PSByZXNvbHZlKSB7XG5cdCAgICAgIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaWYgKHRoZW4kJCA9PT0gR0VUX1RIRU5fRVJST1IpIHtcblx0ICAgICAgICBfcmVqZWN0KHByb21pc2UsIEdFVF9USEVOX0VSUk9SLmVycm9yKTtcblx0ICAgICAgfSBlbHNlIGlmICh0aGVuJCQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG5cdCAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih0aGVuJCQpKSB7XG5cdCAgICAgICAgaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJCk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gX3Jlc29sdmUocHJvbWlzZSwgdmFsdWUpIHtcblx0ICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuXHQgICAgICBfcmVqZWN0KHByb21pc2UsIHNlbGZGdWxmaWxsbWVudCgpKTtcblx0ICAgIH0gZWxzZSBpZiAob2JqZWN0T3JGdW5jdGlvbih2YWx1ZSkpIHtcblx0ICAgICAgaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSwgZ2V0VGhlbih2YWx1ZSkpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBwdWJsaXNoUmVqZWN0aW9uKHByb21pc2UpIHtcblx0ICAgIGlmIChwcm9taXNlLl9vbmVycm9yKSB7XG5cdCAgICAgIHByb21pc2UuX29uZXJyb3IocHJvbWlzZS5fcmVzdWx0KTtcblx0ICAgIH1cblx0XG5cdCAgICBwdWJsaXNoKHByb21pc2UpO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gZnVsZmlsbChwcm9taXNlLCB2YWx1ZSkge1xuXHQgICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0XG5cdCAgICBwcm9taXNlLl9yZXN1bHQgPSB2YWx1ZTtcblx0ICAgIHByb21pc2UuX3N0YXRlID0gRlVMRklMTEVEO1xuXHRcblx0ICAgIGlmIChwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggIT09IDApIHtcblx0ICAgICAgYXNhcChwdWJsaXNoLCBwcm9taXNlKTtcblx0ICAgIH1cblx0ICB9XG5cdFxuXHQgIGZ1bmN0aW9uIF9yZWplY3QocHJvbWlzZSwgcmVhc29uKSB7XG5cdCAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgcHJvbWlzZS5fc3RhdGUgPSBSRUpFQ1RFRDtcblx0ICAgIHByb21pc2UuX3Jlc3VsdCA9IHJlYXNvbjtcblx0XG5cdCAgICBhc2FwKHB1Ymxpc2hSZWplY3Rpb24sIHByb21pc2UpO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG5cdCAgICB2YXIgX3N1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcblx0ICAgIHZhciBsZW5ndGggPSBfc3Vic2NyaWJlcnMubGVuZ3RoO1xuXHRcblx0ICAgIHBhcmVudC5fb25lcnJvciA9IG51bGw7XG5cdFxuXHQgICAgX3N1YnNjcmliZXJzW2xlbmd0aF0gPSBjaGlsZDtcblx0ICAgIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcblx0ICAgIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBSRUpFQ1RFRF0gPSBvblJlamVjdGlvbjtcblx0XG5cdCAgICBpZiAobGVuZ3RoID09PSAwICYmIHBhcmVudC5fc3RhdGUpIHtcblx0ICAgICAgYXNhcChwdWJsaXNoLCBwYXJlbnQpO1xuXHQgICAgfVxuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gcHVibGlzaChwcm9taXNlKSB7XG5cdCAgICB2YXIgc3Vic2NyaWJlcnMgPSBwcm9taXNlLl9zdWJzY3JpYmVycztcblx0ICAgIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cdFxuXHQgICAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdFxuXHQgICAgdmFyIGNoaWxkID0gdW5kZWZpbmVkLFxuXHQgICAgICAgIGNhbGxiYWNrID0gdW5kZWZpbmVkLFxuXHQgICAgICAgIGRldGFpbCA9IHByb21pc2UuX3Jlc3VsdDtcblx0XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSArPSAzKSB7XG5cdCAgICAgIGNoaWxkID0gc3Vic2NyaWJlcnNbaV07XG5cdCAgICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXHRcblx0ICAgICAgaWYgKGNoaWxkKSB7XG5cdCAgICAgICAgaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICBwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggPSAwO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gRXJyb3JPYmplY3QoKSB7XG5cdCAgICB0aGlzLmVycm9yID0gbnVsbDtcblx0ICB9XG5cdFxuXHQgIHZhciBUUllfQ0FUQ0hfRVJST1IgPSBuZXcgRXJyb3JPYmplY3QoKTtcblx0XG5cdCAgZnVuY3Rpb24gdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCkge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgcmV0dXJuIGNhbGxiYWNrKGRldGFpbCk7XG5cdCAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgIFRSWV9DQVRDSF9FUlJPUi5lcnJvciA9IGU7XG5cdCAgICAgIHJldHVybiBUUllfQ0FUQ0hfRVJST1I7XG5cdCAgICB9XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBwcm9taXNlLCBjYWxsYmFjaywgZGV0YWlsKSB7XG5cdCAgICB2YXIgaGFzQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKGNhbGxiYWNrKSxcblx0ICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZCxcblx0ICAgICAgICBlcnJvciA9IHVuZGVmaW5lZCxcblx0ICAgICAgICBzdWNjZWVkZWQgPSB1bmRlZmluZWQsXG5cdCAgICAgICAgZmFpbGVkID0gdW5kZWZpbmVkO1xuXHRcblx0ICAgIGlmIChoYXNDYWxsYmFjaykge1xuXHQgICAgICB2YWx1ZSA9IHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpO1xuXHRcblx0ICAgICAgaWYgKHZhbHVlID09PSBUUllfQ0FUQ0hfRVJST1IpIHtcblx0ICAgICAgICBmYWlsZWQgPSB0cnVlO1xuXHQgICAgICAgIGVycm9yID0gdmFsdWUuZXJyb3I7XG5cdCAgICAgICAgdmFsdWUgPSBudWxsO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuXHQgICAgICAgIF9yZWplY3QocHJvbWlzZSwgY2Fubm90UmV0dXJuT3duKCkpO1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdmFsdWUgPSBkZXRhaWw7XG5cdCAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG5cdCAgICB9XG5cdFxuXHQgICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG5cdCAgICAgIC8vIG5vb3Bcblx0ICAgIH0gZWxzZSBpZiAoaGFzQ2FsbGJhY2sgJiYgc3VjY2VlZGVkKSB7XG5cdCAgICAgIF9yZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcblx0ICAgIH0gZWxzZSBpZiAoZmFpbGVkKSB7XG5cdCAgICAgIF9yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuXHQgICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBGVUxGSUxMRUQpIHtcblx0ICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG5cdCAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IFJFSkVDVEVEKSB7XG5cdCAgICAgIF9yZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuXHQgICAgfVxuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gaW5pdGlhbGl6ZVByb21pc2UocHJvbWlzZSwgcmVzb2x2ZXIpIHtcblx0ICAgIHRyeSB7XG5cdCAgICAgIHJlc29sdmVyKGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKSB7XG5cdCAgICAgICAgX3Jlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuXHQgICAgICB9LCBmdW5jdGlvbiByZWplY3RQcm9taXNlKHJlYXNvbikge1xuXHQgICAgICAgIF9yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcblx0ICAgICAgfSk7XG5cdCAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgIF9yZWplY3QocHJvbWlzZSwgZSk7XG5cdCAgICB9XG5cdCAgfVxuXHRcblx0ICB2YXIgaWQgPSAwO1xuXHQgIGZ1bmN0aW9uIG5leHRJZCgpIHtcblx0ICAgIHJldHVybiBpZCsrO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gbWFrZVByb21pc2UocHJvbWlzZSkge1xuXHQgICAgcHJvbWlzZVtQUk9NSVNFX0lEXSA9IGlkKys7XG5cdCAgICBwcm9taXNlLl9zdGF0ZSA9IHVuZGVmaW5lZDtcblx0ICAgIHByb21pc2UuX3Jlc3VsdCA9IHVuZGVmaW5lZDtcblx0ICAgIHByb21pc2UuX3N1YnNjcmliZXJzID0gW107XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBFbnVtZXJhdG9yKENvbnN0cnVjdG9yLCBpbnB1dCkge1xuXHQgICAgdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuXHQgICAgdGhpcy5wcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuXHRcblx0ICAgIGlmICghdGhpcy5wcm9taXNlW1BST01JU0VfSURdKSB7XG5cdCAgICAgIG1ha2VQcm9taXNlKHRoaXMucHJvbWlzZSk7XG5cdCAgICB9XG5cdFxuXHQgICAgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG5cdCAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cdCAgICAgIHRoaXMubGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXHQgICAgICB0aGlzLl9yZW1haW5pbmcgPSBpbnB1dC5sZW5ndGg7XG5cdFxuXHQgICAgICB0aGlzLl9yZXN1bHQgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXHRcblx0ICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLmxlbmd0aCB8fCAwO1xuXHQgICAgICAgIHRoaXMuX2VudW1lcmF0ZSgpO1xuXHQgICAgICAgIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcblx0ICAgICAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgX3JlamVjdCh0aGlzLnByb21pc2UsIHZhbGlkYXRpb25FcnJvcigpKTtcblx0ICAgIH1cblx0ICB9XG5cdFxuXHQgIGZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcigpIHtcblx0ICAgIHJldHVybiBuZXcgRXJyb3IoJ0FycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheScpO1xuXHQgIH07XG5cdFxuXHQgIEVudW1lcmF0b3IucHJvdG90eXBlLl9lbnVtZXJhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG5cdCAgICB2YXIgX2lucHV0ID0gdGhpcy5faW5wdXQ7XG5cdFxuXHQgICAgZm9yICh2YXIgaSA9IDA7IHRoaXMuX3N0YXRlID09PSBQRU5ESU5HICYmIGkgPCBsZW5ndGg7IGkrKykge1xuXHQgICAgICB0aGlzLl9lYWNoRW50cnkoX2lucHV0W2ldLCBpKTtcblx0ICAgIH1cblx0ICB9O1xuXHRcblx0ICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fZWFjaEVudHJ5ID0gZnVuY3Rpb24gKGVudHJ5LCBpKSB7XG5cdCAgICB2YXIgYyA9IHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3I7XG5cdCAgICB2YXIgcmVzb2x2ZSQkID0gYy5yZXNvbHZlO1xuXHRcblx0ICAgIGlmIChyZXNvbHZlJCQgPT09IHJlc29sdmUpIHtcblx0ICAgICAgdmFyIF90aGVuID0gZ2V0VGhlbihlbnRyeSk7XG5cdFxuXHQgICAgICBpZiAoX3RoZW4gPT09IHRoZW4gJiYgZW50cnkuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG5cdCAgICAgICAgdGhpcy5fc2V0dGxlZEF0KGVudHJ5Ll9zdGF0ZSwgaSwgZW50cnkuX3Jlc3VsdCk7XG5cdCAgICAgIH0gZWxzZSBpZiAodHlwZW9mIF90aGVuICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG5cdCAgICAgICAgdGhpcy5fcmVzdWx0W2ldID0gZW50cnk7XG5cdCAgICAgIH0gZWxzZSBpZiAoYyA9PT0gUHJvbWlzZSkge1xuXHQgICAgICAgIHZhciBwcm9taXNlID0gbmV3IGMobm9vcCk7XG5cdCAgICAgICAgaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBlbnRyeSwgX3RoZW4pO1xuXHQgICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChwcm9taXNlLCBpKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLl93aWxsU2V0dGxlQXQobmV3IGMoZnVuY3Rpb24gKHJlc29sdmUkJCkge1xuXHQgICAgICAgICAgcmV0dXJuIHJlc29sdmUkJChlbnRyeSk7XG5cdCAgICAgICAgfSksIGkpO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLl93aWxsU2V0dGxlQXQocmVzb2x2ZSQkKGVudHJ5KSwgaSk7XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgRW51bWVyYXRvci5wcm90b3R5cGUuX3NldHRsZWRBdCA9IGZ1bmN0aW9uIChzdGF0ZSwgaSwgdmFsdWUpIHtcblx0ICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuXHRcblx0ICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gUEVORElORykge1xuXHQgICAgICB0aGlzLl9yZW1haW5pbmctLTtcblx0XG5cdCAgICAgIGlmIChzdGF0ZSA9PT0gUkVKRUNURUQpIHtcblx0ICAgICAgICBfcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSB2YWx1ZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcblx0ICAgICAgZnVsZmlsbChwcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIEVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbiAocHJvbWlzZSwgaSkge1xuXHQgICAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXHRcblx0ICAgIHN1YnNjcmliZShwcm9taXNlLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gZW51bWVyYXRvci5fc2V0dGxlZEF0KEZVTEZJTExFRCwgaSwgdmFsdWUpO1xuXHQgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuXHQgICAgICByZXR1cm4gZW51bWVyYXRvci5fc2V0dGxlZEF0KFJFSkVDVEVELCBpLCByZWFzb24pO1xuXHQgICAgfSk7XG5cdCAgfTtcblx0XG5cdCAgLyoqXG5cdCAgICBgUHJvbWlzZS5hbGxgIGFjY2VwdHMgYW4gYXJyYXkgb2YgcHJvbWlzZXMsIGFuZCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2hcblx0ICAgIGlzIGZ1bGZpbGxlZCB3aXRoIGFuIGFycmF5IG9mIGZ1bGZpbGxtZW50IHZhbHVlcyBmb3IgdGhlIHBhc3NlZCBwcm9taXNlcywgb3Jcblx0ICAgIHJlamVjdGVkIHdpdGggdGhlIHJlYXNvbiBvZiB0aGUgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQuIEl0IGNhc3RzIGFsbFxuXHQgICAgZWxlbWVudHMgb2YgdGhlIHBhc3NlZCBpdGVyYWJsZSB0byBwcm9taXNlcyBhcyBpdCBydW5zIHRoaXMgYWxnb3JpdGhtLlxuXHQgIFxuXHQgICAgRXhhbXBsZTpcblx0ICBcblx0ICAgIGBgYGphdmFzY3JpcHRcblx0ICAgIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG5cdCAgICBsZXQgcHJvbWlzZTIgPSByZXNvbHZlKDIpO1xuXHQgICAgbGV0IHByb21pc2UzID0gcmVzb2x2ZSgzKTtcblx0ICAgIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXHQgIFxuXHQgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuXHQgICAgICAvLyBUaGUgYXJyYXkgaGVyZSB3b3VsZCBiZSBbIDEsIDIsIDMgXTtcblx0ICAgIH0pO1xuXHQgICAgYGBgXG5cdCAgXG5cdCAgICBJZiBhbnkgb2YgdGhlIGBwcm9taXNlc2AgZ2l2ZW4gdG8gYGFsbGAgYXJlIHJlamVjdGVkLCB0aGUgZmlyc3QgcHJvbWlzZVxuXHQgICAgdGhhdCBpcyByZWplY3RlZCB3aWxsIGJlIGdpdmVuIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSByZXR1cm5lZCBwcm9taXNlcydzXG5cdCAgICByZWplY3Rpb24gaGFuZGxlci4gRm9yIGV4YW1wbGU6XG5cdCAgXG5cdCAgICBFeGFtcGxlOlxuXHQgIFxuXHQgICAgYGBgamF2YXNjcmlwdFxuXHQgICAgbGV0IHByb21pc2UxID0gcmVzb2x2ZSgxKTtcblx0ICAgIGxldCBwcm9taXNlMiA9IHJlamVjdChuZXcgRXJyb3IoXCIyXCIpKTtcblx0ICAgIGxldCBwcm9taXNlMyA9IHJlamVjdChuZXcgRXJyb3IoXCIzXCIpKTtcblx0ICAgIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXHQgIFxuXHQgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuXHQgICAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVucyBiZWNhdXNlIHRoZXJlIGFyZSByZWplY3RlZCBwcm9taXNlcyFcblx0ICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG5cdCAgICAgIC8vIGVycm9yLm1lc3NhZ2UgPT09IFwiMlwiXG5cdCAgICB9KTtcblx0ICAgIGBgYFxuXHQgIFxuXHQgICAgQG1ldGhvZCBhbGxcblx0ICAgIEBzdGF0aWNcblx0ICAgIEBwYXJhbSB7QXJyYXl9IGVudHJpZXMgYXJyYXkgb2YgcHJvbWlzZXNcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBvcHRpb25hbCBzdHJpbmcgZm9yIGxhYmVsaW5nIHRoZSBwcm9taXNlLlxuXHQgICAgVXNlZnVsIGZvciB0b29saW5nLlxuXHQgICAgQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIGFsbCBgcHJvbWlzZXNgIGhhdmUgYmVlblxuXHQgICAgZnVsZmlsbGVkLCBvciByZWplY3RlZCBpZiBhbnkgb2YgdGhlbSBiZWNvbWUgcmVqZWN0ZWQuXG5cdCAgICBAc3RhdGljXG5cdCAgKi9cblx0ICBmdW5jdGlvbiBhbGwoZW50cmllcykge1xuXHQgICAgcmV0dXJuIG5ldyBFbnVtZXJhdG9yKHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG5cdCAgfVxuXHRcblx0ICAvKipcblx0ICAgIGBQcm9taXNlLnJhY2VgIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaCBpcyBzZXR0bGVkIGluIHRoZSBzYW1lIHdheSBhcyB0aGVcblx0ICAgIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIHNldHRsZS5cblx0ICBcblx0ICAgIEV4YW1wbGU6XG5cdCAgXG5cdCAgICBgYGBqYXZhc2NyaXB0XG5cdCAgICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuXHQgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdCAgICAgICAgcmVzb2x2ZSgncHJvbWlzZSAxJyk7XG5cdCAgICAgIH0sIDIwMCk7XG5cdCAgICB9KTtcblx0ICBcblx0ICAgIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG5cdCAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblx0ICAgICAgICByZXNvbHZlKCdwcm9taXNlIDInKTtcblx0ICAgICAgfSwgMTAwKTtcblx0ICAgIH0pO1xuXHQgIFxuXHQgICAgUHJvbWlzZS5yYWNlKFtwcm9taXNlMSwgcHJvbWlzZTJdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG5cdCAgICAgIC8vIHJlc3VsdCA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBpdCB3YXMgcmVzb2x2ZWQgYmVmb3JlIHByb21pc2UxXG5cdCAgICAgIC8vIHdhcyByZXNvbHZlZC5cblx0ICAgIH0pO1xuXHQgICAgYGBgXG5cdCAgXG5cdCAgICBgUHJvbWlzZS5yYWNlYCBpcyBkZXRlcm1pbmlzdGljIGluIHRoYXQgb25seSB0aGUgc3RhdGUgb2YgdGhlIGZpcnN0XG5cdCAgICBzZXR0bGVkIHByb21pc2UgbWF0dGVycy4gRm9yIGV4YW1wbGUsIGV2ZW4gaWYgb3RoZXIgcHJvbWlzZXMgZ2l2ZW4gdG8gdGhlXG5cdCAgICBgcHJvbWlzZXNgIGFycmF5IGFyZ3VtZW50IGFyZSByZXNvbHZlZCwgYnV0IHRoZSBmaXJzdCBzZXR0bGVkIHByb21pc2UgaGFzXG5cdCAgICBiZWNvbWUgcmVqZWN0ZWQgYmVmb3JlIHRoZSBvdGhlciBwcm9taXNlcyBiZWNhbWUgZnVsZmlsbGVkLCB0aGUgcmV0dXJuZWRcblx0ICAgIHByb21pc2Ugd2lsbCBiZWNvbWUgcmVqZWN0ZWQ6XG5cdCAgXG5cdCAgICBgYGBqYXZhc2NyaXB0XG5cdCAgICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuXHQgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdCAgICAgICAgcmVzb2x2ZSgncHJvbWlzZSAxJyk7XG5cdCAgICAgIH0sIDIwMCk7XG5cdCAgICB9KTtcblx0ICBcblx0ICAgIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG5cdCAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblx0ICAgICAgICByZWplY3QobmV3IEVycm9yKCdwcm9taXNlIDInKSk7XG5cdCAgICAgIH0sIDEwMCk7XG5cdCAgICB9KTtcblx0ICBcblx0ICAgIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuXHQgICAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVuc1xuXHQgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcblx0ICAgICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgcHJvbWlzZSAyIGJlY2FtZSByZWplY3RlZCBiZWZvcmVcblx0ICAgICAgLy8gcHJvbWlzZSAxIGJlY2FtZSBmdWxmaWxsZWRcblx0ICAgIH0pO1xuXHQgICAgYGBgXG5cdCAgXG5cdCAgICBBbiBleGFtcGxlIHJlYWwtd29ybGQgdXNlIGNhc2UgaXMgaW1wbGVtZW50aW5nIHRpbWVvdXRzOlxuXHQgIFxuXHQgICAgYGBgamF2YXNjcmlwdFxuXHQgICAgUHJvbWlzZS5yYWNlKFthamF4KCdmb28uanNvbicpLCB0aW1lb3V0KDUwMDApXSlcblx0ICAgIGBgYFxuXHQgIFxuXHQgICAgQG1ldGhvZCByYWNlXG5cdCAgICBAc3RhdGljXG5cdCAgICBAcGFyYW0ge0FycmF5fSBwcm9taXNlcyBhcnJheSBvZiBwcm9taXNlcyB0byBvYnNlcnZlXG5cdCAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG5cdCAgICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2Ugd2hpY2ggc2V0dGxlcyBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlIGZpcnN0IHBhc3NlZFxuXHQgICAgcHJvbWlzZSB0byBzZXR0bGUuXG5cdCAgKi9cblx0ICBmdW5jdGlvbiByYWNlKGVudHJpZXMpIHtcblx0ICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG5cdCAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXHRcblx0ICAgIGlmICghaXNBcnJheShlbnRyaWVzKSkge1xuXHQgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcblx0ICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gcmFjZS4nKSk7XG5cdCAgICAgIH0pO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIENvbnN0cnVjdG9yLnJlc29sdmUoZW50cmllc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfVxuXHRcblx0ICAvKipcblx0ICAgIGBQcm9taXNlLnJlamVjdGAgcmV0dXJucyBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgcGFzc2VkIGByZWFzb25gLlxuXHQgICAgSXQgaXMgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXHQgIFxuXHQgICAgYGBgamF2YXNjcmlwdFxuXHQgICAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuXHQgICAgICByZWplY3QobmV3IEVycm9yKCdXSE9PUFMnKSk7XG5cdCAgICB9KTtcblx0ICBcblx0ICAgIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG5cdCAgICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuXHQgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcblx0ICAgICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdXSE9PUFMnXG5cdCAgICB9KTtcblx0ICAgIGBgYFxuXHQgIFxuXHQgICAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXHQgIFxuXHQgICAgYGBgamF2YXNjcmlwdFxuXHQgICAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcblx0ICBcblx0ICAgIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG5cdCAgICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuXHQgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcblx0ICAgICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdXSE9PUFMnXG5cdCAgICB9KTtcblx0ICAgIGBgYFxuXHQgIFxuXHQgICAgQG1ldGhvZCByZWplY3Rcblx0ICAgIEBzdGF0aWNcblx0ICAgIEBwYXJhbSB7QW55fSByZWFzb24gdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGguXG5cdCAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG5cdCAgICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgZ2l2ZW4gYHJlYXNvbmAuXG5cdCAgKi9cblx0ICBmdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG5cdCAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuXHQgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblx0ICAgIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuXHQgICAgX3JlamVjdChwcm9taXNlLCByZWFzb24pO1xuXHQgICAgcmV0dXJuIHByb21pc2U7XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBuZWVkc1Jlc29sdmVyKCkge1xuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gbmVlZHNOZXcoKSB7XG5cdCAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUHJvbWlzZSc6IFBsZWFzZSB1c2UgdGhlICduZXcnIG9wZXJhdG9yLCB0aGlzIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuXHQgIH1cblx0XG5cdCAgLyoqXG5cdCAgICBQcm9taXNlIG9iamVjdHMgcmVwcmVzZW50IHRoZSBldmVudHVhbCByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi4gVGhlXG5cdCAgICBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLCB3aGljaFxuXHQgICAgcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGUgcmVhc29uXG5cdCAgICB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblx0ICBcblx0ICAgIFRlcm1pbm9sb2d5XG5cdCAgICAtLS0tLS0tLS0tLVxuXHQgIFxuXHQgICAgLSBgcHJvbWlzZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHdpdGggYSBgdGhlbmAgbWV0aG9kIHdob3NlIGJlaGF2aW9yIGNvbmZvcm1zIHRvIHRoaXMgc3BlY2lmaWNhdGlvbi5cblx0ICAgIC0gYHRoZW5hYmxlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIGEgYHRoZW5gIG1ldGhvZC5cblx0ICAgIC0gYHZhbHVlYCBpcyBhbnkgbGVnYWwgSmF2YVNjcmlwdCB2YWx1ZSAoaW5jbHVkaW5nIHVuZGVmaW5lZCwgYSB0aGVuYWJsZSwgb3IgYSBwcm9taXNlKS5cblx0ICAgIC0gYGV4Y2VwdGlvbmAgaXMgYSB2YWx1ZSB0aGF0IGlzIHRocm93biB1c2luZyB0aGUgdGhyb3cgc3RhdGVtZW50LlxuXHQgICAgLSBgcmVhc29uYCBpcyBhIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoeSBhIHByb21pc2Ugd2FzIHJlamVjdGVkLlxuXHQgICAgLSBgc2V0dGxlZGAgdGhlIGZpbmFsIHJlc3Rpbmcgc3RhdGUgb2YgYSBwcm9taXNlLCBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG5cdCAgXG5cdCAgICBBIHByb21pc2UgY2FuIGJlIGluIG9uZSBvZiB0aHJlZSBzdGF0ZXM6IHBlbmRpbmcsIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQuXG5cdCAgXG5cdCAgICBQcm9taXNlcyB0aGF0IGFyZSBmdWxmaWxsZWQgaGF2ZSBhIGZ1bGZpbGxtZW50IHZhbHVlIGFuZCBhcmUgaW4gdGhlIGZ1bGZpbGxlZFxuXHQgICAgc3RhdGUuICBQcm9taXNlcyB0aGF0IGFyZSByZWplY3RlZCBoYXZlIGEgcmVqZWN0aW9uIHJlYXNvbiBhbmQgYXJlIGluIHRoZVxuXHQgICAgcmVqZWN0ZWQgc3RhdGUuICBBIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5ldmVyIGEgdGhlbmFibGUuXG5cdCAgXG5cdCAgICBQcm9taXNlcyBjYW4gYWxzbyBiZSBzYWlkIHRvICpyZXNvbHZlKiBhIHZhbHVlLiAgSWYgdGhpcyB2YWx1ZSBpcyBhbHNvIGFcblx0ICAgIHByb21pc2UsIHRoZW4gdGhlIG9yaWdpbmFsIHByb21pc2UncyBzZXR0bGVkIHN0YXRlIHdpbGwgbWF0Y2ggdGhlIHZhbHVlJ3Ncblx0ICAgIHNldHRsZWQgc3RhdGUuICBTbyBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2lsbFxuXHQgICAgaXRzZWxmIHJlamVjdCwgYW5kIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2lsbFxuXHQgICAgaXRzZWxmIGZ1bGZpbGwuXG5cdCAgXG5cdCAgXG5cdCAgICBCYXNpYyBVc2FnZTpcblx0ICAgIC0tLS0tLS0tLS0tLVxuXHQgIFxuXHQgICAgYGBganNcblx0ICAgIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgIC8vIG9uIHN1Y2Nlc3Ncblx0ICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG5cdCAgXG5cdCAgICAgIC8vIG9uIGZhaWx1cmVcblx0ICAgICAgcmVqZWN0KHJlYXNvbik7XG5cdCAgICB9KTtcblx0ICBcblx0ICAgIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAvLyBvbiBmdWxmaWxsbWVudFxuXHQgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG5cdCAgICAgIC8vIG9uIHJlamVjdGlvblxuXHQgICAgfSk7XG5cdCAgICBgYGBcblx0ICBcblx0ICAgIEFkdmFuY2VkIFVzYWdlOlxuXHQgICAgLS0tLS0tLS0tLS0tLS0tXG5cdCAgXG5cdCAgICBQcm9taXNlcyBzaGluZSB3aGVuIGFic3RyYWN0aW5nIGF3YXkgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBzdWNoIGFzXG5cdCAgICBgWE1MSHR0cFJlcXVlc3Rgcy5cblx0ICBcblx0ICAgIGBgYGpzXG5cdCAgICBmdW5jdGlvbiBnZXRKU09OKHVybCkge1xuXHQgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcblx0ICAgICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdCAgXG5cdCAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG5cdCAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZXI7XG5cdCAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcblx0ICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcblx0ICAgICAgICB4aHIuc2VuZCgpO1xuXHQgIFxuXHQgICAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG5cdCAgICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcblx0ICAgICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2dldEpTT046IGAnICsgdXJsICsgJ2AgZmFpbGVkIHdpdGggc3RhdHVzOiBbJyArIHRoaXMuc3RhdHVzICsgJ10nKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICBcblx0ICAgIGdldEpTT04oJy9wb3N0cy5qc29uJykudGhlbihmdW5jdGlvbihqc29uKSB7XG5cdCAgICAgIC8vIG9uIGZ1bGZpbGxtZW50XG5cdCAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcblx0ICAgICAgLy8gb24gcmVqZWN0aW9uXG5cdCAgICB9KTtcblx0ICAgIGBgYFxuXHQgIFxuXHQgICAgVW5saWtlIGNhbGxiYWNrcywgcHJvbWlzZXMgYXJlIGdyZWF0IGNvbXBvc2FibGUgcHJpbWl0aXZlcy5cblx0ICBcblx0ICAgIGBgYGpzXG5cdCAgICBQcm9taXNlLmFsbChbXG5cdCAgICAgIGdldEpTT04oJy9wb3N0cycpLFxuXHQgICAgICBnZXRKU09OKCcvY29tbWVudHMnKVxuXHQgICAgXSkudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuXHQgICAgICB2YWx1ZXNbMF0gLy8gPT4gcG9zdHNKU09OXG5cdCAgICAgIHZhbHVlc1sxXSAvLyA9PiBjb21tZW50c0pTT05cblx0ICBcblx0ICAgICAgcmV0dXJuIHZhbHVlcztcblx0ICAgIH0pO1xuXHQgICAgYGBgXG5cdCAgXG5cdCAgICBAY2xhc3MgUHJvbWlzZVxuXHQgICAgQHBhcmFtIHtmdW5jdGlvbn0gcmVzb2x2ZXJcblx0ICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cblx0ICAgIEBjb25zdHJ1Y3RvclxuXHQgICovXG5cdCAgZnVuY3Rpb24gUHJvbWlzZShyZXNvbHZlcikge1xuXHQgICAgdGhpc1tQUk9NSVNFX0lEXSA9IG5leHRJZCgpO1xuXHQgICAgdGhpcy5fcmVzdWx0ID0gdGhpcy5fc3RhdGUgPSB1bmRlZmluZWQ7XG5cdCAgICB0aGlzLl9zdWJzY3JpYmVycyA9IFtdO1xuXHRcblx0ICAgIGlmIChub29wICE9PSByZXNvbHZlcikge1xuXHQgICAgICB0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicgJiYgbmVlZHNSZXNvbHZlcigpO1xuXHQgICAgICB0aGlzIGluc3RhbmNlb2YgUHJvbWlzZSA/IGluaXRpYWxpemVQcm9taXNlKHRoaXMsIHJlc29sdmVyKSA6IG5lZWRzTmV3KCk7XG5cdCAgICB9XG5cdCAgfVxuXHRcblx0ICBQcm9taXNlLmFsbCA9IGFsbDtcblx0ICBQcm9taXNlLnJhY2UgPSByYWNlO1xuXHQgIFByb21pc2UucmVzb2x2ZSA9IHJlc29sdmU7XG5cdCAgUHJvbWlzZS5yZWplY3QgPSByZWplY3Q7XG5cdCAgUHJvbWlzZS5fc2V0U2NoZWR1bGVyID0gc2V0U2NoZWR1bGVyO1xuXHQgIFByb21pc2UuX3NldEFzYXAgPSBzZXRBc2FwO1xuXHQgIFByb21pc2UuX2FzYXAgPSBhc2FwO1xuXHRcblx0ICBQcm9taXNlLnByb3RvdHlwZSA9IHtcblx0ICAgIGNvbnN0cnVjdG9yOiBQcm9taXNlLFxuXHRcblx0ICAgIC8qKlxuXHQgICAgICBUaGUgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCxcblx0ICAgICAgd2hpY2ggcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGVcblx0ICAgICAgcmVhc29uIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXHQgICAgXG5cdCAgICAgIGBgYGpzXG5cdCAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcblx0ICAgICAgICAvLyB1c2VyIGlzIGF2YWlsYWJsZVxuXHQgICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuXHQgICAgICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG5cdCAgICAgIH0pO1xuXHQgICAgICBgYGBcblx0ICAgIFxuXHQgICAgICBDaGFpbmluZ1xuXHQgICAgICAtLS0tLS0tLVxuXHQgICAgXG5cdCAgICAgIFRoZSByZXR1cm4gdmFsdWUgb2YgYHRoZW5gIGlzIGl0c2VsZiBhIHByb21pc2UuICBUaGlzIHNlY29uZCwgJ2Rvd25zdHJlYW0nXG5cdCAgICAgIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmaXJzdCBwcm9taXNlJ3MgZnVsZmlsbG1lbnRcblx0ICAgICAgb3IgcmVqZWN0aW9uIGhhbmRsZXIsIG9yIHJlamVjdGVkIGlmIHRoZSBoYW5kbGVyIHRocm93cyBhbiBleGNlcHRpb24uXG5cdCAgICBcblx0ICAgICAgYGBganNcblx0ICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG5cdCAgICAgICAgcmV0dXJuIHVzZXIubmFtZTtcblx0ICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuXHQgICAgICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcblx0ICAgICAgfSkudGhlbihmdW5jdGlvbiAodXNlck5hbWUpIHtcblx0ICAgICAgICAvLyBJZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHVzZXJOYW1lYCB3aWxsIGJlIHRoZSB1c2VyJ3MgbmFtZSwgb3RoZXJ3aXNlIGl0XG5cdCAgICAgICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG5cdCAgICAgIH0pO1xuXHQgICAgXG5cdCAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknKTtcblx0ICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScpO1xuXHQgICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcblx0ICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuXHQgICAgICAgIC8vIGlmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgcmVhc29uYCB3aWxsIGJlICdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScuXG5cdCAgICAgICAgLy8gSWYgYGZpbmRVc2VyYCByZWplY3RlZCwgYHJlYXNvbmAgd2lsbCBiZSAnYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScuXG5cdCAgICAgIH0pO1xuXHQgICAgICBgYGBcblx0ICAgICAgSWYgdGhlIGRvd25zdHJlYW0gcHJvbWlzZSBkb2VzIG5vdCBzcGVjaWZ5IGEgcmVqZWN0aW9uIGhhbmRsZXIsIHJlamVjdGlvbiByZWFzb25zIHdpbGwgYmUgcHJvcGFnYXRlZCBmdXJ0aGVyIGRvd25zdHJlYW0uXG5cdCAgICBcblx0ICAgICAgYGBganNcblx0ICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFBlZGFnb2dpY2FsRXhjZXB0aW9uKCdVcHN0cmVhbSBlcnJvcicpO1xuXHQgICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcblx0ICAgICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAvLyBuZXZlciByZWFjaGVkXG5cdCAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcblx0ICAgICAgICAvLyBUaGUgYFBlZGdhZ29jaWFsRXhjZXB0aW9uYCBpcyBwcm9wYWdhdGVkIGFsbCB0aGUgd2F5IGRvd24gdG8gaGVyZVxuXHQgICAgICB9KTtcblx0ICAgICAgYGBgXG5cdCAgICBcblx0ICAgICAgQXNzaW1pbGF0aW9uXG5cdCAgICAgIC0tLS0tLS0tLS0tLVxuXHQgICAgXG5cdCAgICAgIFNvbWV0aW1lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIHRvIGEgZG93bnN0cmVhbSBwcm9taXNlIGNhbiBvbmx5IGJlXG5cdCAgICAgIHJldHJpZXZlZCBhc3luY2hyb25vdXNseS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgcmV0dXJuaW5nIGEgcHJvbWlzZSBpbiB0aGVcblx0ICAgICAgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uIGhhbmRsZXIuIFRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCB0aGVuIGJlIHBlbmRpbmdcblx0ICAgICAgdW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgc2V0dGxlZC4gVGhpcyBpcyBjYWxsZWQgKmFzc2ltaWxhdGlvbiouXG5cdCAgICBcblx0ICAgICAgYGBganNcblx0ICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG5cdCAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuXHQgICAgICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuXHQgICAgICAgIC8vIFRoZSB1c2VyJ3MgY29tbWVudHMgYXJlIG5vdyBhdmFpbGFibGVcblx0ICAgICAgfSk7XG5cdCAgICAgIGBgYFxuXHQgICAgXG5cdCAgICAgIElmIHRoZSBhc3NpbWxpYXRlZCBwcm9taXNlIHJlamVjdHMsIHRoZW4gdGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIGFsc28gcmVqZWN0LlxuXHQgICAgXG5cdCAgICAgIGBgYGpzXG5cdCAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuXHQgICAgICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcblx0ICAgICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcblx0ICAgICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIGZ1bGZpbGxzLCB3ZSdsbCBoYXZlIHRoZSB2YWx1ZSBoZXJlXG5cdCAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcblx0ICAgICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIHJlamVjdHMsIHdlJ2xsIGhhdmUgdGhlIHJlYXNvbiBoZXJlXG5cdCAgICAgIH0pO1xuXHQgICAgICBgYGBcblx0ICAgIFxuXHQgICAgICBTaW1wbGUgRXhhbXBsZVxuXHQgICAgICAtLS0tLS0tLS0tLS0tLVxuXHQgICAgXG5cdCAgICAgIFN5bmNocm9ub3VzIEV4YW1wbGVcblx0ICAgIFxuXHQgICAgICBgYGBqYXZhc2NyaXB0XG5cdCAgICAgIGxldCByZXN1bHQ7XG5cdCAgICBcblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICByZXN1bHQgPSBmaW5kUmVzdWx0KCk7XG5cdCAgICAgICAgLy8gc3VjY2Vzc1xuXHQgICAgICB9IGNhdGNoKHJlYXNvbikge1xuXHQgICAgICAgIC8vIGZhaWx1cmVcblx0ICAgICAgfVxuXHQgICAgICBgYGBcblx0ICAgIFxuXHQgICAgICBFcnJiYWNrIEV4YW1wbGVcblx0ICAgIFxuXHQgICAgICBgYGBqc1xuXHQgICAgICBmaW5kUmVzdWx0KGZ1bmN0aW9uKHJlc3VsdCwgZXJyKXtcblx0ICAgICAgICBpZiAoZXJyKSB7XG5cdCAgICAgICAgICAvLyBmYWlsdXJlXG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIC8vIHN1Y2Nlc3Ncblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgICBgYGBcblx0ICAgIFxuXHQgICAgICBQcm9taXNlIEV4YW1wbGU7XG5cdCAgICBcblx0ICAgICAgYGBgamF2YXNjcmlwdFxuXHQgICAgICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuXHQgICAgICAgIC8vIHN1Y2Nlc3Ncblx0ICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcblx0ICAgICAgICAvLyBmYWlsdXJlXG5cdCAgICAgIH0pO1xuXHQgICAgICBgYGBcblx0ICAgIFxuXHQgICAgICBBZHZhbmNlZCBFeGFtcGxlXG5cdCAgICAgIC0tLS0tLS0tLS0tLS0tXG5cdCAgICBcblx0ICAgICAgU3luY2hyb25vdXMgRXhhbXBsZVxuXHQgICAgXG5cdCAgICAgIGBgYGphdmFzY3JpcHRcblx0ICAgICAgbGV0IGF1dGhvciwgYm9va3M7XG5cdCAgICBcblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICBhdXRob3IgPSBmaW5kQXV0aG9yKCk7XG5cdCAgICAgICAgYm9va3MgID0gZmluZEJvb2tzQnlBdXRob3IoYXV0aG9yKTtcblx0ICAgICAgICAvLyBzdWNjZXNzXG5cdCAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG5cdCAgICAgICAgLy8gZmFpbHVyZVxuXHQgICAgICB9XG5cdCAgICAgIGBgYFxuXHQgICAgXG5cdCAgICAgIEVycmJhY2sgRXhhbXBsZVxuXHQgICAgXG5cdCAgICAgIGBgYGpzXG5cdCAgICBcblx0ICAgICAgZnVuY3Rpb24gZm91bmRCb29rcyhib29rcykge1xuXHQgICAgXG5cdCAgICAgIH1cblx0ICAgIFxuXHQgICAgICBmdW5jdGlvbiBmYWlsdXJlKHJlYXNvbikge1xuXHQgICAgXG5cdCAgICAgIH1cblx0ICAgIFxuXHQgICAgICBmaW5kQXV0aG9yKGZ1bmN0aW9uKGF1dGhvciwgZXJyKXtcblx0ICAgICAgICBpZiAoZXJyKSB7XG5cdCAgICAgICAgICBmYWlsdXJlKGVycik7XG5cdCAgICAgICAgICAvLyBmYWlsdXJlXG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIGZpbmRCb29va3NCeUF1dGhvcihhdXRob3IsIGZ1bmN0aW9uKGJvb2tzLCBlcnIpIHtcblx0ICAgICAgICAgICAgICBpZiAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICBmYWlsdXJlKGVycik7XG5cdCAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgIGZvdW5kQm9va3MoYm9va3MpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaChyZWFzb24pIHtcblx0ICAgICAgICAgICAgICAgICAgZmFpbHVyZShyZWFzb24pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICB9IGNhdGNoKGVycm9yKSB7XG5cdCAgICAgICAgICAgIGZhaWx1cmUoZXJyKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIC8vIHN1Y2Nlc3Ncblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgICBgYGBcblx0ICAgIFxuXHQgICAgICBQcm9taXNlIEV4YW1wbGU7XG5cdCAgICBcblx0ICAgICAgYGBgamF2YXNjcmlwdFxuXHQgICAgICBmaW5kQXV0aG9yKCkuXG5cdCAgICAgICAgdGhlbihmaW5kQm9va3NCeUF1dGhvcikuXG5cdCAgICAgICAgdGhlbihmdW5jdGlvbihib29rcyl7XG5cdCAgICAgICAgICAvLyBmb3VuZCBib29rc1xuXHQgICAgICB9KS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuXHQgICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG5cdCAgICAgIH0pO1xuXHQgICAgICBgYGBcblx0ICAgIFxuXHQgICAgICBAbWV0aG9kIHRoZW5cblx0ICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gb25GdWxmaWxsZWRcblx0ICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3RlZFxuXHQgICAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG5cdCAgICAgIEByZXR1cm4ge1Byb21pc2V9XG5cdCAgICAqL1xuXHQgICAgdGhlbjogdGhlbixcblx0XG5cdCAgICAvKipcblx0ICAgICAgYGNhdGNoYCBpcyBzaW1wbHkgc3VnYXIgZm9yIGB0aGVuKHVuZGVmaW5lZCwgb25SZWplY3Rpb24pYCB3aGljaCBtYWtlcyBpdCB0aGUgc2FtZVxuXHQgICAgICBhcyB0aGUgY2F0Y2ggYmxvY2sgb2YgYSB0cnkvY2F0Y2ggc3RhdGVtZW50LlxuXHQgICAgXG5cdCAgICAgIGBgYGpzXG5cdCAgICAgIGZ1bmN0aW9uIGZpbmRBdXRob3IoKXtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkbid0IGZpbmQgdGhhdCBhdXRob3InKTtcblx0ICAgICAgfVxuXHQgICAgXG5cdCAgICAgIC8vIHN5bmNocm9ub3VzXG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgZmluZEF1dGhvcigpO1xuXHQgICAgICB9IGNhdGNoKHJlYXNvbikge1xuXHQgICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG5cdCAgICAgIH1cblx0ICAgIFxuXHQgICAgICAvLyBhc3luYyB3aXRoIHByb21pc2VzXG5cdCAgICAgIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuXHQgICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG5cdCAgICAgIH0pO1xuXHQgICAgICBgYGBcblx0ICAgIFxuXHQgICAgICBAbWV0aG9kIGNhdGNoXG5cdCAgICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0aW9uXG5cdCAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cblx0ICAgICAgQHJldHVybiB7UHJvbWlzZX1cblx0ICAgICovXG5cdCAgICAnY2F0Y2gnOiBmdW5jdGlvbiBfY2F0Y2gob25SZWplY3Rpb24pIHtcblx0ICAgICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbik7XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgZnVuY3Rpb24gcG9seWZpbGwoKSB7XG5cdCAgICB2YXIgbG9jYWwgPSB1bmRlZmluZWQ7XG5cdFxuXHQgICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgIGxvY2FsID0gZ2xvYmFsO1xuXHQgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgbG9jYWwgPSBzZWxmO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICBsb2NhbCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdCAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvbHlmaWxsIGZhaWxlZCBiZWNhdXNlIGdsb2JhbCBvYmplY3QgaXMgdW5hdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgdmFyIFAgPSBsb2NhbC5Qcm9taXNlO1xuXHRcblx0ICAgIGlmIChQKSB7XG5cdCAgICAgIHZhciBwcm9taXNlVG9TdHJpbmcgPSBudWxsO1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHByb21pc2VUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQLnJlc29sdmUoKSk7XG5cdCAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAvLyBzaWxlbnRseSBpZ25vcmVkXG5cdCAgICAgIH1cblx0XG5cdCAgICAgIGlmIChwcm9taXNlVG9TdHJpbmcgPT09ICdbb2JqZWN0IFByb21pc2VdJyAmJiAhUC5jYXN0KSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgbG9jYWwuUHJvbWlzZSA9IFByb21pc2U7XG5cdCAgfVxuXHRcblx0ICAvLyBTdHJhbmdlIGNvbXBhdC4uXG5cdCAgUHJvbWlzZS5wb2x5ZmlsbCA9IHBvbHlmaWxsO1xuXHQgIFByb21pc2UuUHJvbWlzZSA9IFByb21pc2U7XG5cdFxuXHQgIHJldHVybiBQcm9taXNlO1xuXHR9KTtcblx0Ly8jIHNvdXJjZU1hcHBpbmdVUkw9ZXM2LXByb21pc2UubWFwXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKSwgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0sXG4vKiAzMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0Ly8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cdHZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblx0XG5cdC8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuXHQvLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcblx0Ly8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuXHQvLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXHRcblx0dmFyIGNhY2hlZFNldFRpbWVvdXQ7XG5cdHZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cdFxuXHRmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG5cdH1cblx0ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG5cdH1cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIHRyeSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuXHQgICAgICAgIH1cblx0ICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcblx0ICAgIH1cblx0ICAgIHRyeSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG5cdCAgICB9XG5cdH0pKCk7XG5cdGZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG5cdCAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuXHQgICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuXHQgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG5cdCAgICB9XG5cdCAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuXHQgICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG5cdCAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG5cdCAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcblx0ICAgIH1cblx0ICAgIHRyeSB7XG5cdCAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuXHQgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG5cdCAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG5cdCAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG5cdCAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdH1cblx0ZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuXHQgICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG5cdCAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG5cdCAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuXHQgICAgfVxuXHQgICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuXHQgICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG5cdCAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuXHQgICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcblx0ICAgIH1cblx0ICAgIHRyeSB7XG5cdCAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuXHQgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcblx0ICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG5cdCAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG5cdCAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcblx0ICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHR9XG5cdHZhciBxdWV1ZSA9IFtdO1xuXHR2YXIgZHJhaW5pbmcgPSBmYWxzZTtcblx0dmFyIGN1cnJlbnRRdWV1ZTtcblx0dmFyIHF1ZXVlSW5kZXggPSAtMTtcblx0XG5cdGZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcblx0ICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIGRyYWluaW5nID0gZmFsc2U7XG5cdCAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuXHQgICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcblx0ICAgIH1cblx0ICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcblx0ICAgICAgICBkcmFpblF1ZXVlKCk7XG5cdCAgICB9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG5cdCAgICBpZiAoZHJhaW5pbmcpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcblx0ICAgIGRyYWluaW5nID0gdHJ1ZTtcblx0XG5cdCAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuXHQgICAgd2hpbGUgKGxlbikge1xuXHQgICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuXHQgICAgICAgIHF1ZXVlID0gW107XG5cdCAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuXHQgICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG5cdCAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuXHQgICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcblx0ICAgIH1cblx0ICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG5cdCAgICBkcmFpbmluZyA9IGZhbHNlO1xuXHQgICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHR9XG5cdFxuXHRwcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuXHQgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuXHQgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcblx0ICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG5cdCAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcblx0ICAgIH1cblx0fTtcblx0XG5cdC8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcblx0ZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG5cdCAgICB0aGlzLmZ1biA9IGZ1bjtcblx0ICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcblx0fVxuXHRJdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcblx0fTtcblx0cHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcblx0cHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcblx0cHJvY2Vzcy5lbnYgPSB7fTtcblx0cHJvY2Vzcy5hcmd2ID0gW107XG5cdHByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xuXHRwcm9jZXNzLnZlcnNpb25zID0ge307XG5cdFxuXHRmdW5jdGlvbiBub29wKCkge31cblx0XG5cdHByb2Nlc3Mub24gPSBub29wO1xuXHRwcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcblx0cHJvY2Vzcy5vbmNlID0gbm9vcDtcblx0cHJvY2Vzcy5vZmYgPSBub29wO1xuXHRwcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcblx0cHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xuXHRwcm9jZXNzLmVtaXQgPSBub29wO1xuXHRcblx0cHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcblx0fTtcblx0XG5cdHByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuICcvJztcblx0fTtcblx0cHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG5cdH07XG5cdHByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gMDtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDMzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKiAoaWdub3JlZCkgKi9cblxuLyoqKi8gfSxcbi8qIDM0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cdHdpbmRvdy5jdXN0b21FbGVtZW50cyAmJiBldmFsKFwiLyoqXFxuICogQGxpY2Vuc2VcXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxcbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcXG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXFxuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcXG4gKi9cXG5cXG4vKipcXG4gKiBUaGlzIHNoaW0gYWxsb3dzIGVsZW1lbnRzIHdyaXR0ZW4gaW4sIG9yIGNvbXBpbGVkIHRvLCBFUzUgdG8gd29yayBvbiBuYXRpdmVcXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgQ3VzdG9tIEVsZW1lbnRzLlxcbiAqXFxuICogRVM1LXN0eWxlIGNsYXNzZXMgZG9uJ3Qgd29yayB3aXRoIG5hdGl2ZSBDdXN0b20gRWxlbWVudHMgYmVjYXVzZSB0aGVcXG4gKiBIVE1MRWxlbWVudCBjb25zdHJ1Y3RvciB1c2VzIHRoZSB2YWx1ZSBvZiBgbmV3LnRhcmdldGAgdG8gbG9vayB1cCB0aGUgY3VzdG9tXFxuICogZWxlbWVudCBkZWZpbml0aW9uIGZvciB0aGUgY3VycmVudGx5IGNhbGxlZCBjb25zdHJ1Y3Rvci4gYG5ldy50YXJnZXRgIGlzIG9ubHlcXG4gKiBzZXQgd2hlbiBgbmV3YCBpcyBjYWxsZWQgYW5kIGlzIG9ubHkgcHJvcGFnYXRlZCB2aWEgc3VwZXIoKSBjYWxscy4gc3VwZXIoKVxcbiAqIGlzIG5vdCBlbXVsYXRhYmxlIGluIEVTNS4gVGhlIHBhdHRlcm4gb2YgYFN1cGVyQ2xhc3MuY2FsbCh0aGlzKWBgIG9ubHkgd29ya3NcXG4gKiB3aGVuIGV4dGVuZGluZyBvdGhlciBFUzUtc3R5bGUgY2xhc3NlcywgYW5kIGRvZXMgbm90IHByb3BhZ2F0ZSBgbmV3LnRhcmdldGAuXFxuICpcXG4gKiBUaGlzIHNoaW0gYWxsb3dzIHRoZSBuYXRpdmUgSFRNTEVsZW1lbnQgY29uc3RydWN0b3IgdG8gd29yayBieSBnZW5lcmF0aW5nIGFuZFxcbiAqIHJlZ2lzdGVyaW5nIGEgc3RhbmQtaW4gY2xhc3MgaW5zdGVhZCBvZiB0aGUgdXNlcnMgY3VzdG9tIGVsZW1lbnQgY2xhc3MuIFRoaXNcXG4gKiBzdGFuZC1pbiBjbGFzcydzIGNvbnN0cnVjdG9yIGhhcyBhbiBhY3R1YWwgY2FsbCB0byBzdXBlcigpLlxcbiAqIGBjdXN0b21FbGVtZW50cy5kZWZpbmUoKWAgYW5kIGBjdXN0b21FbGVtZW50cy5nZXQoKWAgYXJlIGJvdGggb3ZlcnJpZGRlbiB0b1xcbiAqIGhpZGUgdGhpcyBzdGFuZC1pbiBjbGFzcyBmcm9tIHVzZXJzLlxcbiAqXFxuICogSW4gb3JkZXIgdG8gY3JlYXRlIGluc3RhbmNlIG9mIHRoZSB1c2VyLWRlZmluZWQgY2xhc3MsIHJhdGhlciB0aGFuIHRoZSBzdGFuZFxcbiAqIGluLCB0aGUgc3RhbmQtaW4ncyBjb25zdHJ1Y3RvciBzd2l6emxlcyBpdHMgaW5zdGFuY2VzIHByb3RvdHlwZSBhbmQgaW52b2tlc1xcbiAqIHRoZSB1c2VyLWRlZmluZWQgY29uc3RydWN0b3IuIFdoZW4gdGhlIHVzZXItZGVmaW5lZCBjb25zdHJ1Y3RvciBpcyBjYWxsZWRcXG4gKiBkaXJlY3RseSBpdCBjcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoZSBzdGFuZC1pbiBjbGFzcyB0byBnZXQgYSByZWFsIGV4dGVuc2lvblxcbiAqIG9mIEhUTUxFbGVtZW50IGFuZCByZXR1cm5zIHRoYXQuXFxuICpcXG4gKiBUaGVyZSBhcmUgdHdvIGltcG9ydGFudCBjb25zdHJ1Y3RvcnM6IEEgcGF0Y2hlZCBIVE1MRWxlbWVudCBjb25zdHJ1Y3RvciwgYW5kXFxuICogdGhlIFN0YW5kSW5FbGVtZW50IGNvbnN0cnVjdG9yLiBUaGV5IGJvdGggd2lsbCBiZSBjYWxsZWQgdG8gY3JlYXRlIGFuIGVsZW1lbnRcXG4gKiBidXQgd2hpY2ggaXMgY2FsbGVkIGZpcnN0IGRlcGVuZHMgb24gd2hldGhlciB0aGUgYnJvd3NlciBjcmVhdGVzIHRoZSBlbGVtZW50XFxuICogb3IgdGhlIHVzZXItZGVmaW5lZCBjb25zdHJ1Y3RvciBpcyBjYWxsZWQgZGlyZWN0bHkuIFRoZSB2YXJpYWJsZXNcXG4gKiBgYnJvd3NlckNvbnN0cnVjdGlvbmAgYW5kIGB1c2VyQ29uc3RydWN0aW9uYCBjb250cm9sIHRoZSBmbG93IGJldHdlZW4gdGhlXFxuICogdHdvIGNvbnN0cnVjdG9ycy5cXG4gKlxcbiAqIFRoaXMgc2hpbSBzaG91bGQgYmUgYmV0dGVyIHRoYW4gZm9yY2luZyB0aGUgcG9seWZpbGwgYmVjYXVzZTpcXG4gKiAgIDEuIEl0J3Mgc21hbGxlclxcbiAqICAgMi4gQWxsIHJlYWN0aW9uIHRpbWluZ3MgYXJlIHRoZSBzYW1lIGFzIG5hdGl2ZSAobW9zdGx5IHN5bmNocm9ub3VzKVxcbiAqICAgMy4gQWxsIHJlYWN0aW9uIHRyaWdnZXJpbmcgRE9NIG9wZXJhdGlvbnMgYXJlIGF1dG9tYXRpY2FsbHkgc3VwcG9ydGVkXFxuICpcXG4gKiBUaGVyZSBhcmUgc29tZSByZXN0cmljdGlvbnMgYW5kIHJlcXVpcmVtZW50cyBvbiBFUzUgY29uc3RydWN0b3JzOlxcbiAqICAgMS4gQWxsIGNvbnN0cnVjdG9ycyBpbiBhIGluaGVyaXRhbmNlIGhpZXJhcmNoeSBtdXN0IGJlIEVTNS1zdHlsZSwgc28gdGhhdFxcbiAqICAgICAgdGhleSBjYW4gYmUgY2FsbGVkIHdpdGggRnVuY3Rpb24uY2FsbCgpLiBUaGlzIGVmZmVjdGl2ZWx5IG1lYW5zIHRoYXQgdGhlXFxuICogICAgICB3aG9sZSBhcHBsaWNhdGlvbiBtdXN0IGJlIGNvbXBpbGVkIHRvIEVTNS5cXG4gKiAgIDIuIENvbnN0cnVjdG9ycyBtdXN0IHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGVtdWxhdGVkIHN1cGVyKCkgY2FsbC4gTGlrZVxcbiAqICAgICAgYHJldHVybiBTdXBlckNsYXNzLmNhbGwodGhpcylgXFxuICogICAzLiBUaGUgYHRoaXNgIHJlZmVyZW5jZSBzaG91bGQgbm90IGJlIHVzZWQgYmVmb3JlIHRoZSBlbXVsYXRlZCBzdXBlcigpIGNhbGxcXG4gKiAgICAgIGp1c3QgbGlrZSBgdGhpc2AgaXMgaWxsZWdhbCB0byB1c2UgYmVmb3JlIHN1cGVyKCkgaW4gRVM2LlxcbiAqICAgNC4gQ29uc3RydWN0b3JzIHNob3VsZCBub3QgY3JlYXRlIG90aGVyIGN1c3RvbSBlbGVtZW50cyBiZWZvcmUgdGhlIGVtdWxhdGVkXFxuICogICAgICBzdXBlcigpIGNhbGwuIFRoaXMgaXMgdGhlIHNhbWUgcmVzdHJpY3Rpb24gYXMgd2l0aCBuYXRpdmUgY3VzdG9tXFxuICogICAgICBlbGVtZW50cy5cXG4gKlxcbiAqICBDb21waWxpbmcgdmFsaWQgY2xhc3MtYmFzZWQgY3VzdG9tIGVsZW1lbnRzIHRvIEVTNSB3aWxsIHNhdGlzZnkgdGhlc2VcXG4gKiAgcmVxdWlyZW1lbnRzIHdpdGggdGhlIGxhdGVzdCB2ZXJzaW9uIG9mIHBvcHVsYXIgdHJhbnNwaWxlcnMuXFxuICovXFxuKCgpID0+IHtcXG4gICd1c2Ugc3RyaWN0JztcXG5cXG4gIC8vIERvIG5vdGhpbmcgaWYgYGN1c3RvbUVsZW1lbnRzYCBkb2VzIG5vdCBleGlzdC5cXG4gIGlmICghd2luZG93LmN1c3RvbUVsZW1lbnRzKSByZXR1cm47XFxuXFxuICBjb25zdCBOYXRpdmVIVE1MRWxlbWVudCA9IHdpbmRvdy5IVE1MRWxlbWVudDtcXG4gIGNvbnN0IG5hdGl2ZURlZmluZSA9IHdpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmU7XFxuICBjb25zdCBuYXRpdmVHZXQgPSB3aW5kb3cuY3VzdG9tRWxlbWVudHMuZ2V0O1xcblxcbiAgLyoqXFxuICAgKiBNYXAgb2YgdXNlci1wcm92aWRlZCBjb25zdHJ1Y3RvcnMgdG8gdGFnIG5hbWVzLlxcbiAgICpcXG4gICAqIEB0eXBlIHtNYXA8RnVuY3Rpb24sIHN0cmluZz59XFxuICAgKi9cXG4gIGNvbnN0IHRhZ25hbWVCeUNvbnN0cnVjdG9yID0gbmV3IE1hcCgpO1xcblxcbiAgLyoqXFxuICAgKiBNYXAgb2YgdGFnIG5hbWVzIHRvIHVzZXItcHJvdmlkZWQgY29uc3RydWN0b3JzLlxcbiAgICpcXG4gICAqIEB0eXBlIHtNYXA8c3RyaW5nLCBGdW5jdGlvbj59XFxuICAgKi9cXG4gIGNvbnN0IGNvbnN0cnVjdG9yQnlUYWduYW1lID0gbmV3IE1hcCgpO1xcblxcblxcbiAgLyoqXFxuICAgKiBXaGV0aGVyIHRoZSBjb25zdHJ1Y3RvcnMgYXJlIGJlaW5nIGNhbGxlZCBieSBhIGJyb3dzZXIgcHJvY2VzcywgaWUgcGFyc2luZ1xcbiAgICogb3IgY3JlYXRlRWxlbWVudC5cXG4gICAqL1xcbiAgbGV0IGJyb3dzZXJDb25zdHJ1Y3Rpb24gPSBmYWxzZTtcXG5cXG4gIC8qKlxcbiAgICogV2hldGhlciB0aGUgY29uc3RydWN0b3JzIGFyZSBiZWluZyBjYWxsZWQgYnkgYSB1c2VyLXNwYWNlIHByb2Nlc3MsIGllXFxuICAgKiBjYWxsaW5nIGFuIGVsZW1lbnQgY29uc3RydWN0b3IuXFxuICAgKi9cXG4gIGxldCB1c2VyQ29uc3RydWN0aW9uID0gZmFsc2U7XFxuXFxuICB3aW5kb3cuSFRNTEVsZW1lbnQgPSBmdW5jdGlvbigpIHtcXG4gICAgaWYgKCFicm93c2VyQ29uc3RydWN0aW9uKSB7XFxuICAgICAgY29uc3QgdGFnbmFtZSA9IHRhZ25hbWVCeUNvbnN0cnVjdG9yLmdldCh0aGlzLmNvbnN0cnVjdG9yKTtcXG4gICAgICBjb25zdCBmYWtlQ2xhc3MgPSBuYXRpdmVHZXQuY2FsbCh3aW5kb3cuY3VzdG9tRWxlbWVudHMsIHRhZ25hbWUpO1xcblxcbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBmYWtlIGNvbnN0cnVjdG9yIGRvZXNuJ3QgY2FsbCBiYWNrIHRvIHRoaXMgY29uc3RydWN0b3JcXG4gICAgICB1c2VyQ29uc3RydWN0aW9uID0gdHJ1ZTtcXG4gICAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyAoZmFrZUNsYXNzKSgpO1xcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcXG4gICAgfVxcbiAgICAvLyBFbHNlIGRvIG5vdGhpbmcuIFRoaXMgd2lsbCBiZSByZWFjaGVkIGJ5IEVTNS1zdHlsZSBjbGFzc2VzIGRvaW5nXFxuICAgIC8vIEhUTUxFbGVtZW50LmNhbGwoKSBkdXJpbmcgaW5pdGlhbGl6YXRpb25cXG4gICAgYnJvd3NlckNvbnN0cnVjdGlvbiA9IGZhbHNlO1xcbiAgfTtcXG4gIC8vIEJ5IHNldHRpbmcgdGhlIHBhdGNoZWQgSFRNTEVsZW1lbnQncyBwcm90b3R5cGUgcHJvcGVydHkgdG8gdGhlIG5hdGl2ZVxcbiAgLy8gSFRNTEVsZW1lbnQncyBwcm90b3R5cGUgd2UgbWFrZSBzdXJlIHRoYXQ6XFxuICAvLyAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpIGluc3RhbmNlb2YgSFRNTEVsZW1lbnRcXG4gIC8vIHdvcmtzIGJlY2F1c2UgaW5zdGFuY2VvZiB1c2VzIEhUTUxFbGVtZW50LnByb3RvdHlwZSwgd2hpY2ggaXMgb24gdGhlXFxuICAvLyBwdG90b3R5cGUgY2hhaW4gb2YgYnVpbHQtaW4gZWxlbWVudHMuXFxuICB3aW5kb3cuSFRNTEVsZW1lbnQucHJvdG90eXBlID0gTmF0aXZlSFRNTEVsZW1lbnQucHJvdG90eXBlO1xcblxcbiAgd2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSA9ICh0YWduYW1lLCBlbGVtZW50Q2xhc3MpID0+IHtcXG4gICAgY29uc3QgZWxlbWVudFByb3RvID0gZWxlbWVudENsYXNzLnByb3RvdHlwZTtcXG4gICAgY29uc3QgU3RhbmRJbkVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIE5hdGl2ZUhUTUxFbGVtZW50IHtcXG4gICAgICBjb25zdHJ1Y3RvcigpIHtcXG4gICAgICAgIC8vIENhbGwgdGhlIG5hdGl2ZSBIVE1MRWxlbWVudCBjb25zdHJ1Y3RvciwgdGhpcyBnaXZlcyB1cyB0aGVcXG4gICAgICAgIC8vIHVuZGVyLWNvbnN0cnVjdGlvbiBpbnN0YW5jZSBhcyBgdGhpc2A6XFxuICAgICAgICBzdXBlcigpO1xcblxcbiAgICAgICAgLy8gVGhlIHByb3RvdHlwZSB3aWxsIGJlIHdyb25nIHVwIGJlY2F1c2UgdGhlIGJyb3dzZXIgdXNlZCBvdXIgZmFrZVxcbiAgICAgICAgLy8gY2xhc3MsIHNvIGZpeCBpdDpcXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBlbGVtZW50UHJvdG8pO1xcblxcbiAgICAgICAgaWYgKCF1c2VyQ29uc3RydWN0aW9uKSB7XFxuICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHVzZXItZGVmaW5lZCBjb25zdHJ1Y3RvciBib3R0b20ncyBvdXQgdG8gYSBkby1ub3RoaW5nXFxuICAgICAgICAgIC8vIEhUTUxFbGVtZW50KCkgY2FsbFxcbiAgICAgICAgICBicm93c2VyQ29uc3RydWN0aW9uID0gdHJ1ZTtcXG4gICAgICAgICAgLy8gQ2FsbCB0aGUgdXNlci1kZWZpbmVkIGNvbnN0cnVjdG9yIG9uIG91ciBpbnN0YW5jZTpcXG4gICAgICAgICAgZWxlbWVudENsYXNzLmNhbGwodGhpcyk7XFxuICAgICAgICB9XFxuICAgICAgICB1c2VyQ29uc3RydWN0aW9uID0gZmFsc2U7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgICBjb25zdCBzdGFuZEluUHJvdG8gPSBTdGFuZEluRWxlbWVudC5wcm90b3R5cGU7XFxuICAgIFN0YW5kSW5FbGVtZW50Lm9ic2VydmVkQXR0cmlidXRlcyA9IGVsZW1lbnRDbGFzcy5vYnNlcnZlZEF0dHJpYnV0ZXM7XFxuICAgIHN0YW5kSW5Qcm90by5jb25uZWN0ZWRDYWxsYmFjayA9IGVsZW1lbnRQcm90by5jb25uZWN0ZWRDYWxsYmFjaztcXG4gICAgc3RhbmRJblByb3RvLmRpc2Nvbm5lY3RlZENhbGxiYWNrID0gZWxlbWVudFByb3RvLmRpc2Nvbm5lY3RlZENhbGxiYWNrO1xcbiAgICBzdGFuZEluUHJvdG8uYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrID0gZWxlbWVudFByb3RvLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaztcXG4gICAgc3RhbmRJblByb3RvLmFkb3B0ZWRDYWxsYmFjayA9IGVsZW1lbnRQcm90by5hZG9wdGVkQ2FsbGJhY2s7XFxuXFxuICAgIHRhZ25hbWVCeUNvbnN0cnVjdG9yLnNldChlbGVtZW50Q2xhc3MsIHRhZ25hbWUpO1xcbiAgICBjb25zdHJ1Y3RvckJ5VGFnbmFtZS5zZXQodGFnbmFtZSwgZWxlbWVudENsYXNzKTtcXG4gICAgbmF0aXZlRGVmaW5lLmNhbGwod2luZG93LmN1c3RvbUVsZW1lbnRzLCB0YWduYW1lLCBTdGFuZEluRWxlbWVudCk7XFxuICB9O1xcblxcbiAgd2luZG93LmN1c3RvbUVsZW1lbnRzLmdldCA9ICh0YWduYW1lKSA9PiBjb25zdHJ1Y3RvckJ5VGFnbmFtZS5nZXQodGFnbmFtZSk7XFxuXFxufSkoKTtcXG5cIik7XG5cbi8qKiovIH0sXG4vKiAzNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0LyoqXG5cdCAqIEBsaWNlbnNlXG5cdCAqIENvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cdCAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblx0ICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblx0ICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5cdCAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5cdCAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG5cdCAqL1xuXHRcblx0Ly8gbWluaW1hbCB0ZW1wbGF0ZSBwb2x5ZmlsbFxuXHQoZnVuY3Rpb24gKCkge1xuXHRcblx0ICB2YXIgbmVlZHNUZW1wbGF0ZSA9IHR5cGVvZiBIVE1MVGVtcGxhdGVFbGVtZW50ID09PSAndW5kZWZpbmVkJztcblx0XG5cdCAgLy8gTk9URTogUGF0Y2ggZG9jdW1lbnQuaW1wb3J0Tm9kZSB0byB3b3JrIGFyb3VuZCBJRTExIGJ1ZyB0aGF0XG5cdCAgLy8gY2FzdWVzIGNoaWxkcmVuIG9mIGEgZG9jdW1lbnQgZnJhZ21lbnQgaW1wb3J0ZWQgd2hpbGVcblx0ICAvLyB0aGVyZSBpcyBhIG11dGF0aW9uIG9ic2VydmVyIHRvIG5vdCBoYXZlIGEgcGFyZW50Tm9kZSAoIT8hKVxuXHQgIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgdGhpcyBpcyB0aGUgZmlyc3QgcGF0Y2ggdG8gYGltcG9ydE5vZGVgIHNvIHRoYXRcblx0ICAvLyBkb20gcHJvZHVjZWQgZm9yIGxhdGVyIHBhdGNoZXMgaXMgY29ycmVjdC5cblx0ICBpZiAoL1RyaWRlbnQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBOYXRpdmVfaW1wb3J0Tm9kZSA9IERvY3VtZW50LnByb3RvdHlwZS5pbXBvcnROb2RlO1xuXHQgICAgICBEb2N1bWVudC5wcm90b3R5cGUuaW1wb3J0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgbiA9IE5hdGl2ZV9pbXBvcnROb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgLy8gQ29weSBhbGwgY2hpbGRyZW4gdG8gYSBuZXcgZG9jdW1lbnQgZnJhZ21lbnQgc2luY2Vcblx0ICAgICAgICAvLyB0aGlzIG9uZSBtYXkgYmUgYnJva2VuXG5cdCAgICAgICAgaWYgKG4ubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuXHQgICAgICAgICAgdmFyIGYgPSB0aGlzLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0ICAgICAgICAgIGYuYXBwZW5kQ2hpbGQobik7XG5cdCAgICAgICAgICByZXR1cm4gZjtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgcmV0dXJuIG47XG5cdCAgICAgICAgfVxuXHQgICAgICB9O1xuXHQgICAgfSkoKTtcblx0ICB9XG5cdFxuXHQgIC8vIE5PVEU6IHdlIHJlbHkgb24gdGhpcyBjbG9uZU5vZGUgbm90IGNhdXNpbmcgZWxlbWVudCB1cGdyYWRlLlxuXHQgIC8vIFRoaXMgbWVhbnMgdGhpcyBwb2x5ZmlsbCBtdXN0IGxvYWQgYmVmb3JlIHRoZSBDRSBwb2x5ZmlsbCBhbmRcblx0ICAvLyB0aGlzIHdvdWxkIG5lZWQgdG8gYmUgcmUtd29ya2VkIGlmIGEgYnJvd3NlciBzdXBwb3J0cyBuYXRpdmUgQ0Vcblx0ICAvLyBidXQgbm90IDx0ZW1wbGF0ZT4uXG5cdCAgdmFyIE5hdGl2ZV9jbG9uZU5vZGUgPSBOb2RlLnByb3RvdHlwZS5jbG9uZU5vZGU7XG5cdCAgdmFyIE5hdGl2ZV9jcmVhdGVFbGVtZW50ID0gRG9jdW1lbnQucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQ7XG5cdCAgdmFyIE5hdGl2ZV9pbXBvcnROb2RlID0gRG9jdW1lbnQucHJvdG90eXBlLmltcG9ydE5vZGU7XG5cdFxuXHQgIC8vIHJldHVybnMgdHJ1ZSBpZiBuZXN0ZWQgdGVtcGxhdGVzIGNhbm5vdCBiZSBjbG9uZWQgKHRoZXkgY2Fubm90IGJlIG9uXG5cdCAgLy8gc29tZSBpbXBsJ3MgbGlrZSBTYWZhcmkgOCBhbmQgRWRnZSlcblx0ICAvLyBPUiBpZiBjbG9uaW5nIGEgZG9jdW1lbnQgZnJhZ21lbnQgZG9lcyBub3QgcmVzdWx0IGluIGEgZG9jdW1lbnQgZnJhZ21lbnRcblx0ICB2YXIgbmVlZHNDbG9uaW5nID0gZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKCFuZWVkc1RlbXBsYXRlKSB7XG5cdCAgICAgIHZhciB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcblx0ICAgICAgdmFyIHQyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcblx0ICAgICAgdDIuY29udGVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG5cdCAgICAgIHQuY29udGVudC5hcHBlbmRDaGlsZCh0Mik7XG5cdCAgICAgIHZhciBjbG9uZSA9IHQuY2xvbmVOb2RlKHRydWUpO1xuXHQgICAgICByZXR1cm4gY2xvbmUuY29udGVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCB8fCBjbG9uZS5jb250ZW50LmZpcnN0Q2hpbGQuY29udGVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCB8fCAhKGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKS5jbG9uZU5vZGUoKSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpO1xuXHQgICAgfVxuXHQgIH0oKTtcblx0XG5cdCAgdmFyIFRFTVBMQVRFX1RBRyA9ICd0ZW1wbGF0ZSc7XG5cdCAgdmFyIFBvbHlmaWxsZWRIVE1MVGVtcGxhdGVFbGVtZW50ID0gZnVuY3Rpb24gUG9seWZpbGxlZEhUTUxUZW1wbGF0ZUVsZW1lbnQoKSB7fTtcblx0XG5cdCAgaWYgKG5lZWRzVGVtcGxhdGUpIHtcblx0ICAgIHZhciBjb250ZW50RG9jO1xuXHQgICAgdmFyIGNhbkRlY29yYXRlO1xuXHQgICAgdmFyIHRlbXBsYXRlU3R5bGU7XG5cdCAgICB2YXIgaGVhZDtcblx0ICAgIHZhciBjYW5Qcm90b1BhdGNoO1xuXHQgICAgdmFyIGVzY2FwZURhdGFSZWdFeHA7XG5cdFxuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIGRlZmluZUlubmVySFRNTCA9IGZ1bmN0aW9uIGRlZmluZUlubmVySFRNTChvYmopIHtcblx0ICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCAnaW5uZXJIVE1MJywge1xuXHQgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgICAgICAgIHZhciBvID0gJyc7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGUgPSB0aGlzLmNvbnRlbnQuZmlyc3RDaGlsZDsgZTsgZSA9IGUubmV4dFNpYmxpbmcpIHtcblx0ICAgICAgICAgICAgICBvICs9IGUub3V0ZXJIVE1MIHx8IGVzY2FwZURhdGEoZS5kYXRhKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gbztcblx0ICAgICAgICAgIH0sXG5cdCAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0ZXh0KSB7XG5cdCAgICAgICAgICAgIGNvbnRlbnREb2MuYm9keS5pbm5lckhUTUwgPSB0ZXh0O1xuXHQgICAgICAgICAgICBQb2x5ZmlsbGVkSFRNTFRlbXBsYXRlRWxlbWVudC5ib290c3RyYXAoY29udGVudERvYyk7XG5cdCAgICAgICAgICAgIHdoaWxlICh0aGlzLmNvbnRlbnQuZmlyc3RDaGlsZCkge1xuXHQgICAgICAgICAgICAgIHRoaXMuY29udGVudC5yZW1vdmVDaGlsZCh0aGlzLmNvbnRlbnQuZmlyc3RDaGlsZCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgd2hpbGUgKGNvbnRlbnREb2MuYm9keS5maXJzdENoaWxkKSB7XG5cdCAgICAgICAgICAgICAgdGhpcy5jb250ZW50LmFwcGVuZENoaWxkKGNvbnRlbnREb2MuYm9keS5maXJzdENoaWxkKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfSxcblx0ICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9O1xuXHRcblx0ICAgICAgdmFyIGVzY2FwZVJlcGxhY2UgPSBmdW5jdGlvbiBlc2NhcGVSZXBsYWNlKGMpIHtcblx0ICAgICAgICBzd2l0Y2ggKGMpIHtcblx0ICAgICAgICAgIGNhc2UgJyYnOlxuXHQgICAgICAgICAgICByZXR1cm4gJyZhbXA7Jztcblx0ICAgICAgICAgIGNhc2UgJzwnOlxuXHQgICAgICAgICAgICByZXR1cm4gJyZsdDsnO1xuXHQgICAgICAgICAgY2FzZSAnPic6XG5cdCAgICAgICAgICAgIHJldHVybiAnJmd0Oyc7XG5cdCAgICAgICAgICBjYXNlICdcXHhBMCc6XG5cdCAgICAgICAgICAgIHJldHVybiAnJm5ic3A7Jztcblx0ICAgICAgICB9XG5cdCAgICAgIH07XG5cdFxuXHQgICAgICB2YXIgZXNjYXBlRGF0YSA9IGZ1bmN0aW9uIGVzY2FwZURhdGEocykge1xuXHQgICAgICAgIHJldHVybiBzLnJlcGxhY2UoZXNjYXBlRGF0YVJlZ0V4cCwgZXNjYXBlUmVwbGFjZSk7XG5cdCAgICAgIH07XG5cdFxuXHQgICAgICBjb250ZW50RG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCd0ZW1wbGF0ZScpO1xuXHQgICAgICBjYW5EZWNvcmF0ZSA9IHRydWU7XG5cdCAgICAgIHRlbXBsYXRlU3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuXHRcblx0ICAgICAgdGVtcGxhdGVTdHlsZS50ZXh0Q29udGVudCA9IFRFTVBMQVRFX1RBRyArICd7ZGlzcGxheTpub25lO30nO1xuXHRcblx0ICAgICAgaGVhZCA9IGRvY3VtZW50LmhlYWQ7XG5cdFxuXHQgICAgICBoZWFkLmluc2VydEJlZm9yZSh0ZW1wbGF0ZVN0eWxlLCBoZWFkLmZpcnN0RWxlbWVudENoaWxkKTtcblx0XG5cdCAgICAgIC8qKlxuXHQgICAgICAgIFByb3ZpZGVzIGEgbWluaW1hbCBzaGltIGZvciB0aGUgPHRlbXBsYXRlPiBlbGVtZW50LlxuXHQgICAgICAqL1xuXHQgICAgICBQb2x5ZmlsbGVkSFRNTFRlbXBsYXRlRWxlbWVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEhUTUxFbGVtZW50LnByb3RvdHlwZSk7XG5cdFxuXHQgICAgICAvLyBpZiBlbGVtZW50cyBkbyBub3QgaGF2ZSBgaW5uZXJIVE1MYCBvbiBpbnN0YW5jZXMsIHRoZW5cblx0ICAgICAgLy8gdGVtcGxhdGVzIGNhbiBiZSBwYXRjaGVkIGJ5IHN3aXp6bGluZyB0aGVpciBwcm90b3R5cGVzLlxuXHQgICAgICBjYW5Qcm90b1BhdGNoID0gIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLmhhc093blByb3BlcnR5KCdpbm5lckhUTUwnKTtcblx0XG5cdCAgICAgIC8qKlxuXHQgICAgICAgIFRoZSBgZGVjb3JhdGVgIG1ldGhvZCBtb3ZlcyBlbGVtZW50IGNoaWxkcmVuIHRvIHRoZSB0ZW1wbGF0ZSdzIGBjb250ZW50YC5cblx0ICAgICAgICBOT1RFOiB0aGVyZSBpcyBubyBzdXBwb3J0IGZvciBkeW5hbWljYWxseSBhZGRpbmcgZWxlbWVudHMgdG8gdGVtcGxhdGVzLlxuXHQgICAgICAqL1xuXHRcblx0ICAgICAgUG9seWZpbGxlZEhUTUxUZW1wbGF0ZUVsZW1lbnQuZGVjb3JhdGUgPSBmdW5jdGlvbiAodGVtcGxhdGUpIHtcblx0ICAgICAgICAvLyBpZiB0aGUgdGVtcGxhdGUgaXMgZGVjb3JhdGVkLCByZXR1cm4gZmFzdFxuXHQgICAgICAgIGlmICh0ZW1wbGF0ZS5jb250ZW50KSB7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRlbXBsYXRlLmNvbnRlbnQgPSBjb250ZW50RG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0ICAgICAgICB2YXIgY2hpbGQ7XG5cdCAgICAgICAgd2hpbGUgKGNoaWxkID0gdGVtcGxhdGUuZmlyc3RDaGlsZCkge1xuXHQgICAgICAgICAgdGVtcGxhdGUuY29udGVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIE5PVEU6IHByZWZlciBwcm90b3R5cGUgcGF0Y2hpbmcgZm9yIHBlcmZvcm1hbmNlIGFuZFxuXHQgICAgICAgIC8vIGJlY2F1c2Ugb24gc29tZSBicm93c2VycyAoSUUxMSksIHJlLWRlZmluaW5nIGBpbm5lckhUTUxgXG5cdCAgICAgICAgLy8gY2FuIHJlc3VsdCBpbiBpbnRlcm1pdHRlbnQgZXJyb3JzLlxuXHQgICAgICAgIGlmIChjYW5Qcm90b1BhdGNoKSB7XG5cdCAgICAgICAgICB0ZW1wbGF0ZS5fX3Byb3RvX18gPSBQb2x5ZmlsbGVkSFRNTFRlbXBsYXRlRWxlbWVudC5wcm90b3R5cGU7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHRlbXBsYXRlLmNsb25lTm9kZSA9IGZ1bmN0aW9uIChkZWVwKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBQb2x5ZmlsbGVkSFRNTFRlbXBsYXRlRWxlbWVudC5fY2xvbmVOb2RlKHRoaXMsIGRlZXApO1xuXHQgICAgICAgICAgfTtcblx0ICAgICAgICAgIC8vIGFkZCBpbm5lckhUTUwgdG8gdGVtcGxhdGUsIGlmIHBvc3NpYmxlXG5cdCAgICAgICAgICAvLyBOb3RlOiB0aGlzIHRocm93cyBvbiBTYWZhcmkgN1xuXHQgICAgICAgICAgaWYgKGNhbkRlY29yYXRlKSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgZGVmaW5lSW5uZXJIVE1MKHRlbXBsYXRlKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgY2FuRGVjb3JhdGUgPSBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBib290c3RyYXAgcmVjdXJzaXZlbHlcblx0ICAgICAgICBQb2x5ZmlsbGVkSFRNTFRlbXBsYXRlRWxlbWVudC5ib290c3RyYXAodGVtcGxhdGUuY29udGVudCk7XG5cdCAgICAgIH07XG5cdFxuXHQgICAgICBkZWZpbmVJbm5lckhUTUwoUG9seWZpbGxlZEhUTUxUZW1wbGF0ZUVsZW1lbnQucHJvdG90eXBlKTtcblx0XG5cdCAgICAgIC8qKlxuXHQgICAgICAgIFRoZSBgYm9vdHN0cmFwYCBtZXRob2QgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYW5kIFwiZml4ZXNcIiBhbGxcblx0ICAgICAgICA8dGVtcGxhdGU+IGVsZW1lbnRzIGluIHRoZSBkb2N1bWVudCByZWZlcmVuY2VkIGJ5IHRoZSBgZG9jYCBhcmd1bWVudC5cblx0ICAgICAgKi9cblx0ICAgICAgUG9seWZpbGxlZEhUTUxUZW1wbGF0ZUVsZW1lbnQuYm9vdHN0cmFwID0gZnVuY3Rpb24gKGRvYykge1xuXHQgICAgICAgIHZhciB0ZW1wbGF0ZXMgPSBkb2MucXVlcnlTZWxlY3RvckFsbChURU1QTEFURV9UQUcpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGVtcGxhdGVzLmxlbmd0aCwgdDsgaSA8IGwgJiYgKHQgPSB0ZW1wbGF0ZXNbaV0pOyBpKyspIHtcblx0ICAgICAgICAgIFBvbHlmaWxsZWRIVE1MVGVtcGxhdGVFbGVtZW50LmRlY29yYXRlKHQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfTtcblx0XG5cdCAgICAgIC8vIGF1dG8tYm9vdHN0cmFwcGluZyBmb3IgbWFpbiBkb2N1bWVudFxuXHQgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFBvbHlmaWxsZWRIVE1MVGVtcGxhdGVFbGVtZW50LmJvb3RzdHJhcChkb2N1bWVudCk7XG5cdCAgICAgIH0pO1xuXHRcblx0ICAgICAgLy8gUGF0Y2ggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCB0byBlbnN1cmUgbmV3bHkgY3JlYXRlZCB0ZW1wbGF0ZXMgaGF2ZSBjb250ZW50XG5cdCAgICAgIERvY3VtZW50LnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICd1c2Ugc3RyaWN0Jztcblx0XG5cdCAgICAgICAgdmFyIGVsID0gTmF0aXZlX2NyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICBpZiAoZWwubG9jYWxOYW1lID09PSAndGVtcGxhdGUnKSB7XG5cdCAgICAgICAgICBQb2x5ZmlsbGVkSFRNTFRlbXBsYXRlRWxlbWVudC5kZWNvcmF0ZShlbCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBlbDtcblx0ICAgICAgfTtcblx0XG5cdCAgICAgIGVzY2FwZURhdGFSZWdFeHAgPSAvWyZcXHUwMEEwPD5dL2c7XG5cdCAgICB9KSgpO1xuXHQgIH1cblx0XG5cdCAgLy8gbWFrZSBjbG9uaW5nL2ltcG9ydGluZyB3b3JrIVxuXHQgIGlmIChuZWVkc1RlbXBsYXRlIHx8IG5lZWRzQ2xvbmluZykge1xuXHRcblx0ICAgIFBvbHlmaWxsZWRIVE1MVGVtcGxhdGVFbGVtZW50Ll9jbG9uZU5vZGUgPSBmdW5jdGlvbiAodGVtcGxhdGUsIGRlZXApIHtcblx0ICAgICAgdmFyIGNsb25lID0gTmF0aXZlX2Nsb25lTm9kZS5jYWxsKHRlbXBsYXRlLCBmYWxzZSk7XG5cdCAgICAgIC8vIE5PVEU6IGRlY29yYXRlIGRvZXNuJ3QgYXV0by1maXggY2hpbGRyZW4gYmVjYXVzZSB0aGV5IGFyZSBhbHJlYWR5XG5cdCAgICAgIC8vIGRlY29yYXRlZCBzbyB0aGV5IG5lZWQgc3BlY2lhbCBjbG9uZSBmaXh1cC5cblx0ICAgICAgaWYgKHRoaXMuZGVjb3JhdGUpIHtcblx0ICAgICAgICB0aGlzLmRlY29yYXRlKGNsb25lKTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoZGVlcCkge1xuXHQgICAgICAgIC8vIE5PVEU6IHVzZSBuYXRpdmUgY2xvbmUgbm9kZSB0byBtYWtlIHN1cmUgQ0UncyB3cmFwcGVkXG5cdCAgICAgICAgLy8gY2xvbmVOb2RlIGRvZXMgbm90IGNhdXNlIGVsZW1lbnRzIHRvIHVwZ3JhZGUuXG5cdCAgICAgICAgY2xvbmUuY29udGVudC5hcHBlbmRDaGlsZChOYXRpdmVfY2xvbmVOb2RlLmNhbGwodGVtcGxhdGUuY29udGVudCwgdHJ1ZSkpO1xuXHQgICAgICAgIC8vIG5vdyBlbnN1cmUgbmVzdGVkIHRlbXBsYXRlcyBhcmUgY2xvbmVkIGNvcnJlY3RseS5cblx0ICAgICAgICB0aGlzLmZpeENsb25lZERvbShjbG9uZS5jb250ZW50LCB0ZW1wbGF0ZS5jb250ZW50KTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICB9O1xuXHRcblx0ICAgIFBvbHlmaWxsZWRIVE1MVGVtcGxhdGVFbGVtZW50LnByb3RvdHlwZS5jbG9uZU5vZGUgPSBmdW5jdGlvbiAoZGVlcCkge1xuXHQgICAgICByZXR1cm4gUG9seWZpbGxlZEhUTUxUZW1wbGF0ZUVsZW1lbnQuX2Nsb25lTm9kZSh0aGlzLCBkZWVwKTtcblx0ICAgIH07XG5cdFxuXHQgICAgLy8gR2l2ZW4gYSBzb3VyY2UgYW5kIGNsb25lZCBzdWJ0cmVlLCBmaW5kIDx0ZW1wbGF0ZT4ncyBpbiB0aGUgY2xvbmVkXG5cdCAgICAvLyBzdWJ0cmVlIGFuZCByZXBsYWNlIHRoZW0gd2l0aCBjbG9uZWQgPHRlbXBsYXRlPidzIGZyb20gc291cmNlLlxuXHQgICAgLy8gV2UgbXVzdCBkbyB0aGlzIGJlY2F1c2Ugb25seSB0aGUgc291cmNlIHRlbXBsYXRlcyBoYXZlIHByb3BlciAuY29udGVudC5cblx0ICAgIFBvbHlmaWxsZWRIVE1MVGVtcGxhdGVFbGVtZW50LmZpeENsb25lZERvbSA9IGZ1bmN0aW9uIChjbG9uZSwgc291cmNlKSB7XG5cdCAgICAgIC8vIGRvIG5vdGhpbmcgaWYgY2xvbmVkIG5vZGUgaXMgbm90IGFuIGVsZW1lbnRcblx0ICAgICAgaWYgKCFzb3VyY2UucXVlcnlTZWxlY3RvckFsbCkgcmV0dXJuO1xuXHQgICAgICAvLyB0aGVzZSB0d28gbGlzdHMgc2hvdWxkIGJlIGNvaW5jaWRlbnRcblx0ICAgICAgdmFyIHMkID0gc291cmNlLnF1ZXJ5U2VsZWN0b3JBbGwoVEVNUExBVEVfVEFHKTtcblx0ICAgICAgdmFyIHQkID0gY2xvbmUucXVlcnlTZWxlY3RvckFsbChURU1QTEFURV9UQUcpO1xuXHQgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHQkLmxlbmd0aCwgdCwgczsgaSA8IGw7IGkrKykge1xuXHQgICAgICAgIHMgPSBzJFtpXTtcblx0ICAgICAgICB0ID0gdCRbaV07XG5cdCAgICAgICAgaWYgKHRoaXMuZGVjb3JhdGUpIHtcblx0ICAgICAgICAgIHRoaXMuZGVjb3JhdGUocyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQocy5jbG9uZU5vZGUodHJ1ZSksIHQpO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXHRcblx0ICAgIC8vIG92ZXJyaWRlIGFsbCBjbG9uaW5nIHRvIGZpeCB0aGUgY2xvbmVkIHN1YnRyZWUgdG8gY29udGFpbiBwcm9wZXJseVxuXHQgICAgLy8gY2xvbmVkIHRlbXBsYXRlcy5cblx0ICAgIE5vZGUucHJvdG90eXBlLmNsb25lTm9kZSA9IGZ1bmN0aW9uIChkZWVwKSB7XG5cdCAgICAgIHZhciBkb207XG5cdCAgICAgIC8vIHdvcmthcm91bmQgZm9yIEVkZ2UgYnVnIGNsb25pbmcgZG9jdW1lbnRGcmFnbWVudHNcblx0ICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvODYxOTY0Ni9cblx0ICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG5cdCAgICAgICAgaWYgKCFkZWVwKSB7XG5cdCAgICAgICAgICByZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgZG9tID0gdGhpcy5vd25lckRvY3VtZW50LmltcG9ydE5vZGUodGhpcywgdHJ1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGRvbSA9IE5hdGl2ZV9jbG9uZU5vZGUuY2FsbCh0aGlzLCBkZWVwKTtcblx0ICAgICAgfVxuXHQgICAgICAvLyB0ZW1wbGF0ZS5jb250ZW50IGlzIGNsb25lZCBpZmYgYGRlZXBgLlxuXHQgICAgICBpZiAoZGVlcCkge1xuXHQgICAgICAgIFBvbHlmaWxsZWRIVE1MVGVtcGxhdGVFbGVtZW50LmZpeENsb25lZERvbShkb20sIHRoaXMpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBkb207XG5cdCAgICB9O1xuXHRcblx0ICAgIC8vIE5PVEU6IHdlIGFyZSBjbG9uaW5nIGluc3RlYWQgb2YgaW1wb3J0aW5nIDx0ZW1wbGF0ZT4ncy5cblx0ICAgIC8vIEhvd2V2ZXIsIHRoZSBvd25lckRvY3VtZW50IG9mIHRoZSBjbG9uZWQgdGVtcGxhdGUgd2lsbCBiZSBjb3JyZWN0IVxuXHQgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZSBuYXRpdmUgaW1wb3J0IG5vZGUgY3JlYXRlcyB0aGUgcmlnaHQgZG9jdW1lbnQgb3duZWRcblx0ICAgIC8vIHN1YnRyZWUgYW5kIGBmaXhDbG9uZWREb21gIGluc2VydHMgY2xvbmVkIHRlbXBsYXRlcyBpbnRvIHRoaXMgc3VidHJlZSxcblx0ICAgIC8vIHRodXMgdXBkYXRpbmcgdGhlIG93bmVyIGRvYy5cblx0ICAgIERvY3VtZW50LnByb3RvdHlwZS5pbXBvcnROb2RlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGRlZXApIHtcblx0ICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09PSBURU1QTEFURV9UQUcpIHtcblx0ICAgICAgICByZXR1cm4gUG9seWZpbGxlZEhUTUxUZW1wbGF0ZUVsZW1lbnQuX2Nsb25lTm9kZShlbGVtZW50LCBkZWVwKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB2YXIgZG9tID0gTmF0aXZlX2ltcG9ydE5vZGUuY2FsbCh0aGlzLCBlbGVtZW50LCBkZWVwKTtcblx0ICAgICAgICBpZiAoZGVlcCkge1xuXHQgICAgICAgICAgUG9seWZpbGxlZEhUTUxUZW1wbGF0ZUVsZW1lbnQuZml4Q2xvbmVkRG9tKGRvbSwgZWxlbWVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBkb207XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdFxuXHQgICAgaWYgKG5lZWRzQ2xvbmluZykge1xuXHQgICAgICB3aW5kb3cuSFRNTFRlbXBsYXRlRWxlbWVudC5wcm90b3R5cGUuY2xvbmVOb2RlID0gZnVuY3Rpb24gKGRlZXApIHtcblx0ICAgICAgICByZXR1cm4gUG9seWZpbGxlZEhUTUxUZW1wbGF0ZUVsZW1lbnQuX2Nsb25lTm9kZSh0aGlzLCBkZWVwKTtcblx0ICAgICAgfTtcblx0ICAgIH1cblx0ICB9XG5cdFxuXHQgIGlmIChuZWVkc1RlbXBsYXRlKSB7XG5cdCAgICB3aW5kb3cuSFRNTFRlbXBsYXRlRWxlbWVudCA9IFBvbHlmaWxsZWRIVE1MVGVtcGxhdGVFbGVtZW50O1xuXHQgIH1cblx0fSkoKTtcblxuLyoqKi8gfSxcbi8qIDM2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgX0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcblx0XG5cdHZhciBfQ3VzdG9tRWxlbWVudEludGVybmFsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DdXN0b21FbGVtZW50SW50ZXJuYWxzKTtcblx0XG5cdHZhciBfQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XG5cdFxuXHR2YXIgX0N1c3RvbUVsZW1lbnRSZWdpc3RyeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DdXN0b21FbGVtZW50UmVnaXN0cnkpO1xuXHRcblx0dmFyIF9IVE1MRWxlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xuXHRcblx0dmFyIF9IVE1MRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9IVE1MRWxlbWVudCk7XG5cdFxuXHR2YXIgX0RvY3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nik7XG5cdFxuXHR2YXIgX0RvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RvY3VtZW50KTtcblx0XG5cdHZhciBfTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xuXHRcblx0dmFyIF9Ob2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05vZGUpO1xuXHRcblx0dmFyIF9FbGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XG5cdFxuXHR2YXIgX0VsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRWxlbWVudCk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0LyoqXG5cdCAqIEBsaWNlbnNlXG5cdCAqIENvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cdCAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblx0ICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblx0ICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5cdCAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5cdCAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG5cdCAqL1xuXHRcblx0dmFyIHByaW9yQ3VzdG9tRWxlbWVudHMgPSB3aW5kb3dbJ2N1c3RvbUVsZW1lbnRzJ107XG5cdFxuXHRpZiAoIXByaW9yQ3VzdG9tRWxlbWVudHMgfHwgcHJpb3JDdXN0b21FbGVtZW50c1snZm9yY2VQb2x5ZmlsbCddIHx8IHR5cGVvZiBwcmlvckN1c3RvbUVsZW1lbnRzWydkZWZpbmUnXSAhPSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBwcmlvckN1c3RvbUVsZW1lbnRzWydnZXQnXSAhPSAnZnVuY3Rpb24nKSB7XG5cdCAgLyoqIEB0eXBlIHshQ3VzdG9tRWxlbWVudEludGVybmFsc30gKi9cblx0ICB2YXIgaW50ZXJuYWxzID0gbmV3IF9DdXN0b21FbGVtZW50SW50ZXJuYWxzMi5kZWZhdWx0KCk7XG5cdFxuXHQgICgwLCBfSFRNTEVsZW1lbnQyLmRlZmF1bHQpKGludGVybmFscyk7XG5cdCAgKDAsIF9Eb2N1bWVudDIuZGVmYXVsdCkoaW50ZXJuYWxzKTtcblx0ICAoMCwgX05vZGUyLmRlZmF1bHQpKGludGVybmFscyk7XG5cdCAgKDAsIF9FbGVtZW50Mi5kZWZhdWx0KShpbnRlcm5hbHMpO1xuXHRcblx0ICAvLyBUaGUgbWFpbiBkb2N1bWVudCBpcyBhbHdheXMgYXNzb2NpYXRlZCB3aXRoIHRoZSByZWdpc3RyeS5cblx0ICBkb2N1bWVudC5fX0NFX2hhc1JlZ2lzdHJ5ID0gdHJ1ZTtcblx0XG5cdCAgLyoqIEB0eXBlIHshQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5fSAqL1xuXHQgIHZhciBjdXN0b21FbGVtZW50cyA9IG5ldyBfQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5Mi5kZWZhdWx0KGludGVybmFscyk7XG5cdFxuXHQgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdjdXN0b21FbGVtZW50cycsIHtcblx0ICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0ICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICB2YWx1ZTogY3VzdG9tRWxlbWVudHNcblx0ICB9KTtcblx0fVxuXG4vKioqLyB9LFxuLyogMzcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblx0XG5cdHZhciBfVXRpbGl0aWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XG5cdFxuXHR2YXIgVXRpbGl0aWVzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX1V0aWxpdGllcyk7XG5cdFxuXHR2YXIgX0N1c3RvbUVsZW1lbnRTdGF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuXHRcblx0dmFyIF9DdXN0b21FbGVtZW50U3RhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ3VzdG9tRWxlbWVudFN0YXRlKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXHRcblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblx0XG5cdHZhciBDdXN0b21FbGVtZW50SW50ZXJuYWxzID0gZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMoKSB7XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3VzdG9tRWxlbWVudEludGVybmFscyk7XG5cdFxuXHQgICAgLyoqIEB0eXBlIHshTWFwPHN0cmluZywgIUN1c3RvbUVsZW1lbnREZWZpbml0aW9uPn0gKi9cblx0ICAgIHRoaXMuX2xvY2FsTmFtZVRvRGVmaW5pdGlvbiA9IG5ldyBNYXAoKTtcblx0XG5cdCAgICAvKiogQHR5cGUgeyFNYXA8IUZ1bmN0aW9uLCAhQ3VzdG9tRWxlbWVudERlZmluaXRpb24+fSAqL1xuXHQgICAgdGhpcy5fY29uc3RydWN0b3JUb0RlZmluaXRpb24gPSBuZXcgTWFwKCk7XG5cdFxuXHQgICAgLyoqIEB0eXBlIHshQXJyYXk8IWZ1bmN0aW9uKCFOb2RlKT59ICovXG5cdCAgICB0aGlzLl9wYXRjaGVzID0gW107XG5cdFxuXHQgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuXHQgICAgdGhpcy5faGFzUGF0Y2hlcyA9IGZhbHNlO1xuXHQgIH1cblx0XG5cdCAgLyoqXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsTmFtZVxuXHQgICAqIEBwYXJhbSB7IUN1c3RvbUVsZW1lbnREZWZpbml0aW9ufSBkZWZpbml0aW9uXG5cdCAgICovXG5cdFxuXHRcblx0ICBfY3JlYXRlQ2xhc3MoQ3VzdG9tRWxlbWVudEludGVybmFscywgW3tcblx0ICAgIGtleTogJ3NldERlZmluaXRpb24nLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHNldERlZmluaXRpb24obG9jYWxOYW1lLCBkZWZpbml0aW9uKSB7XG5cdCAgICAgIHRoaXMuX2xvY2FsTmFtZVRvRGVmaW5pdGlvbi5zZXQobG9jYWxOYW1lLCBkZWZpbml0aW9uKTtcblx0ICAgICAgdGhpcy5fY29uc3RydWN0b3JUb0RlZmluaXRpb24uc2V0KGRlZmluaXRpb24uY29uc3RydWN0b3IsIGRlZmluaXRpb24pO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsTmFtZVxuXHQgICAgICogQHJldHVybiB7IUN1c3RvbUVsZW1lbnREZWZpbml0aW9ufHVuZGVmaW5lZH1cblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdsb2NhbE5hbWVUb0RlZmluaXRpb24nLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGxvY2FsTmFtZVRvRGVmaW5pdGlvbihsb2NhbE5hbWUpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsTmFtZVRvRGVmaW5pdGlvbi5nZXQobG9jYWxOYW1lKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBjb25zdHJ1Y3RvclxuXHQgICAgICogQHJldHVybiB7IUN1c3RvbUVsZW1lbnREZWZpbml0aW9ufHVuZGVmaW5lZH1cblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdjb25zdHJ1Y3RvclRvRGVmaW5pdGlvbicsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gY29uc3RydWN0b3JUb0RlZmluaXRpb24oY29uc3RydWN0b3IpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdG9yVG9EZWZpbml0aW9uLmdldChjb25zdHJ1Y3Rvcik7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBAcGFyYW0geyFmdW5jdGlvbighTm9kZSl9IGxpc3RlbmVyXG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnYWRkUGF0Y2gnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFBhdGNoKGxpc3RlbmVyKSB7XG5cdCAgICAgIHRoaXMuX2hhc1BhdGNoZXMgPSB0cnVlO1xuXHQgICAgICB0aGlzLl9wYXRjaGVzLnB1c2gobGlzdGVuZXIpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuXHQgICAgICovXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ3BhdGNoVHJlZScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gcGF0Y2hUcmVlKG5vZGUpIHtcblx0ICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0XG5cdCAgICAgIGlmICghdGhpcy5faGFzUGF0Y2hlcykgcmV0dXJuO1xuXHRcblx0ICAgICAgVXRpbGl0aWVzLndhbGtEZWVwRGVzY2VuZGFudEVsZW1lbnRzKG5vZGUsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzLnBhdGNoKGVsZW1lbnQpO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdwYXRjaCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gcGF0Y2gobm9kZSkge1xuXHQgICAgICBpZiAoIXRoaXMuX2hhc1BhdGNoZXMpIHJldHVybjtcblx0XG5cdCAgICAgIGlmIChub2RlLl9fQ0VfcGF0Y2hlZCkgcmV0dXJuO1xuXHQgICAgICBub2RlLl9fQ0VfcGF0Y2hlZCA9IHRydWU7XG5cdFxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3BhdGNoZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB0aGlzLl9wYXRjaGVzW2ldKG5vZGUpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBAcGFyYW0geyFOb2RlfSByb290XG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnY29ubmVjdFRyZWUnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3RUcmVlKHJvb3QpIHtcblx0ICAgICAgdmFyIGVsZW1lbnRzID0gW107XG5cdFxuXHQgICAgICBVdGlsaXRpZXMud2Fsa0RlZXBEZXNjZW5kYW50RWxlbWVudHMocm9vdCwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0ICAgICAgICByZXR1cm4gZWxlbWVudHMucHVzaChlbGVtZW50KTtcblx0ICAgICAgfSk7XG5cdFxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcblx0ICAgICAgICBpZiAoZWxlbWVudC5fX0NFX3N0YXRlID09PSBfQ3VzdG9tRWxlbWVudFN0YXRlMi5kZWZhdWx0LmN1c3RvbSkge1xuXHQgICAgICAgICAgdGhpcy5jb25uZWN0ZWRDYWxsYmFjayhlbGVtZW50KTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdGhpcy51cGdyYWRlRWxlbWVudChlbGVtZW50KTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEBwYXJhbSB7IU5vZGV9IHJvb3Rcblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdkaXNjb25uZWN0VHJlZScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZGlzY29ubmVjdFRyZWUocm9vdCkge1xuXHQgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcblx0XG5cdCAgICAgIFV0aWxpdGllcy53YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50cyhyb290LCBmdW5jdGlvbiAoZWxlbWVudCkge1xuXHQgICAgICAgIHJldHVybiBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuXHQgICAgICB9KTtcblx0XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuXHQgICAgICAgIGlmIChlbGVtZW50Ll9fQ0Vfc3RhdGUgPT09IF9DdXN0b21FbGVtZW50U3RhdGUyLmRlZmF1bHQuY3VzdG9tKSB7XG5cdCAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RlZENhbGxiYWNrKGVsZW1lbnQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVXBncmFkZXMgYWxsIHVuY3VzdG9taXplZCBjdXN0b20gZWxlbWVudHMgYXQgYW5kIGJlbG93IGEgcm9vdCBub2RlIGZvclxuXHQgICAgICogd2hpY2ggdGhlcmUgaXMgYSBkZWZpbml0aW9uLiBXaGVuIGN1c3RvbSBlbGVtZW50IHJlYWN0aW9uIGNhbGxiYWNrcyBhcmVcblx0ICAgICAqIGFzc3VtZWQgdG8gYmUgY2FsbGVkIHN5bmNocm9ub3VzbHkgKHdoaWNoLCBieSB0aGUgY3VycmVudCBET00gLyBIVE1MIHNwZWNcblx0ICAgICAqIGRlZmluaXRpb25zLCB0aGV5IGFyZSAqbm90KiksIGNhbGxiYWNrcyBmb3IgYm90aCBlbGVtZW50cyBjdXN0b21pemVkXG5cdCAgICAgKiBzeW5jaHJvbm91c2x5IGJ5IHRoZSBwYXJzZXIgYW5kIGVsZW1lbnRzIGJlaW5nIHVwZ3JhZGVkIG9jY3VyIGluIHRoZSBzYW1lXG5cdCAgICAgKiByZWxhdGl2ZSBvcmRlci5cblx0ICAgICAqXG5cdCAgICAgKiBOT1RFOiBUaGlzIGZ1bmN0aW9uLCB3aGVuIHVzZWQgdG8gc2ltdWxhdGUgdGhlIGNvbnN0cnVjdGlvbiBvZiBhIHRyZWUgdGhhdFxuXHQgICAgICogaXMgYWxyZWFkeSBjcmVhdGVkIGJ1dCBub3QgY3VzdG9taXplZCAoaS5lLiBieSB0aGUgcGFyc2VyKSwgZG9lcyAqbm90KlxuXHQgICAgICogcHJldmVudCB0aGUgZWxlbWVudCBmcm9tIHJlYWRpbmcgdGhlICdmaW5hbCcgKHRydWUpIHN0YXRlIG9mIHRoZSB0cmVlLiBGb3Jcblx0ICAgICAqIGV4YW1wbGUsIHRoZSBlbGVtZW50LCBkdXJpbmcgdHJ1bHkgc3luY2hyb25vdXMgcGFyc2luZyAvIGNvbnN0cnVjdGlvbiB3b3VsZFxuXHQgICAgICogc2VlIHRoYXQgaXQgY29udGFpbnMgbm8gY2hpbGRyZW4gYXMgdGhleSBoYXZlIG5vdCB5ZXQgYmVlbiBpbnNlcnRlZC5cblx0ICAgICAqIEhvd2V2ZXIsIHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgbW9kaWZ5IHRoZSB0cmVlLCB0aGUgZWxlbWVudCB3aWxsXG5cdCAgICAgKiAoaW5jb3JyZWN0bHkpIGhhdmUgY2hpbGRyZW4uIEFkZGl0aW9uYWxseSwgc2VsZi1tb2RpZmljYXRpb24gcmVzdHJpY3Rpb25zXG5cdCAgICAgKiBmb3IgY3VzdG9tIGVsZW1lbnQgY29uc3RydWN0b3JzIGltcG9zZWQgYnkgdGhlIERPTSBzcGVjIGFyZSAqbm90KiBlbmZvcmNlZC5cblx0ICAgICAqXG5cdCAgICAgKlxuXHQgICAgICogVGhlIGZvbGxvd2luZyBuZXN0ZWQgbGlzdCBzaG93cyB0aGUgc3RlcHMgZXh0ZW5kaW5nIGRvd24gZnJvbSB0aGUgSFRNTFxuXHQgICAgICogc3BlYydzIHBhcnNpbmcgc2VjdGlvbiB0aGF0IGNhdXNlIGVsZW1lbnRzIHRvIGJlIHN5bmNocm9ub3VzbHkgY3JlYXRlZCBhbmRcblx0ICAgICAqIHVwZ3JhZGVkOlxuXHQgICAgICpcblx0ICAgICAqIFRoZSBcImluIGJvZHlcIiBpbnNlcnRpb24gbW9kZTpcblx0ICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcblx0ICAgICAqIC0gU3dpdGNoIG9uIHRva2VuOlxuXHQgICAgICogICAuLiBvdGhlciBjYXNlcyAuLlxuXHQgICAgICogICAtPiBBbnkgb3RoZXIgc3RhcnQgdGFnXG5cdCAgICAgKiAgICAgIC0gW0luc2VydCBhbiBIVE1MIGVsZW1lbnRdKGJlbG93KSBmb3IgdGhlIHRva2VuLlxuXHQgICAgICpcblx0ICAgICAqIEluc2VydCBhbiBIVE1MIGVsZW1lbnQ6XG5cdCAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNpbnNlcnQtYW4taHRtbC1lbGVtZW50XG5cdCAgICAgKiAtIEluc2VydCBhIGZvcmVpZ24gZWxlbWVudCBmb3IgdGhlIHRva2VuIGluIHRoZSBIVE1MIG5hbWVzcGFjZTpcblx0ICAgICAqICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaW5zZXJ0LWEtZm9yZWlnbi1lbGVtZW50XG5cdCAgICAgKiAgIC0gQ3JlYXRlIGFuIGVsZW1lbnQgZm9yIGEgdG9rZW46XG5cdCAgICAgKiAgICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjY3JlYXRlLWFuLWVsZW1lbnQtZm9yLXRoZS10b2tlblxuXHQgICAgICogICAgIC0gV2lsbCBleGVjdXRlIHNjcmlwdCBmbGFnIGlzIHRydWU/XG5cdCAgICAgKiAgICAgICAtIChFbGVtZW50IHF1ZXVlIHB1c2hlZCB0byB0aGUgY3VzdG9tIGVsZW1lbnQgcmVhY3Rpb25zIHN0YWNrLilcblx0ICAgICAqICAgICAtIENyZWF0ZSBhbiBlbGVtZW50OlxuXHQgICAgICogICAgICAgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWNyZWF0ZS1lbGVtZW50XG5cdCAgICAgKiAgICAgICAtIFN5bmMgQ0UgZmxhZyBpcyB0cnVlP1xuXHQgICAgICogICAgICAgICAtIENvbnN0cnVjdG9yIGNhbGxlZC5cblx0ICAgICAqICAgICAgICAgLSBTZWxmLW1vZGlmaWNhdGlvbiByZXN0cmljdGlvbnMgZW5mb3JjZWQuXG5cdCAgICAgKiAgICAgICAtIFN5bmMgQ0UgZmxhZyBpcyBmYWxzZT9cblx0ICAgICAqICAgICAgICAgLSAoVXBncmFkZSByZWFjdGlvbiBlbnF1ZXVlZC4pXG5cdCAgICAgKiAgICAgLSBBdHRyaWJ1dGVzIGFwcGVuZGVkIHRvIGVsZW1lbnQuXG5cdCAgICAgKiAgICAgICAoYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AgcmVhY3Rpb25zIGVucXVldWVkLilcblx0ICAgICAqICAgICAtIFdpbGwgZXhlY3V0ZSBzY3JpcHQgZmxhZyBpcyB0cnVlP1xuXHQgICAgICogICAgICAgLSAoRWxlbWVudCBxdWV1ZSBwb3BwZWQgZnJvbSB0aGUgY3VzdG9tIGVsZW1lbnQgcmVhY3Rpb25zIHN0YWNrLlxuXHQgICAgICogICAgICAgICBSZWFjdGlvbnMgaW4gdGhlIHBvcHBlZCBzdGFjayBhcmUgaW52b2tlZC4pXG5cdCAgICAgKiAgIC0gKEVsZW1lbnQgcXVldWUgcHVzaGVkIHRvIHRoZSBjdXN0b20gZWxlbWVudCByZWFjdGlvbnMgc3RhY2suKVxuXHQgICAgICogICAtIEluc2VydCB0aGUgZWxlbWVudDpcblx0ICAgICAqICAgICBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtbm9kZS1pbnNlcnRcblx0ICAgICAqICAgICAtIFNoYWRvdy1pbmNsdWRpbmcgZGVzY2VuZGFudHMgYXJlIGNvbm5lY3RlZC4gRHVyaW5nIHBhcnNpbmdcblx0ICAgICAqICAgICAgIGNvbnN0cnVjdGlvbiwgdGhlcmUgYXJlIG5vIHNoYWRvdy0qZXhjbHVkaW5nKiBkZXNjZW5kYW50cy5cblx0ICAgICAqICAgICAgIEhvd2V2ZXIsIHRoZSBjb25zdHJ1Y3RvciBtYXkgaGF2ZSB2YWxpZGx5IGF0dGFjaGVkIGEgc2hhZG93XG5cdCAgICAgKiAgICAgICB0cmVlIHRvIGl0c2VsZiBhbmQgYWRkZWQgZGVzY2VuZGFudHMgdG8gdGhhdCBzaGFkb3cgdHJlZS5cblx0ICAgICAqICAgICAgIChgY29ubmVjdGVkQ2FsbGJhY2tgIHJlYWN0aW9ucyBlbnF1ZXVlZC4pXG5cdCAgICAgKiAgIC0gKEVsZW1lbnQgcXVldWUgcG9wcGVkIGZyb20gdGhlIGN1c3RvbSBlbGVtZW50IHJlYWN0aW9ucyBzdGFjay5cblx0ICAgICAqICAgICBSZWFjdGlvbnMgaW4gdGhlIHBvcHBlZCBzdGFjayBhcmUgaW52b2tlZC4pXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHshTm9kZX0gcm9vdFxuXHQgICAgICogQHBhcmFtIHshU2V0PE5vZGU+PX0gdmlzaXRlZEltcG9ydHNcblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdwYXRjaEFuZFVwZ3JhZGVUcmVlJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRjaEFuZFVwZ3JhZGVUcmVlKHJvb3QpIHtcblx0ICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cdFxuXHQgICAgICB2YXIgdmlzaXRlZEltcG9ydHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG5ldyBTZXQoKTtcblx0XG5cdCAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuXHRcblx0ICAgICAgdmFyIGdhdGhlckVsZW1lbnRzID0gZnVuY3Rpb24gZ2F0aGVyRWxlbWVudHMoZWxlbWVudCkge1xuXHQgICAgICAgIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PT0gJ2xpbmsnICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyZWwnKSA9PT0gJ2ltcG9ydCcpIHtcblx0ICAgICAgICAgIC8vIFRoZSBIVE1MIEltcG9ydHMgcG9seWZpbGwgc2V0cyBhIGRlc2NlbmRhbnQgZWxlbWVudCBvZiB0aGUgbGluayB0b1xuXHQgICAgICAgICAgLy8gdGhlIGBpbXBvcnRgIHByb3BlcnR5LCBzcGVjaWZpY2FsbHkgdGhpcyBpcyAqbm90KiBhIERvY3VtZW50LlxuXHQgICAgICAgICAgdmFyIGltcG9ydE5vZGUgPSAvKiogQHR5cGUgez9Ob2RlfSAqL2VsZW1lbnQuaW1wb3J0O1xuXHRcblx0ICAgICAgICAgIGlmIChpbXBvcnROb2RlIGluc3RhbmNlb2YgTm9kZSAmJiBpbXBvcnROb2RlLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcblx0ICAgICAgICAgICAgaW1wb3J0Tm9kZS5fX0NFX2lzSW1wb3J0RG9jdW1lbnQgPSB0cnVlO1xuXHRcblx0ICAgICAgICAgICAgLy8gQ29ubmVjdGVkIGxpbmtzIGFyZSBhc3NvY2lhdGVkIHdpdGggdGhlIHJlZ2lzdHJ5LlxuXHQgICAgICAgICAgICBpbXBvcnROb2RlLl9fQ0VfaGFzUmVnaXN0cnkgPSB0cnVlO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy8gSWYgdGhpcyBsaW5rJ3MgaW1wb3J0IHJvb3QgaXMgbm90IGF2YWlsYWJsZSwgaXRzIGNvbnRlbnRzIGNhbid0IGJlXG5cdCAgICAgICAgICAgIC8vIHdhbGtlZC4gV2FpdCBmb3IgJ2xvYWQnIGFuZCB3YWxrIGl0IHdoZW4gaXQncyByZWFkeS5cblx0ICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgIHZhciBpbXBvcnROb2RlID0gLyoqIEB0eXBlIHshTm9kZX0gKi9lbGVtZW50LmltcG9ydDtcblx0XG5cdCAgICAgICAgICAgICAgaWYgKGltcG9ydE5vZGUuX19DRV9kb2N1bWVudExvYWRIYW5kbGVkKSByZXR1cm47XG5cdCAgICAgICAgICAgICAgaW1wb3J0Tm9kZS5fX0NFX2RvY3VtZW50TG9hZEhhbmRsZWQgPSB0cnVlO1xuXHRcblx0ICAgICAgICAgICAgICBpbXBvcnROb2RlLl9fQ0VfaXNJbXBvcnREb2N1bWVudCA9IHRydWU7XG5cdFxuXHQgICAgICAgICAgICAgIC8vIENvbm5lY3RlZCBsaW5rcyBhcmUgYXNzb2NpYXRlZCB3aXRoIHRoZSByZWdpc3RyeS5cblx0ICAgICAgICAgICAgICBpbXBvcnROb2RlLl9fQ0VfaGFzUmVnaXN0cnkgPSB0cnVlO1xuXHRcblx0ICAgICAgICAgICAgICAvLyBDbG9uZSB0aGUgYHZpc2l0ZWRJbXBvcnRzYCBzZXQgdGhhdCB3YXMgcG9wdWxhdGVkIHN5bmMgZHVyaW5nXG5cdCAgICAgICAgICAgICAgLy8gdGhlIGBwYXRjaEFuZFVwZ3JhZGVUcmVlYCBjYWxsIHRoYXQgY2F1c2VkIHRoaXMgJ2xvYWQnIGhhbmRsZXIgdG9cblx0ICAgICAgICAgICAgICAvLyBiZSBhZGRlZC4gVGhlbiwgcmVtb3ZlICp0aGlzKiBsaW5rJ3MgaW1wb3J0IG5vZGUgc28gdGhhdCB3ZSBjYW5cblx0ICAgICAgICAgICAgICAvLyB3YWxrIHRoYXQgaW1wb3J0IGFnYWluLCBldmVuIGlmIGl0IHdhcyBwYXJ0aWFsbHkgd2Fsa2VkIGxhdGVyXG5cdCAgICAgICAgICAgICAgLy8gZHVyaW5nIHRoZSBzYW1lIGBwYXRjaEFuZFVwZ3JhZGVUcmVlYCBjYWxsLlxuXHQgICAgICAgICAgICAgIHZhciBjbG9uZWRWaXNpdGVkSW1wb3J0cyA9IG5ldyBTZXQodmlzaXRlZEltcG9ydHMpO1xuXHQgICAgICAgICAgICAgIHZpc2l0ZWRJbXBvcnRzLmRlbGV0ZShpbXBvcnROb2RlKTtcblx0XG5cdCAgICAgICAgICAgICAgX3RoaXMyLnBhdGNoQW5kVXBncmFkZVRyZWUoaW1wb3J0Tm9kZSwgdmlzaXRlZEltcG9ydHMpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcblx0ICAgICAgICB9XG5cdCAgICAgIH07XG5cdFxuXHQgICAgICAvLyBgd2Fsa0RlZXBEZXNjZW5kYW50RWxlbWVudHNgIHBvcHVsYXRlcyAoYW5kIGludGVybmFsbHkgY2hlY2tzIGFnYWluc3QpXG5cdCAgICAgIC8vIGB2aXNpdGVkSW1wb3J0c2Agd2hlbiB0cmF2ZXJzaW5nIGEgbG9hZGVkIGltcG9ydC5cblx0ICAgICAgVXRpbGl0aWVzLndhbGtEZWVwRGVzY2VuZGFudEVsZW1lbnRzKHJvb3QsIGdhdGhlckVsZW1lbnRzLCB2aXNpdGVkSW1wb3J0cyk7XG5cdFxuXHQgICAgICBpZiAodGhpcy5faGFzUGF0Y2hlcykge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIHRoaXMucGF0Y2goZWxlbWVudHNbaV0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHRcblx0ICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVsZW1lbnRzLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgIHRoaXMudXBncmFkZUVsZW1lbnQoZWxlbWVudHNbX2ldKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuXHQgICAgICovXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ3VwZ3JhZGVFbGVtZW50Jyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiB1cGdyYWRlRWxlbWVudChlbGVtZW50KSB7XG5cdCAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBlbGVtZW50Ll9fQ0Vfc3RhdGU7XG5cdCAgICAgIGlmIChjdXJyZW50U3RhdGUgIT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXHRcblx0ICAgICAgdmFyIGRlZmluaXRpb24gPSB0aGlzLmxvY2FsTmFtZVRvRGVmaW5pdGlvbihlbGVtZW50LmxvY2FsTmFtZSk7XG5cdCAgICAgIGlmICghZGVmaW5pdGlvbikgcmV0dXJuO1xuXHRcblx0ICAgICAgZGVmaW5pdGlvbi5jb25zdHJ1Y3Rpb25TdGFjay5wdXNoKGVsZW1lbnQpO1xuXHRcblx0ICAgICAgdmFyIGNvbnN0cnVjdG9yID0gZGVmaW5pdGlvbi5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBjb25zdHJ1Y3RvcigpO1xuXHQgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gZWxlbWVudCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjdXN0b20gZWxlbWVudCBjb25zdHJ1Y3RvciBkaWQgbm90IHByb2R1Y2UgdGhlIGVsZW1lbnQgYmVpbmcgdXBncmFkZWQuJyk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBmaW5hbGx5IHtcblx0ICAgICAgICAgIGRlZmluaXRpb24uY29uc3RydWN0aW9uU3RhY2sucG9wKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgZWxlbWVudC5fX0NFX3N0YXRlID0gX0N1c3RvbUVsZW1lbnRTdGF0ZTIuZGVmYXVsdC5mYWlsZWQ7XG5cdCAgICAgICAgdGhyb3cgZTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgZWxlbWVudC5fX0NFX3N0YXRlID0gX0N1c3RvbUVsZW1lbnRTdGF0ZTIuZGVmYXVsdC5jdXN0b207XG5cdCAgICAgIGVsZW1lbnQuX19DRV9kZWZpbml0aW9uID0gZGVmaW5pdGlvbjtcblx0XG5cdCAgICAgIGlmIChkZWZpbml0aW9uLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaykge1xuXHQgICAgICAgIHZhciBvYnNlcnZlZEF0dHJpYnV0ZXMgPSBkZWZpbml0aW9uLm9ic2VydmVkQXR0cmlidXRlcztcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9ic2VydmVkQXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgdmFyIG5hbWUgPSBvYnNlcnZlZEF0dHJpYnV0ZXNbaV07XG5cdCAgICAgICAgICB2YXIgdmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKTtcblx0ICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhlbGVtZW50LCBuYW1lLCBudWxsLCB2YWx1ZSwgbnVsbCk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdFxuXHQgICAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKGVsZW1lbnQpKSB7XG5cdCAgICAgICAgdGhpcy5jb25uZWN0ZWRDYWxsYmFjayhlbGVtZW50KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuXHQgICAgICovXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2Nvbm5lY3RlZENhbGxiYWNrJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBjb25uZWN0ZWRDYWxsYmFjayhlbGVtZW50KSB7XG5cdCAgICAgIHZhciBkZWZpbml0aW9uID0gZWxlbWVudC5fX0NFX2RlZmluaXRpb247XG5cdCAgICAgIGlmIChkZWZpbml0aW9uLmNvbm5lY3RlZENhbGxiYWNrKSB7XG5cdCAgICAgICAgZGVmaW5pdGlvbi5jb25uZWN0ZWRDYWxsYmFjay5jYWxsKGVsZW1lbnQpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnZGlzY29ubmVjdGVkQ2FsbGJhY2snLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2Nvbm5lY3RlZENhbGxiYWNrKGVsZW1lbnQpIHtcblx0ICAgICAgdmFyIGRlZmluaXRpb24gPSBlbGVtZW50Ll9fQ0VfZGVmaW5pdGlvbjtcblx0ICAgICAgaWYgKGRlZmluaXRpb24uZGlzY29ubmVjdGVkQ2FsbGJhY2spIHtcblx0ICAgICAgICBkZWZpbml0aW9uLmRpc2Nvbm5lY3RlZENhbGxiYWNrLmNhbGwoZWxlbWVudCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG9sZFZhbHVlXG5cdCAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG5ld1ZhbHVlXG5cdCAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG5hbWVzcGFjZVxuXHQgICAgICovXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2F0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGVsZW1lbnQsIG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgbmFtZXNwYWNlKSB7XG5cdCAgICAgIHZhciBkZWZpbml0aW9uID0gZWxlbWVudC5fX0NFX2RlZmluaXRpb247XG5cdCAgICAgIGlmIChkZWZpbml0aW9uLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayAmJiBkZWZpbml0aW9uLm9ic2VydmVkQXR0cmlidXRlcy5pbmRleE9mKG5hbWUpID4gLTEpIHtcblx0ICAgICAgICBkZWZpbml0aW9uLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjay5jYWxsKGVsZW1lbnQsIG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgbmFtZXNwYWNlKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1dKTtcblx0XG5cdCAgcmV0dXJuIEN1c3RvbUVsZW1lbnRJbnRlcm5hbHM7XG5cdH0oKTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IEN1c3RvbUVsZW1lbnRJbnRlcm5hbHM7XG5cbi8qKiovIH0sXG4vKiAzOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdGV4cG9ydHMuaXNWYWxpZEN1c3RvbUVsZW1lbnROYW1lID0gaXNWYWxpZEN1c3RvbUVsZW1lbnROYW1lO1xuXHRleHBvcnRzLmlzQ29ubmVjdGVkID0gaXNDb25uZWN0ZWQ7XG5cdGV4cG9ydHMud2Fsa0RlZXBEZXNjZW5kYW50RWxlbWVudHMgPSB3YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50cztcblx0ZXhwb3J0cy5zZXRQcm9wZXJ0eVVuY2hlY2tlZCA9IHNldFByb3BlcnR5VW5jaGVja2VkO1xuXHR2YXIgcmVzZXJ2ZWRUYWdMaXN0ID0gbmV3IFNldChbJ2Fubm90YXRpb24teG1sJywgJ2NvbG9yLXByb2ZpbGUnLCAnZm9udC1mYWNlJywgJ2ZvbnQtZmFjZS1zcmMnLCAnZm9udC1mYWNlLXVyaScsICdmb250LWZhY2UtZm9ybWF0JywgJ2ZvbnQtZmFjZS1uYW1lJywgJ21pc3NpbmctZ2x5cGgnXSk7XG5cdFxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsTmFtZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGZ1bmN0aW9uIGlzVmFsaWRDdXN0b21FbGVtZW50TmFtZShsb2NhbE5hbWUpIHtcblx0ICB2YXIgcmVzZXJ2ZWQgPSByZXNlcnZlZFRhZ0xpc3QuaGFzKGxvY2FsTmFtZSk7XG5cdCAgdmFyIHZhbGlkRm9ybSA9IC9eW2Etel1bLjAtOV9hLXpdKi1bXFwtLjAtOV9hLXpdKiQvLnRlc3QobG9jYWxOYW1lKTtcblx0ICByZXR1cm4gIXJlc2VydmVkICYmIHZhbGlkRm9ybTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGZ1bmN0aW9uIGlzQ29ubmVjdGVkKG5vZGUpIHtcblx0ICAvLyBVc2UgYE5vZGUjaXNDb25uZWN0ZWRgLCBpZiBkZWZpbmVkLlxuXHQgIHZhciBuYXRpdmVWYWx1ZSA9IG5vZGUuaXNDb25uZWN0ZWQ7XG5cdCAgaWYgKG5hdGl2ZVZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgIHJldHVybiBuYXRpdmVWYWx1ZTtcblx0ICB9XG5cdFxuXHQgIC8qKiBAdHlwZSB7P05vZGV8dW5kZWZpbmVkfSAqL1xuXHQgIHZhciBjdXJyZW50ID0gbm9kZTtcblx0ICB3aGlsZSAoY3VycmVudCAmJiAhKGN1cnJlbnQuX19DRV9pc0ltcG9ydERvY3VtZW50IHx8IGN1cnJlbnQgaW5zdGFuY2VvZiBEb2N1bWVudCkpIHtcblx0ICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGUgfHwgKHdpbmRvdy5TaGFkb3dSb290ICYmIGN1cnJlbnQgaW5zdGFuY2VvZiBTaGFkb3dSb290ID8gY3VycmVudC5ob3N0IDogdW5kZWZpbmVkKTtcblx0ICB9XG5cdCAgcmV0dXJuICEhKGN1cnJlbnQgJiYgKGN1cnJlbnQuX19DRV9pc0ltcG9ydERvY3VtZW50IHx8IGN1cnJlbnQgaW5zdGFuY2VvZiBEb2N1bWVudCkpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQHBhcmFtIHshTm9kZX0gcm9vdFxuXHQgKiBAcGFyYW0geyFOb2RlfSBzdGFydFxuXHQgKiBAcmV0dXJuIHs/Tm9kZX1cblx0ICovXG5cdGZ1bmN0aW9uIG5leHRTaWJsaW5nT3JBbmNlc3RvclNpYmxpbmcocm9vdCwgc3RhcnQpIHtcblx0ICB2YXIgbm9kZSA9IHN0YXJ0O1xuXHQgIHdoaWxlIChub2RlICYmIG5vZGUgIT09IHJvb3QgJiYgIW5vZGUubmV4dFNpYmxpbmcpIHtcblx0ICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdCAgfVxuXHQgIHJldHVybiAhbm9kZSB8fCBub2RlID09PSByb290ID8gbnVsbCA6IG5vZGUubmV4dFNpYmxpbmc7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBAcGFyYW0geyFOb2RlfSByb290XG5cdCAqIEBwYXJhbSB7IU5vZGV9IHN0YXJ0XG5cdCAqIEByZXR1cm4gez9Ob2RlfVxuXHQgKi9cblx0ZnVuY3Rpb24gbmV4dE5vZGUocm9vdCwgc3RhcnQpIHtcblx0ICByZXR1cm4gc3RhcnQuZmlyc3RDaGlsZCA/IHN0YXJ0LmZpcnN0Q2hpbGQgOiBuZXh0U2libGluZ09yQW5jZXN0b3JTaWJsaW5nKHJvb3QsIHN0YXJ0KTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEBwYXJhbSB7IU5vZGV9IHJvb3Rcblx0ICogQHBhcmFtIHshZnVuY3Rpb24oIUVsZW1lbnQpfSBjYWxsYmFja1xuXHQgKiBAcGFyYW0geyFTZXQ8Tm9kZT49fSB2aXNpdGVkSW1wb3J0c1xuXHQgKi9cblx0ZnVuY3Rpb24gd2Fsa0RlZXBEZXNjZW5kYW50RWxlbWVudHMocm9vdCwgY2FsbGJhY2spIHtcblx0ICB2YXIgdmlzaXRlZEltcG9ydHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG5ldyBTZXQoKTtcblx0XG5cdCAgdmFyIG5vZGUgPSByb290O1xuXHQgIHdoaWxlIChub2RlKSB7XG5cdCAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcblx0ICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFFbGVtZW50fSAqL25vZGU7XG5cdFxuXHQgICAgICBjYWxsYmFjayhlbGVtZW50KTtcblx0XG5cdCAgICAgIHZhciBsb2NhbE5hbWUgPSBlbGVtZW50LmxvY2FsTmFtZTtcblx0ICAgICAgaWYgKGxvY2FsTmFtZSA9PT0gJ2xpbmsnICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyZWwnKSA9PT0gJ2ltcG9ydCcpIHtcblx0ICAgICAgICAvLyBJZiB0aGlzIGltcG9ydCAocG9seWZpbGxlZCBvciBub3QpIGhhcyBpdCdzIHJvb3Qgbm9kZSBhdmFpbGFibGUsXG5cdCAgICAgICAgLy8gd2FsayBpdC5cblx0ICAgICAgICB2YXIgaW1wb3J0Tm9kZSA9IC8qKiBAdHlwZSB7IU5vZGV9ICovZWxlbWVudC5pbXBvcnQ7XG5cdCAgICAgICAgaWYgKGltcG9ydE5vZGUgaW5zdGFuY2VvZiBOb2RlICYmICF2aXNpdGVkSW1wb3J0cy5oYXMoaW1wb3J0Tm9kZSkpIHtcblx0ICAgICAgICAgIC8vIFByZXZlbnQgbXVsdGlwbGUgd2Fsa3Mgb2YgdGhlIHNhbWUgaW1wb3J0IHJvb3QuXG5cdCAgICAgICAgICB2aXNpdGVkSW1wb3J0cy5hZGQoaW1wb3J0Tm9kZSk7XG5cdFxuXHQgICAgICAgICAgZm9yICh2YXIgY2hpbGQgPSBpbXBvcnROb2RlLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG5cdCAgICAgICAgICAgIHdhbGtEZWVwRGVzY2VuZGFudEVsZW1lbnRzKGNoaWxkLCBjYWxsYmFjaywgdmlzaXRlZEltcG9ydHMpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLy8gSWdub3JlIGRlc2NlbmRhbnRzIG9mIGltcG9ydCBsaW5rcyB0byBwcmV2ZW50IGF0dGVtcHRpbmcgdG8gd2FsayB0aGVcblx0ICAgICAgICAvLyBlbGVtZW50cyBjcmVhdGVkIGJ5IHRoZSBIVE1MIEltcG9ydHMgcG9seWZpbGwgdGhhdCB3ZSBqdXN0IHdhbGtlZFxuXHQgICAgICAgIC8vIGFib3ZlLlxuXHQgICAgICAgIG5vZGUgPSBuZXh0U2libGluZ09yQW5jZXN0b3JTaWJsaW5nKHJvb3QsIGVsZW1lbnQpO1xuXHQgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICB9IGVsc2UgaWYgKGxvY2FsTmFtZSA9PT0gJ3RlbXBsYXRlJykge1xuXHQgICAgICAgIC8vIElnbm9yZSBkZXNjZW5kYW50cyBvZiB0ZW1wbGF0ZXMuIFRoZXJlIHNob3VsZG4ndCBiZSBhbnkgZGVzY2VuZGFudHNcblx0ICAgICAgICAvLyBiZWNhdXNlIHRoZXkgd2lsbCBiZSBtb3ZlZCBpbnRvIGAuY29udGVudGAgZHVyaW5nIGNvbnN0cnVjdGlvbiBpblxuXHQgICAgICAgIC8vIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0ZW1wbGF0ZSBidXQsIGluIGNhc2UgdGhleSBleGlzdCBhbmQgYXJlIHN0aWxsXG5cdCAgICAgICAgLy8gd2FpdGluZyB0byBiZSBtb3ZlZCBieSBhIHBvbHlmaWxsLCB0aGV5IHdpbGwgYmUgaWdub3JlZC5cblx0ICAgICAgICBub2RlID0gbmV4dFNpYmxpbmdPckFuY2VzdG9yU2libGluZyhyb290LCBlbGVtZW50KTtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgLy8gV2FsayBzaGFkb3cgcm9vdHMuXG5cdCAgICAgIHZhciBzaGFkb3dSb290ID0gZWxlbWVudC5fX0NFX3NoYWRvd1Jvb3Q7XG5cdCAgICAgIGlmIChzaGFkb3dSb290KSB7XG5cdCAgICAgICAgZm9yICh2YXIgX2NoaWxkID0gc2hhZG93Um9vdC5maXJzdENoaWxkOyBfY2hpbGQ7IF9jaGlsZCA9IF9jaGlsZC5uZXh0U2libGluZykge1xuXHQgICAgICAgICAgd2Fsa0RlZXBEZXNjZW5kYW50RWxlbWVudHMoX2NoaWxkLCBjYWxsYmFjaywgdmlzaXRlZEltcG9ydHMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIG5vZGUgPSBuZXh0Tm9kZShyb290LCBub2RlKTtcblx0ICB9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBVc2VkIHRvIHN1cHByZXNzIENsb3N1cmUncyBcIk1vZGlmeWluZyB0aGUgcHJvdG90eXBlIGlzIG9ubHkgYWxsb3dlZCBpZiB0aGVcblx0ICogY29uc3RydWN0b3IgaXMgaW4gdGhlIHNhbWUgc2NvcGVcIiB3YXJuaW5nIHdpdGhvdXQgdXNpbmdcblx0ICogYEBzdXBwcmVzcyB7bmV3Q2hlY2tUeXBlcywgZHVwbGljYXRlfWAgYmVjYXVzZSBgbmV3Q2hlY2tUeXBlc2AgaXMgdG9vIGJyb2FkLlxuXHQgKlxuXHQgKiBAcGFyYW0geyFPYmplY3R9IGRlc3RpbmF0aW9uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWVcblx0ICovXG5cdGZ1bmN0aW9uIHNldFByb3BlcnR5VW5jaGVja2VkKGRlc3RpbmF0aW9uLCBuYW1lLCB2YWx1ZSkge1xuXHQgIGRlc3RpbmF0aW9uW25hbWVdID0gdmFsdWU7XG5cdH1cblxuLyoqKi8gfSxcbi8qIDM5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHQvKipcblx0ICogQGVudW0ge251bWJlcn1cblx0ICovXG5cdHZhciBDdXN0b21FbGVtZW50U3RhdGUgPSB7XG5cdCAgY3VzdG9tOiAxLFxuXHQgIGZhaWxlZDogMlxuXHR9O1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gQ3VzdG9tRWxlbWVudFN0YXRlO1xuXG4vKioqLyB9LFxuLyogNDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblx0XG5cdHZhciBfQ3VzdG9tRWxlbWVudEludGVybmFscyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xuXHRcblx0dmFyIF9DdXN0b21FbGVtZW50SW50ZXJuYWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMpO1xuXHRcblx0dmFyIF9Eb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XG5cdFxuXHR2YXIgX0RvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRG9jdW1lbnRDb25zdHJ1Y3Rpb25PYnNlcnZlcik7XG5cdFxuXHR2YXIgX0RlZmVycmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG5cdFxuXHR2YXIgX0RlZmVycmVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RlZmVycmVkKTtcblx0XG5cdHZhciBfVXRpbGl0aWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XG5cdFxuXHR2YXIgVXRpbGl0aWVzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX1V0aWxpdGllcyk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cdFxuXHQvKipcblx0ICogQHVucmVzdHJpY3RlZFxuXHQgKi9cblx0dmFyIEN1c3RvbUVsZW1lbnRSZWdpc3RyeSA9IGZ1bmN0aW9uICgpIHtcblx0XG5cdCAgLyoqXG5cdCAgICogQHBhcmFtIHshQ3VzdG9tRWxlbWVudEludGVybmFsc30gaW50ZXJuYWxzXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5KGludGVybmFscykge1xuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1c3RvbUVsZW1lbnRSZWdpc3RyeSk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHR5cGUge2Jvb2xlYW59XG5cdCAgICAgKi9cblx0ICAgIHRoaXMuX2VsZW1lbnREZWZpbml0aW9uSXNSdW5uaW5nID0gZmFsc2U7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHR5cGUgeyFDdXN0b21FbGVtZW50SW50ZXJuYWxzfVxuXHQgICAgICovXG5cdCAgICB0aGlzLl9pbnRlcm5hbHMgPSBpbnRlcm5hbHM7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHR5cGUgeyFNYXA8c3RyaW5nLCAhRGVmZXJyZWQ8dW5kZWZpbmVkPj59XG5cdCAgICAgKi9cblx0ICAgIHRoaXMuX3doZW5EZWZpbmVkRGVmZXJyZWQgPSBuZXcgTWFwKCk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgZGVmYXVsdCBmbHVzaCBjYWxsYmFjayB0cmlnZ2VycyB0aGUgZG9jdW1lbnQgd2FsayBzeW5jaHJvbm91c2x5LlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEB0eXBlIHshRnVuY3Rpb259XG5cdCAgICAgKi9cblx0ICAgIHRoaXMuX2ZsdXNoQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZm4pIHtcblx0ICAgICAgcmV0dXJuIGZuKCk7XG5cdCAgICB9O1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEB0eXBlIHtib29sZWFufVxuXHQgICAgICovXG5cdCAgICB0aGlzLl9mbHVzaFBlbmRpbmcgPSBmYWxzZTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAdHlwZSB7IUFycmF5PHN0cmluZz59XG5cdCAgICAgKi9cblx0ICAgIHRoaXMuX3VuZmx1c2hlZExvY2FsTmFtZXMgPSBbXTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAdHlwZSB7IURvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXJ9XG5cdCAgICAgKi9cblx0ICAgIHRoaXMuX2RvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXIgPSBuZXcgX0RvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXIyLmRlZmF1bHQoaW50ZXJuYWxzLCBkb2N1bWVudCk7XG5cdCAgfVxuXHRcblx0ICAvKipcblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxOYW1lXG5cdCAgICogQHBhcmFtIHshRnVuY3Rpb259IGNvbnN0cnVjdG9yXG5cdCAgICovXG5cdFxuXHRcblx0ICBfY3JlYXRlQ2xhc3MoQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LCBbe1xuXHQgICAga2V5OiAnZGVmaW5lJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBkZWZpbmUobG9jYWxOYW1lLCBjb25zdHJ1Y3Rvcikge1xuXHQgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcblx0ICAgICAgaWYgKCEoY29uc3RydWN0b3IgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDdXN0b20gZWxlbWVudCBjb25zdHJ1Y3RvcnMgbXVzdCBiZSBmdW5jdGlvbnMuJyk7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIGlmICghVXRpbGl0aWVzLmlzVmFsaWRDdXN0b21FbGVtZW50TmFtZShsb2NhbE5hbWUpKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdUaGUgZWxlbWVudCBuYW1lIFxcJycgKyBsb2NhbE5hbWUgKyAnXFwnIGlzIG5vdCB2YWxpZC4nKTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgaWYgKHRoaXMuX2ludGVybmFscy5sb2NhbE5hbWVUb0RlZmluaXRpb24obG9jYWxOYW1lKSkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBjdXN0b20gZWxlbWVudCB3aXRoIG5hbWUgXFwnJyArIGxvY2FsTmFtZSArICdcXCcgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkLicpO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICBpZiAodGhpcy5fZWxlbWVudERlZmluaXRpb25Jc1J1bm5pbmcpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgY3VzdG9tIGVsZW1lbnQgaXMgYWxyZWFkeSBiZWluZyBkZWZpbmVkLicpO1xuXHQgICAgICB9XG5cdCAgICAgIHRoaXMuX2VsZW1lbnREZWZpbml0aW9uSXNSdW5uaW5nID0gdHJ1ZTtcblx0XG5cdCAgICAgIHZhciBjb25uZWN0ZWRDYWxsYmFjayA9IHZvaWQgMDtcblx0ICAgICAgdmFyIGRpc2Nvbm5lY3RlZENhbGxiYWNrID0gdm9pZCAwO1xuXHQgICAgICB2YXIgYWRvcHRlZENhbGxiYWNrID0gdm9pZCAwO1xuXHQgICAgICB2YXIgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrID0gdm9pZCAwO1xuXHQgICAgICB2YXIgb2JzZXJ2ZWRBdHRyaWJ1dGVzID0gdm9pZCAwO1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICB2YXIgZ2V0Q2FsbGJhY2sgPSBmdW5jdGlvbiBnZXRDYWxsYmFjayhuYW1lKSB7XG5cdCAgICAgICAgICAgIHZhciBjYWxsYmFja1ZhbHVlID0gcHJvdG90eXBlW25hbWVdO1xuXHQgICAgICAgICAgICBpZiAoY2FsbGJhY2tWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICEoY2FsbGJhY2tWYWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuXHQgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIFxcJycgKyBuYW1lICsgJ1xcJyBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrVmFsdWU7XG5cdCAgICAgICAgICB9O1xuXHRcblx0ICAgICAgICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cblx0ICAgICAgICAgIHZhciBwcm90b3R5cGUgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cdCAgICAgICAgICBpZiAoIShwcm90b3R5cGUgaW5zdGFuY2VvZiBPYmplY3QpKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBjdXN0b20gZWxlbWVudCBjb25zdHJ1Y3RvclxcJ3MgcHJvdG90eXBlIGlzIG5vdCBhbiBvYmplY3QuJyk7XG5cdCAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2sgPSBnZXRDYWxsYmFjaygnY29ubmVjdGVkQ2FsbGJhY2snKTtcblx0ICAgICAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrID0gZ2V0Q2FsbGJhY2soJ2Rpc2Nvbm5lY3RlZENhbGxiYWNrJyk7XG5cdCAgICAgICAgICBhZG9wdGVkQ2FsbGJhY2sgPSBnZXRDYWxsYmFjaygnYWRvcHRlZENhbGxiYWNrJyk7XG5cdCAgICAgICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgPSBnZXRDYWxsYmFjaygnYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJyk7XG5cdCAgICAgICAgICBvYnNlcnZlZEF0dHJpYnV0ZXMgPSBjb25zdHJ1Y3Rvclsnb2JzZXJ2ZWRBdHRyaWJ1dGVzJ10gfHwgW107XG5cdCAgICAgICAgfSkoKTtcblx0ICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfSBmaW5hbGx5IHtcblx0ICAgICAgICB0aGlzLl9lbGVtZW50RGVmaW5pdGlvbklzUnVubmluZyA9IGZhbHNlO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICB2YXIgZGVmaW5pdGlvbiA9IHtcblx0ICAgICAgICBsb2NhbE5hbWU6IGxvY2FsTmFtZSxcblx0ICAgICAgICBjb25zdHJ1Y3RvcjogY29uc3RydWN0b3IsXG5cdCAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2s6IGNvbm5lY3RlZENhbGxiYWNrLFxuXHQgICAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrOiBkaXNjb25uZWN0ZWRDYWxsYmFjayxcblx0ICAgICAgICBhZG9wdGVkQ2FsbGJhY2s6IGFkb3B0ZWRDYWxsYmFjayxcblx0ICAgICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6IGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayxcblx0ICAgICAgICBvYnNlcnZlZEF0dHJpYnV0ZXM6IG9ic2VydmVkQXR0cmlidXRlcyxcblx0ICAgICAgICBjb25zdHJ1Y3Rpb25TdGFjazogW11cblx0ICAgICAgfTtcblx0XG5cdCAgICAgIHRoaXMuX2ludGVybmFscy5zZXREZWZpbml0aW9uKGxvY2FsTmFtZSwgZGVmaW5pdGlvbik7XG5cdFxuXHQgICAgICB0aGlzLl91bmZsdXNoZWRMb2NhbE5hbWVzLnB1c2gobG9jYWxOYW1lKTtcblx0XG5cdCAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgY2FsbGVkIHRoZSBmbHVzaCBjYWxsYmFjayBhbmQgaXQgaGFzbid0IGNhbGxlZCBiYWNrIHlldCxcblx0ICAgICAgLy8gZG9uJ3QgY2FsbCBpdCBhZ2Fpbi5cblx0ICAgICAgaWYgKCF0aGlzLl9mbHVzaFBlbmRpbmcpIHtcblx0ICAgICAgICB0aGlzLl9mbHVzaFBlbmRpbmcgPSB0cnVlO1xuXHQgICAgICAgIHRoaXMuX2ZsdXNoQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgcmV0dXJuIF90aGlzLl9mbHVzaCgpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX2ZsdXNoJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBfZmx1c2goKSB7XG5cdCAgICAgIC8vIElmIG5vIG5ldyBkZWZpbml0aW9ucyB3ZXJlIGRlZmluZWQsIGRvbid0IGF0dGVtcHQgdG8gZmx1c2guIFRoaXMgY291bGRcblx0ICAgICAgLy8gaGFwcGVuIGlmIGEgZmx1c2ggY2FsbGJhY2sga2VlcHMgdGhlIGZ1bmN0aW9uIGl0IGlzIGdpdmVuIGFuZCBjYWxscyBpdFxuXHQgICAgICAvLyBtdWx0aXBsZSB0aW1lcy5cblx0ICAgICAgaWYgKHRoaXMuX2ZsdXNoUGVuZGluZyA9PT0gZmFsc2UpIHJldHVybjtcblx0XG5cdCAgICAgIHRoaXMuX2ZsdXNoUGVuZGluZyA9IGZhbHNlO1xuXHQgICAgICB0aGlzLl9pbnRlcm5hbHMucGF0Y2hBbmRVcGdyYWRlVHJlZShkb2N1bWVudCk7XG5cdFxuXHQgICAgICB3aGlsZSAodGhpcy5fdW5mbHVzaGVkTG9jYWxOYW1lcy5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgdmFyIGxvY2FsTmFtZSA9IHRoaXMuX3VuZmx1c2hlZExvY2FsTmFtZXMuc2hpZnQoKTtcblx0ICAgICAgICB2YXIgZGVmZXJyZWQgPSB0aGlzLl93aGVuRGVmaW5lZERlZmVycmVkLmdldChsb2NhbE5hbWUpO1xuXHQgICAgICAgIGlmIChkZWZlcnJlZCkge1xuXHQgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh1bmRlZmluZWQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsTmFtZVxuXHQgICAgICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuXHQgICAgICovXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2dldCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGxvY2FsTmFtZSkge1xuXHQgICAgICB2YXIgZGVmaW5pdGlvbiA9IHRoaXMuX2ludGVybmFscy5sb2NhbE5hbWVUb0RlZmluaXRpb24obG9jYWxOYW1lKTtcblx0ICAgICAgaWYgKGRlZmluaXRpb24pIHtcblx0ICAgICAgICByZXR1cm4gZGVmaW5pdGlvbi5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbE5hbWVcblx0ICAgICAqIEByZXR1cm4geyFQcm9taXNlPHVuZGVmaW5lZD59XG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnd2hlbkRlZmluZWQnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHdoZW5EZWZpbmVkKGxvY2FsTmFtZSkge1xuXHQgICAgICBpZiAoIVV0aWxpdGllcy5pc1ZhbGlkQ3VzdG9tRWxlbWVudE5hbWUobG9jYWxOYW1lKSkge1xuXHQgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgU3ludGF4RXJyb3IoJ1xcJycgKyBsb2NhbE5hbWUgKyAnXFwnIGlzIG5vdCBhIHZhbGlkIGN1c3RvbSBlbGVtZW50IG5hbWUuJykpO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICB2YXIgcHJpb3IgPSB0aGlzLl93aGVuRGVmaW5lZERlZmVycmVkLmdldChsb2NhbE5hbWUpO1xuXHQgICAgICBpZiAocHJpb3IpIHtcblx0ICAgICAgICByZXR1cm4gcHJpb3IudG9Qcm9taXNlKCk7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyBfRGVmZXJyZWQyLmRlZmF1bHQoKTtcblx0ICAgICAgdGhpcy5fd2hlbkRlZmluZWREZWZlcnJlZC5zZXQobG9jYWxOYW1lLCBkZWZlcnJlZCk7XG5cdFxuXHQgICAgICB2YXIgZGVmaW5pdGlvbiA9IHRoaXMuX2ludGVybmFscy5sb2NhbE5hbWVUb0RlZmluaXRpb24obG9jYWxOYW1lKTtcblx0ICAgICAgLy8gUmVzb2x2ZSBpbW1lZGlhdGVseSBvbmx5IGlmIHRoZSBnaXZlbiBsb2NhbCBuYW1lIGhhcyBhIGRlZmluaXRpb24gKmFuZCpcblx0ICAgICAgLy8gdGhlIGZ1bGwgZG9jdW1lbnQgd2FsayB0byB1cGdyYWRlIGVsZW1lbnRzIHdpdGggdGhhdCBsb2NhbCBuYW1lIGhhc1xuXHQgICAgICAvLyBhbHJlYWR5IGhhcHBlbmVkLlxuXHQgICAgICBpZiAoZGVmaW5pdGlvbiAmJiB0aGlzLl91bmZsdXNoZWRMb2NhbE5hbWVzLmluZGV4T2YobG9jYWxOYW1lKSA9PT0gLTEpIHtcblx0ICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHVuZGVmaW5lZCk7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHJldHVybiBkZWZlcnJlZC50b1Byb21pc2UoKTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdwb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBwb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrKG91dGVyKSB7XG5cdCAgICAgIHRoaXMuX2RvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXHQgICAgICB2YXIgaW5uZXIgPSB0aGlzLl9mbHVzaENhbGxiYWNrO1xuXHQgICAgICB0aGlzLl9mbHVzaENhbGxiYWNrID0gZnVuY3Rpb24gKGZsdXNoKSB7XG5cdCAgICAgICAgcmV0dXJuIG91dGVyKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIHJldHVybiBpbm5lcihmbHVzaCk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH07XG5cdCAgICB9XG5cdCAgfV0pO1xuXHRcblx0ICByZXR1cm4gQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5O1xuXHR9KCk7XG5cdFxuXHQvLyBDbG9zdXJlIGNvbXBpbGVyIGV4cG9ydHMuXG5cdFxuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5O1xuXHR3aW5kb3dbJ0N1c3RvbUVsZW1lbnRSZWdpc3RyeSddID0gQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5O1xuXHRDdXN0b21FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlWydkZWZpbmUnXSA9IEN1c3RvbUVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGUuZGVmaW5lO1xuXHRDdXN0b21FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlWydnZXQnXSA9IEN1c3RvbUVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGUuZ2V0O1xuXHRDdXN0b21FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlWyd3aGVuRGVmaW5lZCddID0gQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZS53aGVuRGVmaW5lZDtcblx0Q3VzdG9tRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZVsncG9seWZpbGxXcmFwRmx1c2hDYWxsYmFjayddID0gQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZS5wb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrO1xuXG4vKioqLyB9LFxuLyogNDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblx0XG5cdHZhciBfQ3VzdG9tRWxlbWVudEludGVybmFscyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xuXHRcblx0dmFyIF9DdXN0b21FbGVtZW50SW50ZXJuYWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMpO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cdFxuXHR2YXIgRG9jdW1lbnRDb25zdHJ1Y3Rpb25PYnNlcnZlciA9IGZ1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBEb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyKGludGVybmFscywgZG9jKSB7XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRG9jdW1lbnRDb25zdHJ1Y3Rpb25PYnNlcnZlcik7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBAdHlwZSB7IUN1c3RvbUVsZW1lbnRJbnRlcm5hbHN9XG5cdCAgICAgKi9cblx0ICAgIHRoaXMuX2ludGVybmFscyA9IGludGVybmFscztcblx0XG5cdCAgICAvKipcblx0ICAgICAqIEB0eXBlIHshRG9jdW1lbnR9XG5cdCAgICAgKi9cblx0ICAgIHRoaXMuX2RvY3VtZW50ID0gZG9jO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQHR5cGUge011dGF0aW9uT2JzZXJ2ZXJ8dW5kZWZpbmVkfVxuXHQgICAgICovXG5cdCAgICB0aGlzLl9vYnNlcnZlciA9IHVuZGVmaW5lZDtcblx0XG5cdCAgICAvLyBTaW11bGF0ZSB0cmVlIGNvbnN0cnVjdGlvbiBmb3IgYWxsIGN1cnJlbnRseSBhY2Nlc3NpYmxlIG5vZGVzIGluIHRoZVxuXHQgICAgLy8gZG9jdW1lbnQuXG5cdCAgICB0aGlzLl9pbnRlcm5hbHMucGF0Y2hBbmRVcGdyYWRlVHJlZSh0aGlzLl9kb2N1bWVudCk7XG5cdFxuXHQgICAgaWYgKHRoaXMuX2RvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuXHQgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX2hhbmRsZU11dGF0aW9ucy5iaW5kKHRoaXMpKTtcblx0XG5cdCAgICAgIC8vIE5vZGVzIGNyZWF0ZWQgYnkgdGhlIHBhcnNlciBhcmUgZ2l2ZW4gdG8gdGhlIG9ic2VydmVyICpiZWZvcmUqIHRoZSBuZXh0XG5cdCAgICAgIC8vIHRhc2sgcnVucy4gSW5saW5lIHNjcmlwdHMgYXJlIHJ1biBpbiBhIG5ldyB0YXNrLiBUaGlzIG1lYW5zIHRoYXQgdGhlXG5cdCAgICAgIC8vIG9ic2VydmVyIHdpbGwgYmUgYWJsZSB0byBoYW5kbGUgdGhlIG5ld2x5IHBhcnNlZCBub2RlcyBiZWZvcmUgdGhlIGlubGluZVxuXHQgICAgICAvLyBzY3JpcHQgaXMgcnVuLlxuXHQgICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX2RvY3VtZW50LCB7XG5cdCAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuXHQgICAgICAgIHN1YnRyZWU6IHRydWVcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfVxuXHRcblx0ICBfY3JlYXRlQ2xhc3MoRG9jdW1lbnRDb25zdHJ1Y3Rpb25PYnNlcnZlciwgW3tcblx0ICAgIGtleTogJ2Rpc2Nvbm5lY3QnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2Nvbm5lY3QoKSB7XG5cdCAgICAgIGlmICh0aGlzLl9vYnNlcnZlcikge1xuXHQgICAgICAgIHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQHBhcmFtIHshQXJyYXk8IU11dGF0aW9uUmVjb3JkPn0gbXV0YXRpb25zXG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX2hhbmRsZU11dGF0aW9ucycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZU11dGF0aW9ucyhtdXRhdGlvbnMpIHtcblx0ICAgICAgLy8gT25jZSB0aGUgZG9jdW1lbnQncyBgcmVhZHlTdGF0ZWAgaXMgJ2ludGVyYWN0aXZlJyBvciAnY29tcGxldGUnLCBhbGwgbmV3XG5cdCAgICAgIC8vIG5vZGVzIGNyZWF0ZWQgd2l0aGluIHRoYXQgZG9jdW1lbnQgd2lsbCBiZSB0aGUgcmVzdWx0IG9mIHNjcmlwdCBhbmRcblx0ICAgICAgLy8gc2hvdWxkIGJlIGhhbmRsZWQgYnkgcGF0Y2hpbmcuXG5cdCAgICAgIHZhciByZWFkeVN0YXRlID0gdGhpcy5fZG9jdW1lbnQucmVhZHlTdGF0ZTtcblx0ICAgICAgaWYgKHJlYWR5U3RhdGUgPT09ICdpbnRlcmFjdGl2ZScgfHwgcmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuXHQgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBhZGRlZE5vZGVzID0gbXV0YXRpb25zW2ldLmFkZGVkTm9kZXM7XG5cdCAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhZGRlZE5vZGVzLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICB2YXIgbm9kZSA9IGFkZGVkTm9kZXNbal07XG5cdCAgICAgICAgICB0aGlzLl9pbnRlcm5hbHMucGF0Y2hBbmRVcGdyYWRlVHJlZShub2RlKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XSk7XG5cdFxuXHQgIHJldHVybiBEb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyO1xuXHR9KCk7XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBEb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyO1xuXG4vKioqLyB9LFxuLyogNDIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblx0XG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cdFxuXHQvKipcblx0ICogQHRlbXBsYXRlIFRcblx0ICovXG5cdHZhciBEZWZlcnJlZCA9IGZ1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBEZWZlcnJlZCgpIHtcblx0ICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdFxuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERlZmVycmVkKTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAdHlwZSB7VHx1bmRlZmluZWR9XG5cdCAgICAgKi9cblx0ICAgIHRoaXMuX3ZhbHVlID0gdW5kZWZpbmVkO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEB0eXBlIHtGdW5jdGlvbnx1bmRlZmluZWR9XG5cdCAgICAgKi9cblx0ICAgIHRoaXMuX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHR5cGUgeyFQcm9taXNlPFQ+fVxuXHQgICAgICovXG5cdCAgICB0aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcblx0ICAgICAgX3RoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuXHRcblx0ICAgICAgaWYgKF90aGlzLl92YWx1ZSkge1xuXHQgICAgICAgIHJlc29sdmUoX3RoaXMuX3ZhbHVlKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfVxuXHRcblx0ICAvKipcblx0ICAgKiBAcGFyYW0ge1R9IHZhbHVlXG5cdCAgICovXG5cdFxuXHRcblx0ICBfY3JlYXRlQ2xhc3MoRGVmZXJyZWQsIFt7XG5cdCAgICBrZXk6ICdyZXNvbHZlJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlKHZhbHVlKSB7XG5cdCAgICAgIGlmICh0aGlzLl92YWx1ZSkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignQWxyZWFkeSByZXNvbHZlZC4nKTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcblx0XG5cdCAgICAgIGlmICh0aGlzLl9yZXNvbHZlKSB7XG5cdCAgICAgICAgdGhpcy5fcmVzb2x2ZSh2YWx1ZSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEByZXR1cm4geyFQcm9taXNlPFQ+fVxuXHQgICAgICovXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ3RvUHJvbWlzZScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gdG9Qcm9taXNlKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcblx0ICAgIH1cblx0ICB9XSk7XG5cdFxuXHQgIHJldHVybiBEZWZlcnJlZDtcblx0fSgpO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gRGVmZXJyZWQ7XG5cbi8qKiovIH0sXG4vKiA0MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoaW50ZXJuYWxzKSB7XG5cdCAgd2luZG93WydIVE1MRWxlbWVudCddID0gZnVuY3Rpb24gKCkge1xuXHQgICAgLyoqXG5cdCAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obmV3OiBIVE1MRWxlbWVudCk6ICFIVE1MRWxlbWVudH1cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gSFRNTEVsZW1lbnQoKSB7XG5cdCAgICAgIC8vIFRoaXMgc2hvdWxkIHJlYWxseSBiZSBgbmV3LnRhcmdldGAgYnV0IGBuZXcudGFyZ2V0YCBjYW4ndCBiZSBlbXVsYXRlZFxuXHQgICAgICAvLyBpbiBFUzUuIEFzc3VtaW5nIHRoZSB1c2VyIGtlZXBzIHRoZSBkZWZhdWx0IHZhbHVlIG9mIHRoZSBjb25zdHJ1Y3RvcidzXG5cdCAgICAgIC8vIHByb3RvdHlwZSdzIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHksIHRoaXMgaXMgZXF1aXZhbGVudC5cblx0ICAgICAgLyoqIEB0eXBlIHshRnVuY3Rpb259ICovXG5cdCAgICAgIHZhciBjb25zdHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG5cdFxuXHQgICAgICB2YXIgZGVmaW5pdGlvbiA9IGludGVybmFscy5jb25zdHJ1Y3RvclRvRGVmaW5pdGlvbihjb25zdHJ1Y3Rvcik7XG5cdCAgICAgIGlmICghZGVmaW5pdGlvbikge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGN1c3RvbSBlbGVtZW50IGJlaW5nIGNvbnN0cnVjdGVkIHdhcyBub3QgcmVnaXN0ZXJlZCB3aXRoIGBjdXN0b21FbGVtZW50c2AuJyk7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHZhciBjb25zdHJ1Y3Rpb25TdGFjayA9IGRlZmluaXRpb24uY29uc3RydWN0aW9uU3RhY2s7XG5cdFxuXHQgICAgICBpZiAoY29uc3RydWN0aW9uU3RhY2subGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgdmFyIF9lbGVtZW50ID0gX05hdGl2ZTIuZGVmYXVsdC5Eb2N1bWVudF9jcmVhdGVFbGVtZW50LmNhbGwoZG9jdW1lbnQsIGRlZmluaXRpb24ubG9jYWxOYW1lKTtcblx0ICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX2VsZW1lbnQsIGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG5cdCAgICAgICAgX2VsZW1lbnQuX19DRV9zdGF0ZSA9IF9DdXN0b21FbGVtZW50U3RhdGUyLmRlZmF1bHQuY3VzdG9tO1xuXHQgICAgICAgIF9lbGVtZW50Ll9fQ0VfZGVmaW5pdGlvbiA9IGRlZmluaXRpb247XG5cdCAgICAgICAgaW50ZXJuYWxzLnBhdGNoKF9lbGVtZW50KTtcblx0ICAgICAgICByZXR1cm4gX2VsZW1lbnQ7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHZhciBsYXN0SW5kZXggPSBjb25zdHJ1Y3Rpb25TdGFjay5sZW5ndGggLSAxO1xuXHQgICAgICB2YXIgZWxlbWVudCA9IGNvbnN0cnVjdGlvblN0YWNrW2xhc3RJbmRleF07XG5cdCAgICAgIGlmIChlbGVtZW50ID09PSBfQWxyZWFkeUNvbnN0cnVjdGVkTWFya2VyMi5kZWZhdWx0KSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgSFRNTEVsZW1lbnQgY29uc3RydWN0b3Igd2FzIGVpdGhlciBjYWxsZWQgcmVlbnRyYW50bHkgZm9yIHRoaXMgY29uc3RydWN0b3Igb3IgY2FsbGVkIG11bHRpcGxlIHRpbWVzLicpO1xuXHQgICAgICB9XG5cdCAgICAgIGNvbnN0cnVjdGlvblN0YWNrW2xhc3RJbmRleF0gPSBfQWxyZWFkeUNvbnN0cnVjdGVkTWFya2VyMi5kZWZhdWx0O1xuXHRcblx0ICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGVsZW1lbnQsIGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG5cdCAgICAgIGludGVybmFscy5wYXRjaCggLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudCk7XG5cdFxuXHQgICAgICByZXR1cm4gZWxlbWVudDtcblx0ICAgIH1cblx0XG5cdCAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUgPSBfTmF0aXZlMi5kZWZhdWx0LkhUTUxFbGVtZW50LnByb3RvdHlwZTtcblx0XG5cdCAgICByZXR1cm4gSFRNTEVsZW1lbnQ7XG5cdCAgfSgpO1xuXHR9O1xuXHRcblx0dmFyIF9OYXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcblx0XG5cdHZhciBfTmF0aXZlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05hdGl2ZSk7XG5cdFxuXHR2YXIgX0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcblx0XG5cdHZhciBfQ3VzdG9tRWxlbWVudEludGVybmFsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DdXN0b21FbGVtZW50SW50ZXJuYWxzKTtcblx0XG5cdHZhciBfQ3VzdG9tRWxlbWVudFN0YXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG5cdFxuXHR2YXIgX0N1c3RvbUVsZW1lbnRTdGF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DdXN0b21FbGVtZW50U3RhdGUpO1xuXHRcblx0dmFyIF9BbHJlYWR5Q29uc3RydWN0ZWRNYXJrZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KTtcblx0XG5cdHZhciBfQWxyZWFkeUNvbnN0cnVjdGVkTWFya2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0FscmVhZHlDb25zdHJ1Y3RlZE1hcmtlcik7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0O1xuXHRcblx0LyoqXG5cdCAqIEBwYXJhbSB7IUN1c3RvbUVsZW1lbnRJbnRlcm5hbHN9IGludGVybmFsc1xuXHQgKi9cblxuLyoqKi8gfSxcbi8qIDQ0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xuXHQgIERvY3VtZW50X2NyZWF0ZUVsZW1lbnQ6IHdpbmRvdy5Eb2N1bWVudC5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCxcblx0ICBEb2N1bWVudF9jcmVhdGVFbGVtZW50TlM6IHdpbmRvdy5Eb2N1bWVudC5wcm90b3R5cGUuY3JlYXRlRWxlbWVudE5TLFxuXHQgIERvY3VtZW50X2ltcG9ydE5vZGU6IHdpbmRvdy5Eb2N1bWVudC5wcm90b3R5cGUuaW1wb3J0Tm9kZSxcblx0ICBEb2N1bWVudF9wcmVwZW5kOiB3aW5kb3cuRG9jdW1lbnQucHJvdG90eXBlWydwcmVwZW5kJ10sXG5cdCAgRG9jdW1lbnRfYXBwZW5kOiB3aW5kb3cuRG9jdW1lbnQucHJvdG90eXBlWydhcHBlbmQnXSxcblx0ICBOb2RlX2Nsb25lTm9kZTogd2luZG93Lk5vZGUucHJvdG90eXBlLmNsb25lTm9kZSxcblx0ICBOb2RlX2FwcGVuZENoaWxkOiB3aW5kb3cuTm9kZS5wcm90b3R5cGUuYXBwZW5kQ2hpbGQsXG5cdCAgTm9kZV9pbnNlcnRCZWZvcmU6IHdpbmRvdy5Ob2RlLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUsXG5cdCAgTm9kZV9yZW1vdmVDaGlsZDogd2luZG93Lk5vZGUucHJvdG90eXBlLnJlbW92ZUNoaWxkLFxuXHQgIE5vZGVfcmVwbGFjZUNoaWxkOiB3aW5kb3cuTm9kZS5wcm90b3R5cGUucmVwbGFjZUNoaWxkLFxuXHQgIE5vZGVfdGV4dENvbnRlbnQ6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iod2luZG93Lk5vZGUucHJvdG90eXBlLCAndGV4dENvbnRlbnQnKSxcblx0ICBFbGVtZW50X2F0dGFjaFNoYWRvdzogd2luZG93LkVsZW1lbnQucHJvdG90eXBlWydhdHRhY2hTaGFkb3cnXSxcblx0ICBFbGVtZW50X2lubmVySFRNTDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUsICdpbm5lckhUTUwnKSxcblx0ICBFbGVtZW50X2dldEF0dHJpYnV0ZTogd2luZG93LkVsZW1lbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZSxcblx0ICBFbGVtZW50X3NldEF0dHJpYnV0ZTogd2luZG93LkVsZW1lbnQucHJvdG90eXBlLnNldEF0dHJpYnV0ZSxcblx0ICBFbGVtZW50X3JlbW92ZUF0dHJpYnV0ZTogd2luZG93LkVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZSxcblx0ICBFbGVtZW50X2dldEF0dHJpYnV0ZU5TOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlTlMsXG5cdCAgRWxlbWVudF9zZXRBdHRyaWJ1dGVOUzogd2luZG93LkVsZW1lbnQucHJvdG90eXBlLnNldEF0dHJpYnV0ZU5TLFxuXHQgIEVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlTlM6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGVOUyxcblx0ICBFbGVtZW50X2luc2VydEFkamFjZW50RWxlbWVudDogd2luZG93LkVsZW1lbnQucHJvdG90eXBlWydpbnNlcnRBZGphY2VudEVsZW1lbnQnXSxcblx0ICBFbGVtZW50X3ByZXBlbmQ6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZVsncHJlcGVuZCddLFxuXHQgIEVsZW1lbnRfYXBwZW5kOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGVbJ2FwcGVuZCddLFxuXHQgIEVsZW1lbnRfYmVmb3JlOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGVbJ2JlZm9yZSddLFxuXHQgIEVsZW1lbnRfYWZ0ZXI6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZVsnYWZ0ZXInXSxcblx0ICBFbGVtZW50X3JlcGxhY2VXaXRoOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGVbJ3JlcGxhY2VXaXRoJ10sXG5cdCAgRWxlbWVudF9yZW1vdmU6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZVsncmVtb3ZlJ10sXG5cdCAgSFRNTEVsZW1lbnQ6IHdpbmRvdy5IVE1MRWxlbWVudCxcblx0ICBIVE1MRWxlbWVudF9pbm5lckhUTUw6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iod2luZG93LkhUTUxFbGVtZW50LnByb3RvdHlwZSwgJ2lubmVySFRNTCcpLFxuXHQgIEhUTUxFbGVtZW50X2luc2VydEFkamFjZW50RWxlbWVudDogd2luZG93LkhUTUxFbGVtZW50LnByb3RvdHlwZVsnaW5zZXJ0QWRqYWNlbnRFbGVtZW50J11cblx0fTtcblxuLyoqKi8gfSxcbi8qIDQ1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblx0XG5cdC8qKlxuXHQgKiBUaGlzIGNsYXNzIGV4aXN0cyBvbmx5IHRvIHdvcmsgYXJvdW5kIENsb3N1cmUncyBsYWNrIG9mIGEgd2F5IHRvIGRlc2NyaWJlXG5cdCAqIHNpbmdsZXRvbnMuIEl0IHJlcHJlc2VudHMgdGhlICdhbHJlYWR5IGNvbnN0cnVjdGVkIG1hcmtlcicgdXNlZCBpbiBjdXN0b21cblx0ICogZWxlbWVudCBjb25zdHJ1Y3Rpb24gc3RhY2tzLlxuXHQgKlxuXHQgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWFscmVhZHktY29uc3RydWN0ZWQtbWFya2VyXG5cdCAqL1xuXHR2YXIgQWxyZWFkeUNvbnN0cnVjdGVkTWFya2VyID0gZnVuY3Rpb24gQWxyZWFkeUNvbnN0cnVjdGVkTWFya2VyKCkge1xuXHQgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBbHJlYWR5Q29uc3RydWN0ZWRNYXJrZXIpO1xuXHR9O1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gbmV3IEFscmVhZHlDb25zdHJ1Y3RlZE1hcmtlcigpO1xuXG4vKioqLyB9LFxuLyogNDYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGludGVybmFscykge1xuXHQgIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChEb2N1bWVudC5wcm90b3R5cGUsICdjcmVhdGVFbGVtZW50Jyxcblx0ICAvKipcblx0ICAgKiBAdGhpcyB7RG9jdW1lbnR9XG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsTmFtZVxuXHQgICAqIEByZXR1cm4geyFFbGVtZW50fVxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIChsb2NhbE5hbWUpIHtcblx0ICAgIC8vIE9ubHkgY3JlYXRlIGN1c3RvbSBlbGVtZW50cyBpZiB0aGlzIGRvY3VtZW50IGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVnaXN0cnkuXG5cdCAgICBpZiAodGhpcy5fX0NFX2hhc1JlZ2lzdHJ5KSB7XG5cdCAgICAgIHZhciBkZWZpbml0aW9uID0gaW50ZXJuYWxzLmxvY2FsTmFtZVRvRGVmaW5pdGlvbihsb2NhbE5hbWUpO1xuXHQgICAgICBpZiAoZGVmaW5pdGlvbikge1xuXHQgICAgICAgIHJldHVybiBuZXcgZGVmaW5pdGlvbi5jb25zdHJ1Y3RvcigpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgdmFyIHJlc3VsdCA9IC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovXG5cdCAgICBfTmF0aXZlMi5kZWZhdWx0LkRvY3VtZW50X2NyZWF0ZUVsZW1lbnQuY2FsbCh0aGlzLCBsb2NhbE5hbWUpO1xuXHQgICAgaW50ZXJuYWxzLnBhdGNoKHJlc3VsdCk7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH0pO1xuXHRcblx0ICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoRG9jdW1lbnQucHJvdG90eXBlLCAnaW1wb3J0Tm9kZScsXG5cdCAgLyoqXG5cdCAgICogQHRoaXMge0RvY3VtZW50fVxuXHQgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcblx0ICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBkZWVwXG5cdCAgICogQHJldHVybiB7IU5vZGV9XG5cdCAgICovXG5cdCAgZnVuY3Rpb24gKG5vZGUsIGRlZXApIHtcblx0ICAgIHZhciBjbG9uZSA9IF9OYXRpdmUyLmRlZmF1bHQuRG9jdW1lbnRfaW1wb3J0Tm9kZS5jYWxsKHRoaXMsIG5vZGUsIGRlZXApO1xuXHQgICAgLy8gT25seSBjcmVhdGUgY3VzdG9tIGVsZW1lbnRzIGlmIHRoaXMgZG9jdW1lbnQgaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSByZWdpc3RyeS5cblx0ICAgIGlmICghdGhpcy5fX0NFX2hhc1JlZ2lzdHJ5KSB7XG5cdCAgICAgIGludGVybmFscy5wYXRjaFRyZWUoY2xvbmUpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaW50ZXJuYWxzLnBhdGNoQW5kVXBncmFkZVRyZWUoY2xvbmUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNsb25lO1xuXHQgIH0pO1xuXHRcblx0ICB2YXIgTlNfSFRNTCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuXHRcblx0ICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoRG9jdW1lbnQucHJvdG90eXBlLCAnY3JlYXRlRWxlbWVudE5TJyxcblx0ICAvKipcblx0ICAgKiBAdGhpcyB7RG9jdW1lbnR9XG5cdCAgICogQHBhcmFtIHs/c3RyaW5nfSBuYW1lc3BhY2Vcblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxOYW1lXG5cdCAgICogQHJldHVybiB7IUVsZW1lbnR9XG5cdCAgICovXG5cdCAgZnVuY3Rpb24gKG5hbWVzcGFjZSwgbG9jYWxOYW1lKSB7XG5cdCAgICAvLyBPbmx5IGNyZWF0ZSBjdXN0b20gZWxlbWVudHMgaWYgdGhpcyBkb2N1bWVudCBpcyBhc3NvY2lhdGVkIHdpdGggdGhlIHJlZ2lzdHJ5LlxuXHQgICAgaWYgKHRoaXMuX19DRV9oYXNSZWdpc3RyeSAmJiAobmFtZXNwYWNlID09PSBudWxsIHx8IG5hbWVzcGFjZSA9PT0gTlNfSFRNTCkpIHtcblx0ICAgICAgdmFyIGRlZmluaXRpb24gPSBpbnRlcm5hbHMubG9jYWxOYW1lVG9EZWZpbml0aW9uKGxvY2FsTmFtZSk7XG5cdCAgICAgIGlmIChkZWZpbml0aW9uKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBkZWZpbml0aW9uLmNvbnN0cnVjdG9yKCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICB2YXIgcmVzdWx0ID0gLyoqIEB0eXBlIHshRWxlbWVudH0gKi9cblx0ICAgIF9OYXRpdmUyLmRlZmF1bHQuRG9jdW1lbnRfY3JlYXRlRWxlbWVudE5TLmNhbGwodGhpcywgbmFtZXNwYWNlLCBsb2NhbE5hbWUpO1xuXHQgICAgaW50ZXJuYWxzLnBhdGNoKHJlc3VsdCk7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH0pO1xuXHRcblx0ICAoMCwgX1BhcmVudE5vZGUyLmRlZmF1bHQpKGludGVybmFscywgRG9jdW1lbnQucHJvdG90eXBlLCB7XG5cdCAgICBwcmVwZW5kOiBfTmF0aXZlMi5kZWZhdWx0LkRvY3VtZW50X3ByZXBlbmQsXG5cdCAgICBhcHBlbmQ6IF9OYXRpdmUyLmRlZmF1bHQuRG9jdW1lbnRfYXBwZW5kXG5cdCAgfSk7XG5cdH07XG5cdFxuXHR2YXIgX05hdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xuXHRcblx0dmFyIF9OYXRpdmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTmF0aXZlKTtcblx0XG5cdHZhciBfQ3VzdG9tRWxlbWVudEludGVybmFscyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xuXHRcblx0dmFyIF9DdXN0b21FbGVtZW50SW50ZXJuYWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMpO1xuXHRcblx0dmFyIF9VdGlsaXRpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcblx0XG5cdHZhciBVdGlsaXRpZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfVXRpbGl0aWVzKTtcblx0XG5cdHZhciBfUGFyZW50Tm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpO1xuXHRcblx0dmFyIF9QYXJlbnROb2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BhcmVudE5vZGUpO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHQ7XG5cdFxuXHQvKipcblx0ICogQHBhcmFtIHshQ3VzdG9tRWxlbWVudEludGVybmFsc30gaW50ZXJuYWxzXG5cdCAqL1xuXG4vKioqLyB9LFxuLyogNDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGludGVybmFscywgZGVzdGluYXRpb24sIGJ1aWx0SW4pIHtcblx0ICAvKipcblx0ICAgKiBAcGFyYW0gey4uLighTm9kZXxzdHJpbmcpfSBub2Rlc1xuXHQgICAqL1xuXHQgIGRlc3RpbmF0aW9uWydwcmVwZW5kJ10gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbm9kZXMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcblx0ICAgICAgbm9kZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gVE9ETzogRml4IHRoaXMgZm9yIHdoZW4gb25lIG9mIGBub2Rlc2AgaXMgYSBEb2N1bWVudEZyYWdtZW50IVxuXHQgICAgdmFyIGNvbm5lY3RlZEJlZm9yZSA9IC8qKiBAdHlwZSB7IUFycmF5PCFOb2RlPn0gKi9ub2Rlcy5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgLy8gRG9jdW1lbnRGcmFnbWVudHMgYXJlIG5vdCBjb25uZWN0ZWQgYW5kIHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBsaXN0LlxuXHQgICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE5vZGUgJiYgVXRpbGl0aWVzLmlzQ29ubmVjdGVkKG5vZGUpO1xuXHQgICAgfSk7XG5cdFxuXHQgICAgYnVpbHRJbi5wcmVwZW5kLmFwcGx5KHRoaXMsIG5vZGVzKTtcblx0XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbm5lY3RlZEJlZm9yZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUoY29ubmVjdGVkQmVmb3JlW2ldKTtcblx0ICAgIH1cblx0XG5cdCAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpKSB7XG5cdCAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2Rlcy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW19pXTtcblx0ICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcblx0ICAgICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShub2RlKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHRcblx0ICAvKipcblx0ICAgKiBAcGFyYW0gey4uLighTm9kZXxzdHJpbmcpfSBub2Rlc1xuXHQgICAqL1xuXHQgIGRlc3RpbmF0aW9uWydhcHBlbmQnXSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgbm9kZXMgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuXHQgICAgICBub2Rlc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuXHQgICAgfVxuXHRcblx0ICAgIC8vIFRPRE86IEZpeCB0aGlzIGZvciB3aGVuIG9uZSBvZiBgbm9kZXNgIGlzIGEgRG9jdW1lbnRGcmFnbWVudCFcblx0ICAgIHZhciBjb25uZWN0ZWRCZWZvcmUgPSAvKiogQHR5cGUgeyFBcnJheTwhTm9kZT59ICovbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgIC8vIERvY3VtZW50RnJhZ21lbnRzIGFyZSBub3QgY29ubmVjdGVkIGFuZCB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgbGlzdC5cblx0ICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBOb2RlICYmIFV0aWxpdGllcy5pc0Nvbm5lY3RlZChub2RlKTtcblx0ICAgIH0pO1xuXHRcblx0ICAgIGJ1aWx0SW4uYXBwZW5kLmFwcGx5KHRoaXMsIG5vZGVzKTtcblx0XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbm5lY3RlZEJlZm9yZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUoY29ubmVjdGVkQmVmb3JlW2ldKTtcblx0ICAgIH1cblx0XG5cdCAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpKSB7XG5cdCAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVzLmxlbmd0aDsgX2kyKyspIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW19pMl07XG5cdCAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG5cdCAgICAgICAgICBpbnRlcm5hbHMuY29ubmVjdFRyZWUobm9kZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblx0fTtcblx0XG5cdHZhciBfQ3VzdG9tRWxlbWVudEludGVybmFscyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xuXHRcblx0dmFyIF9DdXN0b21FbGVtZW50SW50ZXJuYWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMpO1xuXHRcblx0dmFyIF9VdGlsaXRpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcblx0XG5cdHZhciBVdGlsaXRpZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfVXRpbGl0aWVzKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0LyoqXG5cdCAqIEB0eXBlZGVmIHt7XG5cdCAqICAgcHJlcGVuZDogIWZ1bmN0aW9uKC4uLighTm9kZXxzdHJpbmcpKSxcblx0ICAqICBhcHBlbmQ6ICFmdW5jdGlvbiguLi4oIU5vZGV8c3RyaW5nKSksXG5cdCAqIH19XG5cdCAqL1xuXHR2YXIgUGFyZW50Tm9kZU5hdGl2ZU1ldGhvZHMgPSB2b2lkIDA7XG5cdFxuXHQvKipcblx0ICogQHBhcmFtIHshQ3VzdG9tRWxlbWVudEludGVybmFsc30gaW50ZXJuYWxzXG5cdCAqIEBwYXJhbSB7IU9iamVjdH0gZGVzdGluYXRpb25cblx0ICogQHBhcmFtIHshUGFyZW50Tm9kZU5hdGl2ZU1ldGhvZHN9IGJ1aWx0SW5cblx0ICovXG5cdDtcblxuLyoqKi8gfSxcbi8qIDQ4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChpbnRlcm5hbHMpIHtcblx0ICAvLyBgTm9kZSNub2RlVmFsdWVgIGlzIGltcGxlbWVudGVkIG9uIGBBdHRyYC5cblx0ICAvLyBgTm9kZSN0ZXh0Q29udGVudGAgaXMgaW1wbGVtZW50ZWQgb24gYEF0dHJgLCBgRWxlbWVudGAuXG5cdFxuXHQgIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChOb2RlLnByb3RvdHlwZSwgJ2luc2VydEJlZm9yZScsXG5cdCAgLyoqXG5cdCAgICogQHRoaXMge05vZGV9XG5cdCAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuXHQgICAqIEBwYXJhbSB7P05vZGV9IHJlZk5vZGVcblx0ICAgKiBAcmV0dXJuIHshTm9kZX1cblx0ICAgKi9cblx0ICBmdW5jdGlvbiAobm9kZSwgcmVmTm9kZSkge1xuXHQgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG5cdCAgICAgIHZhciBpbnNlcnRlZE5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KG5vZGUuY2hpbGROb2Rlcyk7XG5cdCAgICAgIHZhciBfbmF0aXZlUmVzdWx0ID0gX05hdGl2ZTIuZGVmYXVsdC5Ob2RlX2luc2VydEJlZm9yZS5jYWxsKHRoaXMsIG5vZGUsIHJlZk5vZGUpO1xuXHRcblx0ICAgICAgLy8gRG9jdW1lbnRGcmFnbWVudHMgY2FuJ3QgYmUgY29ubmVjdGVkLCBzbyBgZGlzY29ubmVjdFRyZWVgIHdpbGwgbmV2ZXJcblx0ICAgICAgLy8gbmVlZCB0byBiZSBjYWxsZWQgb24gYSBEb2N1bWVudEZyYWdtZW50J3MgY2hpbGRyZW4gYWZ0ZXIgaW5zZXJ0aW5nIGl0LlxuXHRcblx0ICAgICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKSkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zZXJ0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKGluc2VydGVkTm9kZXNbaV0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHRcblx0ICAgICAgcmV0dXJuIF9uYXRpdmVSZXN1bHQ7XG5cdCAgICB9XG5cdFxuXHQgICAgdmFyIG5vZGVXYXNDb25uZWN0ZWQgPSBVdGlsaXRpZXMuaXNDb25uZWN0ZWQobm9kZSk7XG5cdCAgICB2YXIgbmF0aXZlUmVzdWx0ID0gX05hdGl2ZTIuZGVmYXVsdC5Ob2RlX2luc2VydEJlZm9yZS5jYWxsKHRoaXMsIG5vZGUsIHJlZk5vZGUpO1xuXHRcblx0ICAgIGlmIChub2RlV2FzQ29ubmVjdGVkKSB7XG5cdCAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShub2RlKTtcblx0ICAgIH1cblx0XG5cdCAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpKSB7XG5cdCAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShub2RlKTtcblx0ICAgIH1cblx0XG5cdCAgICByZXR1cm4gbmF0aXZlUmVzdWx0O1xuXHQgIH0pO1xuXHRcblx0ICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoTm9kZS5wcm90b3R5cGUsICdhcHBlbmRDaGlsZCcsXG5cdCAgLyoqXG5cdCAgICogQHRoaXMge05vZGV9XG5cdCAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuXHQgICAqIEByZXR1cm4geyFOb2RlfVxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICBpZiAobm9kZSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcblx0ICAgICAgdmFyIGluc2VydGVkTm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkobm9kZS5jaGlsZE5vZGVzKTtcblx0ICAgICAgdmFyIF9uYXRpdmVSZXN1bHQyID0gX05hdGl2ZTIuZGVmYXVsdC5Ob2RlX2FwcGVuZENoaWxkLmNhbGwodGhpcywgbm9kZSk7XG5cdFxuXHQgICAgICAvLyBEb2N1bWVudEZyYWdtZW50cyBjYW4ndCBiZSBjb25uZWN0ZWQsIHNvIGBkaXNjb25uZWN0VHJlZWAgd2lsbCBuZXZlclxuXHQgICAgICAvLyBuZWVkIHRvIGJlIGNhbGxlZCBvbiBhIERvY3VtZW50RnJhZ21lbnQncyBjaGlsZHJlbiBhZnRlciBpbnNlcnRpbmcgaXQuXG5cdFxuXHQgICAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnNlcnRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICBpbnRlcm5hbHMuY29ubmVjdFRyZWUoaW5zZXJ0ZWROb2Rlc1tpXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdFxuXHQgICAgICByZXR1cm4gX25hdGl2ZVJlc3VsdDI7XG5cdCAgICB9XG5cdFxuXHQgICAgdmFyIG5vZGVXYXNDb25uZWN0ZWQgPSBVdGlsaXRpZXMuaXNDb25uZWN0ZWQobm9kZSk7XG5cdCAgICB2YXIgbmF0aXZlUmVzdWx0ID0gX05hdGl2ZTIuZGVmYXVsdC5Ob2RlX2FwcGVuZENoaWxkLmNhbGwodGhpcywgbm9kZSk7XG5cdFxuXHQgICAgaWYgKG5vZGVXYXNDb25uZWN0ZWQpIHtcblx0ICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKG5vZGUpO1xuXHQgICAgfVxuXHRcblx0ICAgIGlmIChVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcykpIHtcblx0ICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKG5vZGUpO1xuXHQgICAgfVxuXHRcblx0ICAgIHJldHVybiBuYXRpdmVSZXN1bHQ7XG5cdCAgfSk7XG5cdFxuXHQgIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChOb2RlLnByb3RvdHlwZSwgJ2Nsb25lTm9kZScsXG5cdCAgLyoqXG5cdCAgICogQHRoaXMge05vZGV9XG5cdCAgICogQHBhcmFtIHtib29sZWFuPX0gZGVlcFxuXHQgICAqIEByZXR1cm4geyFOb2RlfVxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIChkZWVwKSB7XG5cdCAgICB2YXIgY2xvbmUgPSBfTmF0aXZlMi5kZWZhdWx0Lk5vZGVfY2xvbmVOb2RlLmNhbGwodGhpcywgZGVlcCk7XG5cdCAgICAvLyBPbmx5IGNyZWF0ZSBjdXN0b20gZWxlbWVudHMgaWYgdGhpcyBlbGVtZW50J3Mgb3duZXIgZG9jdW1lbnQgaXNcblx0ICAgIC8vIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVnaXN0cnkuXG5cdCAgICBpZiAoIXRoaXMub3duZXJEb2N1bWVudC5fX0NFX2hhc1JlZ2lzdHJ5KSB7XG5cdCAgICAgIGludGVybmFscy5wYXRjaFRyZWUoY2xvbmUpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaW50ZXJuYWxzLnBhdGNoQW5kVXBncmFkZVRyZWUoY2xvbmUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNsb25lO1xuXHQgIH0pO1xuXHRcblx0ICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoTm9kZS5wcm90b3R5cGUsICdyZW1vdmVDaGlsZCcsXG5cdCAgLyoqXG5cdCAgICogQHRoaXMge05vZGV9XG5cdCAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuXHQgICAqIEByZXR1cm4geyFOb2RlfVxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICB2YXIgbm9kZVdhc0Nvbm5lY3RlZCA9IFV0aWxpdGllcy5pc0Nvbm5lY3RlZChub2RlKTtcblx0ICAgIHZhciBuYXRpdmVSZXN1bHQgPSBfTmF0aXZlMi5kZWZhdWx0Lk5vZGVfcmVtb3ZlQ2hpbGQuY2FsbCh0aGlzLCBub2RlKTtcblx0XG5cdCAgICBpZiAobm9kZVdhc0Nvbm5lY3RlZCkge1xuXHQgICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUobm9kZSk7XG5cdCAgICB9XG5cdFxuXHQgICAgcmV0dXJuIG5hdGl2ZVJlc3VsdDtcblx0ICB9KTtcblx0XG5cdCAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKE5vZGUucHJvdG90eXBlLCAncmVwbGFjZUNoaWxkJyxcblx0ICAvKipcblx0ICAgKiBAdGhpcyB7Tm9kZX1cblx0ICAgKiBAcGFyYW0geyFOb2RlfSBub2RlVG9JbnNlcnRcblx0ICAgKiBAcGFyYW0geyFOb2RlfSBub2RlVG9SZW1vdmVcblx0ICAgKiBAcmV0dXJuIHshTm9kZX1cblx0ICAgKi9cblx0ICBmdW5jdGlvbiAobm9kZVRvSW5zZXJ0LCBub2RlVG9SZW1vdmUpIHtcblx0ICAgIGlmIChub2RlVG9JbnNlcnQgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG5cdCAgICAgIHZhciBpbnNlcnRlZE5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KG5vZGVUb0luc2VydC5jaGlsZE5vZGVzKTtcblx0ICAgICAgdmFyIF9uYXRpdmVSZXN1bHQzID0gX05hdGl2ZTIuZGVmYXVsdC5Ob2RlX3JlcGxhY2VDaGlsZC5jYWxsKHRoaXMsIG5vZGVUb0luc2VydCwgbm9kZVRvUmVtb3ZlKTtcblx0XG5cdCAgICAgIC8vIERvY3VtZW50RnJhZ21lbnRzIGNhbid0IGJlIGNvbm5lY3RlZCwgc28gYGRpc2Nvbm5lY3RUcmVlYCB3aWxsIG5ldmVyXG5cdCAgICAgIC8vIG5lZWQgdG8gYmUgY2FsbGVkIG9uIGEgRG9jdW1lbnRGcmFnbWVudCdzIGNoaWxkcmVuIGFmdGVyIGluc2VydGluZyBpdC5cblx0XG5cdCAgICAgIGlmIChVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcykpIHtcblx0ICAgICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUobm9kZVRvUmVtb3ZlKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluc2VydGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShpbnNlcnRlZE5vZGVzW2ldKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHJldHVybiBfbmF0aXZlUmVzdWx0Mztcblx0ICAgIH1cblx0XG5cdCAgICB2YXIgbm9kZVRvSW5zZXJ0V2FzQ29ubmVjdGVkID0gVXRpbGl0aWVzLmlzQ29ubmVjdGVkKG5vZGVUb0luc2VydCk7XG5cdCAgICB2YXIgbmF0aXZlUmVzdWx0ID0gX05hdGl2ZTIuZGVmYXVsdC5Ob2RlX3JlcGxhY2VDaGlsZC5jYWxsKHRoaXMsIG5vZGVUb0luc2VydCwgbm9kZVRvUmVtb3ZlKTtcblx0ICAgIHZhciB0aGlzSXNDb25uZWN0ZWQgPSBVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcyk7XG5cdFxuXHQgICAgaWYgKHRoaXNJc0Nvbm5lY3RlZCkge1xuXHQgICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUobm9kZVRvUmVtb3ZlKTtcblx0ICAgIH1cblx0XG5cdCAgICBpZiAobm9kZVRvSW5zZXJ0V2FzQ29ubmVjdGVkKSB7XG5cdCAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShub2RlVG9JbnNlcnQpO1xuXHQgICAgfVxuXHRcblx0ICAgIGlmICh0aGlzSXNDb25uZWN0ZWQpIHtcblx0ICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKG5vZGVUb0luc2VydCk7XG5cdCAgICB9XG5cdFxuXHQgICAgcmV0dXJuIG5hdGl2ZVJlc3VsdDtcblx0ICB9KTtcblx0XG5cdCAgZnVuY3Rpb24gcGF0Y2hfdGV4dENvbnRlbnQoZGVzdGluYXRpb24sIGJhc2VEZXNjcmlwdG9yKSB7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVzdGluYXRpb24sICd0ZXh0Q29udGVudCcsIHtcblx0ICAgICAgZW51bWVyYWJsZTogYmFzZURlc2NyaXB0b3IuZW51bWVyYWJsZSxcblx0ICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXHQgICAgICBnZXQ6IGJhc2VEZXNjcmlwdG9yLmdldCxcblx0ICAgICAgc2V0OiAvKiogQHRoaXMge05vZGV9ICovZnVuY3Rpb24gc2V0KGFzc2lnbmVkVmFsdWUpIHtcblx0ICAgICAgICAvLyBJZiB0aGlzIGlzIGEgdGV4dCBub2RlIHRoZW4gdGhlcmUgYXJlIG5vIG5vZGVzIHRvIGRpc2Nvbm5lY3QuXG5cdCAgICAgICAgaWYgKHRoaXMubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG5cdCAgICAgICAgICBiYXNlRGVzY3JpcHRvci5zZXQuY2FsbCh0aGlzLCBhc3NpZ25lZFZhbHVlKTtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHZhciByZW1vdmVkTm9kZXMgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgLy8gQ2hlY2tpbmcgZm9yIGBmaXJzdENoaWxkYCBpcyBmYXN0ZXIgdGhhbiByZWFkaW5nIGBjaGlsZE5vZGVzLmxlbmd0aGBcblx0ICAgICAgICAvLyB0byBjb21wYXJlIHdpdGggMC5cblx0ICAgICAgICBpZiAodGhpcy5maXJzdENoaWxkKSB7XG5cdCAgICAgICAgICAvLyBVc2luZyBgY2hpbGROb2Rlc2AgaXMgZmFzdGVyIHRoYW4gYGNoaWxkcmVuYCwgZXZlbiB0aG91Z2ggd2Ugb25seVxuXHQgICAgICAgICAgLy8gY2FyZSBhYm91dCBlbGVtZW50cy5cblx0ICAgICAgICAgIHZhciBjaGlsZE5vZGVzID0gdGhpcy5jaGlsZE5vZGVzO1xuXHQgICAgICAgICAgdmFyIGNoaWxkTm9kZXNMZW5ndGggPSBjaGlsZE5vZGVzLmxlbmd0aDtcblx0ICAgICAgICAgIGlmIChjaGlsZE5vZGVzTGVuZ3RoID4gMCAmJiBVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcykpIHtcblx0ICAgICAgICAgICAgLy8gQ29weWluZyBhbiBhcnJheSBieSBpdGVyYXRpbmcgaXMgZmFzdGVyIHRoYW4gdXNpbmcgc2xpY2UuXG5cdCAgICAgICAgICAgIHJlbW92ZWROb2RlcyA9IG5ldyBBcnJheShjaGlsZE5vZGVzTGVuZ3RoKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZE5vZGVzTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICByZW1vdmVkTm9kZXNbaV0gPSBjaGlsZE5vZGVzW2ldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBiYXNlRGVzY3JpcHRvci5zZXQuY2FsbCh0aGlzLCBhc3NpZ25lZFZhbHVlKTtcblx0XG5cdCAgICAgICAgaWYgKHJlbW92ZWROb2Rlcykge1xuXHQgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHJlbW92ZWROb2Rlcy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKHJlbW92ZWROb2Rlc1tfaV0pO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfVxuXHRcblx0ICBpZiAoX05hdGl2ZTIuZGVmYXVsdC5Ob2RlX3RleHRDb250ZW50ICYmIF9OYXRpdmUyLmRlZmF1bHQuTm9kZV90ZXh0Q29udGVudC5nZXQpIHtcblx0ICAgIHBhdGNoX3RleHRDb250ZW50KE5vZGUucHJvdG90eXBlLCBfTmF0aXZlMi5kZWZhdWx0Lk5vZGVfdGV4dENvbnRlbnQpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBpbnRlcm5hbHMuYWRkUGF0Y2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0ICAgICAgcGF0Y2hfdGV4dENvbnRlbnQoZWxlbWVudCwge1xuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIC8vIE5PVEU6IFRoaXMgaW1wbGVtZW50YXRpb24gb2YgdGhlIGB0ZXh0Q29udGVudGAgZ2V0dGVyIGFzc3VtZXMgdGhhdFxuXHQgICAgICAgIC8vIHRleHQgbm9kZXMnIGB0ZXh0Q29udGVudGAgZ2V0dGVyIHdpbGwgbm90IGJlIHBhdGNoZWQuXG5cdCAgICAgICAgZ2V0OiAvKiogQHRoaXMge05vZGV9ICovZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICAgICAgLyoqIEB0eXBlIHshQXJyYXk8c3RyaW5nPn0gKi9cblx0ICAgICAgICAgIHZhciBwYXJ0cyA9IFtdO1xuXHRcblx0ICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5jaGlsZE5vZGVzW2ldLnRleHRDb250ZW50KTtcblx0ICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICByZXR1cm4gcGFydHMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IC8qKiBAdGhpcyB7Tm9kZX0gKi9mdW5jdGlvbiBzZXQoYXNzaWduZWRWYWx1ZSkge1xuXHQgICAgICAgICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuXHQgICAgICAgICAgICBfTmF0aXZlMi5kZWZhdWx0Lk5vZGVfcmVtb3ZlQ2hpbGQuY2FsbCh0aGlzLCB0aGlzLmZpcnN0Q2hpbGQpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgX05hdGl2ZTIuZGVmYXVsdC5Ob2RlX2FwcGVuZENoaWxkLmNhbGwodGhpcywgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYXNzaWduZWRWYWx1ZSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9KTtcblx0ICB9XG5cdH07XG5cdFxuXHR2YXIgX05hdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xuXHRcblx0dmFyIF9OYXRpdmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTmF0aXZlKTtcblx0XG5cdHZhciBfQ3VzdG9tRWxlbWVudEludGVybmFscyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xuXHRcblx0dmFyIF9DdXN0b21FbGVtZW50SW50ZXJuYWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMpO1xuXHRcblx0dmFyIF9VdGlsaXRpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcblx0XG5cdHZhciBVdGlsaXRpZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfVXRpbGl0aWVzKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0O1xuXHRcblx0LyoqXG5cdCAqIEBwYXJhbSB7IUN1c3RvbUVsZW1lbnRJbnRlcm5hbHN9IGludGVybmFsc1xuXHQgKi9cblxuLyoqKi8gfSxcbi8qIDQ5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChpbnRlcm5hbHMpIHtcblx0ICBpZiAoX05hdGl2ZTIuZGVmYXVsdC5FbGVtZW50X2F0dGFjaFNoYWRvdykge1xuXHQgICAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKEVsZW1lbnQucHJvdG90eXBlLCAnYXR0YWNoU2hhZG93Jyxcblx0ICAgIC8qKlxuXHQgICAgICogQHRoaXMge0VsZW1lbnR9XG5cdCAgICAgKiBAcGFyYW0geyF7bW9kZTogc3RyaW5nfX0gaW5pdFxuXHQgICAgICogQHJldHVybiB7U2hhZG93Um9vdH1cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gKGluaXQpIHtcblx0ICAgICAgdmFyIHNoYWRvd1Jvb3QgPSBfTmF0aXZlMi5kZWZhdWx0LkVsZW1lbnRfYXR0YWNoU2hhZG93LmNhbGwodGhpcywgaW5pdCk7XG5cdCAgICAgIHRoaXMuX19DRV9zaGFkb3dSb290ID0gc2hhZG93Um9vdDtcblx0ICAgICAgcmV0dXJuIHNoYWRvd1Jvb3Q7XG5cdCAgICB9KTtcblx0ICB9IGVsc2Uge1xuXHQgICAgY29uc29sZS53YXJuKCdDdXN0b20gRWxlbWVudHM6IGBFbGVtZW50I2F0dGFjaFNoYWRvd2Agd2FzIG5vdCBwYXRjaGVkLicpO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gcGF0Y2hfaW5uZXJIVE1MKGRlc3RpbmF0aW9uLCBiYXNlRGVzY3JpcHRvcikge1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlc3RpbmF0aW9uLCAnaW5uZXJIVE1MJywge1xuXHQgICAgICBlbnVtZXJhYmxlOiBiYXNlRGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuXHQgICAgICBjb25maWd1cmFibGU6IHRydWUsXG5cdCAgICAgIGdldDogYmFzZURlc2NyaXB0b3IuZ2V0LFxuXHQgICAgICBzZXQ6IC8qKiBAdGhpcyB7RWxlbWVudH0gKi9mdW5jdGlvbiBzZXQoaHRtbFN0cmluZykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdFxuXHQgICAgICAgIHZhciBpc0Nvbm5lY3RlZCA9IFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKTtcblx0XG5cdCAgICAgICAgLy8gTk9URTogSW4gSUUxMSwgd2hlbiB1c2luZyB0aGUgbmF0aXZlIGBpbm5lckhUTUxgIHNldHRlciwgYWxsIG5vZGVzXG5cdCAgICAgICAgLy8gdGhhdCB3ZXJlIHByZXZpb3VzbHkgZGVzY2VuZGFudHMgb2YgdGhlIGNvbnRleHQgZWxlbWVudCBoYXZlIGFsbCBvZlxuXHQgICAgICAgIC8vIHRoZWlyIGNoaWxkcmVuIHJlbW92ZWQgYXMgcGFydCBvZiB0aGUgc2V0IC0gdGhlIGVudGlyZSBzdWJ0cmVlIGlzXG5cdCAgICAgICAgLy8gJ2Rpc2Fzc2VtYmxlZCcuIFRoaXMgd29yayBhcm91bmQgd2Fsa3MgdGhlIHN1YnRyZWUgKmJlZm9yZSogdXNpbmcgdGhlXG5cdCAgICAgICAgLy8gbmF0aXZlIHNldHRlci5cblx0ICAgICAgICAvKiogQHR5cGUgeyFBcnJheTwhRWxlbWVudD58dW5kZWZpbmVkfSAqL1xuXHQgICAgICAgIHZhciByZW1vdmVkRWxlbWVudHMgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgaWYgKGlzQ29ubmVjdGVkKSB7XG5cdCAgICAgICAgICByZW1vdmVkRWxlbWVudHMgPSBbXTtcblx0ICAgICAgICAgIFV0aWxpdGllcy53YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50cyh0aGlzLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuXHQgICAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gX3RoaXMpIHtcblx0ICAgICAgICAgICAgICByZW1vdmVkRWxlbWVudHMucHVzaChlbGVtZW50KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBiYXNlRGVzY3JpcHRvci5zZXQuY2FsbCh0aGlzLCBodG1sU3RyaW5nKTtcblx0XG5cdCAgICAgICAgaWYgKHJlbW92ZWRFbGVtZW50cykge1xuXHQgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW1vdmVkRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSByZW1vdmVkRWxlbWVudHNbaV07XG5cdCAgICAgICAgICAgIGlmIChlbGVtZW50Ll9fQ0Vfc3RhdGUgPT09IF9DdXN0b21FbGVtZW50U3RhdGUyLmRlZmF1bHQuY3VzdG9tKSB7XG5cdCAgICAgICAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RlZENhbGxiYWNrKGVsZW1lbnQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvLyBPbmx5IGNyZWF0ZSBjdXN0b20gZWxlbWVudHMgaWYgdGhpcyBlbGVtZW50J3Mgb3duZXIgZG9jdW1lbnQgaXNcblx0ICAgICAgICAvLyBhc3NvY2lhdGVkIHdpdGggdGhlIHJlZ2lzdHJ5LlxuXHQgICAgICAgIGlmICghdGhpcy5vd25lckRvY3VtZW50Ll9fQ0VfaGFzUmVnaXN0cnkpIHtcblx0ICAgICAgICAgIGludGVybmFscy5wYXRjaFRyZWUodGhpcyk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGludGVybmFscy5wYXRjaEFuZFVwZ3JhZGVUcmVlKHRoaXMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gaHRtbFN0cmluZztcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfVxuXHRcblx0ICBpZiAoX05hdGl2ZTIuZGVmYXVsdC5FbGVtZW50X2lubmVySFRNTCAmJiBfTmF0aXZlMi5kZWZhdWx0LkVsZW1lbnRfaW5uZXJIVE1MLmdldCkge1xuXHQgICAgcGF0Y2hfaW5uZXJIVE1MKEVsZW1lbnQucHJvdG90eXBlLCBfTmF0aXZlMi5kZWZhdWx0LkVsZW1lbnRfaW5uZXJIVE1MKTtcblx0ICB9IGVsc2UgaWYgKF9OYXRpdmUyLmRlZmF1bHQuSFRNTEVsZW1lbnRfaW5uZXJIVE1MICYmIF9OYXRpdmUyLmRlZmF1bHQuSFRNTEVsZW1lbnRfaW5uZXJIVE1MLmdldCkge1xuXHQgICAgcGF0Y2hfaW5uZXJIVE1MKEhUTUxFbGVtZW50LnByb3RvdHlwZSwgX05hdGl2ZTIuZGVmYXVsdC5IVE1MRWxlbWVudF9pbm5lckhUTUwpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHRcblx0ICAgICAgLyoqIEB0eXBlIHtIVE1MRGl2RWxlbWVudH0gKi9cblx0ICAgICAgdmFyIHJhd0RpdiA9IF9OYXRpdmUyLmRlZmF1bHQuRG9jdW1lbnRfY3JlYXRlRWxlbWVudC5jYWxsKGRvY3VtZW50LCAnZGl2Jyk7XG5cdFxuXHQgICAgICBpbnRlcm5hbHMuYWRkUGF0Y2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0ICAgICAgICBwYXRjaF9pbm5lckhUTUwoZWxlbWVudCwge1xuXHQgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0ICAgICAgICAgIC8vIEltcGxlbWVudHMgZ2V0dGluZyBgaW5uZXJIVE1MYCBieSBwZXJmb3JtaW5nIGFuIHVucGF0Y2hlZCBgY2xvbmVOb2RlYFxuXHQgICAgICAgICAgLy8gb2YgdGhlIGVsZW1lbnQgYW5kIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIGVsZW1lbnQncyBgaW5uZXJIVE1MYC5cblx0ICAgICAgICAgIC8vIFRPRE86IElzIHRoaXMgdG9vIGV4cGVuc2l2ZT9cblx0ICAgICAgICAgIGdldDogLyoqIEB0aGlzIHtFbGVtZW50fSAqL2Z1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9OYXRpdmUyLmRlZmF1bHQuTm9kZV9jbG9uZU5vZGUuY2FsbCh0aGlzLCB0cnVlKS5pbm5lckhUTUw7XG5cdCAgICAgICAgICB9LFxuXHQgICAgICAgICAgLy8gSW1wbGVtZW50cyBzZXR0aW5nIGBpbm5lckhUTUxgIGJ5IGNyZWF0aW5nIGFuIHVucGF0Y2hlZCBlbGVtZW50LFxuXHQgICAgICAgICAgLy8gc2V0dGluZyBgaW5uZXJIVE1MYCBvZiB0aGF0IGVsZW1lbnQgYW5kIHJlcGxhY2luZyB0aGUgdGFyZ2V0XG5cdCAgICAgICAgICAvLyBlbGVtZW50J3MgY2hpbGRyZW4gd2l0aCB0aG9zZSBvZiB0aGUgdW5wYXRjaGVkIGVsZW1lbnQuXG5cdCAgICAgICAgICBzZXQ6IC8qKiBAdGhpcyB7RWxlbWVudH0gKi9mdW5jdGlvbiBzZXQoYXNzaWduZWRWYWx1ZSkge1xuXHQgICAgICAgICAgICAvLyBOT1RFOiByZS1yb3V0ZSB0byBgY29udGVudGAgZm9yIGB0ZW1wbGF0ZWAgZWxlbWVudHMuXG5cdCAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZG8gdGhpcyBiZWNhdXNlIGB0ZW1wbGF0ZS5hcHBlbmRDaGlsZGAgZG9lcyBub3Rcblx0ICAgICAgICAgICAgLy8gcm91dGUgaW50byBgdGVtcGxhdGUuY29udGVudGAuXG5cdCAgICAgICAgICAgIC8qKiBAdHlwZSB7IU5vZGV9ICovXG5cdCAgICAgICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5sb2NhbE5hbWUgPT09ICd0ZW1wbGF0ZScgPyAvKiogQHR5cGUgeyFIVE1MVGVtcGxhdGVFbGVtZW50fSAqL3RoaXMuY29udGVudCA6IHRoaXM7XG5cdCAgICAgICAgICAgIHJhd0Rpdi5pbm5lckhUTUwgPSBhc3NpZ25lZFZhbHVlO1xuXHRcblx0ICAgICAgICAgICAgd2hpbGUgKGNvbnRlbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgX05hdGl2ZTIuZGVmYXVsdC5Ob2RlX3JlbW92ZUNoaWxkLmNhbGwoY29udGVudCwgY29udGVudC5jaGlsZE5vZGVzWzBdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB3aGlsZSAocmF3RGl2LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgIF9OYXRpdmUyLmRlZmF1bHQuTm9kZV9hcHBlbmRDaGlsZC5jYWxsKGNvbnRlbnQsIHJhd0Rpdi5jaGlsZE5vZGVzWzBdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9KTtcblx0ICAgIH0pKCk7XG5cdCAgfVxuXHRcblx0ICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoRWxlbWVudC5wcm90b3R5cGUsICdzZXRBdHRyaWJ1dGUnLFxuXHQgIC8qKlxuXHQgICAqIEB0aGlzIHtFbGVtZW50fVxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IG5ld1ZhbHVlXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gKG5hbWUsIG5ld1ZhbHVlKSB7XG5cdCAgICAvLyBGYXN0IHBhdGggZm9yIG5vbi1jdXN0b20gZWxlbWVudHMuXG5cdCAgICBpZiAodGhpcy5fX0NFX3N0YXRlICE9PSBfQ3VzdG9tRWxlbWVudFN0YXRlMi5kZWZhdWx0LmN1c3RvbSkge1xuXHQgICAgICByZXR1cm4gX05hdGl2ZTIuZGVmYXVsdC5FbGVtZW50X3NldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUsIG5ld1ZhbHVlKTtcblx0ICAgIH1cblx0XG5cdCAgICB2YXIgb2xkVmFsdWUgPSBfTmF0aXZlMi5kZWZhdWx0LkVsZW1lbnRfZ2V0QXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSk7XG5cdCAgICBfTmF0aXZlMi5kZWZhdWx0LkVsZW1lbnRfc2V0QXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSwgbmV3VmFsdWUpO1xuXHQgICAgbmV3VmFsdWUgPSBfTmF0aXZlMi5kZWZhdWx0LkVsZW1lbnRfZ2V0QXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSk7XG5cdCAgICBpZiAob2xkVmFsdWUgIT09IG5ld1ZhbHVlKSB7XG5cdCAgICAgIGludGVybmFscy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sodGhpcywgbmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlLCBudWxsKTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKEVsZW1lbnQucHJvdG90eXBlLCAnc2V0QXR0cmlidXRlTlMnLFxuXHQgIC8qKlxuXHQgICAqIEB0aGlzIHtFbGVtZW50fVxuXHQgICAqIEBwYXJhbSB7P3N0cmluZ30gbmFtZXNwYWNlXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3VmFsdWVcblx0ICAgKi9cblx0ICBmdW5jdGlvbiAobmFtZXNwYWNlLCBuYW1lLCBuZXdWYWx1ZSkge1xuXHQgICAgLy8gRmFzdCBwYXRoIGZvciBub24tY3VzdG9tIGVsZW1lbnRzLlxuXHQgICAgaWYgKHRoaXMuX19DRV9zdGF0ZSAhPT0gX0N1c3RvbUVsZW1lbnRTdGF0ZTIuZGVmYXVsdC5jdXN0b20pIHtcblx0ICAgICAgcmV0dXJuIF9OYXRpdmUyLmRlZmF1bHQuRWxlbWVudF9zZXRBdHRyaWJ1dGVOUy5jYWxsKHRoaXMsIG5hbWVzcGFjZSwgbmFtZSwgbmV3VmFsdWUpO1xuXHQgICAgfVxuXHRcblx0ICAgIHZhciBvbGRWYWx1ZSA9IF9OYXRpdmUyLmRlZmF1bHQuRWxlbWVudF9nZXRBdHRyaWJ1dGVOUy5jYWxsKHRoaXMsIG5hbWVzcGFjZSwgbmFtZSk7XG5cdCAgICBfTmF0aXZlMi5kZWZhdWx0LkVsZW1lbnRfc2V0QXR0cmlidXRlTlMuY2FsbCh0aGlzLCBuYW1lc3BhY2UsIG5hbWUsIG5ld1ZhbHVlKTtcblx0ICAgIG5ld1ZhbHVlID0gX05hdGl2ZTIuZGVmYXVsdC5FbGVtZW50X2dldEF0dHJpYnV0ZU5TLmNhbGwodGhpcywgbmFtZXNwYWNlLCBuYW1lKTtcblx0ICAgIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcblx0ICAgICAgaW50ZXJuYWxzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayh0aGlzLCBuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIG5hbWVzcGFjZSk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChFbGVtZW50LnByb3RvdHlwZSwgJ3JlbW92ZUF0dHJpYnV0ZScsXG5cdCAgLyoqXG5cdCAgICogQHRoaXMge0VsZW1lbnR9XG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICAgKi9cblx0ICBmdW5jdGlvbiAobmFtZSkge1xuXHQgICAgLy8gRmFzdCBwYXRoIGZvciBub24tY3VzdG9tIGVsZW1lbnRzLlxuXHQgICAgaWYgKHRoaXMuX19DRV9zdGF0ZSAhPT0gX0N1c3RvbUVsZW1lbnRTdGF0ZTIuZGVmYXVsdC5jdXN0b20pIHtcblx0ICAgICAgcmV0dXJuIF9OYXRpdmUyLmRlZmF1bHQuRWxlbWVudF9yZW1vdmVBdHRyaWJ1dGUuY2FsbCh0aGlzLCBuYW1lKTtcblx0ICAgIH1cblx0XG5cdCAgICB2YXIgb2xkVmFsdWUgPSBfTmF0aXZlMi5kZWZhdWx0LkVsZW1lbnRfZ2V0QXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSk7XG5cdCAgICBfTmF0aXZlMi5kZWZhdWx0LkVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSk7XG5cdCAgICBpZiAob2xkVmFsdWUgIT09IG51bGwpIHtcblx0ICAgICAgaW50ZXJuYWxzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayh0aGlzLCBuYW1lLCBvbGRWYWx1ZSwgbnVsbCwgbnVsbCk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChFbGVtZW50LnByb3RvdHlwZSwgJ3JlbW92ZUF0dHJpYnV0ZU5TJyxcblx0ICAvKipcblx0ICAgKiBAdGhpcyB7RWxlbWVudH1cblx0ICAgKiBAcGFyYW0gez9zdHJpbmd9IG5hbWVzcGFjZVxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gKG5hbWVzcGFjZSwgbmFtZSkge1xuXHQgICAgLy8gRmFzdCBwYXRoIGZvciBub24tY3VzdG9tIGVsZW1lbnRzLlxuXHQgICAgaWYgKHRoaXMuX19DRV9zdGF0ZSAhPT0gX0N1c3RvbUVsZW1lbnRTdGF0ZTIuZGVmYXVsdC5jdXN0b20pIHtcblx0ICAgICAgcmV0dXJuIF9OYXRpdmUyLmRlZmF1bHQuRWxlbWVudF9yZW1vdmVBdHRyaWJ1dGVOUy5jYWxsKHRoaXMsIG5hbWVzcGFjZSwgbmFtZSk7XG5cdCAgICB9XG5cdFxuXHQgICAgdmFyIG9sZFZhbHVlID0gX05hdGl2ZTIuZGVmYXVsdC5FbGVtZW50X2dldEF0dHJpYnV0ZU5TLmNhbGwodGhpcywgbmFtZXNwYWNlLCBuYW1lKTtcblx0ICAgIF9OYXRpdmUyLmRlZmF1bHQuRWxlbWVudF9yZW1vdmVBdHRyaWJ1dGVOUy5jYWxsKHRoaXMsIG5hbWVzcGFjZSwgbmFtZSk7XG5cdCAgICAvLyBJbiBvbGRlciBicm93c2VycywgYEVsZW1lbnQjZ2V0QXR0cmlidXRlTlNgIG1heSByZXR1cm4gdGhlIGVtcHR5IHN0cmluZ1xuXHQgICAgLy8gaW5zdGVhZCBvZiBudWxsIGlmIHRoZSBhdHRyaWJ1dGUgZG9lcyBub3QgZXhpc3QuIEZvciBkZXRhaWxzLCBzZWU7XG5cdCAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9nZXRBdHRyaWJ1dGVOUyNOb3Rlc1xuXHQgICAgdmFyIG5ld1ZhbHVlID0gX05hdGl2ZTIuZGVmYXVsdC5FbGVtZW50X2dldEF0dHJpYnV0ZU5TLmNhbGwodGhpcywgbmFtZXNwYWNlLCBuYW1lKTtcblx0ICAgIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcblx0ICAgICAgaW50ZXJuYWxzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayh0aGlzLCBuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIG5hbWVzcGFjZSk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIGZ1bmN0aW9uIHBhdGNoX2luc2VydEFkamFjZW50RWxlbWVudChkZXN0aW5hdGlvbiwgYmFzZU1ldGhvZCkge1xuXHQgICAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKGRlc3RpbmF0aW9uLCAnaW5zZXJ0QWRqYWNlbnRFbGVtZW50Jyxcblx0ICAgIC8qKlxuXHQgICAgICogQHRoaXMge0VsZW1lbnR9XG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2hlcmVcblx0ICAgICAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcblx0ICAgICAqIEByZXR1cm4gez9FbGVtZW50fVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiAod2hlcmUsIGVsZW1lbnQpIHtcblx0ICAgICAgdmFyIHdhc0Nvbm5lY3RlZCA9IFV0aWxpdGllcy5pc0Nvbm5lY3RlZChlbGVtZW50KTtcblx0ICAgICAgdmFyIGluc2VydGVkRWxlbWVudCA9IC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovXG5cdCAgICAgIGJhc2VNZXRob2QuY2FsbCh0aGlzLCB3aGVyZSwgZWxlbWVudCk7XG5cdFxuXHQgICAgICBpZiAod2FzQ29ubmVjdGVkKSB7XG5cdCAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKGVsZW1lbnQpO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKGluc2VydGVkRWxlbWVudCkpIHtcblx0ICAgICAgICBpbnRlcm5hbHMuY29ubmVjdFRyZWUoZWxlbWVudCk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGluc2VydGVkRWxlbWVudDtcblx0ICAgIH0pO1xuXHQgIH1cblx0XG5cdCAgaWYgKF9OYXRpdmUyLmRlZmF1bHQuSFRNTEVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRFbGVtZW50KSB7XG5cdCAgICBwYXRjaF9pbnNlcnRBZGphY2VudEVsZW1lbnQoSFRNTEVsZW1lbnQucHJvdG90eXBlLCBfTmF0aXZlMi5kZWZhdWx0LkhUTUxFbGVtZW50X2luc2VydEFkamFjZW50RWxlbWVudCk7XG5cdCAgfSBlbHNlIGlmIChfTmF0aXZlMi5kZWZhdWx0LkVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRFbGVtZW50KSB7XG5cdCAgICBwYXRjaF9pbnNlcnRBZGphY2VudEVsZW1lbnQoRWxlbWVudC5wcm90b3R5cGUsIF9OYXRpdmUyLmRlZmF1bHQuRWxlbWVudF9pbnNlcnRBZGphY2VudEVsZW1lbnQpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBjb25zb2xlLndhcm4oJ0N1c3RvbSBFbGVtZW50czogYEVsZW1lbnQjaW5zZXJ0QWRqYWNlbnRFbGVtZW50YCB3YXMgbm90IHBhdGNoZWQuJyk7XG5cdCAgfVxuXHRcblx0ICAoMCwgX1BhcmVudE5vZGUyLmRlZmF1bHQpKGludGVybmFscywgRWxlbWVudC5wcm90b3R5cGUsIHtcblx0ICAgIHByZXBlbmQ6IF9OYXRpdmUyLmRlZmF1bHQuRWxlbWVudF9wcmVwZW5kLFxuXHQgICAgYXBwZW5kOiBfTmF0aXZlMi5kZWZhdWx0LkVsZW1lbnRfYXBwZW5kXG5cdCAgfSk7XG5cdFxuXHQgICgwLCBfQ2hpbGROb2RlMi5kZWZhdWx0KShpbnRlcm5hbHMsIEVsZW1lbnQucHJvdG90eXBlLCB7XG5cdCAgICBiZWZvcmU6IF9OYXRpdmUyLmRlZmF1bHQuRWxlbWVudF9iZWZvcmUsXG5cdCAgICBhZnRlcjogX05hdGl2ZTIuZGVmYXVsdC5FbGVtZW50X2FmdGVyLFxuXHQgICAgcmVwbGFjZVdpdGg6IF9OYXRpdmUyLmRlZmF1bHQuRWxlbWVudF9yZXBsYWNlV2l0aCxcblx0ICAgIHJlbW92ZTogX05hdGl2ZTIuZGVmYXVsdC5FbGVtZW50X3JlbW92ZVxuXHQgIH0pO1xuXHR9O1xuXHRcblx0dmFyIF9OYXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcblx0XG5cdHZhciBfTmF0aXZlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05hdGl2ZSk7XG5cdFxuXHR2YXIgX0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcblx0XG5cdHZhciBfQ3VzdG9tRWxlbWVudEludGVybmFsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DdXN0b21FbGVtZW50SW50ZXJuYWxzKTtcblx0XG5cdHZhciBfQ3VzdG9tRWxlbWVudFN0YXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG5cdFxuXHR2YXIgX0N1c3RvbUVsZW1lbnRTdGF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DdXN0b21FbGVtZW50U3RhdGUpO1xuXHRcblx0dmFyIF9VdGlsaXRpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcblx0XG5cdHZhciBVdGlsaXRpZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfVXRpbGl0aWVzKTtcblx0XG5cdHZhciBfUGFyZW50Tm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpO1xuXHRcblx0dmFyIF9QYXJlbnROb2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BhcmVudE5vZGUpO1xuXHRcblx0dmFyIF9DaGlsZE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKTtcblx0XG5cdHZhciBfQ2hpbGROb2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NoaWxkTm9kZSk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdDtcblx0XG5cdC8qKlxuXHQgKiBAcGFyYW0geyFDdXN0b21FbGVtZW50SW50ZXJuYWxzfSBpbnRlcm5hbHNcblx0ICovXG5cbi8qKiovIH0sXG4vKiA1MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoaW50ZXJuYWxzLCBkZXN0aW5hdGlvbiwgYnVpbHRJbikge1xuXHQgIC8qKlxuXHQgICAqIEBwYXJhbSB7Li4uKCFOb2RlfHN0cmluZyl9IG5vZGVzXG5cdCAgICovXG5cdCAgZGVzdGluYXRpb25bJ2JlZm9yZSddID0gZnVuY3Rpb24gKCkge1xuXHQgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG5vZGVzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG5cdCAgICAgIG5vZGVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuXHQgICAgfVxuXHRcblx0ICAgIC8vIFRPRE86IEZpeCB0aGlzIGZvciB3aGVuIG9uZSBvZiBgbm9kZXNgIGlzIGEgRG9jdW1lbnRGcmFnbWVudCFcblx0ICAgIHZhciBjb25uZWN0ZWRCZWZvcmUgPSAvKiogQHR5cGUgeyFBcnJheTwhTm9kZT59ICovbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgIC8vIERvY3VtZW50RnJhZ21lbnRzIGFyZSBub3QgY29ubmVjdGVkIGFuZCB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgbGlzdC5cblx0ICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBOb2RlICYmIFV0aWxpdGllcy5pc0Nvbm5lY3RlZChub2RlKTtcblx0ICAgIH0pO1xuXHRcblx0ICAgIGJ1aWx0SW4uYmVmb3JlLmFwcGx5KHRoaXMsIG5vZGVzKTtcblx0XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbm5lY3RlZEJlZm9yZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUoY29ubmVjdGVkQmVmb3JlW2ldKTtcblx0ICAgIH1cblx0XG5cdCAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpKSB7XG5cdCAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2Rlcy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW19pXTtcblx0ICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcblx0ICAgICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShub2RlKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHRcblx0ICAvKipcblx0ICAgKiBAcGFyYW0gey4uLighTm9kZXxzdHJpbmcpfSBub2Rlc1xuXHQgICAqL1xuXHQgIGRlc3RpbmF0aW9uWydhZnRlciddID0gZnVuY3Rpb24gKCkge1xuXHQgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBub2RlcyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG5cdCAgICAgIG5vZGVzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gVE9ETzogRml4IHRoaXMgZm9yIHdoZW4gb25lIG9mIGBub2Rlc2AgaXMgYSBEb2N1bWVudEZyYWdtZW50IVxuXHQgICAgdmFyIGNvbm5lY3RlZEJlZm9yZSA9IC8qKiBAdHlwZSB7IUFycmF5PCFOb2RlPn0gKi9ub2Rlcy5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgLy8gRG9jdW1lbnRGcmFnbWVudHMgYXJlIG5vdCBjb25uZWN0ZWQgYW5kIHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBsaXN0LlxuXHQgICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE5vZGUgJiYgVXRpbGl0aWVzLmlzQ29ubmVjdGVkKG5vZGUpO1xuXHQgICAgfSk7XG5cdFxuXHQgICAgYnVpbHRJbi5hZnRlci5hcHBseSh0aGlzLCBub2Rlcyk7XG5cdFxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25uZWN0ZWRCZWZvcmUubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKGNvbm5lY3RlZEJlZm9yZVtpXSk7XG5cdCAgICB9XG5cdFxuXHQgICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKSkge1xuXHQgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2Rlcy5sZW5ndGg7IF9pMisrKSB7XG5cdCAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tfaTJdO1xuXHQgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuXHQgICAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKG5vZGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIC8qKlxuXHQgICAqIEBwYXJhbSB7Li4uKCFOb2RlfHN0cmluZyl9IG5vZGVzXG5cdCAgICovXG5cdCAgZGVzdGluYXRpb25bJ3JlcGxhY2VXaXRoJ10gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIG5vZGVzID0gQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcblx0ICAgICAgbm9kZXNbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcblx0ICAgIH1cblx0XG5cdCAgICAvLyBUT0RPOiBGaXggdGhpcyBmb3Igd2hlbiBvbmUgb2YgYG5vZGVzYCBpcyBhIERvY3VtZW50RnJhZ21lbnQhXG5cdCAgICB2YXIgY29ubmVjdGVkQmVmb3JlID0gLyoqIEB0eXBlIHshQXJyYXk8IU5vZGU+fSAqL25vZGVzLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICAvLyBEb2N1bWVudEZyYWdtZW50cyBhcmUgbm90IGNvbm5lY3RlZCBhbmQgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIGxpc3QuXG5cdCAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgTm9kZSAmJiBVdGlsaXRpZXMuaXNDb25uZWN0ZWQobm9kZSk7XG5cdCAgICB9KTtcblx0XG5cdCAgICB2YXIgd2FzQ29ubmVjdGVkID0gVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpO1xuXHRcblx0ICAgIGJ1aWx0SW4ucmVwbGFjZVdpdGguYXBwbHkodGhpcywgbm9kZXMpO1xuXHRcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29ubmVjdGVkQmVmb3JlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShjb25uZWN0ZWRCZWZvcmVbaV0pO1xuXHQgICAgfVxuXHRcblx0ICAgIGlmICh3YXNDb25uZWN0ZWQpIHtcblx0ICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKHRoaXMpO1xuXHQgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBub2Rlcy5sZW5ndGg7IF9pMysrKSB7XG5cdCAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tfaTNdO1xuXHQgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuXHQgICAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKG5vZGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIGRlc3RpbmF0aW9uWydyZW1vdmUnXSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciB3YXNDb25uZWN0ZWQgPSBVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcyk7XG5cdFxuXHQgICAgYnVpbHRJbi5yZW1vdmUuY2FsbCh0aGlzKTtcblx0XG5cdCAgICBpZiAod2FzQ29ubmVjdGVkKSB7XG5cdCAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZSh0aGlzKTtcblx0ICAgIH1cblx0ICB9O1xuXHR9O1xuXHRcblx0dmFyIF9DdXN0b21FbGVtZW50SW50ZXJuYWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XG5cdFxuXHR2YXIgX0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ3VzdG9tRWxlbWVudEludGVybmFscyk7XG5cdFxuXHR2YXIgX1V0aWxpdGllcyA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xuXHRcblx0dmFyIFV0aWxpdGllcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9VdGlsaXRpZXMpO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHQvKipcblx0ICogQHR5cGVkZWYge3tcblx0ICogICBiZWZvcmU6ICFmdW5jdGlvbiguLi4oIU5vZGV8c3RyaW5nKSksXG5cdCAqICAgYWZ0ZXI6ICFmdW5jdGlvbiguLi4oIU5vZGV8c3RyaW5nKSksXG5cdCAqICAgcmVwbGFjZVdpdGg6ICFmdW5jdGlvbiguLi4oIU5vZGV8c3RyaW5nKSksXG5cdCAqICAgcmVtb3ZlOiAhZnVuY3Rpb24oKSxcblx0ICogfX1cblx0ICovXG5cdHZhciBDaGlsZE5vZGVOYXRpdmVNZXRob2RzID0gdm9pZCAwO1xuXHRcblx0LyoqXG5cdCAqIEBwYXJhbSB7IUN1c3RvbUVsZW1lbnRJbnRlcm5hbHN9IGludGVybmFsc1xuXHQgKiBAcGFyYW0geyFPYmplY3R9IGRlc3RpbmF0aW9uXG5cdCAqIEBwYXJhbSB7IUNoaWxkTm9kZU5hdGl2ZU1ldGhvZHN9IGJ1aWx0SW5cblx0ICovXG5cdDtcblxuLyoqKi8gfSxcbi8qIDUxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKipcblx0QGxpY2Vuc2Vcblx0Q29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0VGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuXHRUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuXHRUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcblx0Q29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cblx0c3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcblx0Ki9cblx0XG5cdC8qKlxuXHQgKiBQYXRjaGVzIGVsZW1lbnRzIHRoYXQgaW50ZXJhY3RzIHdpdGggU2hhZHlET01cblx0ICogc3VjaCB0aGF0IHRyZWUgdHJhdmVyc2FsIGFuZCBtdXRhdGlvbiBhcGlzIGFjdCBsaWtlIHRoZXkgd291bGQgdW5kZXJcblx0ICogU2hhZG93RE9NLlxuXHQgKlxuXHQgKiBUaGlzIGltcG9ydCBlbmFibGVzIHNlZW1sZXNzIGludGVyYWN0aW9uIHdpdGggU2hhZHlET00gcG93ZXJlZFxuXHQgKiBjdXN0b20gZWxlbWVudHMsIGVuYWJsaW5nIGJldHRlciBpbnRlcm9wZXJhdGlvbiB3aXRoIDNyZCBwYXJ0eSBjb2RlLFxuXHQgKiBsaWJyYXJpZXMsIGFuZCBmcmFtZXdvcmtzIHRoYXQgdXNlIERPTSB0cmVlIG1hbmlwdWxhdGlvbiBhcGlzLlxuXHQgKi9cblx0XG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKTtcblx0XG5cdHZhciB1dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlscyk7XG5cdFxuXHR2YXIgX2ZsdXNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XG5cdFxuXHR2YXIgX29ic2VydmVDaGFuZ2VzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NCk7XG5cdFxuXHR2YXIgX25hdGl2ZU1ldGhvZHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1KTtcblx0XG5cdHZhciBuYXRpdmVNZXRob2RzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX25hdGl2ZU1ldGhvZHMpO1xuXHRcblx0dmFyIF9uYXRpdmVUcmVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nik7XG5cdFxuXHR2YXIgbmF0aXZlVHJlZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9uYXRpdmVUcmVlKTtcblx0XG5cdHZhciBfcGF0Y2hCdWlsdGlucyA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpO1xuXHRcblx0dmFyIF9wYXRjaEV2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNjMpO1xuXHRcblx0dmFyIF9hdHRhY2hTaGFkb3cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0KTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cdFxuXHRpZiAodXRpbHMuc2V0dGluZ3MuaW5Vc2UpIHtcblx0XG5cdCAgd2luZG93LlNoYWR5RE9NID0ge1xuXHQgICAgLy8gVE9ETyhzb3J2ZWxsKTogcmVtb3ZlIHdoZW4gUG9seW1lciBkb2VzIG5vdCBkZXBlbmQgb24gdGhpcy5cblx0ICAgIGluVXNlOiB1dGlscy5zZXR0aW5ncy5pblVzZSxcblx0ICAgIC8vIFRPRE8oc29ydmVsbCk6IHJlbW92ZSB3aGVuIFBvbHltZXIgZG9lcyBub3QgZGVwZW5kIG9uIHRoaXMuXG5cdCAgICBwYXRjaDogZnVuY3Rpb24gcGF0Y2gobm9kZSkge1xuXHQgICAgICByZXR1cm4gbm9kZTtcblx0ICAgIH0sXG5cdCAgICBpc1NoYWR5Um9vdDogdXRpbHMuaXNTaGFkeVJvb3QsXG5cdCAgICBlbnF1ZXVlOiBfZmx1c2guZW5xdWV1ZSxcblx0ICAgIGZsdXNoOiBfZmx1c2guZmx1c2gsXG5cdCAgICBzZXR0aW5nczogdXRpbHMuc2V0dGluZ3MsXG5cdCAgICBmaWx0ZXJNdXRhdGlvbnM6IF9vYnNlcnZlQ2hhbmdlcy5maWx0ZXJNdXRhdGlvbnMsXG5cdCAgICBvYnNlcnZlQ2hpbGRyZW46IF9vYnNlcnZlQ2hhbmdlcy5vYnNlcnZlQ2hpbGRyZW4sXG5cdCAgICB1bm9ic2VydmVDaGlsZHJlbjogX29ic2VydmVDaGFuZ2VzLnVub2JzZXJ2ZUNoaWxkcmVuLFxuXHQgICAgbmF0aXZlTWV0aG9kczogbmF0aXZlTWV0aG9kcyxcblx0ICAgIG5hdGl2ZVRyZWU6IG5hdGl2ZVRyZWVcblx0ICB9O1xuXHRcblx0ICAvLyBBcHBseSBwYXRjaGVzIHRvIGV2ZW50cy4uLlxuXHQgICgwLCBfcGF0Y2hFdmVudHMucGF0Y2hFdmVudHMpKCk7XG5cdCAgLy8gQXBwbHkgcGF0Y2hlcyB0byBidWlsdGlucyAoZS5nLiBFbGVtZW50LnByb3RvdHlwZSkgd2hlcmUgYXBwbGljYWJsZS5cblx0ICAoMCwgX3BhdGNoQnVpbHRpbnMucGF0Y2hCdWlsdGlucykoKTtcblx0XG5cdCAgd2luZG93LlNoYWRvd1Jvb3QgPSBfYXR0YWNoU2hhZG93LlNoYWR5Um9vdDtcblx0fVxuXG4vKioqLyB9LFxuLyogNTIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qKlxuXHRAbGljZW5zZVxuXHRDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXHRUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5cdFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5cdFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuXHRDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuXHRzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuXHQqL1xuXHRcblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdGV4cG9ydHMuaXNTaGFkeVJvb3QgPSBpc1NoYWR5Um9vdDtcblx0ZXhwb3J0cy5vd25lclNoYWR5Um9vdEZvck5vZGUgPSBvd25lclNoYWR5Um9vdEZvck5vZGU7XG5cdGV4cG9ydHMubWF0Y2hlc1NlbGVjdG9yID0gbWF0Y2hlc1NlbGVjdG9yO1xuXHRleHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcblx0ZXhwb3J0cy5leHRlbmRBbGwgPSBleHRlbmRBbGw7XG5cdGV4cG9ydHMubWl4aW4gPSBtaXhpbjtcblx0ZXhwb3J0cy5wYXRjaFByb3RvdHlwZSA9IHBhdGNoUHJvdG90eXBlO1xuXHRleHBvcnRzLm1pY3JvdGFzayA9IG1pY3JvdGFzaztcblx0dmFyIHNldHRpbmdzID0gZXhwb3J0cy5zZXR0aW5ncyA9IHdpbmRvdy5TaGFkeURPTSB8fCB7fTtcblx0XG5cdHNldHRpbmdzLmhhc05hdGl2ZVNoYWRvd0RPTSA9IEJvb2xlYW4oRWxlbWVudC5wcm90b3R5cGUuYXR0YWNoU2hhZG93ICYmIE5vZGUucHJvdG90eXBlLmdldFJvb3ROb2RlKTtcblx0XG5cdHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihOb2RlLnByb3RvdHlwZSwgJ2ZpcnN0Q2hpbGQnKTtcblx0XG5cdHNldHRpbmdzLmhhc0Rlc2NyaXB0b3JzID0gQm9vbGVhbihkZXNjICYmIGRlc2MuY29uZmlndXJhYmxlICYmIGRlc2MuZ2V0KTtcblx0c2V0dGluZ3MuaW5Vc2UgPSBzZXR0aW5ncy5mb3JjZSB8fCAhc2V0dGluZ3MuaGFzTmF0aXZlU2hhZG93RE9NO1xuXHRcblx0ZnVuY3Rpb24gaXNTaGFkeVJvb3Qob2JqKSB7XG5cdCAgcmV0dXJuIEJvb2xlYW4ob2JqLl9fbG9jYWxOYW1lID09PSAnU2hhZHlSb290Jyk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIG93bmVyU2hhZHlSb290Rm9yTm9kZShub2RlKSB7XG5cdCAgdmFyIHJvb3QgPSBub2RlLmdldFJvb3ROb2RlKCk7XG5cdCAgaWYgKGlzU2hhZHlSb290KHJvb3QpKSB7XG5cdCAgICByZXR1cm4gcm9vdDtcblx0ICB9XG5cdH1cblx0XG5cdHZhciBwID0gRWxlbWVudC5wcm90b3R5cGU7XG5cdHZhciBtYXRjaGVzID0gcC5tYXRjaGVzIHx8IHAubWF0Y2hlc1NlbGVjdG9yIHx8IHAubW96TWF0Y2hlc1NlbGVjdG9yIHx8IHAubXNNYXRjaGVzU2VsZWN0b3IgfHwgcC5vTWF0Y2hlc1NlbGVjdG9yIHx8IHAud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuXHRcblx0ZnVuY3Rpb24gbWF0Y2hlc1NlbGVjdG9yKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG5cdCAgcmV0dXJuIG1hdGNoZXMuY2FsbChlbGVtZW50LCBzZWxlY3Rvcik7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGNvcHlPd25Qcm9wZXJ0eShuYW1lLCBzb3VyY2UsIHRhcmdldCkge1xuXHQgIHZhciBwZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBuYW1lKTtcblx0ICBpZiAocGQpIHtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHBkKTtcblx0ICB9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuXHQgIGlmICh0YXJnZXQgJiYgc291cmNlKSB7XG5cdCAgICB2YXIgbiQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2UpO1xuXHQgICAgZm9yICh2YXIgaSA9IDAsIG47IGkgPCBuJC5sZW5ndGggJiYgKG4gPSBuJFtpXSk7IGkrKykge1xuXHQgICAgICBjb3B5T3duUHJvcGVydHkobiwgc291cmNlLCB0YXJnZXQpO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gdGFyZ2V0IHx8IHNvdXJjZTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gZXh0ZW5kQWxsKHRhcmdldCkge1xuXHQgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuXHQgICAgc291cmNlc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG5cdCAgfVxuXHRcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIGV4dGVuZCh0YXJnZXQsIHNvdXJjZXNbaV0pO1xuXHQgIH1cblx0ICByZXR1cm4gdGFyZ2V0O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBtaXhpbih0YXJnZXQsIHNvdXJjZSkge1xuXHQgIGZvciAodmFyIGkgaW4gc291cmNlKSB7XG5cdCAgICB0YXJnZXRbaV0gPSBzb3VyY2VbaV07XG5cdCAgfVxuXHQgIHJldHVybiB0YXJnZXQ7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHBhdGNoUHJvdG90eXBlKG9iaiwgbWl4aW4pIHtcblx0ICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcblx0ICBpZiAoIXByb3RvLmhhc093blByb3BlcnR5KCdfX3BhdGNoUHJvdG8nKSkge1xuXHQgICAgdmFyIHBhdGNoUHJvdG8gPSBPYmplY3QuY3JlYXRlKHByb3RvKTtcblx0ICAgIHBhdGNoUHJvdG8uX19zb3VyY2VQcm90byA9IHByb3RvO1xuXHQgICAgZXh0ZW5kKHBhdGNoUHJvdG8sIG1peGluKTtcblx0ICAgIHByb3RvLl9fcGF0Y2hQcm90byA9IHBhdGNoUHJvdG87XG5cdCAgfVxuXHQgIC8vIG9sZCBicm93c2VycyBkb24ndCBoYXZlIHNldFByb3RvdHlwZU9mXG5cdCAgb2JqLl9fcHJvdG9fXyA9IHByb3RvLl9fcGF0Y2hQcm90bztcblx0fVxuXHRcblx0dmFyIHR3aWRkbGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG5cdHZhciBjb250ZW50ID0gMDtcblx0dmFyIHF1ZXVlID0gW107XG5cdG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uICgpIHtcblx0ICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG5cdCAgICAvLyBjYXRjaCBlcnJvcnMgaW4gdXNlciBjb2RlLi4uXG5cdCAgICB0cnkge1xuXHQgICAgICBxdWV1ZS5zaGlmdCgpKCk7XG5cdCAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgIC8vIGVucXVldWUgYW5vdGhlciByZWNvcmQgYW5kIHRocm93XG5cdCAgICAgIHR3aWRkbGUudGV4dENvbnRlbnQgPSBjb250ZW50Kys7XG5cdCAgICAgIHRocm93IGU7XG5cdCAgICB9XG5cdCAgfVxuXHR9KS5vYnNlcnZlKHR3aWRkbGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblx0XG5cdC8vIHVzZSBNdXRhdGlvbk9ic2VydmVyIHRvIGdldCBtaWNyb3Rhc2sgYXN5bmMgdGltaW5nLlxuXHRmdW5jdGlvbiBtaWNyb3Rhc2soY2FsbGJhY2spIHtcblx0ICBxdWV1ZS5wdXNoKGNhbGxiYWNrKTtcblx0ICB0d2lkZGxlLnRleHRDb250ZW50ID0gY29udGVudCsrO1xuXHR9XG5cbi8qKiovIH0sXG4vKiA1MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyoqXG5cdEBsaWNlbnNlXG5cdENvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cdFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblx0VGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblx0VGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5cdENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5cdHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG5cdCovXG5cdFxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0ZXhwb3J0cy5lbnF1ZXVlID0gZW5xdWV1ZTtcblx0ZXhwb3J0cy5mbHVzaCA9IGZsdXNoO1xuXHRcblx0dmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNTIpO1xuXHRcblx0dmFyIHV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cdFxuXHQvLyByZW5kZXIgZW5xdWV1ZXIvZmx1c2hlclxuXHR2YXIgZmx1c2hMaXN0ID0gW107XG5cdHZhciBzY2hlZHVsZWQgPSB2b2lkIDA7XG5cdGZ1bmN0aW9uIGVucXVldWUoY2FsbGJhY2spIHtcblx0ICBpZiAoIXNjaGVkdWxlZCkge1xuXHQgICAgc2NoZWR1bGVkID0gdHJ1ZTtcblx0ICAgIHV0aWxzLm1pY3JvdGFzayhmbHVzaCk7XG5cdCAgfVxuXHQgIGZsdXNoTGlzdC5wdXNoKGNhbGxiYWNrKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gZmx1c2goKSB7XG5cdCAgc2NoZWR1bGVkID0gZmFsc2U7XG5cdCAgdmFyIGRpZEZsdXNoID0gQm9vbGVhbihmbHVzaExpc3QubGVuZ3RoKTtcblx0ICB3aGlsZSAoZmx1c2hMaXN0Lmxlbmd0aCkge1xuXHQgICAgZmx1c2hMaXN0LnNoaWZ0KCkoKTtcblx0ICB9XG5cdCAgcmV0dXJuIGRpZEZsdXNoO1xuXHR9XG5cdFxuXHRmbHVzaC5saXN0ID0gZmx1c2hMaXN0O1xuXG4vKioqLyB9LFxuLyogNTQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qKlxuXHRAbGljZW5zZVxuXHRDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXHRUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5cdFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5cdFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuXHRDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuXHRzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuXHQqL1xuXHRcblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdGV4cG9ydHMudW5vYnNlcnZlQ2hpbGRyZW4gPSBleHBvcnRzLm9ic2VydmVDaGlsZHJlbiA9IHVuZGVmaW5lZDtcblx0XG5cdHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cdFxuXHRleHBvcnRzLmZpbHRlck11dGF0aW9ucyA9IGZpbHRlck11dGF0aW9ucztcblx0XG5cdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKTtcblx0XG5cdHZhciB1dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlscyk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXHRcblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblx0XG5cdHZhciBBc3luY09ic2VydmVyID0gZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIEFzeW5jT2JzZXJ2ZXIoKSB7XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXN5bmNPYnNlcnZlcik7XG5cdFxuXHQgICAgdGhpcy5fc2NoZWR1bGVkID0gZmFsc2U7XG5cdCAgICB0aGlzLmFkZGVkTm9kZXMgPSBbXTtcblx0ICAgIHRoaXMucmVtb3ZlZE5vZGVzID0gW107XG5cdCAgICB0aGlzLmNhbGxiYWNrcyA9IG5ldyBTZXQoKTtcblx0ICB9XG5cdFxuXHQgIF9jcmVhdGVDbGFzcyhBc3luY09ic2VydmVyLCBbe1xuXHQgICAga2V5OiAnc2NoZWR1bGUnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHNjaGVkdWxlKCkge1xuXHQgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcblx0ICAgICAgaWYgKCF0aGlzLl9zY2hlZHVsZWQpIHtcblx0ICAgICAgICB0aGlzLl9zY2hlZHVsZWQgPSB0cnVlO1xuXHQgICAgICAgIHV0aWxzLm1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICBfdGhpcy5mbHVzaCgpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnZmx1c2gnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGZsdXNoKCkge1xuXHQgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblx0XG5cdCAgICAgIGlmICh0aGlzLl9zY2hlZHVsZWQpIHtcblx0ICAgICAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgX3RoaXMyLl9zY2hlZHVsZWQgPSBmYWxzZTtcblx0ICAgICAgICAgIHZhciBtdXRhdGlvbnMgPSBfdGhpczIudGFrZVJlY29yZHMoKTtcblx0ICAgICAgICAgIGlmIChtdXRhdGlvbnMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIF90aGlzMi5jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcblx0ICAgICAgICAgICAgICBjYihtdXRhdGlvbnMpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9KSgpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAndGFrZVJlY29yZHMnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHRha2VSZWNvcmRzKCkge1xuXHQgICAgICBpZiAodGhpcy5hZGRlZE5vZGVzLmxlbmd0aCB8fCB0aGlzLnJlbW92ZWROb2Rlcy5sZW5ndGgpIHtcblx0ICAgICAgICB2YXIgbXV0YXRpb25zID0gW3tcblx0ICAgICAgICAgIGFkZGVkTm9kZXM6IHRoaXMuYWRkZWROb2Rlcyxcblx0ICAgICAgICAgIHJlbW92ZWROb2RlczogdGhpcy5yZW1vdmVkTm9kZXNcblx0ICAgICAgICB9XTtcblx0ICAgICAgICB0aGlzLmFkZGVkTm9kZXMgPSBbXTtcblx0ICAgICAgICB0aGlzLnJlbW92ZWROb2RlcyA9IFtdO1xuXHQgICAgICAgIHJldHVybiBtdXRhdGlvbnM7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIFtdO1xuXHQgICAgfVxuXHQgIH1dKTtcblx0XG5cdCAgcmV0dXJuIEFzeW5jT2JzZXJ2ZXI7XG5cdH0oKTtcblx0XG5cdC8vIFRPRE8oc29ydmVsbCk6IGNvbnNpZGVyIGluc3RlYWQgcG9seWZpbGxpbmcgTXV0YXRpb25PYnNlcnZlclxuXHQvLyBkaXJlY3RseSBzbyB0aGF0IHVzZXJzIGRvIG5vdCBoYXZlIHRvIGZvcmsgdGhlaXIgY29kZS5cblx0Ly8gU3VwcG9ydGluZyB0aGUgZW50aXJlIGFwaSBtYXkgYmUgY2hhbGxlbmdpbmc6IGUuZy4gZmlsdGVyaW5nIG91dFxuXHQvLyByZW1vdmVkIG5vZGVzIGluIHRoZSB3cm9uZyBzY29wZSBhbmQgc2VlaW5nIG5vbi1kaXN0cmlidXRpbmdcblx0Ly8gc3VidHJlZSBjaGlsZCBtdXRhdGlvbnMuXG5cdFxuXHRcblx0dmFyIG9ic2VydmVDaGlsZHJlbiA9IGV4cG9ydHMub2JzZXJ2ZUNoaWxkcmVuID0gZnVuY3Rpb24gb2JzZXJ2ZUNoaWxkcmVuKG5vZGUsIGNhbGxiYWNrKSB7XG5cdCAgbm9kZS5fX3NoYWR5ID0gbm9kZS5fX3NoYWR5IHx8IHt9O1xuXHQgIGlmICghbm9kZS5fX3NoYWR5Lm9ic2VydmVyKSB7XG5cdCAgICBub2RlLl9fc2hhZHkub2JzZXJ2ZXIgPSBuZXcgQXN5bmNPYnNlcnZlcigpO1xuXHQgIH1cblx0ICBub2RlLl9fc2hhZHkub2JzZXJ2ZXIuY2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG5cdCAgdmFyIG9ic2VydmVyID0gbm9kZS5fX3NoYWR5Lm9ic2VydmVyO1xuXHQgIHJldHVybiB7XG5cdCAgICBfY2FsbGJhY2s6IGNhbGxiYWNrLFxuXHQgICAgX29ic2VydmVyOiBvYnNlcnZlcixcblx0ICAgIF9ub2RlOiBub2RlLFxuXHQgICAgdGFrZVJlY29yZHM6IGZ1bmN0aW9uIHRha2VSZWNvcmRzKCkge1xuXHQgICAgICByZXR1cm4gb2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcblx0ICAgIH1cblx0ICB9O1xuXHR9O1xuXHRcblx0dmFyIHVub2JzZXJ2ZUNoaWxkcmVuID0gZXhwb3J0cy51bm9ic2VydmVDaGlsZHJlbiA9IGZ1bmN0aW9uIHVub2JzZXJ2ZUNoaWxkcmVuKGhhbmRsZSkge1xuXHQgIHZhciBvYnNlcnZlciA9IGhhbmRsZSAmJiBoYW5kbGUuX29ic2VydmVyO1xuXHQgIGlmIChvYnNlcnZlcikge1xuXHQgICAgb2JzZXJ2ZXIuY2FsbGJhY2tzLmRlbGV0ZShoYW5kbGUuX2NhbGxiYWNrKTtcblx0ICAgIGlmICghb2JzZXJ2ZXIuY2FsbGJhY2tzLnNpemUpIHtcblx0ICAgICAgaGFuZGxlLl9ub2RlLl9fc2hhZHkub2JzZXJ2ZXIgPSBudWxsO1xuXHQgICAgfVxuXHQgIH1cblx0fTtcblx0XG5cdGZ1bmN0aW9uIGZpbHRlck11dGF0aW9ucyhtdXRhdGlvbnMsIHRhcmdldCkge1xuXHQgIHZhciB0YXJnZXRSb290Tm9kZSA9IHRhcmdldC5nZXRSb290Tm9kZSgpO1xuXHQgIHJldHVybiBtdXRhdGlvbnMubWFwKGZ1bmN0aW9uIChtdXRhdGlvbikge1xuXHQgICAgdmFyIG11dGF0aW9uSW5TY29wZSA9IHRhcmdldFJvb3ROb2RlID09PSBtdXRhdGlvbi50YXJnZXQuZ2V0Um9vdE5vZGUoKTtcblx0ICAgIGlmIChtdXRhdGlvbkluU2NvcGUgJiYgbXV0YXRpb24uYWRkZWROb2Rlcykge1xuXHQgICAgICB2YXIgbm9kZXMgPSBBcnJheS5mcm9tKG11dGF0aW9uLmFkZGVkTm9kZXMpLmZpbHRlcihmdW5jdGlvbiAobikge1xuXHQgICAgICAgIHJldHVybiB0YXJnZXRSb290Tm9kZSA9PT0gbi5nZXRSb290Tm9kZSgpO1xuXHQgICAgICB9KTtcblx0ICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuXHQgICAgICAgIG11dGF0aW9uID0gT2JqZWN0LmNyZWF0ZShtdXRhdGlvbik7XG5cdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG11dGF0aW9uLCAnYWRkZWROb2RlcycsIHtcblx0ICAgICAgICAgIHZhbHVlOiBub2Rlcyxcblx0ICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiBtdXRhdGlvbjtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIGlmIChtdXRhdGlvbkluU2NvcGUpIHtcblx0ICAgICAgcmV0dXJuIG11dGF0aW9uO1xuXHQgICAgfVxuXHQgIH0pLmZpbHRlcihmdW5jdGlvbiAobSkge1xuXHQgICAgcmV0dXJuIG07XG5cdCAgfSk7XG5cdH1cblxuLyoqKi8gfSxcbi8qIDU1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKipcblx0QGxpY2Vuc2Vcblx0Q29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0VGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuXHRUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuXHRUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcblx0Q29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cblx0c3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcblx0Ki9cblx0XG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHR2YXIgYXBwZW5kQ2hpbGQgPSBleHBvcnRzLmFwcGVuZENoaWxkID0gRWxlbWVudC5wcm90b3R5cGUuYXBwZW5kQ2hpbGQ7XG5cdHZhciBpbnNlcnRCZWZvcmUgPSBleHBvcnRzLmluc2VydEJlZm9yZSA9IEVsZW1lbnQucHJvdG90eXBlLmluc2VydEJlZm9yZTtcblx0dmFyIHJlbW92ZUNoaWxkID0gZXhwb3J0cy5yZW1vdmVDaGlsZCA9IEVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUNoaWxkO1xuXHR2YXIgc2V0QXR0cmlidXRlID0gZXhwb3J0cy5zZXRBdHRyaWJ1dGUgPSBFbGVtZW50LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGU7XG5cdHZhciByZW1vdmVBdHRyaWJ1dGUgPSBleHBvcnRzLnJlbW92ZUF0dHJpYnV0ZSA9IEVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZTtcblx0dmFyIGNsb25lTm9kZSA9IGV4cG9ydHMuY2xvbmVOb2RlID0gRWxlbWVudC5wcm90b3R5cGUuY2xvbmVOb2RlO1xuXHR2YXIgaW1wb3J0Tm9kZSA9IGV4cG9ydHMuaW1wb3J0Tm9kZSA9IERvY3VtZW50LnByb3RvdHlwZS5pbXBvcnROb2RlO1xuXHR2YXIgYWRkRXZlbnRMaXN0ZW5lciA9IGV4cG9ydHMuYWRkRXZlbnRMaXN0ZW5lciA9IEVsZW1lbnQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XG5cdHZhciByZW1vdmVFdmVudExpc3RlbmVyID0gZXhwb3J0cy5yZW1vdmVFdmVudExpc3RlbmVyID0gRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblxuLyoqKi8gfSxcbi8qIDU2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKipcblx0QGxpY2Vuc2Vcblx0Q29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0VGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuXHRUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuXHRUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcblx0Q29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cblx0c3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcblx0Ki9cblx0XG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRleHBvcnRzLnBhcmVudE5vZGUgPSBwYXJlbnROb2RlO1xuXHRleHBvcnRzLmZpcnN0Q2hpbGQgPSBmaXJzdENoaWxkO1xuXHRleHBvcnRzLmxhc3RDaGlsZCA9IGxhc3RDaGlsZDtcblx0ZXhwb3J0cy5wcmV2aW91c1NpYmxpbmcgPSBwcmV2aW91c1NpYmxpbmc7XG5cdGV4cG9ydHMubmV4dFNpYmxpbmcgPSBuZXh0U2libGluZztcblx0ZXhwb3J0cy5jaGlsZE5vZGVzID0gY2hpbGROb2Rlcztcblx0ZXhwb3J0cy5wYXJlbnRFbGVtZW50ID0gcGFyZW50RWxlbWVudDtcblx0ZXhwb3J0cy5maXJzdEVsZW1lbnRDaGlsZCA9IGZpcnN0RWxlbWVudENoaWxkO1xuXHRleHBvcnRzLmxhc3RFbGVtZW50Q2hpbGQgPSBsYXN0RWxlbWVudENoaWxkO1xuXHRleHBvcnRzLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgPSBwcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuXHRleHBvcnRzLm5leHRFbGVtZW50U2libGluZyA9IG5leHRFbGVtZW50U2libGluZztcblx0ZXhwb3J0cy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuXHRleHBvcnRzLmlubmVySFRNTCA9IGlubmVySFRNTDtcblx0ZXhwb3J0cy50ZXh0Q29udGVudCA9IHRleHRDb250ZW50O1xuXHRcblx0dmFyIF9pbm5lckhUTUwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KTtcblx0XG5cdHZhciBub2RlV2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihkb2N1bWVudCwgTm9kZUZpbHRlci5TSE9XX0FMTCwgbnVsbCwgZmFsc2UpO1xuXHRcblx0dmFyIGVsZW1lbnRXYWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGRvY3VtZW50LCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCwgbnVsbCwgZmFsc2UpO1xuXHRcblx0ZnVuY3Rpb24gcGFyZW50Tm9kZShub2RlKSB7XG5cdCAgbm9kZVdhbGtlci5jdXJyZW50Tm9kZSA9IG5vZGU7XG5cdCAgcmV0dXJuIG5vZGVXYWxrZXIucGFyZW50Tm9kZSgpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBmaXJzdENoaWxkKG5vZGUpIHtcblx0ICBub2RlV2Fsa2VyLmN1cnJlbnROb2RlID0gbm9kZTtcblx0ICByZXR1cm4gbm9kZVdhbGtlci5maXJzdENoaWxkKCk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGxhc3RDaGlsZChub2RlKSB7XG5cdCAgbm9kZVdhbGtlci5jdXJyZW50Tm9kZSA9IG5vZGU7XG5cdCAgcmV0dXJuIG5vZGVXYWxrZXIubGFzdENoaWxkKCk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHByZXZpb3VzU2libGluZyhub2RlKSB7XG5cdCAgbm9kZVdhbGtlci5jdXJyZW50Tm9kZSA9IG5vZGU7XG5cdCAgcmV0dXJuIG5vZGVXYWxrZXIucHJldmlvdXNTaWJsaW5nKCk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIG5leHRTaWJsaW5nKG5vZGUpIHtcblx0ICBub2RlV2Fsa2VyLmN1cnJlbnROb2RlID0gbm9kZTtcblx0ICByZXR1cm4gbm9kZVdhbGtlci5uZXh0U2libGluZygpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBjaGlsZE5vZGVzKG5vZGUpIHtcblx0ICB2YXIgbm9kZXMgPSBbXTtcblx0ICBub2RlV2Fsa2VyLmN1cnJlbnROb2RlID0gbm9kZTtcblx0ICB2YXIgbiA9IG5vZGVXYWxrZXIuZmlyc3RDaGlsZCgpO1xuXHQgIHdoaWxlIChuKSB7XG5cdCAgICBub2Rlcy5wdXNoKG4pO1xuXHQgICAgbiA9IG5vZGVXYWxrZXIubmV4dFNpYmxpbmcoKTtcblx0ICB9XG5cdCAgcmV0dXJuIG5vZGVzO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBwYXJlbnRFbGVtZW50KG5vZGUpIHtcblx0ICBlbGVtZW50V2Fsa2VyLmN1cnJlbnROb2RlID0gbm9kZTtcblx0ICByZXR1cm4gZWxlbWVudFdhbGtlci5wYXJlbnROb2RlKCk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGZpcnN0RWxlbWVudENoaWxkKG5vZGUpIHtcblx0ICBlbGVtZW50V2Fsa2VyLmN1cnJlbnROb2RlID0gbm9kZTtcblx0ICByZXR1cm4gZWxlbWVudFdhbGtlci5maXJzdENoaWxkKCk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGxhc3RFbGVtZW50Q2hpbGQobm9kZSkge1xuXHQgIGVsZW1lbnRXYWxrZXIuY3VycmVudE5vZGUgPSBub2RlO1xuXHQgIHJldHVybiBlbGVtZW50V2Fsa2VyLmxhc3RDaGlsZCgpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBwcmV2aW91c0VsZW1lbnRTaWJsaW5nKG5vZGUpIHtcblx0ICBlbGVtZW50V2Fsa2VyLmN1cnJlbnROb2RlID0gbm9kZTtcblx0ICByZXR1cm4gZWxlbWVudFdhbGtlci5wcmV2aW91c1NpYmxpbmcoKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gbmV4dEVsZW1lbnRTaWJsaW5nKG5vZGUpIHtcblx0ICBlbGVtZW50V2Fsa2VyLmN1cnJlbnROb2RlID0gbm9kZTtcblx0ICByZXR1cm4gZWxlbWVudFdhbGtlci5uZXh0U2libGluZygpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBjaGlsZHJlbihub2RlKSB7XG5cdCAgdmFyIG5vZGVzID0gW107XG5cdCAgZWxlbWVudFdhbGtlci5jdXJyZW50Tm9kZSA9IG5vZGU7XG5cdCAgdmFyIG4gPSBlbGVtZW50V2Fsa2VyLmZpcnN0Q2hpbGQoKTtcblx0ICB3aGlsZSAobikge1xuXHQgICAgbm9kZXMucHVzaChuKTtcblx0ICAgIG4gPSBlbGVtZW50V2Fsa2VyLm5leHRTaWJsaW5nKCk7XG5cdCAgfVxuXHQgIHJldHVybiBub2Rlcztcblx0fVxuXHRcblx0ZnVuY3Rpb24gaW5uZXJIVE1MKG5vZGUpIHtcblx0ICByZXR1cm4gKDAsIF9pbm5lckhUTUwuZ2V0SW5uZXJIVE1MKShub2RlLCBmdW5jdGlvbiAobikge1xuXHQgICAgcmV0dXJuIGNoaWxkTm9kZXMobik7XG5cdCAgfSk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHRleHRDb250ZW50KG5vZGUpIHtcblx0ICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcblx0ICAgIHJldHVybiBub2RlLm5vZGVWYWx1ZTtcblx0ICB9XG5cdCAgdmFyIHRleHRXYWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKG5vZGUsIE5vZGVGaWx0ZXIuU0hPV19URVhULCBudWxsLCBmYWxzZSk7XG5cdCAgdmFyIGNvbnRlbnQgPSAnJyxcblx0ICAgICAgbiA9IHZvaWQgMDtcblx0ICB3aGlsZSAobiA9IHRleHRXYWxrZXIubmV4dE5vZGUoKSkge1xuXHQgICAgLy8gVE9ETyhzb3J2ZWxsKTogY2FuJ3QgdXNlIHRleHRDb250ZW50IHNpbmNlIHdlIHBhdGNoIGl0IG9uIE5vZGUucHJvdG90eXBlIVxuXHQgICAgLy8gSG93ZXZlciwgc2hvdWxkIHByb2JhYmx5IHBhdGNoIGl0IG9ubHkgb24gZWxlbWVudC5cblx0ICAgIGNvbnRlbnQgKz0gbi5ub2RlVmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBjb250ZW50O1xuXHR9XG5cbi8qKiovIH0sXG4vKiA1NyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0LyoqXG5cdEBsaWNlbnNlXG5cdENvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cdFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblx0VGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblx0VGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5cdENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5cdHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG5cdCovXG5cdFxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHQvLyBDcmliYmVkIGZyb20gU2hhZG93RE9NIHBvbHlmaWxsXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL3dlYmNvbXBvbmVudHNqcy9ibG9iL21hc3Rlci9zcmMvU2hhZG93RE9NL3dyYXBwZXJzL0hUTUxFbGVtZW50LmpzI0wyOFxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvLyBpbm5lckhUTUwgYW5kIG91dGVySFRNTFxuXHRcblx0Ly8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWVuZC5odG1sI2VzY2FwaW5nU3RyaW5nXG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0ZXhwb3J0cy5nZXRPdXRlckhUTUwgPSBnZXRPdXRlckhUTUw7XG5cdGV4cG9ydHMuZ2V0SW5uZXJIVE1MID0gZ2V0SW5uZXJIVE1MO1xuXHR2YXIgZXNjYXBlQXR0clJlZ0V4cCA9IC9bJlxcdTAwQTBcIl0vZztcblx0dmFyIGVzY2FwZURhdGFSZWdFeHAgPSAvWyZcXHUwMEEwPD5dL2c7XG5cdFxuXHRmdW5jdGlvbiBlc2NhcGVSZXBsYWNlKGMpIHtcblx0ICBzd2l0Y2ggKGMpIHtcblx0ICAgIGNhc2UgJyYnOlxuXHQgICAgICByZXR1cm4gJyZhbXA7Jztcblx0ICAgIGNhc2UgJzwnOlxuXHQgICAgICByZXR1cm4gJyZsdDsnO1xuXHQgICAgY2FzZSAnPic6XG5cdCAgICAgIHJldHVybiAnJmd0Oyc7XG5cdCAgICBjYXNlICdcIic6XG5cdCAgICAgIHJldHVybiAnJnF1b3Q7Jztcblx0ICAgIGNhc2UgJ1xceEEwJzpcblx0ICAgICAgcmV0dXJuICcmbmJzcDsnO1xuXHQgIH1cblx0fVxuXHRcblx0ZnVuY3Rpb24gZXNjYXBlQXR0cihzKSB7XG5cdCAgcmV0dXJuIHMucmVwbGFjZShlc2NhcGVBdHRyUmVnRXhwLCBlc2NhcGVSZXBsYWNlKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gZXNjYXBlRGF0YShzKSB7XG5cdCAgcmV0dXJuIHMucmVwbGFjZShlc2NhcGVEYXRhUmVnRXhwLCBlc2NhcGVSZXBsYWNlKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gbWFrZVNldChhcnIpIHtcblx0ICB2YXIgc2V0ID0ge307XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0ICAgIHNldFthcnJbaV1dID0gdHJ1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIHNldDtcblx0fVxuXHRcblx0Ly8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay8jdm9pZC1lbGVtZW50c1xuXHR2YXIgdm9pZEVsZW1lbnRzID0gbWFrZVNldChbJ2FyZWEnLCAnYmFzZScsICdicicsICdjb2wnLCAnY29tbWFuZCcsICdlbWJlZCcsICdocicsICdpbWcnLCAnaW5wdXQnLCAna2V5Z2VuJywgJ2xpbmsnLCAnbWV0YScsICdwYXJhbScsICdzb3VyY2UnLCAndHJhY2snLCAnd2JyJ10pO1xuXHRcblx0dmFyIHBsYWludGV4dFBhcmVudHMgPSBtYWtlU2V0KFsnc3R5bGUnLCAnc2NyaXB0JywgJ3htcCcsICdpZnJhbWUnLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdwbGFpbnRleHQnLCAnbm9zY3JpcHQnXSk7XG5cdFxuXHRmdW5jdGlvbiBnZXRPdXRlckhUTUwobm9kZSwgcGFyZW50Tm9kZSwgY29tcG9zZWQpIHtcblx0ICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcblx0ICAgIGNhc2UgTm9kZS5FTEVNRU5UX05PREU6XG5cdCAgICAgIHtcblx0ICAgICAgICB2YXIgdGFnTmFtZSA9IG5vZGUubG9jYWxOYW1lO1xuXHQgICAgICAgIHZhciBzID0gJzwnICsgdGFnTmFtZTtcblx0ICAgICAgICB2YXIgYXR0cnMgPSBub2RlLmF0dHJpYnV0ZXM7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDAsIGF0dHI7IGF0dHIgPSBhdHRyc1tpXTsgaSsrKSB7XG5cdCAgICAgICAgICBzICs9ICcgJyArIGF0dHIubmFtZSArICc9XCInICsgZXNjYXBlQXR0cihhdHRyLnZhbHVlKSArICdcIic7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHMgKz0gJz4nO1xuXHQgICAgICAgIGlmICh2b2lkRWxlbWVudHNbdGFnTmFtZV0pIHtcblx0ICAgICAgICAgIHJldHVybiBzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcyArIGdldElubmVySFRNTChub2RlLCBjb21wb3NlZCkgKyAnPC8nICsgdGFnTmFtZSArICc+Jztcblx0ICAgICAgfVxuXHQgICAgY2FzZSBOb2RlLlRFWFRfTk9ERTpcblx0ICAgICAge1xuXHQgICAgICAgIHZhciBkYXRhID0gbm9kZS5kYXRhO1xuXHQgICAgICAgIGlmIChwYXJlbnROb2RlICYmIHBsYWludGV4dFBhcmVudHNbcGFyZW50Tm9kZS5sb2NhbE5hbWVdKSB7XG5cdCAgICAgICAgICByZXR1cm4gZGF0YTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGVzY2FwZURhdGEoZGF0YSk7XG5cdCAgICAgIH1cblx0ICAgIGNhc2UgTm9kZS5DT01NRU5UX05PREU6XG5cdCAgICAgIHtcblx0ICAgICAgICByZXR1cm4gJzwhLS0nICsgbm9kZS5kYXRhICsgJy0tPic7XG5cdCAgICAgIH1cblx0ICAgIGRlZmF1bHQ6XG5cdCAgICAgIHtcblx0ICAgICAgICB3aW5kb3cuY29uc29sZS5lcnJvcihub2RlKTtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuXHQgICAgICB9XG5cdCAgfVxuXHR9XG5cdFxuXHRmdW5jdGlvbiBnZXRJbm5lckhUTUwobm9kZSwgY29tcG9zZWQpIHtcblx0ICBpZiAobm9kZS5sb2NhbE5hbWUgPT09ICd0ZW1wbGF0ZScpIHtcblx0ICAgIG5vZGUgPSBub2RlLmNvbnRlbnQ7XG5cdCAgfVxuXHQgIHZhciBzID0gJyc7XG5cdCAgdmFyIGMkID0gY29tcG9zZWQgPyBjb21wb3NlZChub2RlKSA6IG5vZGUuY2hpbGROb2Rlcztcblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IGMkLmxlbmd0aCwgY2hpbGQ7IGkgPCBsICYmIChjaGlsZCA9IGMkW2ldKTsgaSsrKSB7XG5cdCAgICBzICs9IGdldE91dGVySFRNTChjaGlsZCwgbm9kZSwgY29tcG9zZWQpO1xuXHQgIH1cblx0ICByZXR1cm4gcztcblx0fVxuXG4vKioqLyB9LFxuLyogNTggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qKlxuXHRAbGljZW5zZVxuXHRDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXHRUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5cdFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5cdFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuXHRDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuXHRzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuXHQqL1xuXHRcblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdGV4cG9ydHMucGF0Y2hCdWlsdGlucyA9IHBhdGNoQnVpbHRpbnM7XG5cdFxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Mik7XG5cdFxuXHR2YXIgdXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHMpO1xuXHRcblx0dmFyIF9sb2dpY2FsTXV0YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KTtcblx0XG5cdHZhciBtdXRhdGlvbiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9sb2dpY2FsTXV0YXRpb24pO1xuXHRcblx0dmFyIF9wYXRjaEFjY2Vzc29ycyA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xuXHRcblx0dmFyIF9sb2dpY2FsUHJvcGVydGllcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjApO1xuXHRcblx0dmFyIF9wYXRjaEV2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNjMpO1xuXHRcblx0dmFyIF9hdHRhY2hTaGFkb3cyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NCk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXHRcblx0ZnVuY3Rpb24gZ2V0QXNzaWduZWRTbG90KG5vZGUpIHtcblx0ICBtdXRhdGlvbi5yZW5kZXJSb290Tm9kZShub2RlKTtcblx0ICByZXR1cm4gKDAsIF9sb2dpY2FsUHJvcGVydGllcy5nZXRQcm9wZXJ0eSkobm9kZSwgJ2Fzc2lnbmVkU2xvdCcpIHx8IG51bGw7XG5cdH1cblx0XG5cdHZhciBub2RlTWl4aW4gPSB7XG5cdFxuXHQgIGFkZEV2ZW50TGlzdGVuZXI6IF9wYXRjaEV2ZW50cy5hZGRFdmVudExpc3RlbmVyLFxuXHRcblx0ICByZW1vdmVFdmVudExpc3RlbmVyOiBfcGF0Y2hFdmVudHMucmVtb3ZlRXZlbnRMaXN0ZW5lcixcblx0XG5cdCAgYXBwZW5kQ2hpbGQ6IGZ1bmN0aW9uIGFwcGVuZENoaWxkKG5vZGUpIHtcblx0ICAgIHJldHVybiBtdXRhdGlvbi5pbnNlcnRCZWZvcmUodGhpcywgbm9kZSk7XG5cdCAgfSxcblx0ICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uIGluc2VydEJlZm9yZShub2RlLCByZWZfbm9kZSkge1xuXHQgICAgcmV0dXJuIG11dGF0aW9uLmluc2VydEJlZm9yZSh0aGlzLCBub2RlLCByZWZfbm9kZSk7XG5cdCAgfSxcblx0ICByZW1vdmVDaGlsZDogZnVuY3Rpb24gcmVtb3ZlQ2hpbGQobm9kZSkge1xuXHQgICAgcmV0dXJuIG11dGF0aW9uLnJlbW92ZUNoaWxkKHRoaXMsIG5vZGUpO1xuXHQgIH0sXG5cdCAgcmVwbGFjZUNoaWxkOiBmdW5jdGlvbiByZXBsYWNlQ2hpbGQobm9kZSwgcmVmX25vZGUpIHtcblx0ICAgIHRoaXMuaW5zZXJ0QmVmb3JlKG5vZGUsIHJlZl9ub2RlKTtcblx0ICAgIHRoaXMucmVtb3ZlQ2hpbGQocmVmX25vZGUpO1xuXHQgICAgcmV0dXJuIG5vZGU7XG5cdCAgfSxcblx0ICBjbG9uZU5vZGU6IGZ1bmN0aW9uIGNsb25lTm9kZShkZWVwKSB7XG5cdCAgICByZXR1cm4gbXV0YXRpb24uY2xvbmVOb2RlKHRoaXMsIGRlZXApO1xuXHQgIH0sXG5cdCAgZ2V0Um9vdE5vZGU6IGZ1bmN0aW9uIGdldFJvb3ROb2RlKG9wdGlvbnMpIHtcblx0ICAgIHJldHVybiBtdXRhdGlvbi5nZXRSb290Tm9kZSh0aGlzLCBvcHRpb25zKTtcblx0ICB9LFxuXHRcblx0XG5cdCAgZ2V0IGlzQ29ubmVjdGVkKCkge1xuXHQgICAgLy8gRmFzdCBwYXRoIGZvciBkaXN0cmlidXRlZCBub2Rlcy5cblx0ICAgIHZhciBvd25lckRvY3VtZW50ID0gdGhpcy5vd25lckRvY3VtZW50O1xuXHQgICAgaWYgKG93bmVyRG9jdW1lbnQgJiYgb3duZXJEb2N1bWVudC5jb250YWlucyAmJiBvd25lckRvY3VtZW50LmNvbnRhaW5zKHRoaXMpKSByZXR1cm4gdHJ1ZTtcblx0ICAgIHZhciBvd25lckRvY3VtZW50RWxlbWVudCA9IG93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHQgICAgaWYgKG93bmVyRG9jdW1lbnRFbGVtZW50ICYmIG93bmVyRG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zICYmIG93bmVyRG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHRoaXMpKSByZXR1cm4gdHJ1ZTtcblx0XG5cdCAgICB2YXIgbm9kZSA9IHRoaXM7XG5cdCAgICB3aGlsZSAobm9kZSAmJiAhKG5vZGUgaW5zdGFuY2VvZiBEb2N1bWVudCkpIHtcblx0ICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSB8fCAobm9kZSBpbnN0YW5jZW9mIF9hdHRhY2hTaGFkb3cyLlNoYWR5Um9vdCA/IG5vZGUuaG9zdCA6IHVuZGVmaW5lZCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gISEobm9kZSAmJiBub2RlIGluc3RhbmNlb2YgRG9jdW1lbnQpO1xuXHQgIH1cblx0XG5cdH07XG5cdFxuXHQvLyBOT1RFOiBGb3Igc29tZSByZWFzb24gYFRleHRgIHJlZGVmaW5lcyBgYXNzaWduZWRTbG90YFxuXHR2YXIgdGV4dE1peGluID0ge1xuXHQgIGdldCBhc3NpZ25lZFNsb3QoKSB7XG5cdCAgICByZXR1cm4gZ2V0QXNzaWduZWRTbG90KHRoaXMpO1xuXHQgIH1cblx0fTtcblx0XG5cdHZhciBmcmFnbWVudE1peGluID0ge1xuXHRcblx0ICAvLyBUT0RPKHNvcnZlbGwpOiBjb25zaWRlciBkb2luZyBuYXRpdmUgUVNBIGFuZCBmaWx0ZXJpbmcgcmVzdWx0cy5cblx0ICBxdWVyeVNlbGVjdG9yOiBmdW5jdGlvbiBxdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSB7XG5cdCAgICAvLyBtYXRjaCBzZWxlY3RvciBhbmQgaGFsdCBvbiBmaXJzdCByZXN1bHQuXG5cdCAgICB2YXIgcmVzdWx0ID0gbXV0YXRpb24ucXVlcnkodGhpcywgZnVuY3Rpb24gKG4pIHtcblx0ICAgICAgcmV0dXJuIHV0aWxzLm1hdGNoZXNTZWxlY3RvcihuLCBzZWxlY3Rvcik7XG5cdCAgICB9LCBmdW5jdGlvbiAobikge1xuXHQgICAgICByZXR1cm4gQm9vbGVhbihuKTtcblx0ICAgIH0pWzBdO1xuXHQgICAgcmV0dXJuIHJlc3VsdCB8fCBudWxsO1xuXHQgIH0sXG5cdCAgcXVlcnlTZWxlY3RvckFsbDogZnVuY3Rpb24gcXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcikge1xuXHQgICAgcmV0dXJuIG11dGF0aW9uLnF1ZXJ5KHRoaXMsIGZ1bmN0aW9uIChuKSB7XG5cdCAgICAgIHJldHVybiB1dGlscy5tYXRjaGVzU2VsZWN0b3Iobiwgc2VsZWN0b3IpO1xuXHQgICAgfSk7XG5cdCAgfVxuXHR9O1xuXHRcblx0dmFyIHNsb3RNaXhpbiA9IHtcblx0ICBhc3NpZ25lZE5vZGVzOiBmdW5jdGlvbiBhc3NpZ25lZE5vZGVzKG9wdGlvbnMpIHtcblx0ICAgIGlmICh0aGlzLmxvY2FsTmFtZSA9PT0gJ3Nsb3QnKSB7XG5cdCAgICAgIG11dGF0aW9uLnJlbmRlclJvb3ROb2RlKHRoaXMpO1xuXHQgICAgICByZXR1cm4gdGhpcy5fX3NoYWR5ID8gKG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0dGVuID8gdGhpcy5fX3NoYWR5LmRpc3RyaWJ1dGVkTm9kZXMgOiB0aGlzLl9fc2hhZHkuYXNzaWduZWROb2RlcykgfHwgW10gOiBbXTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cdFxuXHR2YXIgZWxlbWVudE1peGluID0gdXRpbHMuZXh0ZW5kQWxsKHtcblx0ICBzZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuXHQgICAgbXV0YXRpb24uc2V0QXR0cmlidXRlKHRoaXMsIG5hbWUsIHZhbHVlKTtcblx0ICB9LFxuXHQgIHJlbW92ZUF0dHJpYnV0ZTogZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlKG5hbWUpIHtcblx0ICAgIG11dGF0aW9uLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLCBuYW1lKTtcblx0ICB9LFxuXHQgIGF0dGFjaFNoYWRvdzogZnVuY3Rpb24gYXR0YWNoU2hhZG93KG9wdGlvbnMpIHtcblx0ICAgIHJldHVybiAoMCwgX2F0dGFjaFNoYWRvdzIuYXR0YWNoU2hhZG93KSh0aGlzLCBvcHRpb25zKTtcblx0ICB9LFxuXHRcblx0XG5cdCAgZ2V0IHNsb3QoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3Nsb3QnKTtcblx0ICB9LFxuXHRcblx0ICBzZXQgc2xvdCh2YWx1ZSkge1xuXHQgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3Nsb3QnLCB2YWx1ZSk7XG5cdCAgfSxcblx0XG5cdCAgZ2V0IGFzc2lnbmVkU2xvdCgpIHtcblx0ICAgIHJldHVybiBnZXRBc3NpZ25lZFNsb3QodGhpcyk7XG5cdCAgfVxuXHRcblx0fSwgZnJhZ21lbnRNaXhpbiwgc2xvdE1peGluKTtcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGVsZW1lbnRNaXhpbiwgX3BhdGNoQWNjZXNzb3JzLlNoYWRvd1Jvb3RBY2Nlc3Nvcik7XG5cdFxuXHR2YXIgZG9jdW1lbnRNaXhpbiA9IHV0aWxzLmV4dGVuZEFsbCh7XG5cdCAgaW1wb3J0Tm9kZTogZnVuY3Rpb24gaW1wb3J0Tm9kZShub2RlLCBkZWVwKSB7XG5cdCAgICByZXR1cm4gbXV0YXRpb24uaW1wb3J0Tm9kZShub2RlLCBkZWVwKTtcblx0ICB9XG5cdH0sIGZyYWdtZW50TWl4aW4pO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZG9jdW1lbnRNaXhpbiwge1xuXHQgIF9hY3RpdmVFbGVtZW50OiBfcGF0Y2hBY2Nlc3NvcnMuQWN0aXZlRWxlbWVudEFjY2Vzc29yLmFjdGl2ZUVsZW1lbnRcblx0fSk7XG5cdFxuXHRmdW5jdGlvbiBwYXRjaEJ1aWx0aW4ocHJvdG8sIG9iaikge1xuXHQgIHZhciBuJCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaik7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuJC5sZW5ndGg7IGkrKykge1xuXHQgICAgdmFyIG4gPSBuJFtpXTtcblx0ICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIG4pO1xuXHQgICAgLy8gTk9URTogd2UgcHJlZmVyIHdyaXRpbmcgZGlyZWN0bHkgaGVyZSBiZWNhdXNlIHNvbWUgYnJvd3NlcnNcblx0ICAgIC8vIGhhdmUgZGVzY3JpcHRvcnMgdGhhdCBhcmUgd3JpdGFibGUgYnV0IG5vdCBjb25maWd1cmFibGUgKGUuZy5cblx0ICAgIC8vIGBhcHBlbmRDaGlsZGAgb24gb2xkZXIgYnJvd3NlcnMpXG5cdCAgICBpZiAoZC52YWx1ZSkge1xuXHQgICAgICBwcm90b1tuXSA9IGQudmFsdWU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIG4sIGQpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRcblx0Ly8gQXBwbHkgcGF0Y2hlcyB0byBidWlsdGlucyAoZS5nLiBFbGVtZW50LnByb3RvdHlwZSkuIFNvbWUgb2YgdGhlc2UgcGF0Y2hlc1xuXHQvLyBjYW4gYmUgZG9uZSB1bmNvbmRpdGlvbmFsbHkgKG1vc3RseSBtZXRob2RzIGxpa2Vcblx0Ly8gYEVsZW1lbnQucHJvdG90eXBlLmFwcGVuZENoaWxkYCkgYW5kIHNvbWUgY2FuIG9ubHkgYmUgZG9uZSB3aGVuIHRoZSBicm93c2VyXG5cdC8vIGhhcyBwcm9wZXIgZGVzY3JpcHRvcnMgb24gdGhlIGJ1aWx0aW4gcHJvdG90eXBlXG5cdC8vIChlLmcuIGBFbGVtZW50LnByb3RvdHlwZS5maXJzdENoaWxkYClgLiBXaGVuIGRlc2NyaXB0b3JzIGFyZSBub3QgYXZhaWxhYmxlLFxuXHQvLyBlbGVtZW50cyBhcmUgaW5kaXZpZHVhbGx5IHBhdGNoZWQgd2hlbiBuZWVkZWQgKHNlZSBlLmcuXG5cdC8vIGBwYXRjaEluc2lkZS9PdXRzaWRlRWxlbWVudEFjY2Vzc29yc2AgaW4gYHBhdGNoLWFjY2Vzc29ycy5qc2ApLlxuXHRmdW5jdGlvbiBwYXRjaEJ1aWx0aW5zKCkge1xuXHQgIC8vIFRoZXNlIHBhdGNoZXMgY2FuIGFsd2F5cyBiZSBkb25lLCBmb3IgYWxsIHN1cHBvcnRlZCBicm93c2Vycy5cblx0ICBwYXRjaEJ1aWx0aW4od2luZG93Lk5vZGUucHJvdG90eXBlLCBub2RlTWl4aW4pO1xuXHQgIHBhdGNoQnVpbHRpbih3aW5kb3cuVGV4dC5wcm90b3R5cGUsIHRleHRNaXhpbik7XG5cdCAgcGF0Y2hCdWlsdGluKHdpbmRvdy5Eb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZSwgZnJhZ21lbnRNaXhpbik7XG5cdCAgcGF0Y2hCdWlsdGluKHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZSwgZWxlbWVudE1peGluKTtcblx0ICBwYXRjaEJ1aWx0aW4od2luZG93LkRvY3VtZW50LnByb3RvdHlwZSwgZG9jdW1lbnRNaXhpbik7XG5cdCAgaWYgKHdpbmRvdy5IVE1MU2xvdEVsZW1lbnQpIHtcblx0ICAgIHBhdGNoQnVpbHRpbih3aW5kb3cuSFRNTFNsb3RFbGVtZW50LnByb3RvdHlwZSwgc2xvdE1peGluKTtcblx0ICB9XG5cdCAgLy8gVGhlc2UgcGF0Y2hlcyBjYW4gKm9ubHkqIGJlIGRvbmVcblx0ICAvLyBvbiBicm93c2VycyB0aGF0IGhhdmUgcHJvcGVyIHByb3BlcnR5IGRlc2NyaXB0b3JzIG9uIGJ1aWx0aW4gcHJvdG90eXBlcy5cblx0ICAvLyBUaGlzIGluY2x1ZGVzOiBJRTExLCBFZGdlLCBDaHJvbWUgPj0gND87IFNhZmFyaSA+PSAxMCwgRmlyZWZveFxuXHQgIC8vIE9uIG9sZGVyIGJyb3dzZXJzIChDaHJvbWUgPD0gND8sIFNhZmFyaSA5KSwgYSBwZXIgZWxlbWVudCBwYXRjaGluZ1xuXHQgIC8vIHN0cmF0ZWd5IGlzIHVzZWQgZm9yIHBhdGNoaW5nIGFjY2Vzc29ycy5cblx0ICBpZiAodXRpbHMuc2V0dGluZ3MuaGFzRGVzY3JpcHRvcnMpIHtcblx0ICAgICgwLCBfcGF0Y2hBY2Nlc3NvcnMucGF0Y2hBY2Nlc3NvcnMpKHdpbmRvdy5Ob2RlLnByb3RvdHlwZSk7XG5cdCAgICAoMCwgX3BhdGNoQWNjZXNzb3JzLnBhdGNoQWNjZXNzb3JzKSh3aW5kb3cuVGV4dC5wcm90b3R5cGUpO1xuXHQgICAgKDAsIF9wYXRjaEFjY2Vzc29ycy5wYXRjaEFjY2Vzc29ycykod2luZG93LkRvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlKTtcblx0ICAgICgwLCBfcGF0Y2hBY2Nlc3NvcnMucGF0Y2hBY2Nlc3NvcnMpKHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZSk7XG5cdCAgICB2YXIgbmF0aXZlSFRNTEVsZW1lbnQgPSB3aW5kb3cuY3VzdG9tRWxlbWVudHMgJiYgY3VzdG9tRWxlbWVudHMubmF0aXZlSFRNTEVsZW1lbnQgfHwgSFRNTEVsZW1lbnQ7XG5cdCAgICAoMCwgX3BhdGNoQWNjZXNzb3JzLnBhdGNoQWNjZXNzb3JzKShuYXRpdmVIVE1MRWxlbWVudC5wcm90b3R5cGUpO1xuXHQgICAgKDAsIF9wYXRjaEFjY2Vzc29ycy5wYXRjaEFjY2Vzc29ycykod2luZG93LkRvY3VtZW50LnByb3RvdHlwZSk7XG5cdCAgICBpZiAod2luZG93LkhUTUxTbG90RWxlbWVudCkge1xuXHQgICAgICAoMCwgX3BhdGNoQWNjZXNzb3JzLnBhdGNoQWNjZXNzb3JzKSh3aW5kb3cuSFRNTFNsb3RFbGVtZW50LnByb3RvdHlwZSk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cbi8qKiovIH0sXG4vKiA1OSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyoqXG5cdEBsaWNlbnNlXG5cdENvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cdFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblx0VGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblx0VGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5cdENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5cdHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG5cdCovXG5cdFxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0ZXhwb3J0cy5nZXRSb290Tm9kZSA9IGdldFJvb3ROb2RlO1xuXHRleHBvcnRzLnF1ZXJ5ID0gcXVlcnk7XG5cdGV4cG9ydHMucmVuZGVyUm9vdE5vZGUgPSByZW5kZXJSb290Tm9kZTtcblx0ZXhwb3J0cy5zZXRBdHRyaWJ1dGUgPSBzZXRBdHRyaWJ1dGU7XG5cdGV4cG9ydHMucmVtb3ZlQXR0cmlidXRlID0gcmVtb3ZlQXR0cmlidXRlO1xuXHRleHBvcnRzLmluc2VydEJlZm9yZSA9IGluc2VydEJlZm9yZTtcblx0ZXhwb3J0cy5yZW1vdmVDaGlsZCA9IHJlbW92ZUNoaWxkO1xuXHRleHBvcnRzLmNsb25lTm9kZSA9IGNsb25lTm9kZTtcblx0ZXhwb3J0cy5pbXBvcnROb2RlID0gaW1wb3J0Tm9kZTtcblx0XG5cdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKTtcblx0XG5cdHZhciB1dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlscyk7XG5cdFxuXHR2YXIgX2xvZ2ljYWxQcm9wZXJ0aWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MCk7XG5cdFxuXHR2YXIgX2xvZ2ljYWxUcmVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSk7XG5cdFxuXHR2YXIgbG9naWNhbFRyZWUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfbG9naWNhbFRyZWUpO1xuXHRcblx0dmFyIF9uYXRpdmVNZXRob2RzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NSk7XG5cdFxuXHR2YXIgbmF0aXZlTWV0aG9kcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9uYXRpdmVNZXRob2RzKTtcblx0XG5cdHZhciBfbmF0aXZlVHJlZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTYpO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblx0XG5cdC8vIFRyeSB0byBhZGQgbm9kZS4gUmVjb3JkIGxvZ2ljYWwgaW5mbywgdHJhY2sgaW5zZXJ0aW9uIHBvaW50cywgcGVyZm9ybVxuXHQvLyBkaXN0cmlidXRpb24gaWZmIG5lZWRlZC4gUmV0dXJuIHRydWUgaWYgdGhlIGFkZCBpcyBoYW5kbGVkLlxuXHRmdW5jdGlvbiBhZGROb2RlKGNvbnRhaW5lciwgbm9kZSwgcmVmX25vZGUpIHtcblx0ICB2YXIgb3duZXJSb290ID0gdXRpbHMub3duZXJTaGFkeVJvb3RGb3JOb2RlKGNvbnRhaW5lcik7XG5cdCAgdmFyIGlwQWRkZWQgPSB2b2lkIDA7XG5cdCAgaWYgKG93bmVyUm9vdCkge1xuXHQgICAgLy8gb3B0aW1pemF0aW9uOiBzcGVjaWFsIGluc2VydGlvbiBwb2ludCB0cmFja2luZ1xuXHQgICAgLy8gVE9ETyhzb3J2ZWxsKTogdmVyaWZ5IHRoYXQgdGhlIHJlbmRlclBlbmRpbmcgY2hlY2sgaGVyZSBzaG91bGQgbm90IGJlIG5lZWRlZC5cblx0ICAgIGlmIChub2RlLl9fbm9JbnNlcnRpb25Qb2ludCAmJiAhb3duZXJSb290Ll9jaGFuZ2VQZW5kaW5nKSB7XG5cdCAgICAgIG93bmVyUm9vdC5fc2tpcFVwZGF0ZUluc2VydGlvblBvaW50cyA9IHRydWU7XG5cdCAgICB9XG5cdCAgICAvLyBub3RlOiB3ZSBhbHdheXMgbmVlZCB0byBzZWUgaWYgYW4gaW5zZXJ0aW9uIHBvaW50IGlzIGFkZGVkXG5cdCAgICAvLyBzaW5jZSB0aGlzIHNhdmVzIGxvZ2ljYWwgdHJlZSBpbmZvOyBob3dldmVyLCBpbnZhbGlkYXRpb24gc3RhdGVcblx0ICAgIC8vIG5lZWRzXG5cdCAgICBpcEFkZGVkID0gX21heWJlQWRkSW5zZXJ0aW9uUG9pbnQobm9kZSwgY29udGFpbmVyLCBvd25lclJvb3QpO1xuXHQgICAgLy8gaW52YWxpZGF0ZSBpbnNlcnRpb24gcG9pbnRzIElGRiBub3QgYWxyZWFkeSBpbnZhbGlkIVxuXHQgICAgaWYgKGlwQWRkZWQpIHtcblx0ICAgICAgb3duZXJSb290Ll9za2lwVXBkYXRlSW5zZXJ0aW9uUG9pbnRzID0gZmFsc2U7XG5cdCAgICB9XG5cdCAgfVxuXHQgIGlmICgoMCwgX2xvZ2ljYWxQcm9wZXJ0aWVzLmhhc1Byb3BlcnR5KShjb250YWluZXIsICdmaXJzdENoaWxkJykpIHtcblx0ICAgIGxvZ2ljYWxUcmVlLnJlY29yZEluc2VydEJlZm9yZShub2RlLCBjb250YWluZXIsIHJlZl9ub2RlKTtcblx0ICB9XG5cdCAgLy8gaWYgbm90IGRpc3RyaWJ1dGluZyBhbmQgbm90IGFkZGluZyB0byBob3N0LCBkbyBhIGZhc3QgcGF0aCBhZGRpdGlvblxuXHQgIC8vIFRPRE8oc29ydmVsbCk6IHJldmlzaXQgZmxvdyBzaW5jZSBgaXBBZGRlZGAgbmVlZGVkIGhlcmUgaWZcblx0ICAvLyBub2RlIGlzIGEgZnJhZ21lbnQgdGhhdCBoYXMgYSBwYXRjaGVkIFFTQS5cblx0ICB2YXIgaGFuZGxlZCA9IF9tYXliZURpc3RyaWJ1dGUobm9kZSwgY29udGFpbmVyLCBvd25lclJvb3QsIGlwQWRkZWQpIHx8IGNvbnRhaW5lci5zaGFkeVJvb3Q7XG5cdCAgcmV0dXJuIGhhbmRsZWQ7XG5cdH1cblx0XG5cdC8vIFRyeSB0byByZW1vdmUgbm9kZTogdXBkYXRlIGxvZ2ljYWwgaW5mbyBhbmQgcGVyZm9ybSBkaXN0cmlidXRpb24gaWZmXG5cdC8vIG5lZWRlZC4gUmV0dXJuIHRydWUgaWYgdGhlIHJlbW92YWwgaGFzIGJlZW4gaGFuZGxlZC5cblx0Ly8gbm90ZSB0aGF0IGl0J3MgcG9zc2libGUgZm9yIGJvdGggdGhlIG5vZGUncyBob3N0IGFuZCBpdHMgcGFyZW50XG5cdC8vIHRvIHJlcXVpcmUgZGlzdHJpYnV0aW9uLi4uIGJvdGggY2FzZXMgYXJlIGhhbmRsZWQgaGVyZS5cblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZShub2RlKSB7XG5cdCAgLy8gaW1wb3J0YW50IHRoYXQgd2Ugd2FudCB0byBkbyB0aGlzIG9ubHkgaWYgdGhlIG5vZGUgaGFzIGEgbG9naWNhbCBwYXJlbnRcblx0ICB2YXIgbG9naWNhbFBhcmVudCA9ICgwLCBfbG9naWNhbFByb3BlcnRpZXMuaGFzUHJvcGVydHkpKG5vZGUsICdwYXJlbnROb2RlJykgJiYgKDAsIF9sb2dpY2FsUHJvcGVydGllcy5nZXRQcm9wZXJ0eSkobm9kZSwgJ3BhcmVudE5vZGUnKTtcblx0ICB2YXIgZGlzdHJpYnV0ZWQgPSB2b2lkIDA7XG5cdCAgdmFyIG93bmVyUm9vdCA9IHV0aWxzLm93bmVyU2hhZHlSb290Rm9yTm9kZShub2RlKTtcblx0ICBpZiAobG9naWNhbFBhcmVudCB8fCBvd25lclJvb3QpIHtcblx0ICAgIC8vIGRpc3RyaWJ1dGUgbm9kZSdzIHBhcmVudCBpZmYgbmVlZGVkXG5cdCAgICBkaXN0cmlidXRlZCA9IG1heWJlRGlzdHJpYnV0ZVBhcmVudChub2RlKTtcblx0ICAgIGlmIChsb2dpY2FsUGFyZW50KSB7XG5cdCAgICAgIGxvZ2ljYWxUcmVlLnJlY29yZFJlbW92ZUNoaWxkKG5vZGUsIGxvZ2ljYWxQYXJlbnQpO1xuXHQgICAgfVxuXHQgICAgLy8gcmVtb3ZlIG5vZGUgZnJvbSByb290IGFuZCBkaXN0cmlidXRlIGl0IGlmZiBuZWVkZWRcblx0ICAgIHZhciByZW1vdmVkRGlzdHJpYnV0ZWQgPSBvd25lclJvb3QgJiYgX3JlbW92ZURpc3RyaWJ1dGVkQ2hpbGRyZW4ob3duZXJSb290LCBub2RlKTtcblx0ICAgIHZhciBhZGRlZEluc2VydGlvblBvaW50ID0gbG9naWNhbFBhcmVudCAmJiBvd25lclJvb3QgJiYgbG9naWNhbFBhcmVudC5sb2NhbE5hbWUgPT09IG93bmVyUm9vdC5nZXRJbnNlcnRpb25Qb2ludFRhZygpO1xuXHQgICAgaWYgKHJlbW92ZWREaXN0cmlidXRlZCB8fCBhZGRlZEluc2VydGlvblBvaW50KSB7XG5cdCAgICAgIG93bmVyUm9vdC5fc2tpcFVwZGF0ZUluc2VydGlvblBvaW50cyA9IGZhbHNlO1xuXHQgICAgICB1cGRhdGVSb290VmlhQ29udGVudENoYW5nZShvd25lclJvb3QpO1xuXHQgICAgfVxuXHQgIH1cblx0ICBfcmVtb3ZlT3duZXJTaGFkeVJvb3Qobm9kZSk7XG5cdCAgcmV0dXJuIGRpc3RyaWJ1dGVkO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBfc2NoZWR1bGVPYnNlcnZlcihub2RlLCBhZGRlZE5vZGUsIHJlbW92ZWROb2RlKSB7XG5cdCAgdmFyIG9ic2VydmVyID0gbm9kZS5fX3NoYWR5ICYmIG5vZGUuX19zaGFkeS5vYnNlcnZlcjtcblx0ICBpZiAob2JzZXJ2ZXIpIHtcblx0ICAgIGlmIChhZGRlZE5vZGUpIHtcblx0ICAgICAgb2JzZXJ2ZXIuYWRkZWROb2Rlcy5wdXNoKGFkZGVkTm9kZSk7XG5cdCAgICB9XG5cdCAgICBpZiAocmVtb3ZlZE5vZGUpIHtcblx0ICAgICAgb2JzZXJ2ZXIucmVtb3ZlZE5vZGVzLnB1c2gocmVtb3ZlZE5vZGUpO1xuXHQgICAgfVxuXHQgICAgb2JzZXJ2ZXIuc2NoZWR1bGUoKTtcblx0ICB9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGVGcm9tUGFyZW50KG5vZGUsIGxvZ2ljYWxQYXJlbnQpIHtcblx0ICBpZiAobG9naWNhbFBhcmVudCkge1xuXHQgICAgX3NjaGVkdWxlT2JzZXJ2ZXIobG9naWNhbFBhcmVudCwgbnVsbCwgbm9kZSk7XG5cdCAgICByZXR1cm4gcmVtb3ZlTm9kZShub2RlKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gY29tcG9zZWQgYnV0IG5vdCBsb2dpY2FsIHBhcmVudFxuXHQgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuXHQgICAgICBuYXRpdmVNZXRob2RzLnJlbW92ZUNoaWxkLmNhbGwobm9kZS5wYXJlbnROb2RlLCBub2RlKTtcblx0ICAgIH1cblx0ICAgIF9yZW1vdmVPd25lclNoYWR5Um9vdChub2RlKTtcblx0ICB9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIF9oYXNDYWNoZWRPd25lclJvb3Qobm9kZSkge1xuXHQgIHJldHVybiBCb29sZWFuKG5vZGUuX19vd25lclNoYWR5Um9vdCAhPT0gdW5kZWZpbmVkKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gZ2V0Um9vdE5vZGUobm9kZSkge1xuXHQgIGlmICghbm9kZSB8fCAhbm9kZS5ub2RlVHlwZSkge1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblx0ICB2YXIgcm9vdCA9IG5vZGUuX19vd25lclNoYWR5Um9vdDtcblx0ICBpZiAocm9vdCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICBpZiAodXRpbHMuaXNTaGFkeVJvb3Qobm9kZSkpIHtcblx0ICAgICAgcm9vdCA9IG5vZGU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuXHQgICAgICByb290ID0gcGFyZW50ID8gZ2V0Um9vdE5vZGUocGFyZW50KSA6IG5vZGU7XG5cdCAgICB9XG5cdCAgICAvLyBtZW1vLWl6ZSByZXN1bHQgZm9yIHBlcmZvcm1hbmNlIGJ1dCBvbmx5IG1lbW8taXplXG5cdCAgICAvLyByZXN1bHQgaWYgbm9kZSBpcyBpbiB0aGUgZG9jdW1lbnQuIFRoaXMgYXZvaWRzIGEgcHJvYmxlbSB3aGVyZSBhIHJvb3Rcblx0ICAgIC8vIGNhbiBiZSBjYWNoZWQgd2hpbGUgYW4gZWxlbWVudCBpcyBpbnNpZGUgYSBmcmFnbWVudC5cblx0ICAgIC8vIElmIHRoaXMgaGFwcGVucyBhbmQgd2UgY2FjaGUgdGhlIHJlc3VsdCwgdGhlIHZhbHVlIGNhbiBiZWNvbWUgc3RhbGVcblx0ICAgIC8vIGJlY2F1c2UgZm9yIHBlcmYgd2UgYXZvaWQgcHJvY2Vzc2luZyB0aGUgc3VidHJlZSBvZiBhZGRlZCBmcmFnbWVudHMuXG5cdCAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKG5vZGUpKSB7XG5cdCAgICAgIG5vZGUuX19vd25lclNoYWR5Um9vdCA9IHJvb3Q7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByb290O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBfbWF5YmVEaXN0cmlidXRlKG5vZGUsIGNvbnRhaW5lciwgb3duZXJSb290LCBpcEFkZGVkKSB7XG5cdCAgLy8gVE9ETyhzb3J2ZWxsKTogdGVjaG5pY2FsbHkgd2Ugc2hvdWxkIGNoZWNrIG5vbi1mcmFnbWVudCBub2RlcyBmb3Jcblx0ICAvLyA8Y29udGVudD4gY2hpbGRyZW4gYnV0IHNpbmNlIHRoaXMgY2FzZSBpcyBhc3N1bWVkIHRvIGJlIGV4Y2VlZGluZ2x5XG5cdCAgLy8gcmFyZSwgd2UgYXZvaWQgdGhlIGNvc3QgYW5kIHdpbGwgYWRkcmVzcyB3aXRoIHNvbWUgc3BlY2lmaWMgYXBpXG5cdCAgLy8gd2hlbiB0aGUgbmVlZCBhcmlzZXMuICBGb3Igbm93LCB0aGUgdXNlciBtdXN0IGNhbGxcblx0ICAvLyBkaXN0cmlidXRlQ29udGVudCh0cnVlKSwgd2hpY2ggdXBkYXRlcyBpbnNlcnRpb24gcG9pbnRzIG1hbnVhbGx5XG5cdCAgLy8gYW5kIGZvcmNlcyBkaXN0cmlidXRpb24uXG5cdCAgdmFyIGluc2VydGlvblBvaW50VGFnID0gb3duZXJSb290ICYmIG93bmVyUm9vdC5nZXRJbnNlcnRpb25Qb2ludFRhZygpIHx8ICcnO1xuXHQgIHZhciBmcmFnQ29udGVudCA9IG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSAmJiAhbm9kZS5fX25vSW5zZXJ0aW9uUG9pbnQgJiYgaW5zZXJ0aW9uUG9pbnRUYWcgJiYgbm9kZS5xdWVyeVNlbGVjdG9yKGluc2VydGlvblBvaW50VGFnKTtcblx0ICB2YXIgd3JhcHBlZENvbnRlbnQgPSBmcmFnQ29udGVudCAmJiBmcmFnQ29udGVudC5wYXJlbnROb2RlLm5vZGVUeXBlICE9PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREU7XG5cdCAgdmFyIGhhc0NvbnRlbnQgPSBmcmFnQ29udGVudCB8fCBub2RlLmxvY2FsTmFtZSA9PT0gaW5zZXJ0aW9uUG9pbnRUYWc7XG5cdCAgLy8gVGhlcmUgYXJlIDMgcG9zc2libGUgY2FzZXMgd2hlcmUgYSBkaXN0cmlidXRpb24gbWF5IG5lZWQgdG8gb2NjdXI6XG5cdCAgLy8gMS4gPGNvbnRlbnQ+IGJlaW5nIGluc2VydGVkICh0aGUgaG9zdCBvZiB0aGUgc2hhZHkgcm9vdCB3aGVyZVxuXHQgIC8vICAgIGNvbnRlbnQgaXMgaW5zZXJ0ZWQgbmVlZHMgZGlzdHJpYnV0aW9uKVxuXHQgIC8vIDIuIGNoaWxkcmVuIGJlaW5nIGluc2VydGVkIGludG8gcGFyZW50IHdpdGggYSBzaGFkeSByb290IChwYXJlbnRcblx0ICAvLyAgICBuZWVkcyBkaXN0cmlidXRpb24pXG5cdCAgLy8gMy4gY29udGFpbmVyIGlzIGFuIGluc2VydGlvblBvaW50XG5cdCAgaWYgKGhhc0NvbnRlbnQgfHwgY29udGFpbmVyLmxvY2FsTmFtZSA9PT0gaW5zZXJ0aW9uUG9pbnRUYWcgfHwgaXBBZGRlZCkge1xuXHQgICAgaWYgKG93bmVyUm9vdCkge1xuXHQgICAgICAvLyBub3RlLCBpbnNlcnRpb24gcG9pbnQgbGlzdCB1cGRhdGUgaXMgaGFuZGxlZCBhZnRlciBub2RlXG5cdCAgICAgIC8vIG11dGF0aW9ucyBhcmUgY29tcGxldGVcblx0ICAgICAgdXBkYXRlUm9vdFZpYUNvbnRlbnRDaGFuZ2Uob3duZXJSb290KTtcblx0ICAgIH1cblx0ICB9XG5cdCAgdmFyIG5lZWRzRGlzdCA9IF9ub2RlTmVlZHNEaXN0cmlidXRpb24oY29udGFpbmVyKTtcblx0ICBpZiAobmVlZHNEaXN0KSB7XG5cdCAgICB1cGRhdGVSb290VmlhQ29udGVudENoYW5nZShjb250YWluZXIuc2hhZHlSb290KTtcblx0ICB9XG5cdCAgLy8gUmV0dXJuIHRydWUgd2hlbiBkaXN0cmlidXRpb24gd2lsbCBmdWxseSBoYW5kbGUgdGhlIGNvbXBvc2l0aW9uXG5cdCAgLy8gTm90ZSB0aGF0IGlmIGEgY29udGVudCB3YXMgYmVpbmcgaW5zZXJ0ZWQgdGhhdCB3YXMgd3JhcHBlZCBieSBhIG5vZGUsXG5cdCAgLy8gYW5kIHRoZSBwYXJlbnQgZG9lcyBub3QgbmVlZCBkaXN0cmlidXRpb24sIHJldHVybiBmYWxzZSB0byBhbGxvd1xuXHQgIC8vIHRoZSBub2RlcyB0byBiZSBhZGRlZCBkaXJlY3RseSwgYWZ0ZXIgd2hpY2ggY2hpbGRyZW4gbWF5IGJlXG5cdCAgLy8gZGlzdHJpYnV0ZWQgYW5kIGNvbXBvc2VkIGludG8gdGhlIHdyYXBwaW5nIG5vZGUocylcblx0ICByZXR1cm4gbmVlZHNEaXN0IHx8IGhhc0NvbnRlbnQgJiYgIXdyYXBwZWRDb250ZW50O1xuXHR9XG5cdFxuXHQvKiBub3RlOiBwYXJlbnQgYXJndW1lbnQgaXMgcmVxdWlyZWQgc2luY2Ugbm9kZSBtYXkgaGF2ZSBhbiBvdXRcblx0b2YgZGF0ZSBwYXJlbnQgYXQgdGhpcyBwb2ludDsgcmV0dXJucyB0cnVlIGlmIGEgPGNvbnRlbnQ+IGlzIGJlaW5nIGFkZGVkICovXG5cdGZ1bmN0aW9uIF9tYXliZUFkZEluc2VydGlvblBvaW50KG5vZGUsIHBhcmVudCwgcm9vdCkge1xuXHQgIHZhciBhZGRlZCA9IHZvaWQgMDtcblx0ICB2YXIgaW5zZXJ0aW9uUG9pbnRUYWcgPSByb290LmdldEluc2VydGlvblBvaW50VGFnKCk7XG5cdCAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSAmJiAhbm9kZS5fX25vSW5zZXJ0aW9uUG9pbnQpIHtcblx0ICAgIHZhciBjJCA9IG5vZGUucXVlcnlTZWxlY3RvckFsbChpbnNlcnRpb25Qb2ludFRhZyk7XG5cdCAgICBmb3IgKHZhciBpID0gMCwgbiwgbnAsIG5hOyBpIDwgYyQubGVuZ3RoICYmIChuID0gYyRbaV0pOyBpKyspIHtcblx0ICAgICAgbnAgPSBuLnBhcmVudE5vZGU7XG5cdCAgICAgIC8vIGRvbid0IGFsbG93IG5vZGUncyBwYXJlbnQgdG8gYmUgZnJhZ21lbnQgaXRzZWxmXG5cdCAgICAgIGlmIChucCA9PT0gbm9kZSkge1xuXHQgICAgICAgIG5wID0gcGFyZW50O1xuXHQgICAgICB9XG5cdCAgICAgIG5hID0gX21heWJlQWRkSW5zZXJ0aW9uUG9pbnQobiwgbnAsIHJvb3QpO1xuXHQgICAgICBhZGRlZCA9IGFkZGVkIHx8IG5hO1xuXHQgICAgfVxuXHQgIH0gZWxzZSBpZiAobm9kZS5sb2NhbE5hbWUgPT09IGluc2VydGlvblBvaW50VGFnKSB7XG5cdCAgICBsb2dpY2FsVHJlZS5yZWNvcmRDaGlsZE5vZGVzKHBhcmVudCk7XG5cdCAgICBsb2dpY2FsVHJlZS5yZWNvcmRDaGlsZE5vZGVzKG5vZGUpO1xuXHQgICAgYWRkZWQgPSB0cnVlO1xuXHQgIH1cblx0ICByZXR1cm4gYWRkZWQ7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIF9ub2RlTmVlZHNEaXN0cmlidXRpb24obm9kZSkge1xuXHQgIHJldHVybiBub2RlICYmIG5vZGUuc2hhZHlSb290ICYmIG5vZGUuc2hhZHlSb290Lmhhc0luc2VydGlvblBvaW50KCk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIF9yZW1vdmVEaXN0cmlidXRlZENoaWxkcmVuKHJvb3QsIGNvbnRhaW5lcikge1xuXHQgIHZhciBob3N0TmVlZHNEaXN0ID0gdm9pZCAwO1xuXHQgIHZhciBpcCQgPSByb290Ll9pbnNlcnRpb25Qb2ludHM7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBpcCQubGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciBpbnNlcnRpb25Qb2ludCA9IGlwJFtpXTtcblx0ICAgIGlmIChfY29udGFpbnMoY29udGFpbmVyLCBpbnNlcnRpb25Qb2ludCkpIHtcblx0ICAgICAgdmFyIGRjJCA9IGluc2VydGlvblBvaW50LmFzc2lnbmVkTm9kZXMoeyBmbGF0dGVuOiB0cnVlIH0pO1xuXHQgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRjJC5sZW5ndGg7IGorKykge1xuXHQgICAgICAgIGhvc3ROZWVkc0Rpc3QgPSB0cnVlO1xuXHQgICAgICAgIHZhciBub2RlID0gZGMkW2pdO1xuXHQgICAgICAgIHZhciBwYXJlbnQgPSAoMCwgX25hdGl2ZVRyZWUucGFyZW50Tm9kZSkobm9kZSk7XG5cdCAgICAgICAgaWYgKHBhcmVudCkge1xuXHQgICAgICAgICAgbmF0aXZlTWV0aG9kcy5yZW1vdmVDaGlsZC5jYWxsKHBhcmVudCwgbm9kZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBob3N0TmVlZHNEaXN0O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBfY29udGFpbnMoY29udGFpbmVyLCBub2RlKSB7XG5cdCAgd2hpbGUgKG5vZGUpIHtcblx0ICAgIGlmIChub2RlID09IGNvbnRhaW5lcikge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdCAgfVxuXHR9XG5cdFxuXHRmdW5jdGlvbiBfcmVtb3ZlT3duZXJTaGFkeVJvb3Qobm9kZSkge1xuXHQgIC8vIG9wdGltaXphdGlvbjogb25seSByZXNldCB0aGUgdHJlZSBpZiBub2RlIGlzIGFjdHVhbGx5IGluIGEgcm9vdFxuXHQgIGlmIChfaGFzQ2FjaGVkT3duZXJSb290KG5vZGUpKSB7XG5cdCAgICB2YXIgYyQgPSBub2RlLmNoaWxkTm9kZXM7XG5cdCAgICBmb3IgKHZhciBpID0gMCwgbCA9IGMkLmxlbmd0aCwgbjsgaSA8IGwgJiYgKG4gPSBjJFtpXSk7IGkrKykge1xuXHQgICAgICBfcmVtb3ZlT3duZXJTaGFkeVJvb3Qobik7XG5cdCAgICB9XG5cdCAgfVxuXHQgIG5vZGUuX19vd25lclNoYWR5Um9vdCA9IHVuZGVmaW5lZDtcblx0fVxuXHRcblx0Ly8gVE9ETyhzb3J2ZWxsKTogVGhpcyB3aWxsIGZhaWwgaWYgZGlzdHJpYnV0aW9uIHRoYXQgYWZmZWN0cyB0aGlzXG5cdC8vIHF1ZXN0aW9uIGlzIHBlbmRpbmc7IHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgZXhjZWVkaW5nbHkgcmFyZSwgYnV0IGlmXG5cdC8vIHRoZSBpc3N1ZSBjb21lcyB1cCwgd2UgY2FuIGZvcmNlIGEgZmx1c2ggaW4gdGhpcyBjYXNlLlxuXHRmdW5jdGlvbiBmaXJzdENvbXBvc2VkTm9kZShpbnNlcnRpb25Qb2ludCkge1xuXHQgIHZhciBuJCA9IGluc2VydGlvblBvaW50LmFzc2lnbmVkTm9kZXMoeyBmbGF0dGVuOiB0cnVlIH0pO1xuXHQgIHZhciByb290ID0gZ2V0Um9vdE5vZGUoaW5zZXJ0aW9uUG9pbnQpO1xuXHQgIGZvciAodmFyIGkgPSAwLCBsID0gbiQubGVuZ3RoLCBuOyBpIDwgbCAmJiAobiA9IG4kW2ldKTsgaSsrKSB7XG5cdCAgICAvLyBtZWFucyB0aGF0IHdlJ3JlIGNvbXBvc2VkIHRvIHRoaXMgc3BvdC5cblx0ICAgIGlmIChyb290LmlzRmluYWxEZXN0aW5hdGlvbihpbnNlcnRpb25Qb2ludCwgbikpIHtcblx0ICAgICAgcmV0dXJuIG47XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdFxuXHRmdW5jdGlvbiBtYXliZURpc3RyaWJ1dGVQYXJlbnQobm9kZSkge1xuXHQgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG5cdCAgaWYgKF9ub2RlTmVlZHNEaXN0cmlidXRpb24ocGFyZW50KSkge1xuXHQgICAgdXBkYXRlUm9vdFZpYUNvbnRlbnRDaGFuZ2UocGFyZW50LnNoYWR5Um9vdCk7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHVwZGF0ZVJvb3RWaWFDb250ZW50Q2hhbmdlKHJvb3QpIHtcblx0ICAvLyBtYXJrIHJvb3QgYXMgbXV0YXRpb24gYmFzZWQgb24gYSBtdXRhdGlvblxuXHQgIHJvb3QuX2NoYW5nZVBlbmRpbmcgPSB0cnVlO1xuXHQgIHJvb3QudXBkYXRlKCk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGRpc3RyaWJ1dGVBdHRyaWJ1dGVDaGFuZ2Uobm9kZSwgbmFtZSkge1xuXHQgIGlmIChuYW1lID09PSAnc2xvdCcpIHtcblx0ICAgIG1heWJlRGlzdHJpYnV0ZVBhcmVudChub2RlKTtcblx0ICB9IGVsc2UgaWYgKG5vZGUubG9jYWxOYW1lID09PSAnc2xvdCcgJiYgbmFtZSA9PT0gJ25hbWUnKSB7XG5cdCAgICB2YXIgcm9vdCA9IHV0aWxzLm93bmVyU2hhZHlSb290Rm9yTm9kZShub2RlKTtcblx0ICAgIGlmIChyb290KSB7XG5cdCAgICAgIHJvb3QudXBkYXRlKCk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdFxuXHQvLyBOT1RFOiBgcXVlcnlgIGlzIHVzZWQgcHJpbWFyaWx5IGZvciBTaGFkeURPTSdzIHF1ZXJ5U2VsZWN0b3IgaW1wbCxcblx0Ly8gYnV0IGl0J3MgYWxzbyBnZW5lcmFsbHkgdXNlZnVsIHRvIHJlY3Vyc2UgdGhyb3VnaCB0aGUgZWxlbWVudCB0cmVlXG5cdC8vIGFuZCBpcyB1c2VkIGJ5IFBvbHltZXIncyBzdHlsaW5nIHN5c3RlbS5cblx0ZnVuY3Rpb24gcXVlcnkobm9kZSwgbWF0Y2hlciwgaGFsdGVyKSB7XG5cdCAgdmFyIGxpc3QgPSBbXTtcblx0ICBfcXVlcnlFbGVtZW50cyhub2RlLmNoaWxkTm9kZXMsIG1hdGNoZXIsIGhhbHRlciwgbGlzdCk7XG5cdCAgcmV0dXJuIGxpc3Q7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIF9xdWVyeUVsZW1lbnRzKGVsZW1lbnRzLCBtYXRjaGVyLCBoYWx0ZXIsIGxpc3QpIHtcblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IGVsZW1lbnRzLmxlbmd0aCwgYzsgaSA8IGwgJiYgKGMgPSBlbGVtZW50c1tpXSk7IGkrKykge1xuXHQgICAgaWYgKGMubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIF9xdWVyeUVsZW1lbnQoYywgbWF0Y2hlciwgaGFsdGVyLCBsaXN0KSkge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIF9xdWVyeUVsZW1lbnQobm9kZSwgbWF0Y2hlciwgaGFsdGVyLCBsaXN0KSB7XG5cdCAgdmFyIHJlc3VsdCA9IG1hdGNoZXIobm9kZSk7XG5cdCAgaWYgKHJlc3VsdCkge1xuXHQgICAgbGlzdC5wdXNoKG5vZGUpO1xuXHQgIH1cblx0ICBpZiAoaGFsdGVyICYmIGhhbHRlcihyZXN1bHQpKSB7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH1cblx0ICBfcXVlcnlFbGVtZW50cyhub2RlLmNoaWxkTm9kZXMsIG1hdGNoZXIsIGhhbHRlciwgbGlzdCk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHJlbmRlclJvb3ROb2RlKGVsZW1lbnQpIHtcblx0ICB2YXIgcm9vdCA9IGVsZW1lbnQuZ2V0Um9vdE5vZGUoKTtcblx0ICBpZiAodXRpbHMuaXNTaGFkeVJvb3Qocm9vdCkpIHtcblx0ICAgIHJvb3QucmVuZGVyKCk7XG5cdCAgfVxuXHR9XG5cdFxuXHR2YXIgc2NvcGluZ1NoaW0gPSBudWxsO1xuXHRcblx0ZnVuY3Rpb24gc2V0QXR0cmlidXRlKG5vZGUsIGF0dHIsIHZhbHVlKSB7XG5cdCAgaWYgKCFzY29waW5nU2hpbSkge1xuXHQgICAgc2NvcGluZ1NoaW0gPSB3aW5kb3cuU2hhZHlDU1MgJiYgd2luZG93LlNoYWR5Q1NTLlNjb3BpbmdTaGltO1xuXHQgIH1cblx0ICAvLyBhdm9pZCBzY29waW5nIGVsZW1lbnRzIGluIG5vbi1tYWluIGRvY3VtZW50IHRvIGF2b2lkIHRlbXBsYXRlIGRvY3VtZW50c1xuXHQgIGlmIChzY29waW5nU2hpbSAmJiBhdHRyID09PSAnY2xhc3MnICYmIG5vZGUub3duZXJEb2N1bWVudCA9PT0gZG9jdW1lbnQpIHtcblx0ICAgIHNjb3BpbmdTaGltLnNldEVsZW1lbnRDbGFzcyhub2RlLCB2YWx1ZSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIG5hdGl2ZU1ldGhvZHMuc2V0QXR0cmlidXRlLmNhbGwobm9kZSwgYXR0ciwgdmFsdWUpO1xuXHQgICAgZGlzdHJpYnV0ZUF0dHJpYnV0ZUNoYW5nZShub2RlLCBhdHRyKTtcblx0ICB9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZShub2RlLCBhdHRyKSB7XG5cdCAgbmF0aXZlTWV0aG9kcy5yZW1vdmVBdHRyaWJ1dGUuY2FsbChub2RlLCBhdHRyKTtcblx0ICBkaXN0cmlidXRlQXR0cmlidXRlQ2hhbmdlKG5vZGUsIGF0dHIpO1xuXHR9XG5cdFxuXHQvLyBjYXNlcyBpbiB3aGljaCB3ZSBtYXkgbm90IGJlIGFibGUgdG8ganVzdCBkbyBzdGFuZGFyZCBuYXRpdmUgY2FsbFxuXHQvLyAxLiBjb250YWluZXIgaGFzIGEgc2hhZHlSb290IChuZWVkc0Rpc3RyaWJ1dGlvbiBJRkYgdGhlIHNoYWR5Um9vdFxuXHQvLyBoYXMgYW4gaW5zZXJ0aW9uIHBvaW50KVxuXHQvLyAyLiBjb250YWluZXIgaXMgYSBzaGFkeVJvb3QgKGRvbid0IGRpc3RyaWJ1dGUsIGluc3RlYWQgc2V0XG5cdC8vIGNvbnRhaW5lciB0byBjb250YWluZXIuaG9zdC5cblx0Ly8gMy4gbm9kZSBpcyA8Y29udGVudD4gKGhvc3Qgb2YgY29udGFpbmVyIG5lZWRzIGRpc3RyaWJ1dGlvbilcblx0ZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHBhcmVudCwgbm9kZSwgcmVmX25vZGUpIHtcblx0ICBpZiAocmVmX25vZGUpIHtcblx0ICAgIHZhciBwID0gKDAsIF9sb2dpY2FsUHJvcGVydGllcy5nZXRQcm9wZXJ0eSkocmVmX25vZGUsICdwYXJlbnROb2RlJyk7XG5cdCAgICBpZiAocCAhPT0gdW5kZWZpbmVkICYmIHAgIT09IHBhcmVudCkge1xuXHQgICAgICB0aHJvdyBFcnJvcignVGhlIHJlZl9ub2RlIHRvIGJlIGluc2VydGVkIGJlZm9yZSBpcyBub3QgYSBjaGlsZCAnICsgJ29mIHRoaXMgbm9kZScpO1xuXHQgICAgfVxuXHQgIH1cblx0ICAvLyByZW1vdmUgbm9kZSBmcm9tIGl0cyBjdXJyZW50IHBvc2l0aW9uIGlmZiBpdCdzIGluIGEgdHJlZS5cblx0ICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG5cdCAgICB2YXIgX3BhcmVudCA9ICgwLCBfbG9naWNhbFByb3BlcnRpZXMuZ2V0UHJvcGVydHkpKG5vZGUsICdwYXJlbnROb2RlJyk7XG5cdCAgICByZW1vdmVOb2RlRnJvbVBhcmVudChub2RlLCBfcGFyZW50KTtcblx0ICB9XG5cdCAgaWYgKCFhZGROb2RlKHBhcmVudCwgbm9kZSwgcmVmX25vZGUpKSB7XG5cdCAgICBpZiAocmVmX25vZGUpIHtcblx0ICAgICAgLy8gaWYgcmVmX25vZGUgaXMgYW4gaW5zZXJ0aW9uIHBvaW50IHJlcGxhY2Ugd2l0aCBmaXJzdCBkaXN0cmlidXRlZCBub2RlXG5cdCAgICAgIHZhciByb290ID0gdXRpbHMub3duZXJTaGFkeVJvb3RGb3JOb2RlKHJlZl9ub2RlKTtcblx0ICAgICAgaWYgKHJvb3QpIHtcblx0ICAgICAgICByZWZfbm9kZSA9IHJlZl9ub2RlLmxvY2FsTmFtZSA9PT0gcm9vdC5nZXRJbnNlcnRpb25Qb2ludFRhZygpID8gZmlyc3RDb21wb3NlZE5vZGUocmVmX25vZGUpIDogcmVmX25vZGU7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIC8vIGlmIGFkZGluZyB0byBhIHNoYWR5Um9vdCwgYWRkIHRvIGhvc3QgaW5zdGVhZFxuXHQgICAgdmFyIGNvbnRhaW5lciA9IHV0aWxzLmlzU2hhZHlSb290KHBhcmVudCkgPyBwYXJlbnQuaG9zdCA6IHBhcmVudDtcblx0ICAgIGlmIChyZWZfbm9kZSkge1xuXHQgICAgICBuYXRpdmVNZXRob2RzLmluc2VydEJlZm9yZS5jYWxsKGNvbnRhaW5lciwgbm9kZSwgcmVmX25vZGUpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgbmF0aXZlTWV0aG9kcy5hcHBlbmRDaGlsZC5jYWxsKGNvbnRhaW5lciwgbm9kZSk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIF9zY2hlZHVsZU9ic2VydmVyKHBhcmVudCwgbm9kZSk7XG5cdCAgcmV0dXJuIG5vZGU7XG5cdH1cblx0XG5cdC8qKlxuXHQgIFJlbW92ZXMgdGhlIGdpdmVuIGBub2RlYCBmcm9tIHRoZSBlbGVtZW50J3MgYGxpZ2h0Q2hpbGRyZW5gLlxuXHQgIFRoaXMgbWV0aG9kIGFsc28gcGVyZm9ybXMgZG9tIGNvbXBvc2l0aW9uLlxuXHQqL1xuXHRmdW5jdGlvbiByZW1vdmVDaGlsZChwYXJlbnQsIG5vZGUpIHtcblx0ICBpZiAobm9kZS5wYXJlbnROb2RlICE9PSBwYXJlbnQpIHtcblx0ICAgIHRocm93IEVycm9yKCdUaGUgbm9kZSB0byBiZSByZW1vdmVkIGlzIG5vdCBhIGNoaWxkIG9mIHRoaXMgbm9kZTogJyArIG5vZGUpO1xuXHQgIH1cblx0ICBpZiAoIXJlbW92ZU5vZGUobm9kZSkpIHtcblx0ICAgIC8vIGlmIHJlbW92aW5nIGZyb20gYSBzaGFkeVJvb3QsIHJlbW92ZSBmb3JtIGhvc3QgaW5zdGVhZFxuXHQgICAgdmFyIGNvbnRhaW5lciA9IHV0aWxzLmlzU2hhZHlSb290KHBhcmVudCkgPyBwYXJlbnQuaG9zdCA6IHBhcmVudDtcblx0ICAgIC8vIG5vdCBndWFyYW50ZWVkIHRvIHBoeXNpY2FsbHkgYmUgaW4gY29udGFpbmVyOyBlLmcuXG5cdCAgICAvLyB1bmRpc3RyaWJ1dGVkIG5vZGVzLlxuXHQgICAgdmFyIG5hdGl2ZVBhcmVudCA9ICgwLCBfbmF0aXZlVHJlZS5wYXJlbnROb2RlKShub2RlKTtcblx0ICAgIGlmIChjb250YWluZXIgPT09IG5hdGl2ZVBhcmVudCkge1xuXHQgICAgICBuYXRpdmVNZXRob2RzLnJlbW92ZUNoaWxkLmNhbGwoY29udGFpbmVyLCBub2RlKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgX3NjaGVkdWxlT2JzZXJ2ZXIocGFyZW50LCBudWxsLCBub2RlKTtcblx0ICByZXR1cm4gbm9kZTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gY2xvbmVOb2RlKG5vZGUsIGRlZXApIHtcblx0ICBpZiAobm9kZS5sb2NhbE5hbWUgPT0gJ3RlbXBsYXRlJykge1xuXHQgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZHMuY2xvbmVOb2RlLmNhbGwobm9kZSwgZGVlcCk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHZhciBuID0gbmF0aXZlTWV0aG9kcy5jbG9uZU5vZGUuY2FsbChub2RlLCBmYWxzZSk7XG5cdCAgICBpZiAoZGVlcCkge1xuXHQgICAgICB2YXIgYyQgPSBub2RlLmNoaWxkTm9kZXM7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwLCBuYzsgaSA8IGMkLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgbmMgPSBjJFtpXS5jbG9uZU5vZGUodHJ1ZSk7XG5cdCAgICAgICAgbi5hcHBlbmRDaGlsZChuYyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBuO1xuXHQgIH1cblx0fVxuXHRcblx0Ly8gbm90ZTogVGhvdWdoIG5vdCB0ZWNobmljYWxseSBjb3JyZWN0LCB3ZSBmYXN0IHBhdGggYGltcG9ydE5vZGVgXG5cdC8vIHdoZW4gY2FsbGVkIG9uIGEgbm9kZSBub3Qgb3duZWQgYnkgdGhlIG1haW4gZG9jdW1lbnQuXG5cdC8vIFRoaXMgYWxsb3dzLCBmb3IgZXhhbXBsZSwgZWxlbWVudHMgdGhhdCBjYW5ub3Rcblx0Ly8gY29udGFpbiBjdXN0b20gZWxlbWVudHMgYW5kIGFyZSB0aGVyZWZvcmUgbm90IGxpa2VseSB0byBjb250YWluIHNoYWRvd1Jvb3RzXG5cdC8vIHRvIGNsb25lZCBuYXRpdmVseS4gVGhpcyBpcyBhIGZhaXJseSBzaWduaWZpY2FudCBwZXJmb3JtYW5jZSB3aW4uXG5cdGZ1bmN0aW9uIGltcG9ydE5vZGUobm9kZSwgZGVlcCkge1xuXHQgIGlmIChub2RlLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50KSB7XG5cdCAgICByZXR1cm4gbmF0aXZlTWV0aG9kcy5pbXBvcnROb2RlLmNhbGwoZG9jdW1lbnQsIG5vZGUsIGRlZXApO1xuXHQgIH1cblx0ICB2YXIgbiA9IG5hdGl2ZU1ldGhvZHMuaW1wb3J0Tm9kZS5jYWxsKGRvY3VtZW50LCBub2RlLCBmYWxzZSk7XG5cdCAgaWYgKGRlZXApIHtcblx0ICAgIHZhciBjJCA9IG5vZGUuY2hpbGROb2Rlcztcblx0ICAgIGZvciAodmFyIGkgPSAwLCBuYzsgaSA8IGMkLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIG5jID0gaW1wb3J0Tm9kZShjJFtpXSwgdHJ1ZSk7XG5cdCAgICAgIG4uYXBwZW5kQ2hpbGQobmMpO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gbjtcblx0fVxuXG4vKioqLyB9LFxuLyogNjAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qKlxuXHRAbGljZW5zZVxuXHRDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXHRUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5cdFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5cdFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuXHRDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuXHRzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuXHQqL1xuXHRcblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdGV4cG9ydHMuZ2V0UHJvcGVydHkgPSBnZXRQcm9wZXJ0eTtcblx0ZXhwb3J0cy5oYXNQcm9wZXJ0eSA9IGhhc1Byb3BlcnR5O1xuXHRmdW5jdGlvbiBnZXRQcm9wZXJ0eShub2RlLCBwcm9wKSB7XG5cdCAgcmV0dXJuIG5vZGUuX19zaGFkeSAmJiBub2RlLl9fc2hhZHlbcHJvcF07XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGhhc1Byb3BlcnR5KG5vZGUsIHByb3ApIHtcblx0ICByZXR1cm4gZ2V0UHJvcGVydHkobm9kZSwgcHJvcCkgIT09IHVuZGVmaW5lZDtcblx0fVxuXG4vKioqLyB9LFxuLyogNjEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qKlxuXHRAbGljZW5zZVxuXHRDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXHRUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5cdFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5cdFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuXHRDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuXHRzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuXHQqL1xuXHRcblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdGV4cG9ydHMucmVjb3JkQ2hpbGROb2RlcyA9IHVuZGVmaW5lZDtcblx0ZXhwb3J0cy5yZWNvcmRJbnNlcnRCZWZvcmUgPSByZWNvcmRJbnNlcnRCZWZvcmU7XG5cdGV4cG9ydHMucmVjb3JkUmVtb3ZlQ2hpbGQgPSByZWNvcmRSZW1vdmVDaGlsZDtcblx0XG5cdHZhciBfbG9naWNhbFByb3BlcnRpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKTtcblx0XG5cdHZhciBfcGF0Y2hBY2Nlc3NvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyKTtcblx0XG5cdHZhciBfbmF0aXZlVHJlZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTYpO1xuXHRcblx0ZnVuY3Rpb24gcmVjb3JkSW5zZXJ0QmVmb3JlKG5vZGUsIGNvbnRhaW5lciwgcmVmX25vZGUpIHtcblx0ICAoMCwgX3BhdGNoQWNjZXNzb3JzLnBhdGNoSW5zaWRlRWxlbWVudEFjY2Vzc29ycykoY29udGFpbmVyKTtcblx0ICBjb250YWluZXIuX19zaGFkeSA9IGNvbnRhaW5lci5fX3NoYWR5IHx8IHt9O1xuXHQgIGlmICgoMCwgX2xvZ2ljYWxQcm9wZXJ0aWVzLmhhc1Byb3BlcnR5KShjb250YWluZXIsICdmaXJzdENoaWxkJykpIHtcblx0ICAgIGNvbnRhaW5lci5fX3NoYWR5LmNoaWxkTm9kZXMgPSBudWxsO1xuXHQgIH1cblx0ICAvLyBoYW5kbGUgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdCAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuXHQgICAgdmFyIGMkID0gbm9kZS5jaGlsZE5vZGVzO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjJC5sZW5ndGg7IGkrKykge1xuXHQgICAgICBsaW5rTm9kZShjJFtpXSwgY29udGFpbmVyLCByZWZfbm9kZSk7XG5cdCAgICB9XG5cdCAgICAvLyBjbGVhbnVwIGxvZ2ljYWwgZG9tIGluIGRvYyBmcmFnbWVudC5cblx0ICAgIG5vZGUuX19zaGFkeSA9IG5vZGUuX19zaGFkeSB8fCB7fTtcblx0ICAgIHZhciByZXNldFRvID0gKDAsIF9sb2dpY2FsUHJvcGVydGllcy5oYXNQcm9wZXJ0eSkobm9kZSwgJ2ZpcnN0Q2hpbGQnKSA/IG51bGwgOiB1bmRlZmluZWQ7XG5cdCAgICBub2RlLl9fc2hhZHkuZmlyc3RDaGlsZCA9IG5vZGUuX19zaGFkeS5sYXN0Q2hpbGQgPSByZXNldFRvO1xuXHQgICAgbm9kZS5fX3NoYWR5LmNoaWxkTm9kZXMgPSByZXNldFRvO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBsaW5rTm9kZShub2RlLCBjb250YWluZXIsIHJlZl9ub2RlKTtcblx0ICB9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGxpbmtOb2RlKG5vZGUsIGNvbnRhaW5lciwgcmVmX25vZGUpIHtcblx0ICAoMCwgX3BhdGNoQWNjZXNzb3JzLnBhdGNoT3V0c2lkZUVsZW1lbnRBY2Nlc3NvcnMpKG5vZGUpO1xuXHQgIHJlZl9ub2RlID0gcmVmX25vZGUgfHwgbnVsbDtcblx0ICBub2RlLl9fc2hhZHkgPSBub2RlLl9fc2hhZHkgfHwge307XG5cdCAgY29udGFpbmVyLl9fc2hhZHkgPSBjb250YWluZXIuX19zaGFkeSB8fCB7fTtcblx0ICBpZiAocmVmX25vZGUpIHtcblx0ICAgIHJlZl9ub2RlLl9fc2hhZHkgPSByZWZfbm9kZS5fX3NoYWR5IHx8IHt9O1xuXHQgIH1cblx0ICAvLyB1cGRhdGUgcmVmX25vZGUucHJldmlvdXNTaWJsaW5nIDwtPiBub2RlXG5cdCAgbm9kZS5fX3NoYWR5LnByZXZpb3VzU2libGluZyA9IHJlZl9ub2RlID8gcmVmX25vZGUuX19zaGFkeS5wcmV2aW91c1NpYmxpbmcgOiBjb250YWluZXIubGFzdENoaWxkO1xuXHQgIHZhciBwcyA9IG5vZGUuX19zaGFkeS5wcmV2aW91c1NpYmxpbmc7XG5cdCAgaWYgKHBzICYmIHBzLl9fc2hhZHkpIHtcblx0ICAgIHBzLl9fc2hhZHkubmV4dFNpYmxpbmcgPSBub2RlO1xuXHQgIH1cblx0ICAvLyB1cGRhdGUgbm9kZSA8LT4gcmVmX25vZGVcblx0ICB2YXIgbnMgPSBub2RlLl9fc2hhZHkubmV4dFNpYmxpbmcgPSByZWZfbm9kZTtcblx0ICBpZiAobnMgJiYgbnMuX19zaGFkeSkge1xuXHQgICAgbnMuX19zaGFkeS5wcmV2aW91c1NpYmxpbmcgPSBub2RlO1xuXHQgIH1cblx0ICAvLyB1cGRhdGUgbm9kZSA8LT4gY29udGFpbmVyXG5cdCAgbm9kZS5fX3NoYWR5LnBhcmVudE5vZGUgPSBjb250YWluZXI7XG5cdCAgaWYgKHJlZl9ub2RlKSB7XG5cdCAgICBpZiAocmVmX25vZGUgPT09IGNvbnRhaW5lci5fX3NoYWR5LmZpcnN0Q2hpbGQpIHtcblx0ICAgICAgY29udGFpbmVyLl9fc2hhZHkuZmlyc3RDaGlsZCA9IG5vZGU7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIGNvbnRhaW5lci5fX3NoYWR5Lmxhc3RDaGlsZCA9IG5vZGU7XG5cdCAgICBpZiAoIWNvbnRhaW5lci5fX3NoYWR5LmZpcnN0Q2hpbGQpIHtcblx0ICAgICAgY29udGFpbmVyLl9fc2hhZHkuZmlyc3RDaGlsZCA9IG5vZGU7XG5cdCAgICB9XG5cdCAgfVxuXHQgIC8vIHJlbW92ZSBjYWNoaW5nIG9mIGNoaWxkTm9kZXNcblx0ICBjb250YWluZXIuX19zaGFkeS5jaGlsZE5vZGVzID0gbnVsbDtcblx0fVxuXHRcblx0ZnVuY3Rpb24gcmVjb3JkUmVtb3ZlQ2hpbGQobm9kZSwgY29udGFpbmVyKSB7XG5cdCAgbm9kZS5fX3NoYWR5ID0gbm9kZS5fX3NoYWR5IHx8IHt9O1xuXHQgIGNvbnRhaW5lci5fX3NoYWR5ID0gY29udGFpbmVyLl9fc2hhZHkgfHwge307XG5cdCAgaWYgKG5vZGUgPT09IGNvbnRhaW5lci5fX3NoYWR5LmZpcnN0Q2hpbGQpIHtcblx0ICAgIGNvbnRhaW5lci5fX3NoYWR5LmZpcnN0Q2hpbGQgPSBub2RlLl9fc2hhZHkubmV4dFNpYmxpbmc7XG5cdCAgfVxuXHQgIGlmIChub2RlID09PSBjb250YWluZXIuX19zaGFkeS5sYXN0Q2hpbGQpIHtcblx0ICAgIGNvbnRhaW5lci5fX3NoYWR5Lmxhc3RDaGlsZCA9IG5vZGUuX19zaGFkeS5wcmV2aW91c1NpYmxpbmc7XG5cdCAgfVxuXHQgIHZhciBwID0gbm9kZS5fX3NoYWR5LnByZXZpb3VzU2libGluZztcblx0ICB2YXIgbiA9IG5vZGUuX19zaGFkeS5uZXh0U2libGluZztcblx0ICBpZiAocCkge1xuXHQgICAgcC5fX3NoYWR5ID0gcC5fX3NoYWR5IHx8IHt9O1xuXHQgICAgcC5fX3NoYWR5Lm5leHRTaWJsaW5nID0gbjtcblx0ICB9XG5cdCAgaWYgKG4pIHtcblx0ICAgIG4uX19zaGFkeSA9IG4uX19zaGFkeSB8fCB7fTtcblx0ICAgIG4uX19zaGFkeS5wcmV2aW91c1NpYmxpbmcgPSBwO1xuXHQgIH1cblx0ICAvLyBXaGVuIGFuIGVsZW1lbnQgaXMgcmVtb3ZlZCwgbG9naWNhbCBkYXRhIGlzIG5vIGxvbmdlciB0cmFja2VkLlxuXHQgIC8vIEV4cGxpY2l0bHkgc2V0IGB1bmRlZmluZWRgIGhlcmUgdG8gaW5kaWNhdGUgdGhpcy4gVGhpcyBpcyBkaXNnaW5ndWlzaGVkXG5cdCAgLy8gZnJvbSBgbnVsbGAgd2hpY2ggaXMgc2V0IGlmIGluZm8gaXMgbnVsbC5cblx0ICBub2RlLl9fc2hhZHkucGFyZW50Tm9kZSA9IG5vZGUuX19zaGFkeS5wcmV2aW91c1NpYmxpbmcgPSBub2RlLl9fc2hhZHkubmV4dFNpYmxpbmcgPSB1bmRlZmluZWQ7XG5cdCAgaWYgKCgwLCBfbG9naWNhbFByb3BlcnRpZXMuaGFzUHJvcGVydHkpKGNvbnRhaW5lciwgJ2NoaWxkTm9kZXMnKSkge1xuXHQgICAgLy8gcmVtb3ZlIGNhY2hpbmcgb2YgY2hpbGROb2Rlc1xuXHQgICAgY29udGFpbmVyLl9fc2hhZHkuY2hpbGROb2RlcyA9IG51bGw7XG5cdCAgfVxuXHR9XG5cdFxuXHR2YXIgcmVjb3JkQ2hpbGROb2RlcyA9IGV4cG9ydHMucmVjb3JkQ2hpbGROb2RlcyA9IGZ1bmN0aW9uIHJlY29yZENoaWxkTm9kZXMobm9kZSkge1xuXHQgIGlmICghKDAsIF9sb2dpY2FsUHJvcGVydGllcy5oYXNQcm9wZXJ0eSkobm9kZSwgJ2ZpcnN0Q2hpbGQnKSkge1xuXHQgICAgbm9kZS5fX3NoYWR5ID0gbm9kZS5fX3NoYWR5IHx8IHt9O1xuXHQgICAgbm9kZS5fX3NoYWR5LmZpcnN0Q2hpbGQgPSAoMCwgX25hdGl2ZVRyZWUuZmlyc3RDaGlsZCkobm9kZSk7XG5cdCAgICBub2RlLl9fc2hhZHkubGFzdENoaWxkID0gKDAsIF9uYXRpdmVUcmVlLmxhc3RDaGlsZCkobm9kZSk7XG5cdCAgICAoMCwgX3BhdGNoQWNjZXNzb3JzLnBhdGNoSW5zaWRlRWxlbWVudEFjY2Vzc29ycykobm9kZSk7XG5cdCAgICB2YXIgYyQgPSBub2RlLl9fc2hhZHkuY2hpbGROb2RlcyA9ICgwLCBfbmF0aXZlVHJlZS5jaGlsZE5vZGVzKShub2RlKTtcblx0ICAgIGZvciAodmFyIGkgPSAwLCBuOyBpIDwgYyQubGVuZ3RoICYmIChuID0gYyRbaV0pOyBpKyspIHtcblx0ICAgICAgbi5fX3NoYWR5ID0gbi5fX3NoYWR5IHx8IHt9O1xuXHQgICAgICBuLl9fc2hhZHkucGFyZW50Tm9kZSA9IG5vZGU7XG5cdCAgICAgIG4uX19zaGFkeS5uZXh0U2libGluZyA9IGMkW2kgKyAxXSB8fCBudWxsO1xuXHQgICAgICBuLl9fc2hhZHkucHJldmlvdXNTaWJsaW5nID0gYyRbaSAtIDFdIHx8IG51bGw7XG5cdCAgICAgICgwLCBfcGF0Y2hBY2Nlc3NvcnMucGF0Y2hPdXRzaWRlRWxlbWVudEFjY2Vzc29ycykobik7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG4vKioqLyB9LFxuLyogNjIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qKlxuXHRAbGljZW5zZVxuXHRDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXHRUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5cdFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5cdFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuXHRDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuXHRzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuXHQqL1xuXHRcblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdGV4cG9ydHMucGF0Y2hJbnNpZGVFbGVtZW50QWNjZXNzb3JzID0gZXhwb3J0cy5wYXRjaE91dHNpZGVFbGVtZW50QWNjZXNzb3JzID0gZXhwb3J0cy5BY3RpdmVFbGVtZW50QWNjZXNzb3IgPSBleHBvcnRzLlNoYWRvd1Jvb3RBY2Nlc3NvciA9IHVuZGVmaW5lZDtcblx0ZXhwb3J0cy5wYXRjaEFjY2Vzc29ycyA9IHBhdGNoQWNjZXNzb3JzO1xuXHRleHBvcnRzLnBhdGNoU2hhZG93Um9vdEFjY2Vzc29ycyA9IHBhdGNoU2hhZG93Um9vdEFjY2Vzc29ycztcblx0XG5cdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKTtcblx0XG5cdHZhciB1dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlscyk7XG5cdFxuXHR2YXIgX2lubmVySFRNTCA9IF9fd2VicGFja19yZXF1aXJlX18oNTcpO1xuXHRcblx0dmFyIF9sb2dpY2FsUHJvcGVydGllcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjApO1xuXHRcblx0dmFyIF9uYXRpdmVUcmVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nik7XG5cdFxuXHR2YXIgbmF0aXZlVHJlZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9uYXRpdmVUcmVlKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cdFxuXHRmdW5jdGlvbiBnZW5lcmF0ZVNpbXBsZURlc2NyaXB0b3IocHJvcCkge1xuXHQgIHJldHVybiB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgdmFyIGwgPSAoMCwgX2xvZ2ljYWxQcm9wZXJ0aWVzLmdldFByb3BlcnR5KSh0aGlzLCBwcm9wKTtcblx0ICAgICAgcmV0dXJuIGwgIT09IHVuZGVmaW5lZCA/IGwgOiBuYXRpdmVUcmVlW3Byb3BdKHRoaXMpO1xuXHQgICAgfSxcblx0XG5cdCAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICB9O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBjbGVhck5vZGUobm9kZSkge1xuXHQgIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpIHtcblx0ICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcblx0ICB9XG5cdH1cblx0XG5cdHZhciBuYXRpdmVJbm5lckhUTUxEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFbGVtZW50LnByb3RvdHlwZSwgJ2lubmVySFRNTCcpIHx8IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoSFRNTEVsZW1lbnQucHJvdG90eXBlLCAnaW5uZXJIVE1MJyk7XG5cdFxuXHR2YXIgaW5lcnREb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJ2luZXJ0Jyk7XG5cdHZhciBodG1sQ29udGFpbmVyID0gaW5lcnREb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFxuXHR2YXIgbmF0aXZlQWN0aXZlRWxlbWVudERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKERvY3VtZW50LnByb3RvdHlwZSwgJ2FjdGl2ZUVsZW1lbnQnKTtcblx0ZnVuY3Rpb24gZ2V0RG9jdW1lbnRBY3RpdmVFbGVtZW50KCkge1xuXHQgIGlmIChuYXRpdmVBY3RpdmVFbGVtZW50RGVzY3JpcHRvciAmJiBuYXRpdmVBY3RpdmVFbGVtZW50RGVzY3JpcHRvci5nZXQpIHtcblx0ICAgIHJldHVybiBuYXRpdmVBY3RpdmVFbGVtZW50RGVzY3JpcHRvci5nZXQuY2FsbChkb2N1bWVudCk7XG5cdCAgfSBlbHNlIGlmICghdXRpbHMuc2V0dGluZ3MuaGFzRGVzY3JpcHRvcnMpIHtcblx0ICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHQgIH1cblx0fVxuXHRcblx0ZnVuY3Rpb24gYWN0aXZlRWxlbWVudEZvck5vZGUobm9kZSkge1xuXHQgIHZhciBhY3RpdmUgPSBnZXREb2N1bWVudEFjdGl2ZUVsZW1lbnQoKTtcblx0ICAvLyBJbiBJRTExLCBhY3RpdmVFbGVtZW50IG1pZ2h0IGJlIGFuIGVtcHR5IG9iamVjdCBpZiB0aGUgZG9jdW1lbnQgaXNcblx0ICAvLyBjb250YWluZWQgaW4gYW4gaWZyYW1lLlxuXHQgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEwOTk4Nzg4L1xuXHQgIGlmICghYWN0aXZlIHx8ICFhY3RpdmUubm9kZVR5cGUpIHtcblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH1cblx0ICB2YXIgaXNTaGFkeVJvb3QgPSAhIXV0aWxzLmlzU2hhZHlSb290KG5vZGUpO1xuXHQgIGlmIChub2RlICE9PSBkb2N1bWVudCkge1xuXHQgICAgLy8gSWYgdGhpcyBub2RlIGlzbid0IGEgZG9jdW1lbnQgb3Igc2hhZHkgcm9vdCwgdGhlbiBpdCBkb2Vzbid0IGhhdmVcblx0ICAgIC8vIGFuIGFjdGl2ZSBlbGVtZW50LlxuXHQgICAgaWYgKCFpc1NoYWR5Um9vdCkge1xuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0ICAgIC8vIElmIHRoaXMgc2hhZHkgcm9vdCdzIGhvc3QgaXMgdGhlIGFjdGl2ZSBlbGVtZW50IG9yIHRoZSBhY3RpdmVcblx0ICAgIC8vIGVsZW1lbnQgaXMgbm90IGEgZGVzY2VuZGFudCBvZiB0aGUgaG9zdCAoaW4gdGhlIGNvbXBvc2VkIHRyZWUpLFxuXHQgICAgLy8gdGhlbiBpdCBkb2Vzbid0IGhhdmUgYW4gYWN0aXZlIGVsZW1lbnQuXG5cdCAgICBpZiAobm9kZS5ob3N0ID09PSBhY3RpdmUgfHwgIW5vZGUuaG9zdC5jb250YWlucyhhY3RpdmUpKSB7XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXHQgIH1cblx0ICAvLyBUaGlzIG5vZGUgaXMgZWl0aGVyIHRoZSBkb2N1bWVudCBvciBhIHNoYWR5IHJvb3Qgb2Ygd2hpY2ggdGhlIGFjdGl2ZVxuXHQgIC8vIGVsZW1lbnQgaXMgYSAoY29tcG9zZWQpIGRlc2NlbmRhbnQgb2YgaXRzIGhvc3Q7IGl0ZXJhdGUgdXB3YXJkcyB0b1xuXHQgIC8vIGZpbmQgdGhlIGFjdGl2ZSBlbGVtZW50J3MgbW9zdCBzaGFsbG93IGhvc3Qgd2l0aGluIGl0LlxuXHQgIHZhciBhY3RpdmVSb290ID0gdXRpbHMub3duZXJTaGFkeVJvb3RGb3JOb2RlKGFjdGl2ZSk7XG5cdCAgd2hpbGUgKGFjdGl2ZVJvb3QgJiYgYWN0aXZlUm9vdCAhPT0gbm9kZSkge1xuXHQgICAgYWN0aXZlID0gYWN0aXZlUm9vdC5ob3N0O1xuXHQgICAgYWN0aXZlUm9vdCA9IHV0aWxzLm93bmVyU2hhZHlSb290Rm9yTm9kZShhY3RpdmUpO1xuXHQgIH1cblx0ICBpZiAobm9kZSA9PT0gZG9jdW1lbnQpIHtcblx0ICAgIC8vIFRoaXMgbm9kZSBpcyB0aGUgZG9jdW1lbnQsIHNvIGFjdGl2ZVJvb3Qgc2hvdWxkIGJlIG51bGwuXG5cdCAgICByZXR1cm4gYWN0aXZlUm9vdCA/IG51bGwgOiBhY3RpdmU7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIFRoaXMgbm9kZSBpcyBhIG5vbi1kb2N1bWVudCBzaGFkeSByb290LCBhbmQgaXQgc2hvdWxkIGJlXG5cdCAgICAvLyBhY3RpdmVSb290LlxuXHQgICAgcmV0dXJuIGFjdGl2ZVJvb3QgPT09IG5vZGUgPyBhY3RpdmUgOiBudWxsO1xuXHQgIH1cblx0fVxuXHRcblx0dmFyIE91dHNpZGVBY2Nlc3NvcnMgPSB7XG5cdCAgLy8gbm9kZS4uLlxuXHQgIHBhcmVudEVsZW1lbnQ6IGdlbmVyYXRlU2ltcGxlRGVzY3JpcHRvcigncGFyZW50RWxlbWVudCcpLFxuXHRcblx0ICBwYXJlbnROb2RlOiBnZW5lcmF0ZVNpbXBsZURlc2NyaXB0b3IoJ3BhcmVudE5vZGUnKSxcblx0XG5cdCAgbmV4dFNpYmxpbmc6IGdlbmVyYXRlU2ltcGxlRGVzY3JpcHRvcignbmV4dFNpYmxpbmcnKSxcblx0XG5cdCAgcHJldmlvdXNTaWJsaW5nOiBnZW5lcmF0ZVNpbXBsZURlc2NyaXB0b3IoJ3ByZXZpb3VzU2libGluZycpLFxuXHRcblx0ICBjbGFzc05hbWU6IHtcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2NsYXNzJyk7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcblx0ICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdmFsdWUpO1xuXHQgICAgfSxcblx0XG5cdCAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICB9LFxuXHRcblx0ICAvLyBmcmFnbWVudCwgZWxlbWVudCwgZG9jdW1lbnRcblx0ICBuZXh0RWxlbWVudFNpYmxpbmc6IHtcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICBpZiAoKDAsIF9sb2dpY2FsUHJvcGVydGllcy5oYXNQcm9wZXJ0eSkodGhpcywgJ25leHRTaWJsaW5nJykpIHtcblx0ICAgICAgICB2YXIgbiA9IHRoaXMubmV4dFNpYmxpbmc7XG5cdCAgICAgICAgd2hpbGUgKG4gJiYgbi5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcblx0ICAgICAgICAgIG4gPSBuLm5leHRTaWJsaW5nO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbjtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gbmF0aXZlVHJlZS5uZXh0RWxlbWVudFNpYmxpbmcodGhpcyk7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdFxuXHQgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgfSxcblx0XG5cdCAgcHJldmlvdXNFbGVtZW50U2libGluZzoge1xuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgIGlmICgoMCwgX2xvZ2ljYWxQcm9wZXJ0aWVzLmhhc1Byb3BlcnR5KSh0aGlzLCAncHJldmlvdXNTaWJsaW5nJykpIHtcblx0ICAgICAgICB2YXIgbiA9IHRoaXMucHJldmlvdXNTaWJsaW5nO1xuXHQgICAgICAgIHdoaWxlIChuICYmIG4ubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG5cdCAgICAgICAgICBuID0gbi5wcmV2aW91c1NpYmxpbmc7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBuO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBuYXRpdmVUcmVlLnByZXZpb3VzRWxlbWVudFNpYmxpbmcodGhpcyk7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdFxuXHQgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgfVxuXHRcblx0fTtcblx0XG5cdHZhciBJbnNpZGVBY2Nlc3NvcnMgPSB7XG5cdFxuXHQgIGNoaWxkTm9kZXM6IHtcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICBpZiAoKDAsIF9sb2dpY2FsUHJvcGVydGllcy5oYXNQcm9wZXJ0eSkodGhpcywgJ2ZpcnN0Q2hpbGQnKSkge1xuXHQgICAgICAgIGlmICghdGhpcy5fX3NoYWR5LmNoaWxkTm9kZXMpIHtcblx0ICAgICAgICAgIHRoaXMuX19zaGFkeS5jaGlsZE5vZGVzID0gW107XG5cdCAgICAgICAgICBmb3IgKHZhciBuID0gdGhpcy5maXJzdENoaWxkOyBuOyBuID0gbi5uZXh0U2libGluZykge1xuXHQgICAgICAgICAgICB0aGlzLl9fc2hhZHkuY2hpbGROb2Rlcy5wdXNoKG4pO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5fX3NoYWR5LmNoaWxkTm9kZXM7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIG5hdGl2ZVRyZWUuY2hpbGROb2Rlcyh0aGlzKTtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0XG5cdCAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICB9LFxuXHRcblx0ICBmaXJzdENoaWxkOiBnZW5lcmF0ZVNpbXBsZURlc2NyaXB0b3IoJ2ZpcnN0Q2hpbGQnKSxcblx0XG5cdCAgbGFzdENoaWxkOiBnZW5lcmF0ZVNpbXBsZURlc2NyaXB0b3IoJ2xhc3RDaGlsZCcpLFxuXHRcblx0ICB0ZXh0Q29udGVudDoge1xuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgIGlmICgoMCwgX2xvZ2ljYWxQcm9wZXJ0aWVzLmhhc1Byb3BlcnR5KSh0aGlzLCAnZmlyc3RDaGlsZCcpKSB7XG5cdCAgICAgICAgdmFyIHRjID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDAsIGNuID0gdGhpcy5jaGlsZE5vZGVzLCBjOyBjID0gY25baV07IGkrKykge1xuXHQgICAgICAgICAgaWYgKGMubm9kZVR5cGUgIT09IE5vZGUuQ09NTUVOVF9OT0RFKSB7XG5cdCAgICAgICAgICAgIHRjLnB1c2goYy50ZXh0Q29udGVudCk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0Yy5qb2luKCcnKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gbmF0aXZlVHJlZS50ZXh0Q29udGVudCh0aGlzKTtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24gc2V0KHRleHQpIHtcblx0ICAgICAgaWYgKHRoaXMubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG5cdCAgICAgICAgLy8gVE9ETyhzb3J2ZWxsKTogY2FuJ3QgZG8gdGhpcyBpZiBwYXRjaCBub2RlVmFsdWUuXG5cdCAgICAgICAgdGhpcy5ub2RlVmFsdWUgPSB0ZXh0O1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGNsZWFyTm9kZSh0aGlzKTtcblx0ICAgICAgICBpZiAodGV4dCkge1xuXHQgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9LFxuXHRcblx0ICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgIH0sXG5cdFxuXHQgIC8vIGZyYWdtZW50LCBlbGVtZW50LCBkb2N1bWVudFxuXHQgIGZpcnN0RWxlbWVudENoaWxkOiB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgaWYgKCgwLCBfbG9naWNhbFByb3BlcnRpZXMuaGFzUHJvcGVydHkpKHRoaXMsICdmaXJzdENoaWxkJykpIHtcblx0ICAgICAgICB2YXIgbiA9IHRoaXMuZmlyc3RDaGlsZDtcblx0ICAgICAgICB3aGlsZSAobiAmJiBuLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuXHQgICAgICAgICAgbiA9IG4ubmV4dFNpYmxpbmc7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBuO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBuYXRpdmVUcmVlLmZpcnN0RWxlbWVudENoaWxkKHRoaXMpO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHRcblx0ICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgIH0sXG5cdFxuXHQgIGxhc3RFbGVtZW50Q2hpbGQ6IHtcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICBpZiAoKDAsIF9sb2dpY2FsUHJvcGVydGllcy5oYXNQcm9wZXJ0eSkodGhpcywgJ2xhc3RDaGlsZCcpKSB7XG5cdCAgICAgICAgdmFyIG4gPSB0aGlzLmxhc3RDaGlsZDtcblx0ICAgICAgICB3aGlsZSAobiAmJiBuLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuXHQgICAgICAgICAgbiA9IG4ucHJldmlvdXNTaWJsaW5nO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbjtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gbmF0aXZlVHJlZS5sYXN0RWxlbWVudENoaWxkKHRoaXMpO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHRcblx0ICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgIH0sXG5cdFxuXHQgIGNoaWxkcmVuOiB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgaWYgKCgwLCBfbG9naWNhbFByb3BlcnRpZXMuaGFzUHJvcGVydHkpKHRoaXMsICdmaXJzdENoaWxkJykpIHtcblx0ICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKHRoaXMuY2hpbGROb2RlcywgZnVuY3Rpb24gKG4pIHtcblx0ICAgICAgICAgIHJldHVybiBuLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gbmF0aXZlVHJlZS5jaGlsZHJlbih0aGlzKTtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0XG5cdCAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICB9LFxuXHRcblx0ICAvLyBlbGVtZW50IChIVE1MRWxlbWVudCBvbiBJRTExKVxuXHQgIGlubmVySFRNTDoge1xuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgIHZhciBjb250ZW50ID0gdGhpcy5sb2NhbE5hbWUgPT09ICd0ZW1wbGF0ZScgPyB0aGlzLmNvbnRlbnQgOiB0aGlzO1xuXHQgICAgICBpZiAoKDAsIF9sb2dpY2FsUHJvcGVydGllcy5oYXNQcm9wZXJ0eSkodGhpcywgJ2ZpcnN0Q2hpbGQnKSkge1xuXHQgICAgICAgIHJldHVybiAoMCwgX2lubmVySFRNTC5nZXRJbm5lckhUTUwpKGNvbnRlbnQpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBuYXRpdmVUcmVlLmlubmVySFRNTChjb250ZW50KTtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24gc2V0KHRleHQpIHtcblx0ICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLmxvY2FsTmFtZSA9PT0gJ3RlbXBsYXRlJyA/IHRoaXMuY29udGVudCA6IHRoaXM7XG5cdCAgICAgIGNsZWFyTm9kZShjb250ZW50KTtcblx0ICAgICAgaWYgKG5hdGl2ZUlubmVySFRNTERlc2MgJiYgbmF0aXZlSW5uZXJIVE1MRGVzYy5zZXQpIHtcblx0ICAgICAgICBuYXRpdmVJbm5lckhUTUxEZXNjLnNldC5jYWxsKGh0bWxDb250YWluZXIsIHRleHQpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGh0bWxDb250YWluZXIuaW5uZXJIVE1MID0gdGV4dDtcblx0ICAgICAgfVxuXHQgICAgICB3aGlsZSAoaHRtbENvbnRhaW5lci5maXJzdENoaWxkKSB7XG5cdCAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChodG1sQ29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHRcblx0ICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgIH1cblx0XG5cdH07XG5cdFxuXHQvLyBOb3RlOiBDYW4gYmUgcGF0Y2hlZCBvbiBlbGVtZW50IHByb3RvdHlwZSBvbiBhbGwgYnJvd3NlcnMuXG5cdC8vIE11c3QgYmUgcGF0Y2hlZCBvbiBpbnN0YW5jZSBvbiBicm93c2VycyB0aGF0IHN1cHBvcnQgbmF0aXZlIFNoYWRvdyBET01cblx0Ly8gYnV0IGRvIG5vdCBoYXZlIGJ1aWx0aW4gYWNjZXNzb3JzIChvbGQgQ2hyb21lKS5cblx0dmFyIFNoYWRvd1Jvb3RBY2Nlc3NvciA9IGV4cG9ydHMuU2hhZG93Um9vdEFjY2Vzc29yID0ge1xuXHQgIHNoYWRvd1Jvb3Q6IHtcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5zaGFkeVJvb3Q7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcblx0ICAgICAgdGhpcy5zaGFkeVJvb3QgPSB2YWx1ZTtcblx0ICAgIH0sXG5cdFxuXHQgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgfVxuXHR9O1xuXHRcblx0Ly8gTm90ZTogQ2FuIGJlIHBhdGNoZWQgb24gZG9jdW1lbnQgcHJvdG90eXBlIG9uIGJyb3dzZXJzIHdpdGggYnVpbHRpbiBhY2Nlc3NvcnMuXG5cdC8vIE11c3QgYmUgcGF0Y2hlZCBzZXBhcmF0ZWx5IG9uIHNpbXVsYXRlZCBTaGFkb3dSb290LlxuXHQvLyBNdXN0IGJlIHBhdGNoZWQgYXMgYF9hY3RpdmVFbGVtZW50YCBvbiBicm93c2VycyB3aXRob3V0IGJ1aWx0aW4gYWNjZXNzb3JzLlxuXHR2YXIgQWN0aXZlRWxlbWVudEFjY2Vzc29yID0gZXhwb3J0cy5BY3RpdmVFbGVtZW50QWNjZXNzb3IgPSB7XG5cdFxuXHQgIGFjdGl2ZUVsZW1lbnQ6IHtcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gYWN0aXZlRWxlbWVudEZvck5vZGUodGhpcyk7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbiBzZXQoKSB7fSxcblx0XG5cdCAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICB9XG5cdFxuXHR9O1xuXHRcblx0Ly8gcGF0Y2ggYSBncm91cCBvZiBkZXNjcmlwdG9ycyBvbiBhbiBvYmplY3Qgb25seSBpZiBpdCBleGlzdHMgb3IgaWYgdGhlIGBmb3JjZWBcblx0Ly8gYXJndW1lbnQgaXMgdHJ1ZS5cblx0ZnVuY3Rpb24gcGF0Y2hBY2Nlc3Nvckdyb3VwKG9iaiwgZGVzY3JpcHRvcnMsIGZvcmNlKSB7XG5cdCAgZm9yICh2YXIgcCBpbiBkZXNjcmlwdG9ycykge1xuXHQgICAgdmFyIG9iakRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcCk7XG5cdCAgICBpZiAob2JqRGVzYyAmJiBvYmpEZXNjLmNvbmZpZ3VyYWJsZSB8fCAhb2JqRGVzYyAmJiBmb3JjZSkge1xuXHQgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwLCBkZXNjcmlwdG9yc1twXSk7XG5cdCAgICB9IGVsc2UgaWYgKGZvcmNlKSB7XG5cdCAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGRlZmluZScsIHAsICdvbicsIG9iaik7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdFxuXHQvLyBwYXRjaCBkb20gYWNjZXNzb3JzIG9uIHByb3RvIHdoZXJlIHRoZXkgZXhpc3Rcblx0ZnVuY3Rpb24gcGF0Y2hBY2Nlc3NvcnMocHJvdG8pIHtcblx0ICBwYXRjaEFjY2Vzc29yR3JvdXAocHJvdG8sIE91dHNpZGVBY2Nlc3NvcnMpO1xuXHQgIHBhdGNoQWNjZXNzb3JHcm91cChwcm90bywgSW5zaWRlQWNjZXNzb3JzKTtcblx0ICBwYXRjaEFjY2Vzc29yR3JvdXAocHJvdG8sIEFjdGl2ZUVsZW1lbnRBY2Nlc3Nvcik7XG5cdH1cblx0XG5cdC8vIGVuc3VyZSBlbGVtZW50IGRlc2NyaXB0b3JzIChJRS9FZGdlIGRvbid0IGhhdmUgZW0pXG5cdGZ1bmN0aW9uIHBhdGNoU2hhZG93Um9vdEFjY2Vzc29ycyhwcm90bykge1xuXHQgIHBhdGNoQWNjZXNzb3JHcm91cChwcm90bywgSW5zaWRlQWNjZXNzb3JzLCB0cnVlKTtcblx0ICBwYXRjaEFjY2Vzc29yR3JvdXAocHJvdG8sIEFjdGl2ZUVsZW1lbnRBY2Nlc3NvciwgdHJ1ZSk7XG5cdH1cblx0XG5cdC8vIGVuc3VyZSBhbiBlbGVtZW50IGhhcyBwYXRjaGVkIFwib3V0c2lkZVwiIGFjY2Vzc29yczsgbm8tb3Agd2hlbiBub3QgbmVlZGVkXG5cdHZhciBwYXRjaE91dHNpZGVFbGVtZW50QWNjZXNzb3JzID0gZXhwb3J0cy5wYXRjaE91dHNpZGVFbGVtZW50QWNjZXNzb3JzID0gdXRpbHMuc2V0dGluZ3MuaGFzRGVzY3JpcHRvcnMgPyBmdW5jdGlvbiAoKSB7fSA6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdCAgaWYgKCEoZWxlbWVudC5fX3NoYWR5ICYmIGVsZW1lbnQuX19zaGFkeS5fX291dHNpZGVBY2Nlc3NvcnMpKSB7XG5cdCAgICBlbGVtZW50Ll9fc2hhZHkgPSBlbGVtZW50Ll9fc2hhZHkgfHwge307XG5cdCAgICBlbGVtZW50Ll9fc2hhZHkuX19vdXRzaWRlQWNjZXNzb3JzID0gdHJ1ZTtcblx0ICAgIHBhdGNoQWNjZXNzb3JHcm91cChlbGVtZW50LCBPdXRzaWRlQWNjZXNzb3JzLCB0cnVlKTtcblx0ICB9XG5cdH07XG5cdFxuXHQvLyBlbnN1cmUgYW4gZWxlbWVudCBoYXMgcGF0Y2hlZCBcImluc2lkZVwiIGFjY2Vzc29yczsgbm8tb3Agd2hlbiBub3QgbmVlZGVkXG5cdHZhciBwYXRjaEluc2lkZUVsZW1lbnRBY2Nlc3NvcnMgPSBleHBvcnRzLnBhdGNoSW5zaWRlRWxlbWVudEFjY2Vzc29ycyA9IHV0aWxzLnNldHRpbmdzLmhhc0Rlc2NyaXB0b3JzID8gZnVuY3Rpb24gKCkge30gOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuXHQgIGlmICghKGVsZW1lbnQuX19zaGFkeSAmJiBlbGVtZW50Ll9fc2hhZHkuX19pbnNpZGVBY2Nlc3NvcnMpKSB7XG5cdCAgICBlbGVtZW50Ll9fc2hhZHkgPSBlbGVtZW50Ll9fc2hhZHkgfHwge307XG5cdCAgICBlbGVtZW50Ll9fc2hhZHkuX19pbnNpZGVBY2Nlc3NvcnMgPSB0cnVlO1xuXHQgICAgcGF0Y2hBY2Nlc3Nvckdyb3VwKGVsZW1lbnQsIEluc2lkZUFjY2Vzc29ycywgdHJ1ZSk7XG5cdCAgICBwYXRjaEFjY2Vzc29yR3JvdXAoZWxlbWVudCwgU2hhZG93Um9vdEFjY2Vzc29yLCB0cnVlKTtcblx0ICB9XG5cdH07XG5cbi8qKiovIH0sXG4vKiA2MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyoqXG5cdEBsaWNlbnNlXG5cdENvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cdFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblx0VGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblx0VGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5cdENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5cdHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG5cdCovXG5cdFxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblx0XG5cdGV4cG9ydHMuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXI7XG5cdGV4cG9ydHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cdGV4cG9ydHMucGF0Y2hFdmVudHMgPSBwYXRjaEV2ZW50cztcblx0XG5cdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKTtcblx0XG5cdHZhciB1dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlscyk7XG5cdFxuXHR2YXIgX25hdGl2ZU1ldGhvZHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1KTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cdFxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vdzNjL3dlYmNvbXBvbmVudHMvaXNzdWVzLzUxMyNpc3N1ZWNvbW1lbnQtMjI0MTgzOTM3XG5cdHZhciBhbHdheXNDb21wb3NlZCA9IHtcblx0ICBibHVyOiB0cnVlLFxuXHQgIGZvY3VzOiB0cnVlLFxuXHQgIGZvY3VzaW46IHRydWUsXG5cdCAgZm9jdXNvdXQ6IHRydWUsXG5cdCAgY2xpY2s6IHRydWUsXG5cdCAgZGJsY2xpY2s6IHRydWUsXG5cdCAgbW91c2Vkb3duOiB0cnVlLFxuXHQgIG1vdXNlZW50ZXI6IHRydWUsXG5cdCAgbW91c2VsZWF2ZTogdHJ1ZSxcblx0ICBtb3VzZW1vdmU6IHRydWUsXG5cdCAgbW91c2VvdXQ6IHRydWUsXG5cdCAgbW91c2VvdmVyOiB0cnVlLFxuXHQgIG1vdXNldXA6IHRydWUsXG5cdCAgd2hlZWw6IHRydWUsXG5cdCAgYmVmb3JlaW5wdXQ6IHRydWUsXG5cdCAgaW5wdXQ6IHRydWUsXG5cdCAga2V5ZG93bjogdHJ1ZSxcblx0ICBrZXl1cDogdHJ1ZSxcblx0ICBjb21wb3NpdGlvbnN0YXJ0OiB0cnVlLFxuXHQgIGNvbXBvc2l0aW9udXBkYXRlOiB0cnVlLFxuXHQgIGNvbXBvc2l0aW9uZW5kOiB0cnVlLFxuXHQgIHRvdWNoc3RhcnQ6IHRydWUsXG5cdCAgdG91Y2hlbmQ6IHRydWUsXG5cdCAgdG91Y2htb3ZlOiB0cnVlLFxuXHQgIHRvdWNoY2FuY2VsOiB0cnVlLFxuXHQgIHBvaW50ZXJvdmVyOiB0cnVlLFxuXHQgIHBvaW50ZXJlbnRlcjogdHJ1ZSxcblx0ICBwb2ludGVyZG93bjogdHJ1ZSxcblx0ICBwb2ludGVybW92ZTogdHJ1ZSxcblx0ICBwb2ludGVydXA6IHRydWUsXG5cdCAgcG9pbnRlcmNhbmNlbDogdHJ1ZSxcblx0ICBwb2ludGVyb3V0OiB0cnVlLFxuXHQgIHBvaW50ZXJsZWF2ZTogdHJ1ZSxcblx0ICBnb3Rwb2ludGVyY2FwdHVyZTogdHJ1ZSxcblx0ICBsb3N0cG9pbnRlcmNhcHR1cmU6IHRydWUsXG5cdCAgZHJhZ3N0YXJ0OiB0cnVlLFxuXHQgIGRyYWc6IHRydWUsXG5cdCAgZHJhZ2VudGVyOiB0cnVlLFxuXHQgIGRyYWdsZWF2ZTogdHJ1ZSxcblx0ICBkcmFnb3ZlcjogdHJ1ZSxcblx0ICBkcm9wOiB0cnVlLFxuXHQgIGRyYWdlbmQ6IHRydWUsXG5cdCAgRE9NQWN0aXZhdGU6IHRydWUsXG5cdCAgRE9NRm9jdXNJbjogdHJ1ZSxcblx0ICBET01Gb2N1c091dDogdHJ1ZSxcblx0ICBrZXlwcmVzczogdHJ1ZVxuXHR9O1xuXHRcblx0ZnVuY3Rpb24gcGF0aENvbXBvc2VyKHN0YXJ0Tm9kZSwgY29tcG9zZWQpIHtcblx0ICB2YXIgY29tcG9zZWRQYXRoID0gW107XG5cdCAgdmFyIGN1cnJlbnQgPSBzdGFydE5vZGU7XG5cdCAgdmFyIHN0YXJ0Um9vdCA9IHN0YXJ0Tm9kZSA9PT0gd2luZG93ID8gd2luZG93IDogc3RhcnROb2RlLmdldFJvb3ROb2RlKCk7XG5cdCAgd2hpbGUgKGN1cnJlbnQpIHtcblx0ICAgIGNvbXBvc2VkUGF0aC5wdXNoKGN1cnJlbnQpO1xuXHQgICAgaWYgKGN1cnJlbnQuYXNzaWduZWRTbG90KSB7XG5cdCAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmFzc2lnbmVkU2xvdDtcblx0ICAgIH0gZWxzZSBpZiAoY3VycmVudC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFICYmIGN1cnJlbnQuaG9zdCAmJiAoY29tcG9zZWQgfHwgY3VycmVudCAhPT0gc3RhcnRSb290KSkge1xuXHQgICAgICBjdXJyZW50ID0gY3VycmVudC5ob3N0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcblx0ICAgIH1cblx0ICB9XG5cdCAgLy8gZXZlbnQgY29tcG9zZWRQYXRoIGluY2x1ZGVzIHdpbmRvdyB3aGVuIHN0YXJ0Tm9kZSdzIG93bmVyUm9vdCBpcyBkb2N1bWVudFxuXHQgIGlmIChjb21wb3NlZFBhdGhbY29tcG9zZWRQYXRoLmxlbmd0aCAtIDFdID09PSBkb2N1bWVudCkge1xuXHQgICAgY29tcG9zZWRQYXRoLnB1c2god2luZG93KTtcblx0ICB9XG5cdCAgcmV0dXJuIGNvbXBvc2VkUGF0aDtcblx0fVxuXHRcblx0ZnVuY3Rpb24gcmV0YXJnZXQocmVmTm9kZSwgcGF0aCkge1xuXHQgIGlmICghdXRpbHMuaXNTaGFkeVJvb3QpIHtcblx0ICAgIHJldHVybiByZWZOb2RlO1xuXHQgIH1cblx0ICAvLyBJZiBBTkNFU1RPUidzIHJvb3QgaXMgbm90IGEgc2hhZG93IHJvb3Qgb3IgQU5DRVNUT1IncyByb290IGlzIEJBU0Unc1xuXHQgIC8vIHNoYWRvdy1pbmNsdWRpbmcgaW5jbHVzaXZlIGFuY2VzdG9yLCByZXR1cm4gQU5DRVNUT1IuXG5cdCAgdmFyIHJlZk5vZGVQYXRoID0gcGF0aENvbXBvc2VyKHJlZk5vZGUsIHRydWUpO1xuXHQgIHZhciBwJCA9IHBhdGg7XG5cdCAgZm9yICh2YXIgaSA9IDAsIGFuY2VzdG9yLCBsYXN0Um9vdCwgcm9vdCwgcm9vdElkeDsgaSA8IHAkLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBhbmNlc3RvciA9IHAkW2ldO1xuXHQgICAgcm9vdCA9IGFuY2VzdG9yID09PSB3aW5kb3cgPyB3aW5kb3cgOiBhbmNlc3Rvci5nZXRSb290Tm9kZSgpO1xuXHQgICAgaWYgKHJvb3QgIT09IGxhc3RSb290KSB7XG5cdCAgICAgIHJvb3RJZHggPSByZWZOb2RlUGF0aC5pbmRleE9mKHJvb3QpO1xuXHQgICAgICBsYXN0Um9vdCA9IHJvb3Q7XG5cdCAgICB9XG5cdCAgICBpZiAoIXV0aWxzLmlzU2hhZHlSb290KHJvb3QpIHx8IHJvb3RJZHggPiAtMSkge1xuXHQgICAgICByZXR1cm4gYW5jZXN0b3I7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdFxuXHR2YXIgZXZlbnRNaXhpbiA9IHtcblx0XG5cdCAgZ2V0IGNvbXBvc2VkKCkge1xuXHQgICAgaWYgKHRoaXMuaXNUcnVzdGVkICYmIHRoaXMuX19jb21wb3NlZCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIHRoaXMuX19jb21wb3NlZCA9IGFsd2F5c0NvbXBvc2VkW3RoaXMudHlwZV07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5fX2NvbXBvc2VkIHx8IGZhbHNlO1xuXHQgIH0sXG5cdFxuXHQgIGNvbXBvc2VkUGF0aDogZnVuY3Rpb24gY29tcG9zZWRQYXRoKCkge1xuXHQgICAgaWYgKCF0aGlzLl9fY29tcG9zZWRQYXRoKSB7XG5cdCAgICAgIHRoaXMuX19jb21wb3NlZFBhdGggPSBwYXRoQ29tcG9zZXIodGhpcy5fX3RhcmdldCwgdGhpcy5jb21wb3NlZCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5fX2NvbXBvc2VkUGF0aDtcblx0ICB9LFxuXHRcblx0XG5cdCAgZ2V0IHRhcmdldCgpIHtcblx0ICAgIHJldHVybiByZXRhcmdldCh0aGlzLmN1cnJlbnRUYXJnZXQsIHRoaXMuY29tcG9zZWRQYXRoKCkpO1xuXHQgIH0sXG5cdFxuXHQgIC8vIGh0dHA6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9zaGFkb3cvI2V2ZW50LXJlbGF0ZWR0YXJnZXQtcmV0YXJnZXRpbmdcblx0ICBnZXQgcmVsYXRlZFRhcmdldCgpIHtcblx0ICAgIGlmICghdGhpcy5fX3JlbGF0ZWRUYXJnZXQpIHtcblx0ICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdCAgICBpZiAoIXRoaXMuX19yZWxhdGVkVGFyZ2V0Q29tcG9zZWRQYXRoKSB7XG5cdCAgICAgIHRoaXMuX19yZWxhdGVkVGFyZ2V0Q29tcG9zZWRQYXRoID0gcGF0aENvbXBvc2VyKHRoaXMuX19yZWxhdGVkVGFyZ2V0LCB0cnVlKTtcblx0ICAgIH1cblx0ICAgIC8vIGZpbmQgdGhlIGRlZXBlc3Qgbm9kZSBpbiByZWxhdGVkVGFyZ2V0IGNvbXBvc2VkIHBhdGggdGhhdCBpcyBpbiB0aGUgc2FtZSByb290IHdpdGggdGhlIGN1cnJlbnRUYXJnZXRcblx0ICAgIHJldHVybiByZXRhcmdldCh0aGlzLmN1cnJlbnRUYXJnZXQsIHRoaXMuX19yZWxhdGVkVGFyZ2V0Q29tcG9zZWRQYXRoKTtcblx0ICB9LFxuXHQgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKCkge1xuXHQgICAgRXZlbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbi5jYWxsKHRoaXMpO1xuXHQgICAgdGhpcy5fX3Byb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG5cdCAgfSxcblx0ICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIHtcblx0ICAgIEV2ZW50LnByb3RvdHlwZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24uY2FsbCh0aGlzKTtcblx0ICAgIHRoaXMuX19pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuXHQgICAgdGhpcy5fX3Byb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG5cdCAgfVxuXHR9O1xuXHRcblx0ZnVuY3Rpb24gbWl4aW5Db21wb3NlZEZsYWcoQmFzZSkge1xuXHQgIC8vIE5PVEU6IGF2b2lkaW5nIHVzZSBvZiBgY2xhc3NgIGhlcmUgc28gdGhhdCB0cmFuc3BpbGVkIG91dHB1dCBkb2VzIG5vdFxuXHQgIC8vIHRyeSB0byBkbyBgQmFzZS5jYWxsYCB3aXRoIGEgZG9tIGNvbnN0cnV0b3IuXG5cdCAgdmFyIGtsYXp6ID0gZnVuY3Rpb24ga2xhenoodHlwZSwgb3B0aW9ucykge1xuXHQgICAgdmFyIGV2ZW50ID0gbmV3IEJhc2UodHlwZSwgb3B0aW9ucyk7XG5cdCAgICBldmVudC5fX2NvbXBvc2VkID0gb3B0aW9ucyAmJiBCb29sZWFuKG9wdGlvbnMuY29tcG9zZWQpO1xuXHQgICAgcmV0dXJuIGV2ZW50O1xuXHQgIH07XG5cdCAgLy8gcHV0IGNvbnN0cnVjdG9yIHByb3BlcnRpZXMgb24gc3ViY2xhc3Ncblx0ICB1dGlscy5taXhpbihrbGF6eiwgQmFzZSk7XG5cdCAga2xhenoucHJvdG90eXBlID0gQmFzZS5wcm90b3R5cGU7XG5cdCAgcmV0dXJuIGtsYXp6O1xuXHR9XG5cdFxuXHR2YXIgbm9uQnViYmxpbmdFdmVudHNUb1JldGFyZ2V0ID0ge1xuXHQgIGZvY3VzOiB0cnVlLFxuXHQgIGJsdXI6IHRydWVcblx0fTtcblx0XG5cdGZ1bmN0aW9uIGZpcmVIYW5kbGVycyhldmVudCwgbm9kZSwgcGhhc2UpIHtcblx0ICB2YXIgaHMgPSBub2RlLl9faGFuZGxlcnMgJiYgbm9kZS5fX2hhbmRsZXJzW2V2ZW50LnR5cGVdICYmIG5vZGUuX19oYW5kbGVyc1tldmVudC50eXBlXVtwaGFzZV07XG5cdCAgaWYgKGhzKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMCwgZm47IGZuID0gaHNbaV07IGkrKykge1xuXHQgICAgICBmbi5jYWxsKG5vZGUsIGV2ZW50KTtcblx0ICAgICAgaWYgKGV2ZW50Ll9faW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdFxuXHRmdW5jdGlvbiByZXRhcmdldE5vbkJ1YmJsaW5nRXZlbnQoZSkge1xuXHQgIHZhciBwYXRoID0gZS5jb21wb3NlZFBhdGgoKTtcblx0ICB2YXIgbm9kZSA9IHZvaWQgMDtcblx0ICAvLyBvdmVycmlkZSBgY3VycmVudFRhcmdldGAgdG8gbGV0IHBhdGNoZWQgYHRhcmdldGAgY2FsY3VsYXRlIGNvcnJlY3RseVxuXHQgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAnY3VycmVudFRhcmdldCcsIHtcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gbm9kZTtcblx0ICAgIH0sXG5cdCAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICB9KTtcblx0ICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgbm9kZSA9IHBhdGhbaV07XG5cdCAgICAvLyBjYXB0dXJlIHBoYXNlIGZpcmVzIGFsbCBjYXB0dXJlIGhhbmRsZXJzXG5cdCAgICBmaXJlSGFuZGxlcnMoZSwgbm9kZSwgJ2NhcHR1cmUnKTtcblx0ICAgIGlmIChlLl9fcHJvcGFnYXRpb25TdG9wcGVkKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICB9XG5cdFxuXHQgIC8vIHNldCB0aGUgZXZlbnQgcGhhc2UgdG8gYEFUX1RBUkdFVGAgYXMgaW4gc3BlY1xuXHQgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAnZXZlbnRQaGFzZScsIHsgdmFsdWU6IEV2ZW50LkFUX1RBUkdFVCB9KTtcblx0XG5cdCAgLy8gdGhlIGV2ZW50IG9ubHkgbmVlZHMgdG8gYmUgZmlyZWQgd2hlbiBvd25lciByb290cyBjaGFuZ2Ugd2hlbiBpdGVyYXRpbmcgdGhlIGV2ZW50IHBhdGhcblx0ICAvLyBrZWVwIHRyYWNrIG9mIHRoZSBsYXN0IHNlZW4gb3duZXIgcm9vdFxuXHQgIHZhciBsYXN0RmlyZWRSb290ID0gdm9pZCAwO1xuXHQgIGZvciAodmFyIF9pID0gMDsgX2kgPCBwYXRoLmxlbmd0aDsgX2krKykge1xuXHQgICAgbm9kZSA9IHBhdGhbX2ldO1xuXHQgICAgaWYgKF9pID09PSAwIHx8IG5vZGUuc2hhZG93Um9vdCAmJiBub2RlLnNoYWRvd1Jvb3QgPT09IGxhc3RGaXJlZFJvb3QpIHtcblx0ICAgICAgZmlyZUhhbmRsZXJzKGUsIG5vZGUsICdidWJibGUnKTtcblx0ICAgICAgLy8gZG9uJ3QgYm90aGVyIHdpdGggd2luZG93LCBpdCBkb2Vzbid0IGhhdmUgYGdldFJvb3ROb2RlYCBhbmQgd2lsbCBiZSBsYXN0IGluIHRoZSBwYXRoIGFueXdheVxuXHQgICAgICBpZiAobm9kZSAhPT0gd2luZG93KSB7XG5cdCAgICAgICAgbGFzdEZpcmVkUm9vdCA9IG5vZGUuZ2V0Um9vdE5vZGUoKTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoZS5fX3Byb3BhZ2F0aW9uU3RvcHBlZCkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRcblx0ZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgb3B0aW9uc09yQ2FwdHVyZSkge1xuXHQgIGlmICghZm4pIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdFxuXHQgIC8vIFRoZSBjYWxsYmFjayBgZm5gIG1pZ2h0IGJlIHVzZWQgZm9yIG11bHRpcGxlIG5vZGVzL2V2ZW50cy4gU2luY2Ugd2UgZ2VuZXJhdGVcblx0ICAvLyBhIHdyYXBwZXIgZnVuY3Rpb24sIHdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBpdCB3aGVuIHdlIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG5cdCAgLy8gSXQncyBtb3JlIGVmZmljaWVudCB0byBzdG9yZSB0aGUgbm9kZS90eXBlL29wdGlvbnMgaW5mb3JtYXRpb24gYXMgQXJyYXkgaW5cblx0ICAvLyBgZm5gIGl0c2VsZiByYXRoZXIgdGhhbiB0aGUgbm9kZSAod2UgYXNzdW1lIHRoYXQgdGhlIHNhbWUgY2FsbGJhY2sgaXMgdXNlZFxuXHQgIC8vIGZvciBmZXcgbm9kZXMgYXQgbW9zdCwgd2hlcmVhcyBhIG5vZGUgd2lsbCBsaWtlbHkgaGF2ZSBtYW55IGV2ZW50IGxpc3RlbmVycykuXG5cdCAgLy8gTk9URSh2YWxkcmluKSBpbnZva2luZyBleHRlcm5hbCBmdW5jdGlvbnMgaXMgY29zdGx5LCBpbmxpbmUgaGFzIGJldHRlciBwZXJmLlxuXHQgIHZhciBjYXB0dXJlID0gdm9pZCAwLFxuXHQgICAgICBvbmNlID0gdm9pZCAwLFxuXHQgICAgICBwYXNzaXZlID0gdm9pZCAwO1xuXHQgIGlmICgodHlwZW9mIG9wdGlvbnNPckNhcHR1cmUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9wdGlvbnNPckNhcHR1cmUpKSA9PT0gJ29iamVjdCcpIHtcblx0ICAgIGNhcHR1cmUgPSBCb29sZWFuKG9wdGlvbnNPckNhcHR1cmUuY2FwdHVyZSk7XG5cdCAgICBvbmNlID0gQm9vbGVhbihvcHRpb25zT3JDYXB0dXJlLm9uY2UpO1xuXHQgICAgcGFzc2l2ZSA9IEJvb2xlYW4ob3B0aW9uc09yQ2FwdHVyZS5wYXNzaXZlKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgY2FwdHVyZSA9IEJvb2xlYW4ob3B0aW9uc09yQ2FwdHVyZSk7XG5cdCAgICBvbmNlID0gZmFsc2U7XG5cdCAgICBwYXNzaXZlID0gZmFsc2U7XG5cdCAgfVxuXHQgIGlmIChmbi5fX2V2ZW50V3JhcHBlcnMpIHtcblx0ICAgIC8vIFN0b3AgaWYgdGhlIHdyYXBwZXIgZnVuY3Rpb24gaGFzIGFscmVhZHkgYmVlbiBjcmVhdGVkLlxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbi5fX2V2ZW50V3JhcHBlcnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKGZuLl9fZXZlbnRXcmFwcGVyc1tpXS5ub2RlID09PSB0aGlzICYmIGZuLl9fZXZlbnRXcmFwcGVyc1tpXS50eXBlID09PSB0eXBlICYmIGZuLl9fZXZlbnRXcmFwcGVyc1tpXS5jYXB0dXJlID09PSBjYXB0dXJlICYmIGZuLl9fZXZlbnRXcmFwcGVyc1tpXS5vbmNlID09PSBvbmNlICYmIGZuLl9fZXZlbnRXcmFwcGVyc1tpXS5wYXNzaXZlID09PSBwYXNzaXZlKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIGZuLl9fZXZlbnRXcmFwcGVycyA9IFtdO1xuXHQgIH1cblx0XG5cdCAgdmFyIHdyYXBwZXJGbiA9IGZ1bmN0aW9uIHdyYXBwZXJGbihlKSB7XG5cdCAgICAvLyBTdXBwb3J0IGBvbmNlYCBvcHRpb24uXG5cdCAgICBpZiAob25jZSkge1xuXHQgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIG9wdGlvbnNPckNhcHR1cmUpO1xuXHQgICAgfVxuXHQgICAgaWYgKCFlLl9fdGFyZ2V0KSB7XG5cdCAgICAgIHBhdGNoRXZlbnQoZSk7XG5cdCAgICB9XG5cdCAgICAvLyBUaGVyZSBhcmUgdHdvIGNyaXRlcmEgdGhhdCBzaG91bGQgc3RvcCBldmVudHMgZnJvbSBmaXJpbmcgb24gdGhpcyBub2RlXG5cdCAgICAvLyAxLiB0aGUgZXZlbnQgaXMgbm90IGNvbXBvc2VkIGFuZCB0aGUgY3VycmVudCBub2RlIGlzIG5vdCBpbiB0aGUgc2FtZSByb290IGFzIHRoZSB0YXJnZXRcblx0ICAgIC8vIDIuIHdoZW4gYnViYmxpbmcsIGlmIGFmdGVyIHJldGFyZ2V0aW5nLCByZWxhdGVkVGFyZ2V0IGFuZCB0YXJnZXQgcG9pbnQgdG8gdGhlIHNhbWUgbm9kZVxuXHQgICAgaWYgKGUuY29tcG9zZWQgfHwgZS5jb21wb3NlZFBhdGgoKS5pbmRleE9mKHRoaXMpID4gLTEpIHtcblx0ICAgICAgaWYgKGUuZXZlbnRQaGFzZSA9PT0gRXZlbnQuQlVCQkxJTkdfUEhBU0UpIHtcblx0ICAgICAgICBpZiAoZS50YXJnZXQgPT09IGUucmVsYXRlZFRhcmdldCkge1xuXHQgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGZuKGUpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLy8gU3RvcmUgdGhlIHdyYXBwZXIgaW5mb3JtYXRpb24uXG5cdCAgZm4uX19ldmVudFdyYXBwZXJzLnB1c2goe1xuXHQgICAgbm9kZTogdGhpcyxcblx0ICAgIHR5cGU6IHR5cGUsXG5cdCAgICBjYXB0dXJlOiBjYXB0dXJlLFxuXHQgICAgb25jZTogb25jZSxcblx0ICAgIHBhc3NpdmU6IHBhc3NpdmUsXG5cdCAgICB3cmFwcGVyRm46IHdyYXBwZXJGblxuXHQgIH0pO1xuXHRcblx0ICBpZiAobm9uQnViYmxpbmdFdmVudHNUb1JldGFyZ2V0W3R5cGVdKSB7XG5cdCAgICB0aGlzLl9faGFuZGxlcnMgPSB0aGlzLl9faGFuZGxlcnMgfHwge307XG5cdCAgICB0aGlzLl9faGFuZGxlcnNbdHlwZV0gPSB0aGlzLl9faGFuZGxlcnNbdHlwZV0gfHwgeyBjYXB0dXJlOiBbXSwgYnViYmxlOiBbXSB9O1xuXHQgICAgdGhpcy5fX2hhbmRsZXJzW3R5cGVdW2NhcHR1cmUgPyAnY2FwdHVyZScgOiAnYnViYmxlJ10ucHVzaCh3cmFwcGVyRm4pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBfbmF0aXZlTWV0aG9kcy5hZGRFdmVudExpc3RlbmVyLmNhbGwodGhpcywgdHlwZSwgd3JhcHBlckZuLCBvcHRpb25zT3JDYXB0dXJlKTtcblx0ICB9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIG9wdGlvbnNPckNhcHR1cmUpIHtcblx0ICBpZiAoIWZuKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHRcblx0ICAvLyBOT1RFKHZhbGRyaW4pIGludm9raW5nIGV4dGVybmFsIGZ1bmN0aW9ucyBpcyBjb3N0bHksIGlubGluZSBoYXMgYmV0dGVyIHBlcmYuXG5cdCAgdmFyIGNhcHR1cmUgPSB2b2lkIDAsXG5cdCAgICAgIG9uY2UgPSB2b2lkIDAsXG5cdCAgICAgIHBhc3NpdmUgPSB2b2lkIDA7XG5cdCAgaWYgKCh0eXBlb2Ygb3B0aW9uc09yQ2FwdHVyZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob3B0aW9uc09yQ2FwdHVyZSkpID09PSAnb2JqZWN0Jykge1xuXHQgICAgY2FwdHVyZSA9IEJvb2xlYW4ob3B0aW9uc09yQ2FwdHVyZS5jYXB0dXJlKTtcblx0ICAgIG9uY2UgPSBCb29sZWFuKG9wdGlvbnNPckNhcHR1cmUub25jZSk7XG5cdCAgICBwYXNzaXZlID0gQm9vbGVhbihvcHRpb25zT3JDYXB0dXJlLnBhc3NpdmUpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBjYXB0dXJlID0gQm9vbGVhbihvcHRpb25zT3JDYXB0dXJlKTtcblx0ICAgIG9uY2UgPSBmYWxzZTtcblx0ICAgIHBhc3NpdmUgPSBmYWxzZTtcblx0ICB9XG5cdCAgLy8gU2VhcmNoIHRoZSB3cmFwcGVkIGZ1bmN0aW9uLlxuXHQgIHZhciB3cmFwcGVyRm4gPSB1bmRlZmluZWQ7XG5cdCAgaWYgKGZuLl9fZXZlbnRXcmFwcGVycykge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbi5fX2V2ZW50V3JhcHBlcnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKGZuLl9fZXZlbnRXcmFwcGVyc1tpXS5ub2RlID09PSB0aGlzICYmIGZuLl9fZXZlbnRXcmFwcGVyc1tpXS50eXBlID09PSB0eXBlICYmIGZuLl9fZXZlbnRXcmFwcGVyc1tpXS5jYXB0dXJlID09PSBjYXB0dXJlICYmIGZuLl9fZXZlbnRXcmFwcGVyc1tpXS5vbmNlID09PSBvbmNlICYmIGZuLl9fZXZlbnRXcmFwcGVyc1tpXS5wYXNzaXZlID09PSBwYXNzaXZlKSB7XG5cdCAgICAgICAgd3JhcHBlckZuID0gZm4uX19ldmVudFdyYXBwZXJzLnNwbGljZShpLCAxKVswXS53cmFwcGVyRm47XG5cdCAgICAgICAgLy8gQ2xlYW51cC5cblx0ICAgICAgICBpZiAoIWZuLl9fZXZlbnRXcmFwcGVycy5sZW5ndGgpIHtcblx0ICAgICAgICAgIGZuLl9fZXZlbnRXcmFwcGVycyA9IHVuZGVmaW5lZDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdFxuXHQgIF9uYXRpdmVNZXRob2RzLnJlbW92ZUV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCB0eXBlLCB3cmFwcGVyRm4gfHwgZm4sIG9wdGlvbnNPckNhcHR1cmUpO1xuXHQgIGlmICh3cmFwcGVyRm4gJiYgbm9uQnViYmxpbmdFdmVudHNUb1JldGFyZ2V0W3R5cGVdICYmIHRoaXMuX19oYW5kbGVycyAmJiB0aGlzLl9faGFuZGxlcnNbdHlwZV0pIHtcblx0ICAgIHZhciBhcnIgPSB0aGlzLl9faGFuZGxlcnNbdHlwZV1bY2FwdHVyZSA/ICdjYXB0dXJlJyA6ICdidWJibGUnXTtcblx0ICAgIHZhciBpZHggPSBhcnIuaW5kZXhPZih3cmFwcGVyRm4pO1xuXHQgICAgaWYgKGlkeCA+IC0xKSB7XG5cdCAgICAgIGFyci5zcGxpY2UoaWR4LCAxKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGFjdGl2YXRlRm9jdXNFdmVudE92ZXJyaWRlcygpIHtcblx0ICBmb3IgKHZhciBldiBpbiBub25CdWJibGluZ0V2ZW50c1RvUmV0YXJnZXQpIHtcblx0ICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2LCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICBpZiAoIWUuX190YXJnZXQpIHtcblx0ICAgICAgICBwYXRjaEV2ZW50KGUpO1xuXHQgICAgICAgIHJldGFyZ2V0Tm9uQnViYmxpbmdFdmVudChlKTtcblx0ICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHQgICAgICB9XG5cdCAgICB9LCB0cnVlKTtcblx0ICB9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHBhdGNoRXZlbnQoZXZlbnQpIHtcblx0ICBldmVudC5fX3RhcmdldCA9IGV2ZW50LnRhcmdldDtcblx0ICBldmVudC5fX3JlbGF0ZWRUYXJnZXQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuXHQgIC8vIHBhdGNoIGV2ZW50IHByb3RvdHlwZSBpZiB3ZSBjYW5cblx0ICBpZiAodXRpbHMuc2V0dGluZ3MuaGFzRGVzY3JpcHRvcnMpIHtcblx0ICAgIHV0aWxzLnBhdGNoUHJvdG90eXBlKGV2ZW50LCBldmVudE1peGluKTtcblx0ICAgIC8vIGFuZCBmYWxsYmFjayB0byBwYXRjaGluZyBpbnN0YW5jZVxuXHQgIH0gZWxzZSB7XG5cdCAgICB1dGlscy5leHRlbmQoZXZlbnQsIGV2ZW50TWl4aW4pO1xuXHQgIH1cblx0fVxuXHRcblx0dmFyIFBhdGNoZWRFdmVudCA9IG1peGluQ29tcG9zZWRGbGFnKHdpbmRvdy5FdmVudCk7XG5cdHZhciBQYXRjaGVkQ3VzdG9tRXZlbnQgPSBtaXhpbkNvbXBvc2VkRmxhZyh3aW5kb3cuQ3VzdG9tRXZlbnQpO1xuXHR2YXIgUGF0Y2hlZE1vdXNlRXZlbnQgPSBtaXhpbkNvbXBvc2VkRmxhZyh3aW5kb3cuTW91c2VFdmVudCk7XG5cdFxuXHRmdW5jdGlvbiBwYXRjaEV2ZW50cygpIHtcblx0ICB3aW5kb3cuRXZlbnQgPSBQYXRjaGVkRXZlbnQ7XG5cdCAgd2luZG93LkN1c3RvbUV2ZW50ID0gUGF0Y2hlZEN1c3RvbUV2ZW50O1xuXHQgIHdpbmRvdy5Nb3VzZUV2ZW50ID0gUGF0Y2hlZE1vdXNlRXZlbnQ7XG5cdCAgYWN0aXZhdGVGb2N1c0V2ZW50T3ZlcnJpZGVzKCk7XG5cdH1cblxuLyoqKi8gfSxcbi8qIDY0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKipcblx0QGxpY2Vuc2Vcblx0Q29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0VGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuXHRUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuXHRUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcblx0Q29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cblx0c3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcblx0Ki9cblx0XG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRleHBvcnRzLlNoYWR5Um9vdCA9IHVuZGVmaW5lZDtcblx0ZXhwb3J0cy5hdHRhY2hTaGFkb3cgPSBhdHRhY2hTaGFkb3c7XG5cdFxuXHR2YXIgX2FycmF5U3BsaWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NSk7XG5cdFxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Mik7XG5cdFxuXHR2YXIgdXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHMpO1xuXHRcblx0dmFyIF9mbHVzaCA9IF9fd2VicGFja19yZXF1aXJlX18oNTMpO1xuXHRcblx0dmFyIF9sb2dpY2FsVHJlZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xuXHRcblx0dmFyIF9uYXRpdmVNZXRob2RzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NSk7XG5cdFxuXHR2YXIgX25hdGl2ZVRyZWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcblx0XG5cdHZhciBfcGF0Y2hBY2Nlc3NvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyKTtcblx0XG5cdHZhciBfZGlzdHJpYnV0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2KTtcblx0XG5cdHZhciBfZGlzdHJpYnV0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzdHJpYnV0b3IpO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cdFxuXHQvLyBEbyBub3QgZXhwb3J0IHRoaXMgb2JqZWN0LiBJdCBtdXN0IGJlIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlXG5cdC8vIFNoYWR5Um9vdCBjb25zdHJ1Y3RvciBpbiBgYXR0YWNoU2hhZG93YCB0byBwcmV2ZW50IHRoZSBjb25zdHJ1Y3RvciBmcm9tXG5cdC8vIHRocm93aW5nLiBUaGlzIHByZXZlbnRzIHRoZSB1c2VyIGZyb20gYmVpbmcgYWJsZSB0byBtYW51YWxseSBjb25zdHJ1Y3QgYVxuXHQvLyBTaGFkeVJvb3QgKGkuZS4gYG5ldyBTaGFkb3dSb290KClgKS5cblx0dmFyIFNoYWR5Um9vdENvbnN0cnVjdGlvblRva2VuID0ge307XG5cdFxuXHR2YXIgU2hhZHlSb290ID0gZXhwb3J0cy5TaGFkeVJvb3QgPSBmdW5jdGlvbiBTaGFkeVJvb3QodG9rZW4sIGhvc3QpIHtcblx0ICBpZiAodG9rZW4gIT09IFNoYWR5Um9vdENvbnN0cnVjdGlvblRva2VuKSB7XG5cdCAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG5cdCAgfVxuXHQgIC8vIE5PVEU6IHRoaXMgc3RyYW5nZSBjb25zdHJ1Y3Rpb24gaXMgbmVjZXNzYXJ5IGJlY2F1c2Vcblx0ICAvLyBEb2N1bWVudEZyYWdtZW50IGNhbm5vdCBiZSBzdWJjbGFzc2VkIG9uIG9sZGVyIGJyb3dzZXJzLlxuXHQgIHZhciBzaGFkb3dSb290ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHQgIHNoYWRvd1Jvb3QuX19wcm90b19fID0gU2hhZHlSb290LnByb3RvdHlwZTtcblx0ICBzaGFkb3dSb290Ll9pbml0KGhvc3QpO1xuXHQgIHJldHVybiBzaGFkb3dSb290O1xuXHR9O1xuXHRcblx0U2hhZHlSb290LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUpO1xuXHR1dGlscy5leHRlbmRBbGwoU2hhZHlSb290LnByb3RvdHlwZSwge1xuXHQgIF9pbml0OiBmdW5jdGlvbiBfaW5pdChob3N0KSB7XG5cdCAgICAvLyBOT1RFOiBzZXQgYSBmYWtlIGxvY2FsIG5hbWUgc28gdGhpcyBlbGVtZW50IGNhbiBiZVxuXHQgICAgLy8gZGlzdGluZ3Vpc2hlZCBmcm9tIGEgRG9jdW1lbnRGcmFnbWVudCB3aGVuIHBhdGNoaW5nLlxuXHQgICAgLy8gRkYgZG9lc24ndCBhbGxvdyB0aGlzIHRvIGJlIGBsb2NhbE5hbWVgXG5cdCAgICB0aGlzLl9fbG9jYWxOYW1lID0gJ1NoYWR5Um9vdCc7XG5cdCAgICAvLyBsb2dpY2FsIGRvbSBzZXR1cFxuXHQgICAgKDAsIF9sb2dpY2FsVHJlZS5yZWNvcmRDaGlsZE5vZGVzKShob3N0KTtcblx0ICAgICgwLCBfbG9naWNhbFRyZWUucmVjb3JkQ2hpbGROb2RlcykodGhpcyk7XG5cdCAgICAvLyByb290IDw9PiBob3N0XG5cdCAgICBob3N0LnNoYWRvd1Jvb3QgPSB0aGlzO1xuXHQgICAgdGhpcy5ob3N0ID0gaG9zdDtcblx0ICAgIC8vIHN0YXRlIGZsYWdzXG5cdCAgICB0aGlzLl9yZW5kZXJQZW5kaW5nID0gZmFsc2U7XG5cdCAgICB0aGlzLl9oYXNSZW5kZXJlZCA9IGZhbHNlO1xuXHQgICAgdGhpcy5fY2hhbmdlUGVuZGluZyA9IGZhbHNlO1xuXHQgICAgdGhpcy5fZGlzdHJpYnV0b3IgPSBuZXcgX2Rpc3RyaWJ1dG9yMi5kZWZhdWx0KHRoaXMpO1xuXHQgICAgdGhpcy51cGRhdGUoKTtcblx0ICB9LFxuXHRcblx0XG5cdCAgLy8gYXN5bmMgcmVuZGVyXG5cdCAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoKSB7XG5cdCAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcblx0ICAgIGlmICghdGhpcy5fcmVuZGVyUGVuZGluZykge1xuXHQgICAgICB0aGlzLl9yZW5kZXJQZW5kaW5nID0gdHJ1ZTtcblx0ICAgICAgKDAsIF9mbHVzaC5lbnF1ZXVlKShmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzLnJlbmRlcigpO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9LFxuXHRcblx0XG5cdCAgLy8gcmV0dXJucyB0aGUgb2xkZXN0IHJlbmRlclBlbmRpbmcgYW5jZXN0b3Igcm9vdC5cblx0ICBfZ2V0UmVuZGVyUm9vdDogZnVuY3Rpb24gX2dldFJlbmRlclJvb3QoKSB7XG5cdCAgICB2YXIgcmVuZGVyUm9vdCA9IHRoaXM7XG5cdCAgICB2YXIgcm9vdCA9IHRoaXM7XG5cdCAgICB3aGlsZSAocm9vdCkge1xuXHQgICAgICBpZiAocm9vdC5fcmVuZGVyUGVuZGluZykge1xuXHQgICAgICAgIHJlbmRlclJvb3QgPSByb290O1xuXHQgICAgICB9XG5cdCAgICAgIHJvb3QgPSByb290Ll9yZW5kZXJlckZvckhvc3QoKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZW5kZXJSb290O1xuXHQgIH0sXG5cdFxuXHRcblx0ICAvLyBSZXR1cm5zIHRoZSBzaGFkeVJvb3QgYHRoaXMuaG9zdGAgaWYgYHRoaXMuaG9zdGBcblx0ICAvLyBoYXMgY2hpbGRyZW4gdGhhdCByZXF1aXJlIGRpc3RyaWJ1dGlvbi5cblx0ICBfcmVuZGVyZXJGb3JIb3N0OiBmdW5jdGlvbiBfcmVuZGVyZXJGb3JIb3N0KCkge1xuXHQgICAgdmFyIHJvb3QgPSB0aGlzLmhvc3QuZ2V0Um9vdE5vZGUoKTtcblx0ICAgIGlmICh1dGlscy5pc1NoYWR5Um9vdChyb290KSkge1xuXHQgICAgICB2YXIgYyQgPSB0aGlzLmhvc3QuY2hpbGROb2Rlcztcblx0ICAgICAgZm9yICh2YXIgaSA9IDAsIGM7IGkgPCBjJC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGMgPSBjJFtpXTtcblx0ICAgICAgICBpZiAodGhpcy5fZGlzdHJpYnV0b3IuaXNJbnNlcnRpb25Qb2ludChjKSkge1xuXHQgICAgICAgICAgcmV0dXJuIHJvb3Q7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSxcblx0ICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcblx0ICAgIGlmICh0aGlzLl9yZW5kZXJQZW5kaW5nKSB7XG5cdCAgICAgIHRoaXMuX2dldFJlbmRlclJvb3QoKS5fcmVuZGVyKCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfcmVuZGVyOiBmdW5jdGlvbiBfcmVuZGVyKCkge1xuXHQgICAgdGhpcy5fcmVuZGVyUGVuZGluZyA9IGZhbHNlO1xuXHQgICAgdGhpcy5fY2hhbmdlUGVuZGluZyA9IGZhbHNlO1xuXHQgICAgaWYgKCF0aGlzLl9za2lwVXBkYXRlSW5zZXJ0aW9uUG9pbnRzKSB7XG5cdCAgICAgIHRoaXMudXBkYXRlSW5zZXJ0aW9uUG9pbnRzKCk7XG5cdCAgICB9IGVsc2UgaWYgKCF0aGlzLl9oYXNSZW5kZXJlZCkge1xuXHQgICAgICB0aGlzLl9pbnNlcnRpb25Qb2ludHMgPSBbXTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX3NraXBVcGRhdGVJbnNlcnRpb25Qb2ludHMgPSBmYWxzZTtcblx0ICAgIC8vIFRPRE8oc29ydmVsbCk6IGNhbiBhZGQgYSBmaXJzdCByZW5kZXIgb3B0aW1pemF0aW9uIGhlcmVcblx0ICAgIC8vIHRvIHVzZSBpZiB0aGVyZSBhcmUgbm8gaW5zZXJ0aW9uIHBvaW50c1xuXHQgICAgLy8gMS4gY2xlYXIgaG9zdCBub2RlIG9mIGNvbXBvc2VkIGNoaWxkcmVuXG5cdCAgICAvLyAyLiBhcHBlbmRDaGlsZCB0aGUgc2hhZG93Um9vdCBpdHNlbGYgb3IgKG1vcmUgcm9idXN0KSBpdHMgbG9naWNhbCBjaGlsZHJlblxuXHQgICAgLy8gTk9URTogdGhpcyBkaWRuJ3Qgc2VlbSB3b3J0aCBpdCBpbiBwZXJmIHRlc3Rpbmdcblx0ICAgIC8vIGJ1dCBub3QgcmVhZHkgdG8gZGVsZXRlIHRoaXMgaW5mby5cblx0ICAgIC8vIGxvZ2ljYWxcblx0ICAgIHRoaXMuZGlzdHJpYnV0ZSgpO1xuXHQgICAgLy8gcGh5c2ljYWxcblx0ICAgIHRoaXMuY29tcG9zZSgpO1xuXHQgICAgdGhpcy5faGFzUmVuZGVyZWQgPSB0cnVlO1xuXHQgIH0sXG5cdCAgZm9yY2VSZW5kZXI6IGZ1bmN0aW9uIGZvcmNlUmVuZGVyKCkge1xuXHQgICAgdGhpcy5fcmVuZGVyUGVuZGluZyA9IHRydWU7XG5cdCAgICB0aGlzLnJlbmRlcigpO1xuXHQgIH0sXG5cdCAgZGlzdHJpYnV0ZTogZnVuY3Rpb24gZGlzdHJpYnV0ZSgpIHtcblx0ICAgIHZhciBkaXJ0eVJvb3RzID0gdGhpcy5fZGlzdHJpYnV0b3IuZGlzdHJpYnV0ZSgpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJ0eVJvb3RzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGRpcnR5Um9vdHNbaV0uX3JlbmRlcigpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgdXBkYXRlSW5zZXJ0aW9uUG9pbnRzOiBmdW5jdGlvbiB1cGRhdGVJbnNlcnRpb25Qb2ludHMoKSB7XG5cdCAgICB2YXIgaSQgPSB0aGlzLl9faW5zZXJ0aW9uUG9pbnRzO1xuXHQgICAgLy8gaWYgYW55IGluc2VydGlvbiBwb2ludHMgaGF2ZSBiZWVuIHJlbW92ZWQsIGNsZWFyIHRoZWlyIGRpc3RyaWJ1dGlvbiBpbmZvXG5cdCAgICBpZiAoaSQpIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IDAsIGM7IGkgPCBpJC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGMgPSBpJFtpXTtcblx0ICAgICAgICBpZiAoYy5nZXRSb290Tm9kZSgpICE9PSB0aGlzKSB7XG5cdCAgICAgICAgICB0aGlzLl9kaXN0cmlidXRvci5jbGVhckFzc2lnbmVkU2xvdHMoYyk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBpJCA9IHRoaXMuX2luc2VydGlvblBvaW50cyA9IHRoaXMuX2Rpc3RyaWJ1dG9yLmdldEluc2VydGlvblBvaW50cygpO1xuXHQgICAgLy8gZW5zdXJlIGluc2VydGlvblBvaW50cydzIGFuZCB0aGVpciBwYXJlbnRzIGhhdmUgbG9naWNhbCBkb20gaW5mby5cblx0ICAgIC8vIHNhdmUgbG9naWNhbCB0cmVlIGluZm9cblx0ICAgIC8vIGEuIGZvciBzaGFkeVJvb3Rcblx0ICAgIC8vIGIuIGZvciBpbnNlcnRpb24gcG9pbnRzIChmYWxsYmFjaylcblx0ICAgIC8vIGMuIGZvciBwYXJlbnRzIG9mIGluc2VydGlvbiBwb2ludHNcblx0ICAgIGZvciAodmFyIF9pID0gMCwgX2M7IF9pIDwgaSQubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgIF9jID0gaSRbX2ldO1xuXHQgICAgICBfYy5fX3NoYWR5ID0gX2MuX19zaGFkeSB8fCB7fTtcblx0ICAgICAgKDAsIF9sb2dpY2FsVHJlZS5yZWNvcmRDaGlsZE5vZGVzKShfYyk7XG5cdCAgICAgICgwLCBfbG9naWNhbFRyZWUucmVjb3JkQ2hpbGROb2RlcykoX2MucGFyZW50Tm9kZSk7XG5cdCAgICB9XG5cdCAgfSxcblx0XG5cdFxuXHQgIGdldCBfaW5zZXJ0aW9uUG9pbnRzKCkge1xuXHQgICAgaWYgKCF0aGlzLl9faW5zZXJ0aW9uUG9pbnRzKSB7XG5cdCAgICAgIHRoaXMudXBkYXRlSW5zZXJ0aW9uUG9pbnRzKCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5fX2luc2VydGlvblBvaW50cyB8fCAodGhpcy5fX2luc2VydGlvblBvaW50cyA9IFtdKTtcblx0ICB9LFxuXHRcblx0ICBzZXQgX2luc2VydGlvblBvaW50cyhpbnNlcnRpb25Qb2ludHMpIHtcblx0ICAgIHRoaXMuX19pbnNlcnRpb25Qb2ludHMgPSBpbnNlcnRpb25Qb2ludHM7XG5cdCAgfSxcblx0XG5cdCAgaGFzSW5zZXJ0aW9uUG9pbnQ6IGZ1bmN0aW9uIGhhc0luc2VydGlvblBvaW50KCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2Rpc3RyaWJ1dG9yLmhhc0luc2VydGlvblBvaW50KCk7XG5cdCAgfSxcblx0ICBjb21wb3NlOiBmdW5jdGlvbiBjb21wb3NlKCkge1xuXHQgICAgLy8gY29tcG9zZSBzZWxmXG5cdCAgICAvLyBub3RlOiBpdCdzIGltcG9ydGFudCB0byBtYXJrIHRoaXMgY2xlYW4gYmVmb3JlIGRpc3RyaWJ1dGlvblxuXHQgICAgLy8gc28gdGhhdCBhdHRhY2htZW50IHRoYXQgcHJvdm9rZXMgYWRkaXRpb25hbCBkaXN0cmlidXRpb24gKGUuZy5cblx0ICAgIC8vIGFkZGluZyBzb21ldGhpbmcgdG8geW91ciBwYXJlbnROb2RlKSB3b3Jrc1xuXHQgICAgdGhpcy5fY29tcG9zZVRyZWUoKTtcblx0ICAgIC8vIFRPRE8oc29ydmVsbCk6IFNlZSBmYXN0IHBhdGhzIGhlcmUgaW4gUG9seW1lciB2MVxuXHQgICAgLy8gKHRoZXNlIHNlZW0gdW5uZWNlc3NhcnkpXG5cdCAgfSxcblx0XG5cdFxuXHQgIC8vIFJlaWZ5IGRvbSBzdWNoIHRoYXQgaXQgaXMgYXQgaXRzIGNvcnJlY3QgcmVuZGVyaW5nIHBvc2l0aW9uXG5cdCAgLy8gYmFzZWQgb24gbG9naWNhbCBkaXN0cmlidXRpb24uXG5cdCAgX2NvbXBvc2VUcmVlOiBmdW5jdGlvbiBfY29tcG9zZVRyZWUoKSB7XG5cdCAgICB0aGlzLl91cGRhdGVDaGlsZE5vZGVzKHRoaXMuaG9zdCwgdGhpcy5fY29tcG9zZU5vZGUodGhpcy5ob3N0KSk7XG5cdCAgICB2YXIgcCQgPSB0aGlzLl9pbnNlcnRpb25Qb2ludHMgfHwgW107XG5cdCAgICBmb3IgKHZhciBpID0gMCwgbCA9IHAkLmxlbmd0aCwgcCwgcGFyZW50OyBpIDwgbCAmJiAocCA9IHAkW2ldKTsgaSsrKSB7XG5cdCAgICAgIHBhcmVudCA9IHAucGFyZW50Tm9kZTtcblx0ICAgICAgaWYgKHBhcmVudCAhPT0gdGhpcy5ob3N0ICYmIHBhcmVudCAhPT0gdGhpcykge1xuXHQgICAgICAgIHRoaXMuX3VwZGF0ZUNoaWxkTm9kZXMocGFyZW50LCB0aGlzLl9jb21wb3NlTm9kZShwYXJlbnQpKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdFxuXHRcblx0ICAvLyBSZXR1cm5zIHRoZSBsaXN0IG9mIG5vZGVzIHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZCBpbnNpZGUgYG5vZGVgLlxuXHQgIF9jb21wb3NlTm9kZTogZnVuY3Rpb24gX2NvbXBvc2VOb2RlKG5vZGUpIHtcblx0ICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuXHQgICAgdmFyIGMkID0gKG5vZGUuc2hhZHlSb290IHx8IG5vZGUpLmNoaWxkTm9kZXM7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGMkLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBjaGlsZCA9IGMkW2ldO1xuXHQgICAgICBpZiAodGhpcy5fZGlzdHJpYnV0b3IuaXNJbnNlcnRpb25Qb2ludChjaGlsZCkpIHtcblx0ICAgICAgICB2YXIgZGlzdHJpYnV0ZWROb2RlcyA9IGNoaWxkLl9fc2hhZHkuZGlzdHJpYnV0ZWROb2RlcyB8fCAoY2hpbGQuX19zaGFkeS5kaXN0cmlidXRlZE5vZGVzID0gW10pO1xuXHQgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgdmFyIGRpc3RyaWJ1dGVkTm9kZSA9IGRpc3RyaWJ1dGVkTm9kZXNbal07XG5cdCAgICAgICAgICBpZiAodGhpcy5pc0ZpbmFsRGVzdGluYXRpb24oY2hpbGQsIGRpc3RyaWJ1dGVkTm9kZSkpIHtcblx0ICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChkaXN0cmlidXRlZE5vZGUpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNoaWxkcmVuO1xuXHQgIH0sXG5cdCAgaXNGaW5hbERlc3RpbmF0aW9uOiBmdW5jdGlvbiBpc0ZpbmFsRGVzdGluYXRpb24oaW5zZXJ0aW9uUG9pbnQsIG5vZGUpIHtcblx0ICAgIHJldHVybiB0aGlzLl9kaXN0cmlidXRvci5pc0ZpbmFsRGVzdGluYXRpb24oaW5zZXJ0aW9uUG9pbnQsIG5vZGUpO1xuXHQgIH0sXG5cdFxuXHRcblx0ICAvLyBFbnN1cmVzIHRoYXQgdGhlIHJlbmRlcmVkIG5vZGUgbGlzdCBpbnNpZGUgYGNvbnRhaW5lcmAgaXMgYGNoaWxkcmVuYC5cblx0ICBfdXBkYXRlQ2hpbGROb2RlczogZnVuY3Rpb24gX3VwZGF0ZUNoaWxkTm9kZXMoY29udGFpbmVyLCBjaGlsZHJlbikge1xuXHQgICAgdmFyIGNvbXBvc2VkID0gKDAsIF9uYXRpdmVUcmVlLmNoaWxkTm9kZXMpKGNvbnRhaW5lcik7XG5cdCAgICB2YXIgc3BsaWNlcyA9ICgwLCBfYXJyYXlTcGxpY2UuY2FsY3VsYXRlU3BsaWNlcykoY2hpbGRyZW4sIGNvbXBvc2VkKTtcblx0ICAgIC8vIHByb2Nlc3MgcmVtb3ZhbHNcblx0ICAgIGZvciAodmFyIGkgPSAwLCBkID0gMCwgczsgaSA8IHNwbGljZXMubGVuZ3RoICYmIChzID0gc3BsaWNlc1tpXSk7IGkrKykge1xuXHQgICAgICBmb3IgKHZhciBqID0gMCwgbjsgaiA8IHMucmVtb3ZlZC5sZW5ndGggJiYgKG4gPSBzLnJlbW92ZWRbal0pOyBqKyspIHtcblx0ICAgICAgICAvLyBjaGVjayBpZiB0aGUgbm9kZSBpcyBzdGlsbCB3aGVyZSB3ZSBleHBlY3QgaXQgaXMgYmVmb3JlIHRyeWluZ1xuXHQgICAgICAgIC8vIHRvIHJlbW92ZSBpdDsgdGhpcyBjYW4gaGFwcGVuIGlmIHdlIG1vdmUgYSBub2RlIGFuZFxuXHQgICAgICAgIC8vIHRoZW4gc2NoZWR1bGUgaXRzIHByZXZpb3VzIGhvc3QgZm9yIGRpc3RyaWJ1dGlvbiByZXN1bHRpbmcgaW5cblx0ICAgICAgICAvLyB0aGUgbm9kZSBiZWluZyByZW1vdmVkIGhlcmUuXG5cdCAgICAgICAgaWYgKCgwLCBfbmF0aXZlVHJlZS5wYXJlbnROb2RlKShuKSA9PT0gY29udGFpbmVyKSB7XG5cdCAgICAgICAgICBfbmF0aXZlTWV0aG9kcy5yZW1vdmVDaGlsZC5jYWxsKGNvbnRhaW5lciwgbik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNvbXBvc2VkLnNwbGljZShzLmluZGV4ICsgZCwgMSk7XG5cdCAgICAgIH1cblx0ICAgICAgZCAtPSBzLmFkZGVkQ291bnQ7XG5cdCAgICB9XG5cdCAgICAvLyBwcm9jZXNzIGFkZHNcblx0ICAgIGZvciAodmFyIF9pMiA9IDAsIF9zLCBuZXh0OyBfaTIgPCBzcGxpY2VzLmxlbmd0aCAmJiAoX3MgPSBzcGxpY2VzW19pMl0pOyBfaTIrKykge1xuXHQgICAgICAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVkZWNsYXJlXG5cdCAgICAgIG5leHQgPSBjb21wb3NlZFtfcy5pbmRleF07XG5cdCAgICAgIGZvciAodmFyIF9qID0gX3MuaW5kZXgsIF9uOyBfaiA8IF9zLmluZGV4ICsgX3MuYWRkZWRDb3VudDsgX2orKykge1xuXHQgICAgICAgIF9uID0gY2hpbGRyZW5bX2pdO1xuXHQgICAgICAgIF9uYXRpdmVNZXRob2RzLmluc2VydEJlZm9yZS5jYWxsKGNvbnRhaW5lciwgX24sIG5leHQpO1xuXHQgICAgICAgIC8vIFRPRE8oc29ydmVsbCk6IGlzIHRoaXMgc3BsaWNlIHN0cmljdGx5IG5lZWRlZD9cblx0ICAgICAgICBjb21wb3NlZC5zcGxpY2UoX2osIDAsIF9uKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgZ2V0SW5zZXJ0aW9uUG9pbnRUYWc6IGZ1bmN0aW9uIGdldEluc2VydGlvblBvaW50VGFnKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2Rpc3RyaWJ1dG9yLmluc2VydGlvblBvaW50VGFnO1xuXHQgIH1cblx0fSk7XG5cdFxuXHQvKipcblx0ICBJbXBsZW1lbnRzIGEgcGFyZWQgZG93biB2ZXJzaW9uIG9mIFNoYWRvd0RPTSdzIHNjb3BpbmcsIHdoaWNoIGlzIGVhc3kgdG9cblx0ICBwb2x5ZmlsbCBhY3Jvc3MgYnJvd3NlcnMuXG5cdCovXG5cdGZ1bmN0aW9uIGF0dGFjaFNoYWRvdyhob3N0LCBvcHRpb25zKSB7XG5cdCAgaWYgKCFob3N0KSB7XG5cdCAgICB0aHJvdyAnTXVzdCBwcm92aWRlIGEgaG9zdC4nO1xuXHQgIH1cblx0ICBpZiAoIW9wdGlvbnMpIHtcblx0ICAgIHRocm93ICdOb3QgZW5vdWdoIGFyZ3VtZW50cy4nO1xuXHQgIH1cblx0ICByZXR1cm4gbmV3IFNoYWR5Um9vdChTaGFkeVJvb3RDb25zdHJ1Y3Rpb25Ub2tlbiwgaG9zdCk7XG5cdH1cblx0XG5cdCgwLCBfcGF0Y2hBY2Nlc3NvcnMucGF0Y2hTaGFkb3dSb290QWNjZXNzb3JzKShTaGFkeVJvb3QucHJvdG90eXBlKTtcblxuLyoqKi8gfSxcbi8qIDY1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKipcblx0QGxpY2Vuc2Vcblx0Q29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0VGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuXHRUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuXHRUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcblx0Q29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cblx0c3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcblx0Ki9cblx0XG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRmdW5jdGlvbiBuZXdTcGxpY2UoaW5kZXgsIHJlbW92ZWQsIGFkZGVkQ291bnQpIHtcblx0ICByZXR1cm4ge1xuXHQgICAgaW5kZXg6IGluZGV4LFxuXHQgICAgcmVtb3ZlZDogcmVtb3ZlZCxcblx0ICAgIGFkZGVkQ291bnQ6IGFkZGVkQ291bnRcblx0ICB9O1xuXHR9XG5cdFxuXHR2YXIgRURJVF9MRUFWRSA9IDA7XG5cdHZhciBFRElUX1VQREFURSA9IDE7XG5cdHZhciBFRElUX0FERCA9IDI7XG5cdHZhciBFRElUX0RFTEVURSA9IDM7XG5cdFxuXHR2YXIgQXJyYXlTcGxpY2UgPSB7XG5cdFxuXHQgIC8vIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgKmJhc2VkKiBvbiB0aGUgY29tcHV0YXRpb24gb2YgdGhlIExldmVuc2h0ZWluXG5cdCAgLy8gXCJlZGl0XCIgZGlzdGFuY2UuIFRoZSBvbmUgY2hhbmdlIGlzIHRoYXQgXCJ1cGRhdGVzXCIgYXJlIHRyZWF0ZWQgYXMgdHdvXG5cdCAgLy8gZWRpdHMgLSBub3Qgb25lLiBXaXRoIEFycmF5IHNwbGljZXMsIGFuIHVwZGF0ZSBpcyByZWFsbHkgYSBkZWxldGVcblx0ICAvLyBmb2xsb3dlZCBieSBhbiBhZGQuIEJ5IHJldGFpbmluZyB0aGlzLCB3ZSBvcHRpbWl6ZSBmb3IgXCJrZWVwaW5nXCIgdGhlXG5cdCAgLy8gbWF4aW11bSBhcnJheSBpdGVtcyBpbiB0aGUgb3JpZ2luYWwgYXJyYXkuIEZvciBleGFtcGxlOlxuXHQgIC8vXG5cdCAgLy8gICAneHh4eDEyMycgLT4gJzEyM3l5eXknXG5cdCAgLy9cblx0ICAvLyBXaXRoIDEtZWRpdCB1cGRhdGVzLCB0aGUgc2hvcnRlc3QgcGF0aCB3b3VsZCBiZSBqdXN0IHRvIHVwZGF0ZSBhbGwgc2V2ZW5cblx0ICAvLyBjaGFyYWN0ZXJzLiBXaXRoIDItZWRpdCB1cGRhdGVzLCB3ZSBkZWxldGUgNCwgbGVhdmUgMywgYW5kIGFkZCA0LiBUaGlzXG5cdCAgLy8gbGVhdmVzIHRoZSBzdWJzdHJpbmcgJzEyMycgaW50YWN0LlxuXHQgIGNhbGNFZGl0RGlzdGFuY2VzOiBmdW5jdGlvbiBjYWxjRWRpdERpc3RhbmNlcyhjdXJyZW50LCBjdXJyZW50U3RhcnQsIGN1cnJlbnRFbmQsIG9sZCwgb2xkU3RhcnQsIG9sZEVuZCkge1xuXHQgICAgLy8gXCJEZWxldGlvblwiIGNvbHVtbnNcblx0ICAgIHZhciByb3dDb3VudCA9IG9sZEVuZCAtIG9sZFN0YXJ0ICsgMTtcblx0ICAgIHZhciBjb2x1bW5Db3VudCA9IGN1cnJlbnRFbmQgLSBjdXJyZW50U3RhcnQgKyAxO1xuXHQgICAgdmFyIGRpc3RhbmNlcyA9IG5ldyBBcnJheShyb3dDb3VudCk7XG5cdFxuXHQgICAgLy8gXCJBZGRpdGlvblwiIHJvd3MuIEluaXRpYWxpemUgbnVsbCBjb2x1bW4uXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd0NvdW50OyBpKyspIHtcblx0ICAgICAgZGlzdGFuY2VzW2ldID0gbmV3IEFycmF5KGNvbHVtbkNvdW50KTtcblx0ICAgICAgZGlzdGFuY2VzW2ldWzBdID0gaTtcblx0ICAgIH1cblx0XG5cdCAgICAvLyBJbml0aWFsaXplIG51bGwgcm93XG5cdCAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbHVtbkNvdW50OyBqKyspIHtcblx0ICAgICAgZGlzdGFuY2VzWzBdW2pdID0gajtcblx0ICAgIH1mb3IgKHZhciBfaSA9IDE7IF9pIDwgcm93Q291bnQ7IF9pKyspIHtcblx0ICAgICAgZm9yICh2YXIgX2ogPSAxOyBfaiA8IGNvbHVtbkNvdW50OyBfaisrKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuZXF1YWxzKGN1cnJlbnRbY3VycmVudFN0YXJ0ICsgX2ogLSAxXSwgb2xkW29sZFN0YXJ0ICsgX2kgLSAxXSkpIGRpc3RhbmNlc1tfaV1bX2pdID0gZGlzdGFuY2VzW19pIC0gMV1bX2ogLSAxXTtlbHNlIHtcblx0ICAgICAgICAgIHZhciBub3J0aCA9IGRpc3RhbmNlc1tfaSAtIDFdW19qXSArIDE7XG5cdCAgICAgICAgICB2YXIgd2VzdCA9IGRpc3RhbmNlc1tfaV1bX2ogLSAxXSArIDE7XG5cdCAgICAgICAgICBkaXN0YW5jZXNbX2ldW19qXSA9IG5vcnRoIDwgd2VzdCA/IG5vcnRoIDogd2VzdDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICByZXR1cm4gZGlzdGFuY2VzO1xuXHQgIH0sXG5cdFxuXHRcblx0ICAvLyBUaGlzIHN0YXJ0cyBhdCB0aGUgZmluYWwgd2VpZ2h0LCBhbmQgd2Fsa3MgXCJiYWNrd2FyZFwiIGJ5IGZpbmRpbmdcblx0ICAvLyB0aGUgbWluaW11bSBwcmV2aW91cyB3ZWlnaHQgcmVjdXJzaXZlbHkgdW50aWwgdGhlIG9yaWdpbiBvZiB0aGUgd2VpZ2h0XG5cdCAgLy8gbWF0cml4LlxuXHQgIHNwbGljZU9wZXJhdGlvbnNGcm9tRWRpdERpc3RhbmNlczogZnVuY3Rpb24gc3BsaWNlT3BlcmF0aW9uc0Zyb21FZGl0RGlzdGFuY2VzKGRpc3RhbmNlcykge1xuXHQgICAgdmFyIGkgPSBkaXN0YW5jZXMubGVuZ3RoIC0gMTtcblx0ICAgIHZhciBqID0gZGlzdGFuY2VzWzBdLmxlbmd0aCAtIDE7XG5cdCAgICB2YXIgY3VycmVudCA9IGRpc3RhbmNlc1tpXVtqXTtcblx0ICAgIHZhciBlZGl0cyA9IFtdO1xuXHQgICAgd2hpbGUgKGkgPiAwIHx8IGogPiAwKSB7XG5cdCAgICAgIGlmIChpID09IDApIHtcblx0ICAgICAgICBlZGl0cy5wdXNoKEVESVRfQUREKTtcblx0ICAgICAgICBqLS07XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGogPT0gMCkge1xuXHQgICAgICAgIGVkaXRzLnB1c2goRURJVF9ERUxFVEUpO1xuXHQgICAgICAgIGktLTtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgbm9ydGhXZXN0ID0gZGlzdGFuY2VzW2kgLSAxXVtqIC0gMV07XG5cdCAgICAgIHZhciB3ZXN0ID0gZGlzdGFuY2VzW2kgLSAxXVtqXTtcblx0ICAgICAgdmFyIG5vcnRoID0gZGlzdGFuY2VzW2ldW2ogLSAxXTtcblx0XG5cdCAgICAgIHZhciBtaW4gPSB2b2lkIDA7XG5cdCAgICAgIGlmICh3ZXN0IDwgbm9ydGgpIG1pbiA9IHdlc3QgPCBub3J0aFdlc3QgPyB3ZXN0IDogbm9ydGhXZXN0O2Vsc2UgbWluID0gbm9ydGggPCBub3J0aFdlc3QgPyBub3J0aCA6IG5vcnRoV2VzdDtcblx0XG5cdCAgICAgIGlmIChtaW4gPT0gbm9ydGhXZXN0KSB7XG5cdCAgICAgICAgaWYgKG5vcnRoV2VzdCA9PSBjdXJyZW50KSB7XG5cdCAgICAgICAgICBlZGl0cy5wdXNoKEVESVRfTEVBVkUpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBlZGl0cy5wdXNoKEVESVRfVVBEQVRFKTtcblx0ICAgICAgICAgIGN1cnJlbnQgPSBub3J0aFdlc3Q7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGktLTtcblx0ICAgICAgICBqLS07XG5cdCAgICAgIH0gZWxzZSBpZiAobWluID09IHdlc3QpIHtcblx0ICAgICAgICBlZGl0cy5wdXNoKEVESVRfREVMRVRFKTtcblx0ICAgICAgICBpLS07XG5cdCAgICAgICAgY3VycmVudCA9IHdlc3Q7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZWRpdHMucHVzaChFRElUX0FERCk7XG5cdCAgICAgICAgai0tO1xuXHQgICAgICAgIGN1cnJlbnQgPSBub3J0aDtcblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIGVkaXRzLnJldmVyc2UoKTtcblx0ICAgIHJldHVybiBlZGl0cztcblx0ICB9LFxuXHRcblx0XG5cdCAgLyoqXG5cdCAgICogU3BsaWNlIFByb2plY3Rpb24gZnVuY3Rpb25zOlxuXHQgICAqXG5cdCAgICogQSBzcGxpY2UgbWFwIGlzIGEgcmVwcmVzZW50YXRpb24gb2YgaG93IGEgcHJldmlvdXMgYXJyYXkgb2YgaXRlbXNcblx0ICAgKiB3YXMgdHJhbnNmb3JtZWQgaW50byBhIG5ldyBhcnJheSBvZiBpdGVtcy4gQ29uY2VwdHVhbGx5IGl0IGlzIGEgbGlzdCBvZlxuXHQgICAqIHR1cGxlcyBvZlxuXHQgICAqXG5cdCAgICogICA8aW5kZXgsIHJlbW92ZWQsIGFkZGVkQ291bnQ+XG5cdCAgICpcblx0ICAgKiB3aGljaCBhcmUga2VwdCBpbiBhc2NlbmRpbmcgaW5kZXggb3JkZXIgb2YuIFRoZSB0dXBsZSByZXByZXNlbnRzIHRoYXQgYXRcblx0ICAgKiB0aGUgfGluZGV4fCwgfHJlbW92ZWR8IHNlcXVlbmNlIG9mIGl0ZW1zIHdlcmUgcmVtb3ZlZCwgYW5kIGNvdW50aW5nIGZvcndhcmRcblx0ICAgKiBmcm9tIHxpbmRleHwsIHxhZGRlZENvdW50fCBpdGVtcyB3ZXJlIGFkZGVkLlxuXHQgICAqL1xuXHRcblx0ICAvKipcblx0ICAgKiBMYWNraW5nIGluZGl2aWR1YWwgc3BsaWNlIG11dGF0aW9uIGluZm9ybWF0aW9uLCB0aGUgbWluaW1hbCBzZXQgb2Zcblx0ICAgKiBzcGxpY2VzIGNhbiBiZSBzeW50aGVzaXplZCBnaXZlbiB0aGUgcHJldmlvdXMgc3RhdGUgYW5kIGZpbmFsIHN0YXRlIG9mIGFuXG5cdCAgICogYXJyYXkuIFRoZSBiYXNpYyBhcHByb2FjaCBpcyB0byBjYWxjdWxhdGUgdGhlIGVkaXQgZGlzdGFuY2UgbWF0cml4IGFuZFxuXHQgICAqIGNob29zZSB0aGUgc2hvcnRlc3QgcGF0aCB0aHJvdWdoIGl0LlxuXHQgICAqXG5cdCAgICogQ29tcGxleGl0eTogTyhsICogcClcblx0ICAgKiAgIGw6IFRoZSBsZW5ndGggb2YgdGhlIGN1cnJlbnQgYXJyYXlcblx0ICAgKiAgIHA6IFRoZSBsZW5ndGggb2YgdGhlIG9sZCBhcnJheVxuXHQgICAqL1xuXHQgIGNhbGNTcGxpY2VzOiBmdW5jdGlvbiBjYWxjU3BsaWNlcyhjdXJyZW50LCBjdXJyZW50U3RhcnQsIGN1cnJlbnRFbmQsIG9sZCwgb2xkU3RhcnQsIG9sZEVuZCkge1xuXHQgICAgdmFyIHByZWZpeENvdW50ID0gMDtcblx0ICAgIHZhciBzdWZmaXhDb3VudCA9IDA7XG5cdCAgICB2YXIgc3BsaWNlID0gdm9pZCAwO1xuXHRcblx0ICAgIHZhciBtaW5MZW5ndGggPSBNYXRoLm1pbihjdXJyZW50RW5kIC0gY3VycmVudFN0YXJ0LCBvbGRFbmQgLSBvbGRTdGFydCk7XG5cdCAgICBpZiAoY3VycmVudFN0YXJ0ID09IDAgJiYgb2xkU3RhcnQgPT0gMCkgcHJlZml4Q291bnQgPSB0aGlzLnNoYXJlZFByZWZpeChjdXJyZW50LCBvbGQsIG1pbkxlbmd0aCk7XG5cdFxuXHQgICAgaWYgKGN1cnJlbnRFbmQgPT0gY3VycmVudC5sZW5ndGggJiYgb2xkRW5kID09IG9sZC5sZW5ndGgpIHN1ZmZpeENvdW50ID0gdGhpcy5zaGFyZWRTdWZmaXgoY3VycmVudCwgb2xkLCBtaW5MZW5ndGggLSBwcmVmaXhDb3VudCk7XG5cdFxuXHQgICAgY3VycmVudFN0YXJ0ICs9IHByZWZpeENvdW50O1xuXHQgICAgb2xkU3RhcnQgKz0gcHJlZml4Q291bnQ7XG5cdCAgICBjdXJyZW50RW5kIC09IHN1ZmZpeENvdW50O1xuXHQgICAgb2xkRW5kIC09IHN1ZmZpeENvdW50O1xuXHRcblx0ICAgIGlmIChjdXJyZW50RW5kIC0gY3VycmVudFN0YXJ0ID09IDAgJiYgb2xkRW5kIC0gb2xkU3RhcnQgPT0gMCkgcmV0dXJuIFtdO1xuXHRcblx0ICAgIGlmIChjdXJyZW50U3RhcnQgPT0gY3VycmVudEVuZCkge1xuXHQgICAgICBzcGxpY2UgPSBuZXdTcGxpY2UoY3VycmVudFN0YXJ0LCBbXSwgMCk7XG5cdCAgICAgIHdoaWxlIChvbGRTdGFydCA8IG9sZEVuZCkge1xuXHQgICAgICAgIHNwbGljZS5yZW1vdmVkLnB1c2gob2xkW29sZFN0YXJ0KytdKTtcblx0ICAgICAgfXJldHVybiBbc3BsaWNlXTtcblx0ICAgIH0gZWxzZSBpZiAob2xkU3RhcnQgPT0gb2xkRW5kKSByZXR1cm4gW25ld1NwbGljZShjdXJyZW50U3RhcnQsIFtdLCBjdXJyZW50RW5kIC0gY3VycmVudFN0YXJ0KV07XG5cdFxuXHQgICAgdmFyIG9wcyA9IHRoaXMuc3BsaWNlT3BlcmF0aW9uc0Zyb21FZGl0RGlzdGFuY2VzKHRoaXMuY2FsY0VkaXREaXN0YW5jZXMoY3VycmVudCwgY3VycmVudFN0YXJ0LCBjdXJyZW50RW5kLCBvbGQsIG9sZFN0YXJ0LCBvbGRFbmQpKTtcblx0XG5cdCAgICBzcGxpY2UgPSB1bmRlZmluZWQ7XG5cdCAgICB2YXIgc3BsaWNlcyA9IFtdO1xuXHQgICAgdmFyIGluZGV4ID0gY3VycmVudFN0YXJ0O1xuXHQgICAgdmFyIG9sZEluZGV4ID0gb2xkU3RhcnQ7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBzd2l0Y2ggKG9wc1tpXSkge1xuXHQgICAgICAgIGNhc2UgRURJVF9MRUFWRTpcblx0ICAgICAgICAgIGlmIChzcGxpY2UpIHtcblx0ICAgICAgICAgICAgc3BsaWNlcy5wdXNoKHNwbGljZSk7XG5cdCAgICAgICAgICAgIHNwbGljZSA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICBpbmRleCsrO1xuXHQgICAgICAgICAgb2xkSW5kZXgrKztcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgRURJVF9VUERBVEU6XG5cdCAgICAgICAgICBpZiAoIXNwbGljZSkgc3BsaWNlID0gbmV3U3BsaWNlKGluZGV4LCBbXSwgMCk7XG5cdFxuXHQgICAgICAgICAgc3BsaWNlLmFkZGVkQ291bnQrKztcblx0ICAgICAgICAgIGluZGV4Kys7XG5cdFxuXHQgICAgICAgICAgc3BsaWNlLnJlbW92ZWQucHVzaChvbGRbb2xkSW5kZXhdKTtcblx0ICAgICAgICAgIG9sZEluZGV4Kys7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlIEVESVRfQUREOlxuXHQgICAgICAgICAgaWYgKCFzcGxpY2UpIHNwbGljZSA9IG5ld1NwbGljZShpbmRleCwgW10sIDApO1xuXHRcblx0ICAgICAgICAgIHNwbGljZS5hZGRlZENvdW50Kys7XG5cdCAgICAgICAgICBpbmRleCsrO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSBFRElUX0RFTEVURTpcblx0ICAgICAgICAgIGlmICghc3BsaWNlKSBzcGxpY2UgPSBuZXdTcGxpY2UoaW5kZXgsIFtdLCAwKTtcblx0XG5cdCAgICAgICAgICBzcGxpY2UucmVtb3ZlZC5wdXNoKG9sZFtvbGRJbmRleF0pO1xuXHQgICAgICAgICAgb2xkSW5kZXgrKztcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgaWYgKHNwbGljZSkge1xuXHQgICAgICBzcGxpY2VzLnB1c2goc3BsaWNlKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBzcGxpY2VzO1xuXHQgIH0sXG5cdCAgc2hhcmVkUHJlZml4OiBmdW5jdGlvbiBzaGFyZWRQcmVmaXgoY3VycmVudCwgb2xkLCBzZWFyY2hMZW5ndGgpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VhcmNoTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKCF0aGlzLmVxdWFscyhjdXJyZW50W2ldLCBvbGRbaV0pKSByZXR1cm4gaTtcblx0ICAgIH1yZXR1cm4gc2VhcmNoTGVuZ3RoO1xuXHQgIH0sXG5cdCAgc2hhcmVkU3VmZml4OiBmdW5jdGlvbiBzaGFyZWRTdWZmaXgoY3VycmVudCwgb2xkLCBzZWFyY2hMZW5ndGgpIHtcblx0ICAgIHZhciBpbmRleDEgPSBjdXJyZW50Lmxlbmd0aDtcblx0ICAgIHZhciBpbmRleDIgPSBvbGQubGVuZ3RoO1xuXHQgICAgdmFyIGNvdW50ID0gMDtcblx0ICAgIHdoaWxlIChjb3VudCA8IHNlYXJjaExlbmd0aCAmJiB0aGlzLmVxdWFscyhjdXJyZW50Wy0taW5kZXgxXSwgb2xkWy0taW5kZXgyXSkpIHtcblx0ICAgICAgY291bnQrKztcblx0ICAgIH1yZXR1cm4gY291bnQ7XG5cdCAgfSxcblx0ICBjYWxjdWxhdGVTcGxpY2VzOiBmdW5jdGlvbiBjYWxjdWxhdGVTcGxpY2VzKGN1cnJlbnQsIHByZXZpb3VzKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jYWxjU3BsaWNlcyhjdXJyZW50LCAwLCBjdXJyZW50Lmxlbmd0aCwgcHJldmlvdXMsIDAsIHByZXZpb3VzLmxlbmd0aCk7XG5cdCAgfSxcblx0ICBlcXVhbHM6IGZ1bmN0aW9uIGVxdWFscyhjdXJyZW50VmFsdWUsIHByZXZpb3VzVmFsdWUpIHtcblx0ICAgIHJldHVybiBjdXJyZW50VmFsdWUgPT09IHByZXZpb3VzVmFsdWU7XG5cdCAgfVxuXHR9O1xuXHRcblx0dmFyIGNhbGN1bGF0ZVNwbGljZXMgPSBleHBvcnRzLmNhbGN1bGF0ZVNwbGljZXMgPSBmdW5jdGlvbiBjYWxjdWxhdGVTcGxpY2VzKGN1cnJlbnQsIHByZXZpb3VzKSB7XG5cdCAgcmV0dXJuIEFycmF5U3BsaWNlLmNhbGN1bGF0ZVNwbGljZXMoY3VycmVudCwgcHJldmlvdXMpO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogNjYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qKlxuXHRAbGljZW5zZVxuXHRDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXHRUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5cdFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5cdFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuXHRDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuXHRzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuXHQqL1xuXHRcblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdFxuXHR2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXHRcblx0dmFyIF9uYXRpdmVNZXRob2RzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NSk7XG5cdFxuXHR2YXIgX25hdGl2ZVRyZWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcblx0XG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cdFxuXHQvLyBOT1RFOiBub3JtYWxpemUgZXZlbnQgY29udHJ1Y3Rpb24gd2hlcmUgbmVjZXNzYXJ5IChJRTExKVxuXHR2YXIgTm9ybWFsaXplZEV2ZW50ID0gdHlwZW9mIEV2ZW50ID09PSAnZnVuY3Rpb24nID8gRXZlbnQgOiBmdW5jdGlvbiAoaW5UeXBlLCBwYXJhbXMpIHtcblx0ICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cdCAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcblx0ICBlLmluaXRFdmVudChpblR5cGUsIEJvb2xlYW4ocGFyYW1zLmJ1YmJsZXMpLCBCb29sZWFuKHBhcmFtcy5jYW5jZWxhYmxlKSk7XG5cdCAgcmV0dXJuIGU7XG5cdH07XG5cdFxuXHR2YXIgX2NsYXNzID0gZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIF9jbGFzcyhyb290KSB7XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2NsYXNzKTtcblx0XG5cdCAgICB0aGlzLnJvb3QgPSByb290O1xuXHQgICAgdGhpcy5pbnNlcnRpb25Qb2ludFRhZyA9ICdzbG90Jztcblx0ICB9XG5cdFxuXHQgIF9jcmVhdGVDbGFzcyhfY2xhc3MsIFt7XG5cdCAgICBrZXk6ICdnZXRJbnNlcnRpb25Qb2ludHMnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluc2VydGlvblBvaW50cygpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuaW5zZXJ0aW9uUG9pbnRUYWcpO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2hhc0luc2VydGlvblBvaW50Jyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNJbnNlcnRpb25Qb2ludCgpIHtcblx0ICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5yb290Ll9pbnNlcnRpb25Qb2ludHMgJiYgdGhpcy5yb290Ll9pbnNlcnRpb25Qb2ludHMubGVuZ3RoKTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdpc0luc2VydGlvblBvaW50Jyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBpc0luc2VydGlvblBvaW50KG5vZGUpIHtcblx0ICAgICAgcmV0dXJuIG5vZGUubG9jYWxOYW1lICYmIG5vZGUubG9jYWxOYW1lID09IHRoaXMuaW5zZXJ0aW9uUG9pbnRUYWc7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnZGlzdHJpYnV0ZScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdHJpYnV0ZSgpIHtcblx0ICAgICAgaWYgKHRoaXMuaGFzSW5zZXJ0aW9uUG9pbnQoKSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmRpc3RyaWJ1dGVQb29sKHRoaXMucm9vdCwgdGhpcy5jb2xsZWN0UG9vbCgpKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gW107XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gR2F0aGVyIHRoZSBwb29sIG9mIG5vZGVzIHRoYXQgc2hvdWxkIGJlIGRpc3RyaWJ1dGVkLiBXZSB3aWxsIGNvbWJpbmVcblx0ICAgIC8vIHRoZXNlIHdpdGggdGhlIFwiY29udGVudCByb290XCIgdG8gYXJyaXZlIGF0IHRoZSBjb21wb3NlZCB0cmVlLlxuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdjb2xsZWN0UG9vbCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gY29sbGVjdFBvb2woKSB7XG5cdCAgICAgIHZhciBob3N0ID0gdGhpcy5yb290Lmhvc3Q7XG5cdCAgICAgIHZhciBwb29sID0gW10sXG5cdCAgICAgICAgICBpID0gMDtcblx0ICAgICAgZm9yICh2YXIgbiA9IGhvc3QuZmlyc3RDaGlsZDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcpIHtcblx0ICAgICAgICBwb29sW2krK10gPSBuO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBwb29sO1xuXHQgICAgfVxuXHRcblx0ICAgIC8vIHBlcmZvcm0gXCJsb2dpY2FsXCIgZGlzdHJpYnV0aW9uOyBub3RlLCBubyBhY3R1YWwgZG9tIGlzIG1vdmVkIGhlcmUsXG5cdCAgICAvLyBpbnN0ZWFkIGVsZW1lbnRzIGFyZSBkaXN0cmlidXRlZCBpbnRvIHN0b3JhZ2Vcblx0ICAgIC8vIGFycmF5IHdoZXJlIGFwcGxpY2FibGUuXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2Rpc3RyaWJ1dGVQb29sJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0cmlidXRlUG9vbChub2RlLCBwb29sKSB7XG5cdCAgICAgIHZhciBkaXJ0eVJvb3RzID0gW107XG5cdCAgICAgIHZhciBwJCA9IHRoaXMucm9vdC5faW5zZXJ0aW9uUG9pbnRzO1xuXHQgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHAkLmxlbmd0aCwgcDsgaSA8IGwgJiYgKHAgPSBwJFtpXSk7IGkrKykge1xuXHQgICAgICAgIHRoaXMuZGlzdHJpYnV0ZUluc2VydGlvblBvaW50KHAsIHBvb2wpO1xuXHQgICAgICAgIC8vIHByb3Zva2UgcmVkaXN0cmlidXRpb24gb24gaW5zZXJ0aW9uIHBvaW50IHBhcmVudHNcblx0ICAgICAgICAvLyBtdXN0IGRvIHRoaXMgb24gYWxsIGNhbmRpZGF0ZSBob3N0cyBzaW5jZSBkaXN0cmlidXRpb24gaW4gdGhpc1xuXHQgICAgICAgIC8vIHNjb3BlIGludmFsaWRhdGVzIHRoZWlyIGRpc3RyaWJ1dGlvbi5cblx0ICAgICAgICAvLyBvbmx5IGdldCBsb2dpY2FsIHBhcmVudC5cblx0ICAgICAgICB2YXIgcGFyZW50ID0gcC5wYXJlbnROb2RlO1xuXHQgICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnNoYWR5Um9vdCAmJiB0aGlzLmhhc0luc2VydGlvblBvaW50KHBhcmVudC5zaGFkeVJvb3QpKSB7XG5cdCAgICAgICAgICBkaXJ0eVJvb3RzLnB1c2gocGFyZW50LnNoYWR5Um9vdCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBwb29sLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgIHZhciBfcCA9IHBvb2xbX2ldO1xuXHQgICAgICAgIGlmIChfcCkge1xuXHQgICAgICAgICAgX3AuX19zaGFkeSA9IF9wLl9fc2hhZHkgfHwge307XG5cdCAgICAgICAgICBfcC5fX3NoYWR5LmFzc2lnbmVkU2xvdCA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgIC8vIHJlbW92ZSB1bmRpc3RyaWJ1dGVkIGVsZW1lbnRzIGZyb20gcGh5c2ljYWwgZG9tLlxuXHQgICAgICAgICAgdmFyIF9wYXJlbnQgPSAoMCwgX25hdGl2ZVRyZWUucGFyZW50Tm9kZSkoX3ApO1xuXHQgICAgICAgICAgaWYgKF9wYXJlbnQpIHtcblx0ICAgICAgICAgICAgX25hdGl2ZU1ldGhvZHMucmVtb3ZlQ2hpbGQuY2FsbChfcGFyZW50LCBfcCk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBkaXJ0eVJvb3RzO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2Rpc3RyaWJ1dGVJbnNlcnRpb25Qb2ludCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdHJpYnV0ZUluc2VydGlvblBvaW50KGluc2VydGlvblBvaW50LCBwb29sKSB7XG5cdCAgICAgIHZhciBwcmV2QXNzaWduZWROb2RlcyA9IGluc2VydGlvblBvaW50Ll9fc2hhZHkuYXNzaWduZWROb2Rlcztcblx0ICAgICAgaWYgKHByZXZBc3NpZ25lZE5vZGVzKSB7XG5cdCAgICAgICAgdGhpcy5jbGVhckFzc2lnbmVkU2xvdHMoaW5zZXJ0aW9uUG9pbnQsIHRydWUpO1xuXHQgICAgICB9XG5cdCAgICAgIGluc2VydGlvblBvaW50Ll9fc2hhZHkuYXNzaWduZWROb2RlcyA9IFtdO1xuXHQgICAgICB2YXIgbmVlZHNTbG90Q2hhbmdlID0gZmFsc2U7XG5cdCAgICAgIC8vIGRpc3RyaWJ1dGUgbm9kZXMgZnJvbSB0aGUgcG9vbCB0aGF0IHRoaXMgc2VsZWN0b3IgbWF0Y2hlc1xuXHQgICAgICB2YXIgYW55RGlzdHJpYnV0ZWQgPSBmYWxzZTtcblx0ICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwb29sLmxlbmd0aCwgbm9kZTsgaSA8IGw7IGkrKykge1xuXHQgICAgICAgIG5vZGUgPSBwb29sW2ldO1xuXHQgICAgICAgIC8vIHNraXAgbm9kZXMgdGhhdCB3ZXJlIGFscmVhZHkgdXNlZFxuXHQgICAgICAgIGlmICghbm9kZSkge1xuXHQgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIGRpc3RyaWJ1dGUgdGhpcyBub2RlIGlmIGl0IG1hdGNoZXNcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaGVzSW5zZXJ0aW9uUG9pbnQobm9kZSwgaW5zZXJ0aW9uUG9pbnQpKSB7XG5cdCAgICAgICAgICBpZiAobm9kZS5fX3NoYWR5Ll9wcmV2QXNzaWduZWRTbG90ICE9IGluc2VydGlvblBvaW50KSB7XG5cdCAgICAgICAgICAgIG5lZWRzU2xvdENoYW5nZSA9IHRydWU7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICB0aGlzLmRpc3RyaWJ1dGVOb2RlSW50byhub2RlLCBpbnNlcnRpb25Qb2ludCk7XG5cdCAgICAgICAgICAvLyByZW1vdmUgdGhpcyBub2RlIGZyb20gdGhlIHBvb2xcblx0ICAgICAgICAgIHBvb2xbaV0gPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAvLyBzaW5jZSBhdCBsZWFzdCBvbmUgbm9kZSBtYXRjaGVkLCB3ZSB3b24ndCBuZWVkIGZhbGxiYWNrIGNvbnRlbnRcblx0ICAgICAgICAgIGFueURpc3RyaWJ1dGVkID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgLy8gRmFsbGJhY2sgY29udGVudCBpZiBub3RoaW5nIHdhcyBkaXN0cmlidXRlZCBoZXJlXG5cdCAgICAgIGlmICghYW55RGlzdHJpYnV0ZWQpIHtcblx0ICAgICAgICB2YXIgY2hpbGRyZW4gPSBpbnNlcnRpb25Qb2ludC5jaGlsZE5vZGVzO1xuXHQgICAgICAgIGZvciAodmFyIGogPSAwLCBfbm9kZTsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICBfbm9kZSA9IGNoaWxkcmVuW2pdO1xuXHQgICAgICAgICAgaWYgKF9ub2RlLl9fc2hhZHkuX3ByZXZBc3NpZ25lZFNsb3QgIT0gaW5zZXJ0aW9uUG9pbnQpIHtcblx0ICAgICAgICAgICAgbmVlZHNTbG90Q2hhbmdlID0gdHJ1ZTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHRoaXMuZGlzdHJpYnV0ZU5vZGVJbnRvKF9ub2RlLCBpbnNlcnRpb25Qb2ludCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIC8vIHdlJ3JlIGFscmVhZHkgZGlydHkgaWYgYSBub2RlIHdhcyBuZXdseSBhZGRlZCB0byB0aGUgc2xvdFxuXHQgICAgICAvLyBhbmQgd2UncmUgYWxzbyBkaXJ0eSBpZiB0aGUgYXNzaWduZWQgY291bnQgZGVjcmVhc2VkLlxuXHQgICAgICBpZiAocHJldkFzc2lnbmVkTm9kZXMpIHtcblx0ICAgICAgICAvLyBUT0RPKHNvcnZlbGwpOiB0aGUgdHJhY2tpbmcgb2YgcHJldmlvdXNseSBhc3NpZ25lZCBzbG90c1xuXHQgICAgICAgIC8vIGNvdWxkIGluc3RlYWQgYnkgZG9uZSB3aXRoIGEgU2V0IGFuZCB0aGVuIHdlIGNvdWxkXG5cdCAgICAgICAgLy8gYXZvaWQgbmVlZGluZyB0byBpdGVyYXRlIGhlcmUgdG8gY2xlYXIgdGhlIGluZm8uXG5cdCAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcHJldkFzc2lnbmVkTm9kZXMubGVuZ3RoOyBfaTIrKykge1xuXHQgICAgICAgICAgcHJldkFzc2lnbmVkTm9kZXNbX2kyXS5fX3NoYWR5Ll9wcmV2QXNzaWduZWRTbG90ID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGluc2VydGlvblBvaW50Ll9fc2hhZHkuYXNzaWduZWROb2Rlcy5sZW5ndGggPCBwcmV2QXNzaWduZWROb2Rlcy5sZW5ndGgpIHtcblx0ICAgICAgICAgIG5lZWRzU2xvdENoYW5nZSA9IHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHRoaXMuc2V0RGlzdHJpYnV0ZWROb2Rlc09uSW5zZXJ0aW9uUG9pbnQoaW5zZXJ0aW9uUG9pbnQpO1xuXHQgICAgICBpZiAobmVlZHNTbG90Q2hhbmdlKSB7XG5cdCAgICAgICAgdGhpcy5fZmlyZVNsb3RDaGFuZ2UoaW5zZXJ0aW9uUG9pbnQpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnY2xlYXJBc3NpZ25lZFNsb3RzJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckFzc2lnbmVkU2xvdHMoc2xvdCwgc2F2ZVByZXZpb3VzKSB7XG5cdCAgICAgIHZhciBuJCA9IHNsb3QuX19zaGFkeS5hc3NpZ25lZE5vZGVzO1xuXHQgICAgICBpZiAobiQpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG4kLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICB2YXIgbiA9IG4kW2ldO1xuXHQgICAgICAgICAgaWYgKHNhdmVQcmV2aW91cykge1xuXHQgICAgICAgICAgICBuLl9fc2hhZHkuX3ByZXZBc3NpZ25lZFNsb3QgPSBuLl9fc2hhZHkuYXNzaWduZWRTbG90O1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgLy8gb25seSBjbGVhciBpZiBpdCB3YXMgcHJldmlvdXNseSBzZXQgdG8gdGhpcyBzbG90O1xuXHQgICAgICAgICAgLy8gdGhpcyBoZWxwcyBlbnN1cmUgdGhhdCBpZiB0aGUgbm9kZSBoYXMgb3RoZXJ3aXNlIGJlZW4gZGlzdHJpYnV0ZWRcblx0ICAgICAgICAgIC8vIGlnbm9yZSBpdC5cblx0ICAgICAgICAgIGlmIChuLl9fc2hhZHkuYXNzaWduZWRTbG90ID09PSBzbG90KSB7XG5cdCAgICAgICAgICAgIG4uX19zaGFkeS5hc3NpZ25lZFNsb3QgPSBudWxsO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ21hdGNoZXNJbnNlcnRpb25Qb2ludCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hlc0luc2VydGlvblBvaW50KG5vZGUsIGluc2VydGlvblBvaW50KSB7XG5cdCAgICAgIHZhciBzbG90TmFtZSA9IGluc2VydGlvblBvaW50LmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuXHQgICAgICBzbG90TmFtZSA9IHNsb3ROYW1lID8gc2xvdE5hbWUudHJpbSgpIDogJyc7XG5cdCAgICAgIHZhciBzbG90ID0gbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ3Nsb3QnKTtcblx0ICAgICAgc2xvdCA9IHNsb3QgPyBzbG90LnRyaW0oKSA6ICcnO1xuXHQgICAgICByZXR1cm4gc2xvdCA9PSBzbG90TmFtZTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdkaXN0cmlidXRlTm9kZUludG8nLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RyaWJ1dGVOb2RlSW50byhjaGlsZCwgaW5zZXJ0aW9uUG9pbnQpIHtcblx0ICAgICAgaW5zZXJ0aW9uUG9pbnQuX19zaGFkeS5hc3NpZ25lZE5vZGVzLnB1c2goY2hpbGQpO1xuXHQgICAgICBjaGlsZC5fX3NoYWR5LmFzc2lnbmVkU2xvdCA9IGluc2VydGlvblBvaW50O1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ3NldERpc3RyaWJ1dGVkTm9kZXNPbkluc2VydGlvblBvaW50Jyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREaXN0cmlidXRlZE5vZGVzT25JbnNlcnRpb25Qb2ludChpbnNlcnRpb25Qb2ludCkge1xuXHQgICAgICB2YXIgbiQgPSBpbnNlcnRpb25Qb2ludC5fX3NoYWR5LmFzc2lnbmVkTm9kZXM7XG5cdCAgICAgIGluc2VydGlvblBvaW50Ll9fc2hhZHkuZGlzdHJpYnV0ZWROb2RlcyA9IFtdO1xuXHQgICAgICBmb3IgKHZhciBpID0gMCwgbjsgaSA8IG4kLmxlbmd0aCAmJiAobiA9IG4kW2ldKTsgaSsrKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNJbnNlcnRpb25Qb2ludChuKSkge1xuXHQgICAgICAgICAgdmFyIGQkID0gbi5fX3NoYWR5LmRpc3RyaWJ1dGVkTm9kZXM7XG5cdCAgICAgICAgICBpZiAoZCQpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkJC5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgIGluc2VydGlvblBvaW50Ll9fc2hhZHkuZGlzdHJpYnV0ZWROb2Rlcy5wdXNoKGQkW2pdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBpbnNlcnRpb25Qb2ludC5fX3NoYWR5LmRpc3RyaWJ1dGVkTm9kZXMucHVzaChuJFtpXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX2ZpcmVTbG90Q2hhbmdlJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBfZmlyZVNsb3RDaGFuZ2UoaW5zZXJ0aW9uUG9pbnQpIHtcblx0ICAgICAgLy8gTk9URTogY2Fubm90IGJ1YmJsZSBjb3JyZWN0bHkgaGVyZSBzbyBub3Qgc2V0dGluZyBidWJibGVzOiB0cnVlXG5cdCAgICAgIC8vIFNhZmFyaSB0ZWNoIHByZXZpZXcgZG9lcyBub3QgYnViYmxlIGJ1dCBjaHJvbWUgZG9lc1xuXHQgICAgICAvLyBTcGVjIHNheXMgaXQgYnViYmxlcyAoaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNtdXRhdGlvbi1vYnNlcnZlcnMpXG5cdCAgICAgIGluc2VydGlvblBvaW50LmRpc3BhdGNoRXZlbnQobmV3IE5vcm1hbGl6ZWRFdmVudCgnc2xvdGNoYW5nZScpKTtcblx0ICAgICAgaWYgKGluc2VydGlvblBvaW50Ll9fc2hhZHkuYXNzaWduZWRTbG90KSB7XG5cdCAgICAgICAgdGhpcy5fZmlyZVNsb3RDaGFuZ2UoaW5zZXJ0aW9uUG9pbnQuX19zaGFkeS5hc3NpZ25lZFNsb3QpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnaXNGaW5hbERlc3RpbmF0aW9uJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBpc0ZpbmFsRGVzdGluYXRpb24oaW5zZXJ0aW9uUG9pbnQpIHtcblx0ICAgICAgcmV0dXJuICFpbnNlcnRpb25Qb2ludC5fX3NoYWR5LmFzc2lnbmVkU2xvdDtcblx0ICAgIH1cblx0ICB9XSk7XG5cblx0ICByZXR1cm4gX2NsYXNzO1xuXHR9KCk7XG5cblx0ZXhwb3J0cy5kZWZhdWx0ID0gX2NsYXNzO1xuXG4vKioqLyB9LFxuLyogNjcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qKlxuXHRAbGljZW5zZVxuXHRDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXHRUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5cdFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5cdFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuXHRDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuXHRzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuXHQqL1xuXHQndXNlIHN0cmljdCc7XG5cdFxuXHQvKlxuXHRTbWFsbCBtb2R1bGUgdG8gbG9hZCBTaGFkeUNTUyBhbmQgQ3VzdG9tU3R5bGUgdG9nZXRoZXJcblx0Ki9cblx0XG5cdF9fd2VicGFja19yZXF1aXJlX18oNjgpO1xuXHRcblx0X193ZWJwYWNrX3JlcXVpcmVfXyg4MCk7XG5cbi8qKiovIH0sXG4vKiA2OCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyoqXG5cdEBsaWNlbnNlXG5cdENvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cdFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblx0VGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblx0VGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5cdENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5cdHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG5cdCovXG5cdFxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXHRcblx0Ly8gVE9ETyhkZnJlZWRtKTogY29uc2lkZXIgc3BsaXRpbmcgaW50byBzZXBhcmF0ZSBnbG9iYWxcblx0XG5cdFxuXHR2YXIgX2Nzc1BhcnNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OSk7XG5cdFxuXHR2YXIgX3N0eWxlU2V0dGluZ3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcblx0XG5cdHZhciBfc3R5bGVUcmFuc2Zvcm1lciA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xuXHRcblx0dmFyIF9zdHlsZVRyYW5zZm9ybWVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0eWxlVHJhbnNmb3JtZXIpO1xuXHRcblx0dmFyIF9zdHlsZVV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcblx0XG5cdHZhciBTdHlsZVV0aWwgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfc3R5bGVVdGlsKTtcblx0XG5cdHZhciBfc3R5bGVQcm9wZXJ0aWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Myk7XG5cdFxuXHR2YXIgX3N0eWxlUHJvcGVydGllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdHlsZVByb3BlcnRpZXMpO1xuXHRcblx0dmFyIF90ZW1wbGF0ZU1hcCA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpO1xuXHRcblx0dmFyIF90ZW1wbGF0ZU1hcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90ZW1wbGF0ZU1hcCk7XG5cdFxuXHR2YXIgX3N0eWxlUGxhY2Vob2xkZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KTtcblx0XG5cdHZhciBfc3R5bGVQbGFjZWhvbGRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdHlsZVBsYWNlaG9sZGVyKTtcblx0XG5cdHZhciBfc3R5bGVJbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG5cdFxuXHR2YXIgX3N0eWxlSW5mbzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdHlsZUluZm8pO1xuXHRcblx0dmFyIF9zdHlsZUNhY2hlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nyk7XG5cdFxuXHR2YXIgX3N0eWxlQ2FjaGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3R5bGVDYWNoZSk7XG5cdFxuXHR2YXIgX2FwcGx5U2hpbSA9IF9fd2VicGFja19yZXF1aXJlX18oNzgpO1xuXHRcblx0dmFyIF9hcHBseVNoaW0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXBwbHlTaGltKTtcblx0XG5cdHZhciBfZG9jdW1lbnRXYXRjaGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OSk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cdFxuXHR2YXIgc3R5bGVDYWNoZSA9IG5ldyBfc3R5bGVDYWNoZTIuZGVmYXVsdCgpO1xuXHRcblx0dmFyIFNoYWR5Q1NTID0gZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIFNoYWR5Q1NTKCkge1xuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNoYWR5Q1NTKTtcblx0XG5cdCAgICB0aGlzLl9zY29wZUNvdW50ZXIgPSB7fTtcblx0ICAgIHRoaXMuX2RvY3VtZW50T3duZXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdCAgICB0aGlzLl9kb2N1bWVudE93bmVyU3R5bGVJbmZvID0gX3N0eWxlSW5mbzIuZGVmYXVsdC5zZXQoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBuZXcgX3N0eWxlSW5mbzIuZGVmYXVsdCh7IHJ1bGVzOiBbXSB9KSk7XG5cdCAgICB0aGlzLl9lbGVtZW50c0hhdmVBcHBsaWVkID0gZmFsc2U7XG5cdCAgfVxuXHRcblx0ICBfY3JlYXRlQ2xhc3MoU2hhZHlDU1MsIFt7XG5cdCAgICBrZXk6ICdmbHVzaCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZmx1c2goKSB7XG5cdCAgICAgICgwLCBfZG9jdW1lbnRXYXRjaGVyLmZsdXNoKSgpO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ19nZW5lcmF0ZVNjb3BlU2VsZWN0b3InLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZW5lcmF0ZVNjb3BlU2VsZWN0b3IobmFtZSkge1xuXHQgICAgICB2YXIgaWQgPSB0aGlzLl9zY29wZUNvdW50ZXJbbmFtZV0gPSAodGhpcy5fc2NvcGVDb3VudGVyW25hbWVdIHx8IDApICsgMTtcblx0ICAgICAgcmV0dXJuIG5hbWUgKyAnLScgKyBpZDtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdnZXRTdHlsZUFzdCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3R5bGVBc3Qoc3R5bGUpIHtcblx0ICAgICAgcmV0dXJuIFN0eWxlVXRpbC5ydWxlc0ZvclN0eWxlKHN0eWxlKTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdzdHlsZUFzdFRvU3RyaW5nJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBzdHlsZUFzdFRvU3RyaW5nKGFzdCkge1xuXHQgICAgICByZXR1cm4gU3R5bGVVdGlsLnRvQ3NzVGV4dChhc3QpO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ19nYXRoZXJTdHlsZXMnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF9nYXRoZXJTdHlsZXModGVtcGxhdGUpIHtcblx0ICAgICAgdmFyIHN0eWxlcyA9IHRlbXBsYXRlLmNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGUnKTtcblx0ICAgICAgdmFyIGNzc1RleHQgPSBbXTtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgcyA9IHN0eWxlc1tpXTtcblx0ICAgICAgICBjc3NUZXh0LnB1c2gocy50ZXh0Q29udGVudCk7XG5cdCAgICAgICAgcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHMpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBjc3NUZXh0LmpvaW4oJycpLnRyaW0oKTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdfZ2V0Q3NzQnVpbGQnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDc3NCdWlsZCh0ZW1wbGF0ZSkge1xuXHQgICAgICB2YXIgc3R5bGUgPSB0ZW1wbGF0ZS5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlJyk7XG5cdCAgICAgIGlmICghc3R5bGUpIHtcblx0ICAgICAgICByZXR1cm4gJyc7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHN0eWxlLmdldEF0dHJpYnV0ZSgnY3NzLWJ1aWxkJykgfHwgJyc7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAncHJlcGFyZVRlbXBsYXRlJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVwYXJlVGVtcGxhdGUodGVtcGxhdGUsIGVsZW1lbnROYW1lLCB0eXBlRXh0ZW5zaW9uKSB7XG5cdCAgICAgIGlmICh0ZW1wbGF0ZS5fcHJlcGFyZWQpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgICAgdGVtcGxhdGUuX3ByZXBhcmVkID0gdHJ1ZTtcblx0ICAgICAgdGVtcGxhdGUubmFtZSA9IGVsZW1lbnROYW1lO1xuXHQgICAgICB0ZW1wbGF0ZS5leHRlbmRzID0gdHlwZUV4dGVuc2lvbjtcblx0ICAgICAgX3RlbXBsYXRlTWFwMi5kZWZhdWx0W2VsZW1lbnROYW1lXSA9IHRlbXBsYXRlO1xuXHQgICAgICB2YXIgY3NzQnVpbGQgPSB0aGlzLl9nZXRDc3NCdWlsZCh0ZW1wbGF0ZSk7XG5cdCAgICAgIHZhciBjc3NUZXh0ID0gdGhpcy5fZ2F0aGVyU3R5bGVzKHRlbXBsYXRlKTtcblx0ICAgICAgdmFyIGluZm8gPSB7XG5cdCAgICAgICAgaXM6IGVsZW1lbnROYW1lLFxuXHQgICAgICAgIGV4dGVuZHM6IHR5cGVFeHRlbnNpb24sXG5cdCAgICAgICAgX19jc3NCdWlsZDogY3NzQnVpbGRcblx0ICAgICAgfTtcblx0ICAgICAgaWYgKCF0aGlzLm5hdGl2ZVNoYWRvdykge1xuXHQgICAgICAgIF9zdHlsZVRyYW5zZm9ybWVyMi5kZWZhdWx0LmRvbSh0ZW1wbGF0ZS5jb250ZW50LCBlbGVtZW50TmFtZSk7XG5cdCAgICAgIH1cblx0ICAgICAgLy8gY2hlY2sgaWYgdGhlIHN0eWxpbmcgaGFzIG1peGluIGRlZmluaXRpb25zIG9yIHVzZXNcblx0ICAgICAgdmFyIGhhc01peGlucyA9IF9hcHBseVNoaW0yLmRlZmF1bHQuZGV0ZWN0TWl4aW4oY3NzVGV4dCk7XG5cdCAgICAgIHZhciBhc3QgPSAoMCwgX2Nzc1BhcnNlLnBhcnNlKShjc3NUZXh0KTtcblx0ICAgICAgLy8gb25seSBydW4gdGhlIGFwcGx5c2hpbSB0cmFuc2Zvcm1zIGlmIHRoZXJlIGlzIGEgbWl4aW4gaW52b2x2ZWRcblx0ICAgICAgaWYgKGhhc01peGlucyAmJiB0aGlzLm5hdGl2ZUNzcyAmJiAhdGhpcy5uYXRpdmVDc3NBcHBseSkge1xuXHQgICAgICAgIF9hcHBseVNoaW0yLmRlZmF1bHQudHJhbnNmb3JtUnVsZXMoYXN0LCBlbGVtZW50TmFtZSk7XG5cdCAgICAgIH1cblx0ICAgICAgdGVtcGxhdGUuX3N0eWxlQXN0ID0gYXN0O1xuXHRcblx0ICAgICAgdmFyIG93blByb3BlcnR5TmFtZXMgPSBbXTtcblx0ICAgICAgaWYgKCF0aGlzLm5hdGl2ZUNzcykge1xuXHQgICAgICAgIG93blByb3BlcnR5TmFtZXMgPSBfc3R5bGVQcm9wZXJ0aWVzMi5kZWZhdWx0LmRlY29yYXRlU3R5bGVzKHRlbXBsYXRlLl9zdHlsZUFzdCwgaW5mbyk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKCFvd25Qcm9wZXJ0eU5hbWVzLmxlbmd0aCB8fCB0aGlzLm5hdGl2ZUNzcykge1xuXHQgICAgICAgIHZhciByb290ID0gdGhpcy5uYXRpdmVTaGFkb3cgPyB0ZW1wbGF0ZS5jb250ZW50IDogbnVsbDtcblx0ICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSBfc3R5bGVQbGFjZWhvbGRlcjIuZGVmYXVsdFtlbGVtZW50TmFtZV07XG5cdCAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5fZ2VuZXJhdGVTdGF0aWNTdHlsZShpbmZvLCB0ZW1wbGF0ZS5fc3R5bGVBc3QsIHJvb3QsIHBsYWNlaG9sZGVyKTtcblx0ICAgICAgICB0ZW1wbGF0ZS5fc3R5bGUgPSBzdHlsZTtcblx0ICAgICAgfVxuXHQgICAgICB0ZW1wbGF0ZS5fb3duUHJvcGVydHlOYW1lcyA9IG93blByb3BlcnR5TmFtZXM7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX2dlbmVyYXRlU3RhdGljU3R5bGUnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZW5lcmF0ZVN0YXRpY1N0eWxlKGluZm8sIHJ1bGVzLCBzaGFkb3dyb290LCBwbGFjZWhvbGRlcikge1xuXHQgICAgICB2YXIgY3NzVGV4dCA9IF9zdHlsZVRyYW5zZm9ybWVyMi5kZWZhdWx0LmVsZW1lbnRTdHlsZXMoaW5mbywgcnVsZXMpO1xuXHQgICAgICBpZiAoY3NzVGV4dC5sZW5ndGgpIHtcblx0ICAgICAgICByZXR1cm4gU3R5bGVVdGlsLmFwcGx5Q3NzKGNzc1RleHQsIGluZm8uaXMsIHNoYWRvd3Jvb3QsIHBsYWNlaG9sZGVyKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ19wcmVwYXJlSG9zdCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX3ByZXBhcmVIb3N0KGhvc3QpIHtcblx0ICAgICAgdmFyIGlzID0gaG9zdC5nZXRBdHRyaWJ1dGUoJ2lzJykgfHwgaG9zdC5sb2NhbE5hbWU7XG5cdCAgICAgIHZhciB0eXBlRXh0ZW5zaW9uID0gdm9pZCAwO1xuXHQgICAgICBpZiAoaXMgIT09IGhvc3QubG9jYWxOYW1lKSB7XG5cdCAgICAgICAgdHlwZUV4dGVuc2lvbiA9IGhvc3QubG9jYWxOYW1lO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBwbGFjZWhvbGRlciA9IF9zdHlsZVBsYWNlaG9sZGVyMi5kZWZhdWx0W2lzXTtcblx0ICAgICAgdmFyIHRlbXBsYXRlID0gX3RlbXBsYXRlTWFwMi5kZWZhdWx0W2lzXTtcblx0ICAgICAgdmFyIGFzdCA9IHZvaWQgMDtcblx0ICAgICAgdmFyIG93blN0eWxlUHJvcGVydHlOYW1lcyA9IHZvaWQgMDtcblx0ICAgICAgdmFyIGNzc0J1aWxkID0gdm9pZCAwO1xuXHQgICAgICBpZiAodGVtcGxhdGUpIHtcblx0ICAgICAgICBhc3QgPSB0ZW1wbGF0ZS5fc3R5bGVBc3Q7XG5cdCAgICAgICAgb3duU3R5bGVQcm9wZXJ0eU5hbWVzID0gdGVtcGxhdGUuX293blByb3BlcnR5TmFtZXM7XG5cdCAgICAgICAgY3NzQnVpbGQgPSB0ZW1wbGF0ZS5fY3NzQnVpbGQ7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIF9zdHlsZUluZm8yLmRlZmF1bHQuc2V0KGhvc3QsIG5ldyBfc3R5bGVJbmZvMi5kZWZhdWx0KGFzdCwgcGxhY2Vob2xkZXIsIG93blN0eWxlUHJvcGVydHlOYW1lcywgaXMsIHR5cGVFeHRlbnNpb24sIGNzc0J1aWxkKSk7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnYXBwbHlTdHlsZScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlTdHlsZShob3N0LCBvdmVycmlkZVByb3BzKSB7XG5cdCAgICAgIHZhciBpcyA9IGhvc3QuZ2V0QXR0cmlidXRlKCdpcycpIHx8IGhvc3QubG9jYWxOYW1lO1xuXHQgICAgICB2YXIgc3R5bGVJbmZvID0gX3N0eWxlSW5mbzIuZGVmYXVsdC5nZXQoaG9zdCk7XG5cdCAgICAgIHZhciBoYXNBcHBsaWVkID0gQm9vbGVhbihzdHlsZUluZm8pO1xuXHQgICAgICBpZiAoIXN0eWxlSW5mbykge1xuXHQgICAgICAgIHN0eWxlSW5mbyA9IHRoaXMuX3ByZXBhcmVIb3N0KGhvc3QpO1xuXHQgICAgICB9XG5cdCAgICAgIC8vIE9ubHkgdHJpcCB0aGUgYGVsZW1lbnRzSGF2ZUFwcGxpZWRgIGZsYWcgaWYgYSBub2RlIG90aGVyIHRoYXQgdGhlIHJvb3QgZG9jdW1lbnQgaGFzIGBhcHBseVN0eWxlYCBjYWxsZWRcblx0ICAgICAgaWYgKCF0aGlzLl9pc1Jvb3RPd25lcihob3N0KSkge1xuXHQgICAgICAgIHRoaXMuX2VsZW1lbnRzSGF2ZUFwcGxpZWQgPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh3aW5kb3cuQ3VzdG9tU3R5bGUpIHtcblx0ICAgICAgICB2YXIgQ1MgPSB3aW5kb3cuQ3VzdG9tU3R5bGU7XG5cdCAgICAgICAgaWYgKENTLl9kb2N1bWVudERpcnR5KSB7XG5cdCAgICAgICAgICBDUy5maW5kU3R5bGVzKCk7XG5cdCAgICAgICAgICBpZiAoIXRoaXMubmF0aXZlQ3NzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVByb3BlcnRpZXModGhpcy5fZG9jdW1lbnRPd25lciwgdGhpcy5fZG9jdW1lbnRPd25lclN0eWxlSW5mbyk7XG5cdCAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm5hdGl2ZUNzc0FwcGx5KSB7XG5cdCAgICAgICAgICAgIENTLl9yZXZhbGlkYXRlQXBwbHlTaGltKCk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBDUy5hcHBseVN0eWxlcygpO1xuXHQgICAgICAgICAgLy8gaWYgbm8gZWxlbWVudHMgaGF2ZSBib290ZWQgeWV0LCB3ZSBjYW4ganVzdCB1cGRhdGUgdGhlIGRvY3VtZW50IGFuZCBiZSBkb25lXG5cdCAgICAgICAgICBpZiAoIXRoaXMuX2VsZW1lbnRzSGF2ZUFwcGxpZWQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgLy8gaWYgbm8gbmF0aXZlIGNzcyBjdXN0b20gcHJvcGVydGllcywgd2UgbXVzdCByZWNhbGN1bGF0ZSB0aGUgd2hvbGUgdHJlZVxuXHQgICAgICAgICAgaWYgKCF0aGlzLm5hdGl2ZUNzcykge1xuXHQgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlcygpO1xuXHQgICAgICAgICAgICAvKlxuXHQgICAgICAgICAgICBXaGVuIHVwZGF0ZVN0eWxlcygpIHJ1bnMsIHRoaXMgZWxlbWVudCBtYXkgbm90IGhhdmUgYSBzaGFkb3dyb290IHlldC5cblx0ICAgICAgICAgICAgSWYgbm90LCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IHRoaXMgZWxlbWVudCBydW5zIGBhcHBseVN0eWxlYCBvbiBpdHNlbGYgYXQgbGVhc3Qgb25jZSB0byBnZW5lcmF0ZSBhIHN0eWxlXG5cdCAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGlmIChoYXNBcHBsaWVkKSB7XG5cdCAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGlmIChvdmVycmlkZVByb3BzKSB7XG5cdCAgICAgICAgc3R5bGVJbmZvLm92ZXJyaWRlU3R5bGVQcm9wZXJ0aWVzID0gc3R5bGVJbmZvLm92ZXJyaWRlU3R5bGVQcm9wZXJ0aWVzIHx8IHt9O1xuXHQgICAgICAgIE9iamVjdC5hc3NpZ24oc3R5bGVJbmZvLm92ZXJyaWRlU3R5bGVQcm9wZXJ0aWVzLCBvdmVycmlkZVByb3BzKTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodGhpcy5uYXRpdmVDc3MpIHtcblx0ICAgICAgICBpZiAoc3R5bGVJbmZvLm92ZXJyaWRlU3R5bGVQcm9wZXJ0aWVzKSB7XG5cdCAgICAgICAgICB0aGlzLl91cGRhdGVOYXRpdmVQcm9wZXJ0aWVzKGhvc3QsIHN0eWxlSW5mby5vdmVycmlkZVN0eWxlUHJvcGVydGllcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB0ZW1wbGF0ZSA9IF90ZW1wbGF0ZU1hcDIuZGVmYXVsdFtpc107XG5cdCAgICAgICAgLy8gYmFpbCBlYXJseSBpZiB0aGVyZSBpcyBubyBzaGFkb3dyb290IGZvciB0aGlzIGVsZW1lbnRcblx0ICAgICAgICBpZiAoIXRlbXBsYXRlICYmICF0aGlzLl9pc1Jvb3RPd25lcihob3N0KSkge1xuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodGVtcGxhdGUgJiYgdGVtcGxhdGUuX2FwcGx5U2hpbUludmFsaWQgJiYgdGVtcGxhdGUuX3N0eWxlKSB7XG5cdCAgICAgICAgICAvLyB1cGRhdGUgdGVtcGxhdGVcblx0ICAgICAgICAgIGlmICghdGVtcGxhdGUuX3ZhbGlkYXRpbmcpIHtcblx0ICAgICAgICAgICAgX2FwcGx5U2hpbTIuZGVmYXVsdC50cmFuc2Zvcm1SdWxlcyh0ZW1wbGF0ZS5fc3R5bGVBc3QsIGlzKTtcblx0ICAgICAgICAgICAgdGVtcGxhdGUuX3N0eWxlLnRleHRDb250ZW50ID0gX3N0eWxlVHJhbnNmb3JtZXIyLmRlZmF1bHQuZWxlbWVudFN0eWxlcyhob3N0LCBzdHlsZUluZm8uc3R5bGVSdWxlcyk7XG5cdCAgICAgICAgICAgIF9zdHlsZUluZm8yLmRlZmF1bHQuc3RhcnRWYWxpZGF0aW5nKGlzKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIC8vIHVwZGF0ZSBpbnN0YW5jZSBpZiBuYXRpdmUgc2hhZG93ZG9tXG5cdCAgICAgICAgICBpZiAodGhpcy5uYXRpdmVTaGFkb3cpIHtcblx0ICAgICAgICAgICAgdmFyIHJvb3QgPSBob3N0LnNoYWRvd1Jvb3Q7XG5cdCAgICAgICAgICAgIGlmIChyb290KSB7XG5cdCAgICAgICAgICAgICAgdmFyIHN0eWxlID0gcm9vdC5xdWVyeVNlbGVjdG9yKCdzdHlsZScpO1xuXHQgICAgICAgICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gX3N0eWxlVHJhbnNmb3JtZXIyLmRlZmF1bHQuZWxlbWVudFN0eWxlcyhob3N0LCBzdHlsZUluZm8uc3R5bGVSdWxlcyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHN0eWxlSW5mby5zdHlsZVJ1bGVzID0gdGVtcGxhdGUuX3N0eWxlQXN0O1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLl91cGRhdGVQcm9wZXJ0aWVzKGhvc3QsIHN0eWxlSW5mbyk7XG5cdCAgICAgICAgaWYgKHN0eWxlSW5mby5vd25TdHlsZVByb3BlcnR5TmFtZXMgJiYgc3R5bGVJbmZvLm93blN0eWxlUHJvcGVydHlOYW1lcy5sZW5ndGgpIHtcblx0ICAgICAgICAgIHRoaXMuX2FwcGx5U3R5bGVQcm9wZXJ0aWVzKGhvc3QsIHN0eWxlSW5mbyk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGlmIChoYXNBcHBsaWVkKSB7XG5cdCAgICAgICAgdmFyIF9yb290ID0gdGhpcy5faXNSb290T3duZXIoaG9zdCkgPyBob3N0IDogaG9zdC5zaGFkb3dSb290O1xuXHQgICAgICAgIC8vIG5vdGU6IHNvbWUgZWxlbWVudHMgbWF5IG5vdCBoYXZlIGEgcm9vdCFcblx0ICAgICAgICBpZiAoX3Jvb3QpIHtcblx0ICAgICAgICAgIHRoaXMuX2FwcGx5VG9EZXNjZW5kYW50cyhfcm9vdCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX2FwcGx5VG9EZXNjZW5kYW50cycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX2FwcGx5VG9EZXNjZW5kYW50cyhyb290KSB7XG5cdCAgICAgIHZhciBjJCA9IHJvb3QuY2hpbGRyZW47XG5cdCAgICAgIGZvciAodmFyIGkgPSAwLCBjOyBpIDwgYyQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBjID0gYyRbaV07XG5cdCAgICAgICAgaWYgKGMuc2hhZG93Um9vdCkge1xuXHQgICAgICAgICAgdGhpcy5hcHBseVN0eWxlKGMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9hcHBseVRvRGVzY2VuZGFudHMoYyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdfc3R5bGVPd25lckZvck5vZGUnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF9zdHlsZU93bmVyRm9yTm9kZShub2RlKSB7XG5cdCAgICAgIHZhciByb290ID0gbm9kZS5nZXRSb290Tm9kZSgpO1xuXHQgICAgICB2YXIgaG9zdCA9IHJvb3QuaG9zdDtcblx0ICAgICAgaWYgKGhvc3QpIHtcblx0ICAgICAgICBpZiAoX3N0eWxlSW5mbzIuZGVmYXVsdC5nZXQoaG9zdCkpIHtcblx0ICAgICAgICAgIHJldHVybiBob3N0O1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICByZXR1cm4gdGhpcy5fc3R5bGVPd25lckZvck5vZGUoaG9zdCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB0aGlzLl9kb2N1bWVudE93bmVyO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ19pc1Jvb3RPd25lcicsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX2lzUm9vdE93bmVyKG5vZGUpIHtcblx0ICAgICAgcmV0dXJuIG5vZGUgPT09IHRoaXMuX2RvY3VtZW50T3duZXI7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX2FwcGx5U3R5bGVQcm9wZXJ0aWVzJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwbHlTdHlsZVByb3BlcnRpZXMoaG9zdCwgc3R5bGVJbmZvKSB7XG5cdCAgICAgIHZhciBpcyA9IGhvc3QuZ2V0QXR0cmlidXRlKCdpcycpIHx8IGhvc3QubG9jYWxOYW1lO1xuXHQgICAgICB2YXIgY2FjaGVFbnRyeSA9IHN0eWxlQ2FjaGUuZmV0Y2goaXMsIHN0eWxlSW5mby5zdHlsZVByb3BlcnRpZXMsIHN0eWxlSW5mby5vd25TdHlsZVByb3BlcnR5TmFtZXMpO1xuXHQgICAgICB2YXIgY2FjaGVkU2NvcGVTZWxlY3RvciA9IGNhY2hlRW50cnkgJiYgY2FjaGVFbnRyeS5zY29wZVNlbGVjdG9yO1xuXHQgICAgICB2YXIgY2FjaGVkU3R5bGUgPSBjYWNoZUVudHJ5ID8gY2FjaGVFbnRyeS5zdHlsZUVsZW1lbnQgOiBudWxsO1xuXHQgICAgICB2YXIgb2xkU2NvcGVTZWxlY3RvciA9IHN0eWxlSW5mby5zY29wZVNlbGVjdG9yO1xuXHQgICAgICAvLyBvbmx5IGdlbmVyYXRlIG5ldyBzY29wZSBpZiBjYWNoZWQgc3R5bGUgaXMgbm90IGZvdW5kXG5cdCAgICAgIHN0eWxlSW5mby5zY29wZVNlbGVjdG9yID0gY2FjaGVkU2NvcGVTZWxlY3RvciB8fCB0aGlzLl9nZW5lcmF0ZVNjb3BlU2VsZWN0b3IoaXMpO1xuXHQgICAgICB2YXIgc3R5bGUgPSBfc3R5bGVQcm9wZXJ0aWVzMi5kZWZhdWx0LmFwcGx5RWxlbWVudFN0eWxlKGhvc3QsIHN0eWxlSW5mby5zdHlsZVByb3BlcnRpZXMsIHN0eWxlSW5mby5zY29wZVNlbGVjdG9yLCBjYWNoZWRTdHlsZSk7XG5cdCAgICAgIGlmICghdGhpcy5uYXRpdmVTaGFkb3cpIHtcblx0ICAgICAgICBfc3R5bGVQcm9wZXJ0aWVzMi5kZWZhdWx0LmFwcGx5RWxlbWVudFNjb3BlU2VsZWN0b3IoaG9zdCwgc3R5bGVJbmZvLnNjb3BlU2VsZWN0b3IsIG9sZFNjb3BlU2VsZWN0b3IpO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICghY2FjaGVFbnRyeSkge1xuXHQgICAgICAgIHN0eWxlQ2FjaGUuc3RvcmUoaXMsIHN0eWxlSW5mby5zdHlsZVByb3BlcnRpZXMsIHN0eWxlLCBzdHlsZUluZm8uc2NvcGVTZWxlY3Rvcik7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHN0eWxlO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ191cGRhdGVQcm9wZXJ0aWVzJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlUHJvcGVydGllcyhob3N0LCBzdHlsZUluZm8pIHtcblx0ICAgICAgdmFyIG93bmVyID0gdGhpcy5fc3R5bGVPd25lckZvck5vZGUoaG9zdCk7XG5cdCAgICAgIHZhciBvd25lclN0eWxlSW5mbyA9IF9zdHlsZUluZm8yLmRlZmF1bHQuZ2V0KG93bmVyKTtcblx0ICAgICAgdmFyIG93bmVyUHJvcGVydGllcyA9IG93bmVyU3R5bGVJbmZvLnN0eWxlUHJvcGVydGllcztcblx0ICAgICAgdmFyIHByb3BzID0gT2JqZWN0LmNyZWF0ZShvd25lclByb3BlcnRpZXMgfHwgbnVsbCk7XG5cdCAgICAgIHZhciBob3N0QW5kUm9vdFByb3BzID0gX3N0eWxlUHJvcGVydGllczIuZGVmYXVsdC5ob3N0QW5kUm9vdFByb3BlcnRpZXNGb3JTY29wZShob3N0LCBzdHlsZUluZm8uc3R5bGVSdWxlcyk7XG5cdCAgICAgIHZhciBwcm9wZXJ0eURhdGEgPSBfc3R5bGVQcm9wZXJ0aWVzMi5kZWZhdWx0LnByb3BlcnR5RGF0YUZyb21TdHlsZXMob3duZXJTdHlsZUluZm8uc3R5bGVSdWxlcywgaG9zdCk7XG5cdCAgICAgIHZhciBwcm9wZXJ0aWVzTWF0Y2hpbmdIb3N0ID0gcHJvcGVydHlEYXRhLnByb3BlcnRpZXM7XG5cdCAgICAgIE9iamVjdC5hc3NpZ24ocHJvcHMsIGhvc3RBbmRSb290UHJvcHMuaG9zdFByb3BzLCBwcm9wZXJ0aWVzTWF0Y2hpbmdIb3N0LCBob3N0QW5kUm9vdFByb3BzLnJvb3RQcm9wcyk7XG5cdCAgICAgIHRoaXMuX21peGluT3ZlcnJpZGVTdHlsZXMocHJvcHMsIHN0eWxlSW5mby5vdmVycmlkZVN0eWxlUHJvcGVydGllcyk7XG5cdCAgICAgIF9zdHlsZVByb3BlcnRpZXMyLmRlZmF1bHQucmVpZnkocHJvcHMpO1xuXHQgICAgICBzdHlsZUluZm8uc3R5bGVQcm9wZXJ0aWVzID0gcHJvcHM7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX21peGluT3ZlcnJpZGVTdHlsZXMnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF9taXhpbk92ZXJyaWRlU3R5bGVzKHByb3BzLCBvdmVycmlkZXMpIHtcblx0ICAgICAgZm9yICh2YXIgcCBpbiBvdmVycmlkZXMpIHtcblx0ICAgICAgICB2YXIgdiA9IG92ZXJyaWRlc1twXTtcblx0ICAgICAgICAvLyBza2lwIG92ZXJyaWRlIHByb3BzIGlmIHRoZXkgYXJlIG5vdCB0cnV0aHkgb3IgMFxuXHQgICAgICAgIC8vIGluIG9yZGVyIHRvIGZhbGwgYmFjayB0byBpbmhlcml0ZWQgdmFsdWVzXG5cdCAgICAgICAgaWYgKHYgfHwgdiA9PT0gMCkge1xuXHQgICAgICAgICAgcHJvcHNbcF0gPSB2O1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ191cGRhdGVOYXRpdmVQcm9wZXJ0aWVzJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlTmF0aXZlUHJvcGVydGllcyhlbGVtZW50LCBwcm9wZXJ0aWVzKSB7XG5cdCAgICAgIC8vIHJlbW92ZSBwcmV2aW91cyBwcm9wZXJ0aWVzXG5cdCAgICAgIGZvciAodmFyIHAgaW4gcHJvcGVydGllcykge1xuXHQgICAgICAgIC8vIE5PVEU6IGZvciBiYyB3aXRoIHNoaW0sIGRvbid0IGFwcGx5IG51bGwgdmFsdWVzLlxuXHQgICAgICAgIGlmIChwID09PSBudWxsKSB7XG5cdCAgICAgICAgICBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KHApO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KHAsIHByb3BlcnRpZXNbcF0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ3VwZGF0ZVN0eWxlcycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU3R5bGVzKHByb3BlcnRpZXMpIHtcblx0ICAgICAgdGhpcy5hcHBseVN0eWxlKHRoaXMuX2RvY3VtZW50T3duZXIsIHByb3BlcnRpZXMpO1xuXHQgICAgfVxuXHQgICAgLyogQ3VzdG9tIFN0eWxlIG9wZXJhdGlvbnMgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX3RyYW5zZm9ybUN1c3RvbVN0eWxlRm9yRG9jdW1lbnQnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF90cmFuc2Zvcm1DdXN0b21TdHlsZUZvckRvY3VtZW50KHN0eWxlKSB7XG5cdCAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdFxuXHQgICAgICB2YXIgYXN0ID0gU3R5bGVVdGlsLnJ1bGVzRm9yU3R5bGUoc3R5bGUpO1xuXHQgICAgICBTdHlsZVV0aWwuZm9yRWFjaFJ1bGUoYXN0LCBmdW5jdGlvbiAocnVsZSkge1xuXHQgICAgICAgIGlmIChfc3R5bGVTZXR0aW5ncy5uYXRpdmVTaGFkb3cpIHtcblx0ICAgICAgICAgIF9zdHlsZVRyYW5zZm9ybWVyMi5kZWZhdWx0Lm5vcm1hbGl6ZVJvb3RTZWxlY3RvcihydWxlKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgX3N0eWxlVHJhbnNmb3JtZXIyLmRlZmF1bHQuZG9jdW1lbnRSdWxlKHJ1bGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoX3RoaXMubmF0aXZlQ3NzICYmICFfdGhpcy5uYXRpdmVDc3NBcHBseSkge1xuXHQgICAgICAgICAgX2FwcGx5U2hpbTIuZGVmYXVsdC50cmFuc2Zvcm1SdWxlKHJ1bGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICAgIGlmICh0aGlzLm5hdGl2ZUNzcykge1xuXHQgICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gU3R5bGVVdGlsLnRvQ3NzVGV4dChhc3QpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMuX2RvY3VtZW50T3duZXJTdHlsZUluZm8uc3R5bGVSdWxlcy5ydWxlcy5wdXNoKGFzdCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdfcmV2YWxpZGF0ZUFwcGx5U2hpbScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX3JldmFsaWRhdGVBcHBseVNoaW0oc3R5bGUpIHtcblx0ICAgICAgaWYgKHRoaXMubmF0aXZlQ3NzICYmICF0aGlzLm5hdGl2ZUNzc0FwcGx5KSB7XG5cdCAgICAgICAgdmFyIGFzdCA9IFN0eWxlVXRpbC5ydWxlc0ZvclN0eWxlKHN0eWxlKTtcblx0ICAgICAgICBfYXBwbHlTaGltMi5kZWZhdWx0LnRyYW5zZm9ybVJ1bGVzKGFzdCk7XG5cdCAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBTdHlsZVV0aWwudG9Dc3NUZXh0KGFzdCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdfYXBwbHlDdXN0b21TdHlsZVRvRG9jdW1lbnQnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBseUN1c3RvbVN0eWxlVG9Eb2N1bWVudChzdHlsZSkge1xuXHQgICAgICBpZiAoIXRoaXMubmF0aXZlQ3NzKSB7XG5cdCAgICAgICAgX3N0eWxlUHJvcGVydGllczIuZGVmYXVsdC5hcHBseUN1c3RvbVN0eWxlKHN0eWxlLCB0aGlzLl9kb2N1bWVudE93bmVyU3R5bGVJbmZvLnN0eWxlUHJvcGVydGllcyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdnZXRDb21wdXRlZFN0eWxlVmFsdWUnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGVWYWx1ZShlbGVtZW50LCBwcm9wZXJ0eSkge1xuXHQgICAgICB2YXIgdmFsdWUgPSB2b2lkIDA7XG5cdCAgICAgIGlmICghdGhpcy5uYXRpdmVDc3MpIHtcblx0ICAgICAgICAvLyBlbGVtZW50IGlzIGVpdGhlciBhIHN0eWxlIGhvc3QsIG9yIGFuIGFuY2VzdG9yIG9mIGEgc3R5bGUgaG9zdFxuXHQgICAgICAgIHZhciBzdHlsZUluZm8gPSBfc3R5bGVJbmZvMi5kZWZhdWx0LmdldChlbGVtZW50KSB8fCBfc3R5bGVJbmZvMi5kZWZhdWx0LmdldCh0aGlzLl9zdHlsZU93bmVyRm9yTm9kZShlbGVtZW50KSk7XG5cdCAgICAgICAgdmFsdWUgPSBzdHlsZUluZm8uc3R5bGVQcm9wZXJ0aWVzW3Byb3BlcnR5XTtcblx0ICAgICAgfVxuXHQgICAgICAvLyBmYWxsIGJhY2sgdG8gdGhlIHByb3BlcnR5IHZhbHVlIGZyb20gdGhlIGNvbXB1dGVkIHN0eWxpbmdcblx0ICAgICAgdmFsdWUgPSB2YWx1ZSB8fCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcblx0ICAgICAgLy8gdHJpbSB3aGl0ZXNwYWNlIHRoYXQgY2FuIGNvbWUgYWZ0ZXIgdGhlIGA6YCBpbiBjc3Ncblx0ICAgICAgLy8gZXhhbXBsZTogcGFkZGluZzogMnB4IC0+IFwiIDJweFwiXG5cdCAgICAgIHJldHVybiB2YWx1ZS50cmltKCk7XG5cdCAgICB9XG5cdCAgICAvLyBnaXZlbiBhbiBlbGVtZW50IGFuZCBhIGNsYXNzU3RyaW5nLCByZXBsYWNlc1xuXHQgICAgLy8gdGhlIGVsZW1lbnQncyBjbGFzcyB3aXRoIHRoZSBwcm92aWRlZCBjbGFzc1N0cmluZyBhbmQgYWRkc1xuXHQgICAgLy8gYW55IG5lY2Vzc2FyeSBTaGFkeUNTUyBzdGF0aWMgYW5kIHByb3BlcnR5IGJhc2VkIHNjb3Bpbmcgc2VsZWN0b3JzXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ3NldEVsZW1lbnRDbGFzcycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RWxlbWVudENsYXNzKGVsZW1lbnQsIGNsYXNzU3RyaW5nKSB7XG5cdCAgICAgIHZhciByb290ID0gZWxlbWVudC5nZXRSb290Tm9kZSgpO1xuXHQgICAgICB2YXIgY2xhc3NlcyA9IGNsYXNzU3RyaW5nID8gY2xhc3NTdHJpbmcuc3BsaXQoL1xccy8pIDogW107XG5cdCAgICAgIHZhciBzY29wZU5hbWUgPSByb290Lmhvc3QgJiYgcm9vdC5ob3N0LmxvY2FsTmFtZTtcblx0ICAgICAgLy8gSWYgbm8gc2NvcGUsIHRyeSB0byBkaXNjb3ZlciBzY29wZSBuYW1lIGZyb20gZXhpc3RpbmcgY2xhc3MuXG5cdCAgICAgIC8vIFRoaXMgY2FuIG9jY3VyIGlmLCBmb3IgZXhhbXBsZSwgYSB0ZW1wbGF0ZSBzdGFtcGVkIGVsZW1lbnQgdGhhdFxuXHQgICAgICAvLyBoYXMgYmVlbiBzY29wZWQgaXMgbWFuaXB1bGF0ZWQgd2hlbiBub3QgaW4gYSByb290LlxuXHQgICAgICBpZiAoIXNjb3BlTmFtZSkge1xuXHQgICAgICAgIHZhciBjbGFzc0F0dHIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnY2xhc3MnKTtcblx0ICAgICAgICBpZiAoY2xhc3NBdHRyKSB7XG5cdCAgICAgICAgICB2YXIgayQgPSBjbGFzc0F0dHIuc3BsaXQoL1xccy8pO1xuXHQgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrJC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBpZiAoayRbaV0gPT09IF9zdHlsZVRyYW5zZm9ybWVyMi5kZWZhdWx0LlNDT1BFX05BTUUpIHtcblx0ICAgICAgICAgICAgICBzY29wZU5hbWUgPSBrJFtpICsgMV07XG5cdCAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHNjb3BlTmFtZSkge1xuXHQgICAgICAgIGNsYXNzZXMucHVzaChfc3R5bGVUcmFuc2Zvcm1lcjIuZGVmYXVsdC5TQ09QRV9OQU1FLCBzY29wZU5hbWUpO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICghdGhpcy5uYXRpdmVDc3MpIHtcblx0ICAgICAgICB2YXIgc3R5bGVJbmZvID0gX3N0eWxlSW5mbzIuZGVmYXVsdC5nZXQoZWxlbWVudCk7XG5cdCAgICAgICAgaWYgKHN0eWxlSW5mbyAmJiBzdHlsZUluZm8uc2NvcGVTZWxlY3Rvcikge1xuXHQgICAgICAgICAgY2xhc3Nlcy5wdXNoKF9zdHlsZVByb3BlcnRpZXMyLmRlZmF1bHQuWFNDT1BFX05BTUUsIHN0eWxlSW5mby5zY29wZVNlbGVjdG9yKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgU3R5bGVVdGlsLnNldEVsZW1lbnRDbGFzc1JhdyhlbGVtZW50LCBjbGFzc2VzLmpvaW4oJyAnKSk7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX3N0eWxlSW5mb0Zvck5vZGUnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF9zdHlsZUluZm9Gb3JOb2RlKG5vZGUpIHtcblx0ICAgICAgcmV0dXJuIF9zdHlsZUluZm8yLmRlZmF1bHQuZ2V0KG5vZGUpO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ25hdGl2ZVNoYWRvdycsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgcmV0dXJuIF9zdHlsZVNldHRpbmdzLm5hdGl2ZVNoYWRvdztcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICduYXRpdmVDc3MnLFxuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgIHJldHVybiBfc3R5bGVTZXR0aW5ncy5uYXRpdmVDc3NWYXJpYWJsZXM7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnbmF0aXZlQ3NzQXBwbHknLFxuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgIHJldHVybiBfc3R5bGVTZXR0aW5ncy5uYXRpdmVDc3NBcHBseTtcblx0ICAgIH1cblx0ICB9XSk7XG5cdFxuXHQgIHJldHVybiBTaGFkeUNTUztcblx0fSgpO1xuXHRcblx0d2luZG93WydTaGFkeUNTUyddID0gbmV3IFNoYWR5Q1NTKCk7XG5cbi8qKiovIH0sXG4vKiA2OSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0LyoqXG5cdEBsaWNlbnNlXG5cdENvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cdFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblx0VGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblx0VGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5cdENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5cdHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG5cdCovXG5cdFxuXHQvKlxuXHRFeHRyZW1lbHkgc2ltcGxlIGNzcyBwYXJzZXIuIEludGVuZGVkIHRvIGJlIG5vdCBtb3JlIHRoYW4gd2hhdCB3ZSBuZWVkXG5cdGFuZCBkZWZpbml0ZWx5IG5vdCBuZWNlc3NhcmlseSBjb3JyZWN0ID0pLlxuXHQqL1xuXHRcblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0Ly8gZ2l2ZW4gYSBzdHJpbmcgb2YgY3NzLCByZXR1cm4gYSBzaW1wbGUgcnVsZSB0cmVlXG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0ZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuXHRleHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcblx0ZXhwb3J0cy5yZW1vdmVDdXN0b21Qcm9wQXNzaWdubWVudCA9IHJlbW92ZUN1c3RvbVByb3BBc3NpZ25tZW50O1xuXHRmdW5jdGlvbiBwYXJzZSh0ZXh0KSB7XG5cdCAgdGV4dCA9IGNsZWFuKHRleHQpO1xuXHQgIHJldHVybiBwYXJzZUNzcyhsZXgodGV4dCksIHRleHQpO1xuXHR9XG5cdFxuXHQvLyByZW1vdmUgc3R1ZmYgd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGF0IG1heSBoaW5kZXIgcGFyc2luZ1xuXHRmdW5jdGlvbiBjbGVhbihjc3NUZXh0KSB7XG5cdCAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShSWC5jb21tZW50cywgJycpLnJlcGxhY2UoUlgucG9ydCwgJycpO1xuXHR9XG5cdFxuXHQvLyBzdXBlciBzaW1wbGUgey4uLn0gbGV4ZXIgdGhhdCByZXR1cm5zIGEgbm9kZSB0cmVlXG5cdGZ1bmN0aW9uIGxleCh0ZXh0KSB7XG5cdCAgdmFyIHJvb3QgPSB7XG5cdCAgICBzdGFydDogMCxcblx0ICAgIGVuZDogdGV4dC5sZW5ndGhcblx0ICB9O1xuXHQgIHZhciBuID0gcm9vdDtcblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IHRleHQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdCAgICBpZiAodGV4dFtpXSA9PT0gT1BFTl9CUkFDRSkge1xuXHQgICAgICBpZiAoIW4ucnVsZXMpIHtcblx0ICAgICAgICBuLnJ1bGVzID0gW107XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIHAgPSBuO1xuXHQgICAgICB2YXIgcHJldmlvdXMgPSBwLnJ1bGVzW3AucnVsZXMubGVuZ3RoIC0gMV07XG5cdCAgICAgIG4gPSB7XG5cdCAgICAgICAgc3RhcnQ6IGkgKyAxLFxuXHQgICAgICAgIHBhcmVudDogcCxcblx0ICAgICAgICBwcmV2aW91czogcHJldmlvdXNcblx0ICAgICAgfTtcblx0ICAgICAgcC5ydWxlcy5wdXNoKG4pO1xuXHQgICAgfSBlbHNlIGlmICh0ZXh0W2ldID09PSBDTE9TRV9CUkFDRSkge1xuXHQgICAgICBuLmVuZCA9IGkgKyAxO1xuXHQgICAgICBuID0gbi5wYXJlbnQgfHwgcm9vdDtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHJvb3Q7XG5cdH1cblx0XG5cdC8vIGFkZCBzZWxlY3RvcnMvY3NzVGV4dCB0byBub2RlIHRyZWVcblx0ZnVuY3Rpb24gcGFyc2VDc3Mobm9kZSwgdGV4dCkge1xuXHQgIHZhciB0ID0gdGV4dC5zdWJzdHJpbmcobm9kZS5zdGFydCwgbm9kZS5lbmQgLSAxKTtcblx0ICBub2RlLnBhcnNlZENzc1RleHQgPSBub2RlLmNzc1RleHQgPSB0LnRyaW0oKTtcblx0ICBpZiAobm9kZS5wYXJlbnQpIHtcblx0ICAgIHZhciBzcyA9IG5vZGUucHJldmlvdXMgPyBub2RlLnByZXZpb3VzLmVuZCA6IG5vZGUucGFyZW50LnN0YXJ0O1xuXHQgICAgdCA9IHRleHQuc3Vic3RyaW5nKHNzLCBub2RlLnN0YXJ0IC0gMSk7XG5cdCAgICB0ID0gX2V4cGFuZFVuaWNvZGVFc2NhcGVzKHQpO1xuXHQgICAgdCA9IHQucmVwbGFjZShSWC5tdWx0aXBsZVNwYWNlcywgJyAnKTtcblx0ICAgIC8vIFRPRE8oc29ydmVsbCk6IGFkIGhvYzsgbWFrZSBzZWxlY3RvciBpbmNsdWRlIG9ubHkgYWZ0ZXIgbGFzdCA7XG5cdCAgICAvLyBoZWxwcyB3aXRoIG1peGluIHN5bnRheFxuXHQgICAgdCA9IHQuc3Vic3RyaW5nKHQubGFzdEluZGV4T2YoJzsnKSArIDEpO1xuXHQgICAgdmFyIHMgPSBub2RlLnBhcnNlZFNlbGVjdG9yID0gbm9kZS5zZWxlY3RvciA9IHQudHJpbSgpO1xuXHQgICAgbm9kZS5hdFJ1bGUgPSBzLmluZGV4T2YoQVRfU1RBUlQpID09PSAwO1xuXHQgICAgLy8gbm90ZSwgc3VwcG9ydCBhIHN1YnNldCBvZiBydWxlIHR5cGVzLi4uXG5cdCAgICBpZiAobm9kZS5hdFJ1bGUpIHtcblx0ICAgICAgaWYgKHMuaW5kZXhPZihNRURJQV9TVEFSVCkgPT09IDApIHtcblx0ICAgICAgICBub2RlLnR5cGUgPSB0eXBlcy5NRURJQV9SVUxFO1xuXHQgICAgICB9IGVsc2UgaWYgKHMubWF0Y2goUlgua2V5ZnJhbWVzUnVsZSkpIHtcblx0ICAgICAgICBub2RlLnR5cGUgPSB0eXBlcy5LRVlGUkFNRVNfUlVMRTtcblx0ICAgICAgICBub2RlLmtleWZyYW1lc05hbWUgPSBub2RlLnNlbGVjdG9yLnNwbGl0KFJYLm11bHRpcGxlU3BhY2VzKS5wb3AoKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaWYgKHMuaW5kZXhPZihWQVJfU1RBUlQpID09PSAwKSB7XG5cdCAgICAgICAgbm9kZS50eXBlID0gdHlwZXMuTUlYSU5fUlVMRTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBub2RlLnR5cGUgPSB0eXBlcy5TVFlMRV9SVUxFO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHQgIHZhciByJCA9IG5vZGUucnVsZXM7XG5cdCAgaWYgKHIkKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMCwgbCA9IHIkLmxlbmd0aCwgcjsgaSA8IGwgJiYgKHIgPSByJFtpXSk7IGkrKykge1xuXHQgICAgICBwYXJzZUNzcyhyLCB0ZXh0KTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIG5vZGU7XG5cdH1cblx0XG5cdC8vIGNvbnZlcnNpb24gb2Ygc29ydCB1bmljb2RlIGVzY2FwZXMgd2l0aCBzcGFjZXMgbGlrZSBgXFwzMyBgIChhbmQgbG9uZ2VyKSBpbnRvXG5cdC8vIGV4cGFuZGVkIGZvcm0gdGhhdCBkb2Vzbid0IHJlcXVpcmUgdHJhaWxpbmcgc3BhY2UgYFxcMDAwMDMzYFxuXHRmdW5jdGlvbiBfZXhwYW5kVW5pY29kZUVzY2FwZXMocykge1xuXHQgIHJldHVybiBzLnJlcGxhY2UoL1xcXFwoWzAtOWEtZl17MSw2fSlcXHMvZ2ksIGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBjb2RlID0gYXJndW1lbnRzWzFdLFxuXHQgICAgICAgIHJlcGVhdCA9IDYgLSBjb2RlLmxlbmd0aDtcblx0ICAgIHdoaWxlIChyZXBlYXQtLSkge1xuXHQgICAgICBjb2RlID0gJzAnICsgY29kZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiAnXFxcXCcgKyBjb2RlO1xuXHQgIH0pO1xuXHR9XG5cdFxuXHQvLyBzdHJpbmdpZnkgcGFyc2VkIGNzcy5cblx0ZnVuY3Rpb24gc3RyaW5naWZ5KG5vZGUsIHByZXNlcnZlUHJvcGVydGllcywgdGV4dCkge1xuXHQgIHRleHQgPSB0ZXh0IHx8ICcnO1xuXHQgIC8vIGNhbGMgcnVsZSBjc3NUZXh0XG5cdCAgdmFyIGNzc1RleHQgPSAnJztcblx0ICBpZiAobm9kZS5jc3NUZXh0IHx8IG5vZGUucnVsZXMpIHtcblx0ICAgIHZhciByJCA9IG5vZGUucnVsZXM7XG5cdCAgICBpZiAociQgJiYgIV9oYXNNaXhpblJ1bGVzKHIkKSkge1xuXHQgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHIkLmxlbmd0aCwgcjsgaSA8IGwgJiYgKHIgPSByJFtpXSk7IGkrKykge1xuXHQgICAgICAgIGNzc1RleHQgPSBzdHJpbmdpZnkociwgcHJlc2VydmVQcm9wZXJ0aWVzLCBjc3NUZXh0KTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgY3NzVGV4dCA9IHByZXNlcnZlUHJvcGVydGllcyA/IG5vZGUuY3NzVGV4dCA6IHJlbW92ZUN1c3RvbVByb3BzKG5vZGUuY3NzVGV4dCk7XG5cdCAgICAgIGNzc1RleHQgPSBjc3NUZXh0LnRyaW0oKTtcblx0ICAgICAgaWYgKGNzc1RleHQpIHtcblx0ICAgICAgICBjc3NUZXh0ID0gJyAgJyArIGNzc1RleHQgKyAnXFxuJztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0ICAvLyBlbWl0IHJ1bGUgaWYgdGhlcmUgaXMgY3NzVGV4dFxuXHQgIGlmIChjc3NUZXh0KSB7XG5cdCAgICBpZiAobm9kZS5zZWxlY3Rvcikge1xuXHQgICAgICB0ZXh0ICs9IG5vZGUuc2VsZWN0b3IgKyAnICcgKyBPUEVOX0JSQUNFICsgJ1xcbic7XG5cdCAgICB9XG5cdCAgICB0ZXh0ICs9IGNzc1RleHQ7XG5cdCAgICBpZiAobm9kZS5zZWxlY3Rvcikge1xuXHQgICAgICB0ZXh0ICs9IENMT1NFX0JSQUNFICsgJ1xcblxcbic7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiB0ZXh0O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBfaGFzTWl4aW5SdWxlcyhydWxlcykge1xuXHQgIHJldHVybiBydWxlc1swXS5zZWxlY3Rvci5pbmRleE9mKFZBUl9TVEFSVCkgPT09IDA7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHJlbW92ZUN1c3RvbVByb3BzKGNzc1RleHQpIHtcblx0ICBjc3NUZXh0ID0gcmVtb3ZlQ3VzdG9tUHJvcEFzc2lnbm1lbnQoY3NzVGV4dCk7XG5cdCAgcmV0dXJuIHJlbW92ZUN1c3RvbVByb3BBcHBseShjc3NUZXh0KTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gcmVtb3ZlQ3VzdG9tUHJvcEFzc2lnbm1lbnQoY3NzVGV4dCkge1xuXHQgIHJldHVybiBjc3NUZXh0LnJlcGxhY2UoUlguY3VzdG9tUHJvcCwgJycpLnJlcGxhY2UoUlgubWl4aW5Qcm9wLCAnJyk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHJlbW92ZUN1c3RvbVByb3BBcHBseShjc3NUZXh0KSB7XG5cdCAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShSWC5taXhpbkFwcGx5LCAnJykucmVwbGFjZShSWC52YXJBcHBseSwgJycpO1xuXHR9XG5cdFxuXHR2YXIgdHlwZXMgPSBleHBvcnRzLnR5cGVzID0ge1xuXHQgIFNUWUxFX1JVTEU6IDEsXG5cdCAgS0VZRlJBTUVTX1JVTEU6IDcsXG5cdCAgTUVESUFfUlVMRTogNCxcblx0ICBNSVhJTl9SVUxFOiAxMDAwXG5cdH07XG5cdFxuXHR2YXIgT1BFTl9CUkFDRSA9ICd7Jztcblx0dmFyIENMT1NFX0JSQUNFID0gJ30nO1xuXHRcblx0Ly8gaGVscGVyIHJlZ2V4cCdzXG5cdHZhciBSWCA9IHtcblx0ICBjb21tZW50czogL1xcL1xcKlteKl0qXFwqKyhbXi8qXVteKl0qXFwqKykqXFwvL2dpbSxcblx0ICBwb3J0OiAvQGltcG9ydFteO10qOy9naW0sXG5cdCAgY3VzdG9tUHJvcDogLyg/Ol5bXjtcXC1cXHN9XSspPy0tW147e31dKj86W157fTtdKj8oPzpbO1xcbl18JCkvZ2ltLFxuXHQgIG1peGluUHJvcDogLyg/Ol5bXjtcXC1cXHN9XSspPy0tW147e31dKj86W157fTtdKj97W159XSo/fSg/Ols7XFxuXXwkKT8vZ2ltLFxuXHQgIG1peGluQXBwbHk6IC9AYXBwbHlcXHMqXFwoP1teKTtdKlxcKT9cXHMqKD86WztcXG5dfCQpPy9naW0sXG5cdCAgdmFyQXBwbHk6IC9bXjs6XSo/OlteO10qP3ZhclxcKFteO10qXFwpKD86WztcXG5dfCQpPy9naW0sXG5cdCAga2V5ZnJhbWVzUnVsZTogL15AW15cXHNdKmtleWZyYW1lcy8sXG5cdCAgbXVsdGlwbGVTcGFjZXM6IC9cXHMrL2dcblx0fTtcblx0XG5cdHZhciBWQVJfU1RBUlQgPSAnLS0nO1xuXHR2YXIgTUVESUFfU1RBUlQgPSAnQG1lZGlhJztcblx0dmFyIEFUX1NUQVJUID0gJ0AnO1xuXG4vKioqLyB9LFxuLyogNzAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qKlxuXHRAbGljZW5zZVxuXHRDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXHRUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5cdFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5cdFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuXHRDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuXHRzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuXHQqL1xuXHRcblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdHZhciBuYXRpdmVTaGFkb3cgPSBleHBvcnRzLm5hdGl2ZVNoYWRvdyA9ICEod2luZG93LlNoYWR5RE9NICYmIHdpbmRvdy5TaGFkeURPTS5pblVzZSk7XG5cdC8vIGNocm9tZSA0OSBoYXMgc2VtaS13b3JraW5nIGNzcyB2YXJzLCBjaGVjayBpZiBib3gtc2hhZG93IHdvcmtzXG5cdC8vIHNhZmFyaSA5LjEgaGFzIGEgcmVjYWxjIGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NTc4MlxuXHR2YXIgbmF0aXZlQ3NzVmFyaWFibGVzID0gZXhwb3J0cy5uYXRpdmVDc3NWYXJpYWJsZXMgPSAhbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgnQXBwbGVXZWJLaXQvNjAxJykgJiYgd2luZG93LkNTUyAmJiBDU1Muc3VwcG9ydHMgJiYgQ1NTLnN1cHBvcnRzKCdib3gtc2hhZG93JywgJzAgMCAwIHZhcigtLWZvbyknKTtcblx0XG5cdC8vIGV4cGVyaW1lbnRhbCBzdXBwb3J0IGZvciBuYXRpdmUgQGFwcGx5XG5cdGZ1bmN0aW9uIGRldGVjdE5hdGl2ZUFwcGx5KCkge1xuXHQgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cdCAgc3R5bGUudGV4dENvbnRlbnQgPSAnLmZvbyB7IEBhcHBseSAtLWZvbyB9Jztcblx0ICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcblx0ICB2YXIgbmF0aXZlQ3NzQXBwbHkgPSBzdHlsZS5zaGVldC5jc3NSdWxlc1swXS5jc3NUZXh0LmluZGV4T2YoJ2FwcGx5JykgPj0gMDtcblx0ICBkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKHN0eWxlKTtcblx0ICByZXR1cm4gbmF0aXZlQ3NzQXBwbHk7XG5cdH1cblx0XG5cdHZhciBuYXRpdmVDc3NBcHBseSA9IGV4cG9ydHMubmF0aXZlQ3NzQXBwbHkgPSBmYWxzZSAmJiBkZXRlY3ROYXRpdmVBcHBseSgpO1xuXHRcblx0ZnVuY3Rpb24gcGFyc2VTZXR0aW5ncyhzZXR0aW5ncykge1xuXHQgIGlmIChzZXR0aW5ncykge1xuXHQgICAgZXhwb3J0cy5uYXRpdmVDc3NWYXJpYWJsZXMgPSBuYXRpdmVDc3NWYXJpYWJsZXMgPSBuYXRpdmVDc3NWYXJpYWJsZXMgJiYgIXNldHRpbmdzLnNoaW1jc3Nwcm9wZXJ0aWVzO1xuXHQgICAgZXhwb3J0cy5uYXRpdmVTaGFkb3cgPSBuYXRpdmVTaGFkb3cgPSBuYXRpdmVTaGFkb3cgJiYgIXNldHRpbmdzLnNoaW1zaGFkb3c7XG5cdCAgfVxuXHR9XG5cdFxuXHRpZiAod2luZG93LlNoYWR5Q1NTKSB7XG5cdCAgcGFyc2VTZXR0aW5ncyh3aW5kb3cuU2hhZHlDU1MpO1xuXHR9IGVsc2UgaWYgKHdpbmRvdy5XZWJDb21wb25lbnRzKSB7XG5cdCAgcGFyc2VTZXR0aW5ncyh3aW5kb3cuV2ViQ29tcG9uZW50cy5mbGFncyk7XG5cdH1cblxuLyoqKi8gfSxcbi8qIDcxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKipcblx0QGxpY2Vuc2Vcblx0Q29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0VGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuXHRUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuXHRUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcblx0Q29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cblx0c3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcblx0Ki9cblx0XG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblx0XG5cdHZhciBfc3R5bGVVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Mik7XG5cdFxuXHR2YXIgU3R5bGVVdGlsID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3N0eWxlVXRpbCk7XG5cdFxuXHR2YXIgX3N0eWxlU2V0dGluZ3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0LyogVHJhbnNmb3JtcyBTaGFkb3dET00gc3R5bGluZyBpbnRvIFNoYWR5RE9NIHN0eWxpbmdcblx0XG5cdCogc2NvcGluZzpcblx0XG5cdCAgKiBlbGVtZW50cyBpbiBzY29wZSBnZXQgc2NvcGluZyBzZWxlY3RvciBjbGFzcz1cIngtZm9vLXNjb3BlXCJcblx0ICAqIHNlbGVjdG9ycyByZS13cml0dGVuIGFzIGZvbGxvd3M6XG5cdFxuXHQgICAgZGl2IGJ1dHRvbiAtPiBkaXYueC1mb28tc2NvcGUgYnV0dG9uLngtZm9vLXNjb3BlXG5cdFxuXHQqIDpob3N0IC0+IHNjb3BlTmFtZVxuXHRcblx0KiA6aG9zdCguLi4pIC0+IHNjb3BlTmFtZS4uLlxuXHRcblx0KiA6OnNsb3R0ZWQoLi4uKSAtPiBzY29wZU5hbWUgPiAuLi5cblx0XG5cdCogLi4uOmRpcihsdHJ8cnRsKSAtPiBbZGlyPVwibHRyfHJ0bFwiXSAuLi4sIC4uLltkaXI9XCJsdHJ8cnRsXCJdXG5cdFxuXHQqIDpob3N0KDpkaXJbcnRsXSkgLT4gc2NvcGVOYW1lOmRpcihydGwpIC0+IFtkaXI9XCJydGxcIl0gc2NvcGVOYW1lLCBzY29wZU5hbWVbZGlyPVwicnRsXCJdXG5cdFxuXHQqL1xuXHR2YXIgU0NPUEVfTkFNRSA9ICdzdHlsZS1zY29wZSc7XG5cdFxuXHR2YXIgU3R5bGVUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBTdHlsZVRyYW5zZm9ybWVyKCkge1xuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0eWxlVHJhbnNmb3JtZXIpO1xuXHQgIH1cblx0XG5cdCAgX2NyZWF0ZUNsYXNzKFN0eWxlVHJhbnNmb3JtZXIsIFt7XG5cdCAgICBrZXk6ICdkb20nLFxuXHRcblx0ICAgIC8vIEdpdmVuIGEgbm9kZSBhbmQgc2NvcGUgbmFtZSwgYWRkIGEgc2NvcGluZyBjbGFzcyB0byBlYWNoIG5vZGVcblx0ICAgIC8vIGluIHRoZSB0cmVlLiBUaGlzIGZhY2lsaXRhdGVzIHRyYW5zZm9ybWluZyBjc3MgaW50byBzY29wZWQgcnVsZXMuXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZG9tKG5vZGUsIHNjb3BlLCBzaG91bGRSZW1vdmVTY29wZSkge1xuXHQgICAgICAvLyBvbmUgdGltZSBvcHRpbWl6YXRpb24gdG8gc2tpcCBzY29waW5nLi4uXG5cdCAgICAgIGlmIChub2RlLl9fc3R5bGVTY29wZWQpIHtcblx0ICAgICAgICBub2RlLl9fc3R5bGVTY29wZWQgPSBudWxsO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMuX3RyYW5zZm9ybURvbShub2RlLCBzY29wZSB8fCAnJywgc2hvdWxkUmVtb3ZlU2NvcGUpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX3RyYW5zZm9ybURvbScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX3RyYW5zZm9ybURvbShub2RlLCBzZWxlY3Rvciwgc2hvdWxkUmVtb3ZlU2NvcGUpIHtcblx0ICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG5cdCAgICAgICAgdGhpcy5lbGVtZW50KG5vZGUsIHNlbGVjdG9yLCBzaG91bGRSZW1vdmVTY29wZSk7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGMkID0gbm9kZS5sb2NhbE5hbWUgPT09ICd0ZW1wbGF0ZScgPyAobm9kZS5jb250ZW50IHx8IG5vZGUuX2NvbnRlbnQpLmNoaWxkTm9kZXMgOiBub2RlLmNoaWxkcmVuIHx8IG5vZGUuY2hpbGROb2Rlcztcblx0ICAgICAgaWYgKGMkKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjJC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtRG9tKGMkW2ldLCBzZWxlY3Rvciwgc2hvdWxkUmVtb3ZlU2NvcGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2VsZW1lbnQnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGVsZW1lbnQoX2VsZW1lbnQsIHNjb3BlLCBzaG91bGRSZW1vdmVTY29wZSkge1xuXHQgICAgICAvLyBub3RlOiBpZiB1c2luZyBjbGFzc2VzLCB3ZSBhZGQgYm90aCB0aGUgZ2VuZXJhbCAnc3R5bGUtc2NvcGUnIGNsYXNzXG5cdCAgICAgIC8vIGFzIHdlbGwgYXMgdGhlIHNwZWNpZmljIHNjb3BlLiBUaGlzIGVuYWJsZXMgZWFzeSBmaWx0ZXJpbmcgb2YgYWxsXG5cdCAgICAgIC8vIGBzdHlsZS1zY29wZWAgZWxlbWVudHNcblx0ICAgICAgaWYgKHNjb3BlKSB7XG5cdCAgICAgICAgLy8gbm90ZTogc3ZnIG9uIElFIGRvZXMgbm90IGhhdmUgY2xhc3NMaXN0IHNvIGZhbGxiYWNrIHRvIGNsYXNzXG5cdCAgICAgICAgaWYgKF9lbGVtZW50LmNsYXNzTGlzdCkge1xuXHQgICAgICAgICAgaWYgKHNob3VsZFJlbW92ZVNjb3BlKSB7XG5cdCAgICAgICAgICAgIF9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoU0NPUEVfTkFNRSk7XG5cdCAgICAgICAgICAgIF9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoc2NvcGUpO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChTQ09QRV9OQU1FKTtcblx0ICAgICAgICAgICAgX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChzY29wZSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIGlmIChfZWxlbWVudC5nZXRBdHRyaWJ1dGUpIHtcblx0ICAgICAgICAgIHZhciBjID0gX2VsZW1lbnQuZ2V0QXR0cmlidXRlKENMQVNTKTtcblx0ICAgICAgICAgIGlmIChzaG91bGRSZW1vdmVTY29wZSkge1xuXHQgICAgICAgICAgICBpZiAoYykge1xuXHQgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGMucmVwbGFjZShTQ09QRV9OQU1FLCAnJykucmVwbGFjZShzY29wZSwgJycpO1xuXHQgICAgICAgICAgICAgIFN0eWxlVXRpbC5zZXRFbGVtZW50Q2xhc3NSYXcoX2VsZW1lbnQsIG5ld1ZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIF9uZXdWYWx1ZSA9IChjID8gYyArICcgJyA6ICcnKSArIFNDT1BFX05BTUUgKyAnICcgKyBzY29wZTtcblx0ICAgICAgICAgICAgU3R5bGVVdGlsLnNldEVsZW1lbnRDbGFzc1JhdyhfZWxlbWVudCwgX25ld1ZhbHVlKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdlbGVtZW50U3R5bGVzJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBlbGVtZW50U3R5bGVzKGVsZW1lbnQsIHN0eWxlUnVsZXMsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBjc3NCdWlsZFR5cGUgPSBlbGVtZW50Ll9fY3NzQnVpbGQ7XG5cdCAgICAgIC8vIG5vIG5lZWQgdG8gc2hpbSBzZWxlY3RvcnMgaWYgc2V0dGluZ3MudXNlTmF0aXZlU2hhZG93LCBhbHNvXG5cdCAgICAgIC8vIGEgc2hhZHkgY3NzIGJ1aWxkIHdpbGwgYWxyZWFkeSBoYXZlIHRyYW5zZm9ybWVkIHNlbGVjdG9yc1xuXHQgICAgICAvLyBOT1RFOiBUaGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIGFzIHBhcnQgb2Ygc3RhdGljIG9yIHByb3BlcnR5IHNoaW1taW5nLlxuXHQgICAgICAvLyBXaGVuIHRoZXJlIGlzIGEgdGFyZ2V0ZWQgYnVpbGQgaXQgd2lsbCBub3QgYmUgY2FsbGVkIGZvciBzdGF0aWMgc2hpbW1pbmcsXG5cdCAgICAgIC8vIGJ1dCB3aGVuIHRoZSBwcm9wZXJ0eSBzaGltIGlzIHVzZWQgaXQgaXMgY2FsbGVkIGFuZCBzaG91bGQgb3B0IG91dCBvZlxuXHQgICAgICAvLyBzdGF0aWMgc2hpbW1pbmcgd29yayB3aGVuIGEgcHJvcGVyIGJ1aWxkIGV4aXN0cy5cblx0ICAgICAgdmFyIGNzc1RleHQgPSBfc3R5bGVTZXR0aW5ncy5uYXRpdmVTaGFkb3cgfHwgY3NzQnVpbGRUeXBlID09PSAnc2hhZHknID8gU3R5bGVVdGlsLnRvQ3NzVGV4dChzdHlsZVJ1bGVzLCBjYWxsYmFjaykgOiB0aGlzLmNzcyhzdHlsZVJ1bGVzLCBlbGVtZW50LmlzLCBlbGVtZW50LmV4dGVuZHMsIGNhbGxiYWNrKSArICdcXG5cXG4nO1xuXHQgICAgICByZXR1cm4gY3NzVGV4dC50cmltKCk7XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gR2l2ZW4gYSBzdHJpbmcgb2YgY3NzVGV4dCBhbmQgYSBzY29waW5nIHN0cmluZyAoc2NvcGUpLCByZXR1cm5zXG5cdCAgICAvLyBhIHN0cmluZyBvZiBzY29wZWQgY3NzIHdoZXJlIGVhY2ggc2VsZWN0b3IgaXMgdHJhbnNmb3JtZWQgdG8gaW5jbHVkZVxuXHQgICAgLy8gYSBjbGFzcyBjcmVhdGVkIGZyb20gdGhlIHNjb3BlLiBTaGFkb3dET00gc2VsZWN0b3JzIGFyZSBhbHNvIHRyYW5zZm9ybWVkXG5cdCAgICAvLyAoZS5nLiA6aG9zdCkgdG8gdXNlIHRoZSBzY29waW5nIHNlbGVjdG9yLlxuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdjc3MnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGNzcyhydWxlcywgc2NvcGUsIGV4dCwgY2FsbGJhY2spIHtcblx0ICAgICAgdmFyIGhvc3RTY29wZSA9IHRoaXMuX2NhbGNIb3N0U2NvcGUoc2NvcGUsIGV4dCk7XG5cdCAgICAgIHNjb3BlID0gdGhpcy5fY2FsY0VsZW1lbnRTY29wZShzY29wZSk7XG5cdCAgICAgIHZhciBzZWxmID0gdGhpcztcblx0ICAgICAgcmV0dXJuIFN0eWxlVXRpbC50b0Nzc1RleHQocnVsZXMsIGZ1bmN0aW9uIChydWxlKSB7XG5cdCAgICAgICAgaWYgKCFydWxlLmlzU2NvcGVkKSB7XG5cdCAgICAgICAgICBzZWxmLnJ1bGUocnVsZSwgc2NvcGUsIGhvc3RTY29wZSk7XG5cdCAgICAgICAgICBydWxlLmlzU2NvcGVkID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICBjYWxsYmFjayhydWxlLCBzY29wZSwgaG9zdFNjb3BlKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ19jYWxjRWxlbWVudFNjb3BlJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY0VsZW1lbnRTY29wZShzY29wZSkge1xuXHQgICAgICBpZiAoc2NvcGUpIHtcblx0ICAgICAgICByZXR1cm4gQ1NTX0NMQVNTX1BSRUZJWCArIHNjb3BlO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiAnJztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ19jYWxjSG9zdFNjb3BlJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY0hvc3RTY29wZShzY29wZSwgZXh0KSB7XG5cdCAgICAgIHJldHVybiBleHQgPyAnW2lzPScgKyBzY29wZSArICddJyA6IHNjb3BlO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ3J1bGUnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHJ1bGUoX3J1bGUsIHNjb3BlLCBob3N0U2NvcGUpIHtcblx0ICAgICAgdGhpcy5fdHJhbnNmb3JtUnVsZShfcnVsZSwgdGhpcy5fdHJhbnNmb3JtQ29tcGxleFNlbGVjdG9yLCBzY29wZSwgaG9zdFNjb3BlKTtcblx0ICAgIH1cblx0XG5cdCAgICAvLyB0cmFuc2Zvcm1zIGEgY3NzIHJ1bGUgdG8gYSBzY29wZWQgcnVsZS5cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX3RyYW5zZm9ybVJ1bGUnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF90cmFuc2Zvcm1SdWxlKHJ1bGUsIHRyYW5zZm9ybWVyLCBzY29wZSwgaG9zdFNjb3BlKSB7XG5cdCAgICAgIC8vIE5PVEU6IHNhdmUgdHJhbnNmb3JtZWRTZWxlY3RvciBmb3Igc3Vic2VxdWVudCBtYXRjaGluZyBvZiBlbGVtZW50c1xuXHQgICAgICAvLyBhZ2FpbnN0IHNlbGVjdG9ycyAoZS5nLiB3aGVuIGNhbGN1bGF0aW5nIHN0eWxlIHByb3BlcnRpZXMpXG5cdCAgICAgIHJ1bGUuc2VsZWN0b3IgPSBydWxlLnRyYW5zZm9ybWVkU2VsZWN0b3IgPSB0aGlzLl90cmFuc2Zvcm1SdWxlQ3NzKHJ1bGUsIHRyYW5zZm9ybWVyLCBzY29wZSwgaG9zdFNjb3BlKTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdfdHJhbnNmb3JtUnVsZUNzcycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX3RyYW5zZm9ybVJ1bGVDc3MocnVsZSwgdHJhbnNmb3JtZXIsIHNjb3BlLCBob3N0U2NvcGUpIHtcblx0ICAgICAgdmFyIHAkID0gcnVsZS5zZWxlY3Rvci5zcGxpdChDT01QTEVYX1NFTEVDVE9SX1NFUCk7XG5cdCAgICAgIC8vIHdlIHdhbnQgdG8gc2tpcCB0cmFuc2Zvcm1hdGlvbiBvZiBydWxlcyB0aGF0IGFwcGVhciBpbiBrZXlmcmFtZXMsXG5cdCAgICAgIC8vIGJlY2F1c2UgdGhleSBhcmUga2V5ZnJhbWUgc2VsZWN0b3JzLCBub3QgZWxlbWVudCBzZWxlY3RvcnMuXG5cdCAgICAgIGlmICghU3R5bGVVdGlsLmlzS2V5ZnJhbWVzU2VsZWN0b3IocnVsZSkpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHAkLmxlbmd0aCwgcDsgaSA8IGwgJiYgKHAgPSBwJFtpXSk7IGkrKykge1xuXHQgICAgICAgICAgcCRbaV0gPSB0cmFuc2Zvcm1lci5jYWxsKHRoaXMsIHAsIHNjb3BlLCBob3N0U2NvcGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gcCQuam9pbihDT01QTEVYX1NFTEVDVE9SX1NFUCk7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX3RyYW5zZm9ybUNvbXBsZXhTZWxlY3RvcicsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX3RyYW5zZm9ybUNvbXBsZXhTZWxlY3RvcihzZWxlY3Rvciwgc2NvcGUsIGhvc3RTY29wZSkge1xuXHQgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcblx0ICAgICAgdmFyIHN0b3AgPSBmYWxzZTtcblx0ICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci50cmltKCk7XG5cdCAgICAgIC8vIFJlbW92ZSBzcGFjZXMgaW5zaWRlIG9mIHNlbGVjdG9ycyBsaWtlIGA6bnRoLW9mLXR5cGVgIGJlY2F1c2UgaXQgY29uZnVzZXMgU0lNUExFX1NFTEVDVE9SX1NFUFxuXHQgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoTlRILCBmdW5jdGlvbiAobSwgdHlwZSwgaW5uZXIpIHtcblx0ICAgICAgICByZXR1cm4gJzonICsgdHlwZSArICcoJyArIGlubmVyLnJlcGxhY2UoL1xccy9nLCAnJykgKyAnKSc7XG5cdCAgICAgIH0pO1xuXHQgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoU0xPVFRFRF9TVEFSVCwgSE9TVCArICcgJDEnKTtcblx0ICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKFNJTVBMRV9TRUxFQ1RPUl9TRVAsIGZ1bmN0aW9uIChtLCBjLCBzKSB7XG5cdCAgICAgICAgaWYgKCFzdG9wKSB7XG5cdCAgICAgICAgICB2YXIgaW5mbyA9IF90aGlzLl90cmFuc2Zvcm1Db21wb3VuZFNlbGVjdG9yKHMsIGMsIHNjb3BlLCBob3N0U2NvcGUpO1xuXHQgICAgICAgICAgc3RvcCA9IHN0b3AgfHwgaW5mby5zdG9wO1xuXHQgICAgICAgICAgYyA9IGluZm8uY29tYmluYXRvcjtcblx0ICAgICAgICAgIHMgPSBpbmZvLnZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYyArIHM7XG5cdCAgICAgIH0pO1xuXHQgICAgICByZXR1cm4gc2VsZWN0b3I7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX3RyYW5zZm9ybUNvbXBvdW5kU2VsZWN0b3InLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF90cmFuc2Zvcm1Db21wb3VuZFNlbGVjdG9yKHNlbGVjdG9yLCBjb21iaW5hdG9yLCBzY29wZSwgaG9zdFNjb3BlKSB7XG5cdCAgICAgIC8vIHJlcGxhY2UgOmhvc3Qgd2l0aCBob3N0IHNjb3BpbmcgY2xhc3Ncblx0ICAgICAgdmFyIHNsb3R0ZWRJbmRleCA9IHNlbGVjdG9yLmluZGV4T2YoU0xPVFRFRCk7XG5cdCAgICAgIGlmIChzZWxlY3Rvci5pbmRleE9mKEhPU1QpID49IDApIHtcblx0ICAgICAgICBzZWxlY3RvciA9IHRoaXMuX3RyYW5zZm9ybUhvc3RTZWxlY3RvcihzZWxlY3RvciwgaG9zdFNjb3BlKTtcblx0ICAgICAgICAvLyByZXBsYWNlIG90aGVyIHNlbGVjdG9ycyB3aXRoIHNjb3BpbmcgY2xhc3Ncblx0ICAgICAgfSBlbHNlIGlmIChzbG90dGVkSW5kZXggIT09IDApIHtcblx0ICAgICAgICBzZWxlY3RvciA9IHNjb3BlID8gdGhpcy5fdHJhbnNmb3JtU2ltcGxlU2VsZWN0b3Ioc2VsZWN0b3IsIHNjb3BlKSA6IHNlbGVjdG9yO1xuXHQgICAgICB9XG5cdCAgICAgIC8vIG1hcmsgOjpzbG90dGVkKCkgc2NvcGUganVtcCB0byByZXBsYWNlIHdpdGggZGVzY2VuZGFudCBzZWxlY3RvciArIGFyZ1xuXHQgICAgICAvLyBhbHNvIGlnbm9yZSBsZWZ0LXNpZGUgY29tYmluYXRvclxuXHQgICAgICB2YXIgc2xvdHRlZCA9IGZhbHNlO1xuXHQgICAgICBpZiAoc2xvdHRlZEluZGV4ID49IDApIHtcblx0ICAgICAgICBjb21iaW5hdG9yID0gJyc7XG5cdCAgICAgICAgc2xvdHRlZCA9IHRydWU7XG5cdCAgICAgIH1cblx0ICAgICAgLy8gcHJvY2VzcyBzY29wZSBqdW1waW5nIHNlbGVjdG9ycyB1cCB0byB0aGUgc2NvcGUganVtcCBhbmQgdGhlbiBzdG9wXG5cdCAgICAgIHZhciBzdG9wID0gdm9pZCAwO1xuXHQgICAgICBpZiAoc2xvdHRlZCkge1xuXHQgICAgICAgIHN0b3AgPSB0cnVlO1xuXHQgICAgICAgIGlmIChzbG90dGVkKSB7XG5cdCAgICAgICAgICAvLyAuem9uayA6OnNsb3R0ZWQoLmZvbykgLT4gLnpvbmsuc2NvcGUgPiAuZm9vXG5cdCAgICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoU0xPVFRFRF9QQVJFTiwgZnVuY3Rpb24gKG0sIHBhcmVuKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAnID4gJyArIHBhcmVuO1xuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShESVJfUEFSRU4sIGZ1bmN0aW9uIChtLCBiZWZvcmUsIGRpcikge1xuXHQgICAgICAgIHJldHVybiAnW2Rpcj1cIicgKyBkaXIgKyAnXCJdICcgKyBiZWZvcmUgKyAnLCAnICsgYmVmb3JlICsgJ1tkaXI9XCInICsgZGlyICsgJ1wiXSc7XG5cdCAgICAgIH0pO1xuXHQgICAgICByZXR1cm4geyB2YWx1ZTogc2VsZWN0b3IsIGNvbWJpbmF0b3I6IGNvbWJpbmF0b3IsIHN0b3A6IHN0b3AgfTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdfdHJhbnNmb3JtU2ltcGxlU2VsZWN0b3InLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF90cmFuc2Zvcm1TaW1wbGVTZWxlY3RvcihzZWxlY3Rvciwgc2NvcGUpIHtcblx0ICAgICAgdmFyIHAkID0gc2VsZWN0b3Iuc3BsaXQoUFNFVURPX1BSRUZJWCk7XG5cdCAgICAgIHAkWzBdICs9IHNjb3BlO1xuXHQgICAgICByZXR1cm4gcCQuam9pbihQU0VVRE9fUFJFRklYKTtcblx0ICAgIH1cblx0XG5cdCAgICAvLyA6aG9zdCguLi4pIC0+IHNjb3BlTmFtZS4uLlxuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdfdHJhbnNmb3JtSG9zdFNlbGVjdG9yJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBfdHJhbnNmb3JtSG9zdFNlbGVjdG9yKHNlbGVjdG9yLCBob3N0U2NvcGUpIHtcblx0ICAgICAgdmFyIG0gPSBzZWxlY3Rvci5tYXRjaChIT1NUX1BBUkVOKTtcblx0ICAgICAgdmFyIHBhcmVuID0gbSAmJiBtWzJdLnRyaW0oKSB8fCAnJztcblx0ICAgICAgaWYgKHBhcmVuKSB7XG5cdCAgICAgICAgaWYgKCFwYXJlblswXS5tYXRjaChTSU1QTEVfU0VMRUNUT1JfUFJFRklYKSkge1xuXHQgICAgICAgICAgLy8gcGFyZW4gc3RhcnRzIHdpdGggYSB0eXBlIHNlbGVjdG9yXG5cdCAgICAgICAgICB2YXIgdHlwZVNlbGVjdG9yID0gcGFyZW4uc3BsaXQoU0lNUExFX1NFTEVDVE9SX1BSRUZJWClbMF07XG5cdCAgICAgICAgICAvLyBpZiB0aGUgdHlwZSBzZWxlY3RvciBpcyBvdXIgaG9zdFNjb3BlIHRoZW4gYXZvaWQgcHJlLXBlbmRpbmcgaXRcblx0ICAgICAgICAgIGlmICh0eXBlU2VsZWN0b3IgPT09IGhvc3RTY29wZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gcGFyZW47XG5cdCAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgdGhpcyBzZWxlY3RvciBzaG91bGQgbm90IG1hdGNoIGluIHRoaXMgc2NvcGUgc29cblx0ICAgICAgICAgICAgLy8gb3V0cHV0IGEgYm9ndXMgc2VsZWN0b3IuXG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gU0VMRUNUT1JfTk9fTUFUQ0g7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0byBkbyBhIHJlcGxhY2UgaGVyZSB0byBjYXRjaCBzZWxlY3RvcnMgbGlrZTpcblx0ICAgICAgICAgIC8vIGA6aG9zdCguZm9vKTo6YmVmb3JlYFxuXHQgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yLnJlcGxhY2UoSE9TVF9QQVJFTiwgZnVuY3Rpb24gKG0sIGhvc3QsIHBhcmVuKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBob3N0U2NvcGUgKyBwYXJlbjtcblx0ICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBpZiBubyBwYXJlbiwgZG8gYSBzdHJhaWdodCA6aG9zdCByZXBsYWNlbWVudC5cblx0ICAgICAgICAvLyBUT0RPKHNvcnZlbGwpOiB0aGlzIHNob3VsZCBub3Qgc3RyaWN0bHkgYmUgbmVjZXNzYXJ5IGJ1dFxuXHQgICAgICAgIC8vIGl0J3MgbmVlZGVkIHRvIG1haW50YWluIHN1cHBvcnQgZm9yIGA6aG9zdFtmb29dYCB0eXBlIHNlbGVjdG9yc1xuXHQgICAgICAgIC8vIHdoaWNoIGhhdmUgYmVlbiBpbXByb3Blcmx5IHVzZWQgdW5kZXIgU2hhZHkgRE9NLiBUaGlzIHNob3VsZCBiZVxuXHQgICAgICAgIC8vIGRlcHJlY2F0ZWQuXG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIHNlbGVjdG9yLnJlcGxhY2UoSE9TVCwgaG9zdFNjb3BlKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2RvY3VtZW50UnVsZScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZG9jdW1lbnRSdWxlKHJ1bGUpIHtcblx0ICAgICAgLy8gcmVzZXQgc2VsZWN0b3IgaW4gY2FzZSB0aGlzIGlzIHJlZG9uZS5cblx0ICAgICAgcnVsZS5zZWxlY3RvciA9IHJ1bGUucGFyc2VkU2VsZWN0b3I7XG5cdCAgICAgIHRoaXMubm9ybWFsaXplUm9vdFNlbGVjdG9yKHJ1bGUpO1xuXHQgICAgICB0aGlzLl90cmFuc2Zvcm1SdWxlKHJ1bGUsIHRoaXMuX3RyYW5zZm9ybURvY3VtZW50U2VsZWN0b3IpO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ25vcm1hbGl6ZVJvb3RTZWxlY3RvcicsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gbm9ybWFsaXplUm9vdFNlbGVjdG9yKHJ1bGUpIHtcblx0ICAgICAgaWYgKHJ1bGUuc2VsZWN0b3IgPT09IFJPT1QpIHtcblx0ICAgICAgICBydWxlLnNlbGVjdG9yID0gJ2h0bWwnO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX3RyYW5zZm9ybURvY3VtZW50U2VsZWN0b3InLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF90cmFuc2Zvcm1Eb2N1bWVudFNlbGVjdG9yKHNlbGVjdG9yKSB7XG5cdCAgICAgIHJldHVybiBzZWxlY3Rvci5tYXRjaChTTE9UVEVEKSA/IHRoaXMuX3RyYW5zZm9ybUNvbXBsZXhTZWxlY3RvcihzZWxlY3RvciwgU0NPUEVfRE9DX1NFTEVDVE9SKSA6IHRoaXMuX3RyYW5zZm9ybVNpbXBsZVNlbGVjdG9yKHNlbGVjdG9yLnRyaW0oKSwgU0NPUEVfRE9DX1NFTEVDVE9SKTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdTQ09QRV9OQU1FJyxcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gU0NPUEVfTkFNRTtcblx0ICAgIH1cblx0ICB9XSk7XG5cdFxuXHQgIHJldHVybiBTdHlsZVRyYW5zZm9ybWVyO1xuXHR9KCk7XG5cdFxuXHR2YXIgTlRIID0gLzoobnRoWy1cXHddKylcXCgoW14pXSspXFwpLztcblx0dmFyIFNDT1BFX0RPQ19TRUxFQ1RPUiA9ICc6bm90KC4nICsgU0NPUEVfTkFNRSArICcpJztcblx0dmFyIENPTVBMRVhfU0VMRUNUT1JfU0VQID0gJywnO1xuXHR2YXIgU0lNUExFX1NFTEVDVE9SX1NFUCA9IC8oXnxbXFxzPit+XSspKCg/OlxcWy4rP1xcXXxbXlxccz4rfj1cXFtdKSspL2c7XG5cdHZhciBTSU1QTEVfU0VMRUNUT1JfUFJFRklYID0gL1tbLjojKl0vO1xuXHR2YXIgSE9TVCA9ICc6aG9zdCc7XG5cdHZhciBST09UID0gJzpyb290Jztcblx0dmFyIFNMT1RURUQgPSAnOjpzbG90dGVkJztcblx0dmFyIFNMT1RURURfU1RBUlQgPSBuZXcgUmVnRXhwKCdeKCcgKyBTTE9UVEVEICsgJyknKTtcblx0Ly8gTk9URTogdGhpcyBzdXBwb3J0cyAxIG5lc3RlZCAoKSBwYWlyIGZvciB0aGluZ3MgbGlrZVxuXHQvLyA6aG9zdCg6bm90KFtzZWxlY3RlZF0pLCBtb3JlIGdlbmVyYWwgc3VwcG9ydCByZXF1aXJlc1xuXHQvLyBwYXJzaW5nIHdoaWNoIHNlZW1zIGxpa2Ugb3ZlcmtpbGxcblx0dmFyIEhPU1RfUEFSRU4gPSAvKDpob3N0KSg/OlxcKCgoPzpcXChbXikoXSpcXCl8W14pKF0qKSs/KVxcKSkvO1xuXHQvLyBzaW1pbGFyIHRvIEhPU1RfUEFSRU5cblx0dmFyIFNMT1RURURfUEFSRU4gPSAvKD86OjpzbG90dGVkKSg/OlxcKCgoPzpcXChbXikoXSpcXCl8W14pKF0qKSs/KVxcKSkvO1xuXHR2YXIgRElSX1BBUkVOID0gLyguKik6ZGlyXFwoKD86KGx0cnxydGwpKVxcKS87XG5cdHZhciBDU1NfQ0xBU1NfUFJFRklYID0gJy4nO1xuXHR2YXIgUFNFVURPX1BSRUZJWCA9ICc6Jztcblx0dmFyIENMQVNTID0gJ2NsYXNzJztcblx0dmFyIFNFTEVDVE9SX05PX01BVENIID0gJ3Nob3VsZF9ub3RfbWF0Y2gnO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gbmV3IFN0eWxlVHJhbnNmb3JtZXIoKTtcblxuLyoqKi8gfSxcbi8qIDcyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKipcblx0QGxpY2Vuc2Vcblx0Q29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0VGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuXHRUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuXHRUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcblx0Q29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cblx0c3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcblx0Ki9cblx0XG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRleHBvcnRzLnJ4ID0gdW5kZWZpbmVkO1xuXHRleHBvcnRzLnRvQ3NzVGV4dCA9IHRvQ3NzVGV4dDtcblx0ZXhwb3J0cy5ydWxlc0ZvclN0eWxlID0gcnVsZXNGb3JTdHlsZTtcblx0ZXhwb3J0cy5pc0tleWZyYW1lc1NlbGVjdG9yID0gaXNLZXlmcmFtZXNTZWxlY3Rvcjtcblx0ZXhwb3J0cy5mb3JFYWNoUnVsZSA9IGZvckVhY2hSdWxlO1xuXHRleHBvcnRzLmFwcGx5Q3NzID0gYXBwbHlDc3M7XG5cdGV4cG9ydHMuYXBwbHlTdHlsZSA9IGFwcGx5U3R5bGU7XG5cdGV4cG9ydHMuY3JlYXRlU2NvcGVTdHlsZSA9IGNyZWF0ZVNjb3BlU3R5bGU7XG5cdGV4cG9ydHMuYXBwbHlTdHlsZVBsYWNlSG9sZGVyID0gYXBwbHlTdHlsZVBsYWNlSG9sZGVyO1xuXHRleHBvcnRzLmlzVGFyZ2V0ZWRCdWlsZCA9IGlzVGFyZ2V0ZWRCdWlsZDtcblx0ZXhwb3J0cy5nZXRDc3NCdWlsZFR5cGUgPSBnZXRDc3NCdWlsZFR5cGU7XG5cdGV4cG9ydHMucHJvY2Vzc1ZhcmlhYmxlQW5kRmFsbGJhY2sgPSBwcm9jZXNzVmFyaWFibGVBbmRGYWxsYmFjaztcblx0ZXhwb3J0cy5zZXRFbGVtZW50Q2xhc3NSYXcgPSBzZXRFbGVtZW50Q2xhc3NSYXc7XG5cdFxuXHR2YXIgX3N0eWxlU2V0dGluZ3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcblx0XG5cdHZhciBfY3NzUGFyc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KTtcblx0XG5cdGZ1bmN0aW9uIHRvQ3NzVGV4dChydWxlcywgY2FsbGJhY2spIHtcblx0ICBpZiAodHlwZW9mIHJ1bGVzID09PSAnc3RyaW5nJykge1xuXHQgICAgcnVsZXMgPSAoMCwgX2Nzc1BhcnNlLnBhcnNlKShydWxlcyk7XG5cdCAgfVxuXHQgIGlmIChjYWxsYmFjaykge1xuXHQgICAgZm9yRWFjaFJ1bGUocnVsZXMsIGNhbGxiYWNrKTtcblx0ICB9XG5cdCAgcmV0dXJuICgwLCBfY3NzUGFyc2Uuc3RyaW5naWZ5KShydWxlcywgX3N0eWxlU2V0dGluZ3MubmF0aXZlQ3NzVmFyaWFibGVzKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gcnVsZXNGb3JTdHlsZShzdHlsZSkge1xuXHQgIGlmICghc3R5bGUuX19jc3NSdWxlcyAmJiBzdHlsZS50ZXh0Q29udGVudCkge1xuXHQgICAgc3R5bGUuX19jc3NSdWxlcyA9ICgwLCBfY3NzUGFyc2UucGFyc2UpKHN0eWxlLnRleHRDb250ZW50KTtcblx0ICB9XG5cdCAgcmV0dXJuIHN0eWxlLl9fY3NzUnVsZXM7XG5cdH1cblx0XG5cdC8vIFRlc3RzIGlmIGEgcnVsZSBpcyBhIGtleWZyYW1lcyBzZWxlY3Rvciwgd2hpY2ggbG9va3MgYWxtb3N0IGV4YWN0bHlcblx0Ly8gbGlrZSBhIG5vcm1hbCBzZWxlY3RvciBidXQgaXMgbm90IChpdCBoYXMgbm90aGluZyB0byBkbyB3aXRoIHNjb3Bpbmdcblx0Ly8gZm9yIGV4YW1wbGUpLlxuXHRmdW5jdGlvbiBpc0tleWZyYW1lc1NlbGVjdG9yKHJ1bGUpIHtcblx0ICByZXR1cm4gcnVsZS5wYXJlbnQgJiYgcnVsZS5wYXJlbnQudHlwZSA9PT0gX2Nzc1BhcnNlLnR5cGVzLktFWUZSQU1FU19SVUxFO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBmb3JFYWNoUnVsZShub2RlLCBzdHlsZVJ1bGVDYWxsYmFjaywga2V5ZnJhbWVzUnVsZUNhbGxiYWNrLCBvbmx5QWN0aXZlUnVsZXMpIHtcblx0ICBpZiAoIW5vZGUpIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgdmFyIHNraXBSdWxlcyA9IGZhbHNlO1xuXHQgIGlmIChvbmx5QWN0aXZlUnVsZXMpIHtcblx0ICAgIGlmIChub2RlLnR5cGUgPT09IF9jc3NQYXJzZS50eXBlcy5NRURJQV9SVUxFKSB7XG5cdCAgICAgIHZhciBtYXRjaE1lZGlhID0gbm9kZS5zZWxlY3Rvci5tYXRjaChyeC5NRURJQV9NQVRDSCk7XG5cdCAgICAgIGlmIChtYXRjaE1lZGlhKSB7XG5cdCAgICAgICAgLy8gaWYgcnVsZSBpcyBhIG5vbiBtYXRjaGluZyBAbWVkaWEgcnVsZSwgc2tpcCBzdWJydWxlc1xuXHQgICAgICAgIGlmICghd2luZG93Lm1hdGNoTWVkaWEobWF0Y2hNZWRpYVsxXSkubWF0Y2hlcykge1xuXHQgICAgICAgICAgc2tpcFJ1bGVzID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgaWYgKG5vZGUudHlwZSA9PT0gX2Nzc1BhcnNlLnR5cGVzLlNUWUxFX1JVTEUpIHtcblx0ICAgIHN0eWxlUnVsZUNhbGxiYWNrKG5vZGUpO1xuXHQgIH0gZWxzZSBpZiAoa2V5ZnJhbWVzUnVsZUNhbGxiYWNrICYmIG5vZGUudHlwZSA9PT0gX2Nzc1BhcnNlLnR5cGVzLktFWUZSQU1FU19SVUxFKSB7XG5cdCAgICBrZXlmcmFtZXNSdWxlQ2FsbGJhY2sobm9kZSk7XG5cdCAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IF9jc3NQYXJzZS50eXBlcy5NSVhJTl9SVUxFKSB7XG5cdCAgICBza2lwUnVsZXMgPSB0cnVlO1xuXHQgIH1cblx0ICB2YXIgciQgPSBub2RlLnJ1bGVzO1xuXHQgIGlmIChyJCAmJiAhc2tpcFJ1bGVzKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMCwgbCA9IHIkLmxlbmd0aCwgcjsgaSA8IGwgJiYgKHIgPSByJFtpXSk7IGkrKykge1xuXHQgICAgICBmb3JFYWNoUnVsZShyLCBzdHlsZVJ1bGVDYWxsYmFjaywga2V5ZnJhbWVzUnVsZUNhbGxiYWNrLCBvbmx5QWN0aXZlUnVsZXMpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRcblx0Ly8gYWRkIGEgc3RyaW5nIG9mIGNzc1RleHQgdG8gdGhlIGRvY3VtZW50LlxuXHRmdW5jdGlvbiBhcHBseUNzcyhjc3NUZXh0LCBtb25pa2VyLCB0YXJnZXQsIGNvbnRleHROb2RlKSB7XG5cdCAgdmFyIHN0eWxlID0gY3JlYXRlU2NvcGVTdHlsZShjc3NUZXh0LCBtb25pa2VyKTtcblx0ICByZXR1cm4gYXBwbHlTdHlsZShzdHlsZSwgdGFyZ2V0LCBjb250ZXh0Tm9kZSk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGFwcGx5U3R5bGUoc3R5bGUsIHRhcmdldCwgY29udGV4dE5vZGUpIHtcblx0ICB0YXJnZXQgPSB0YXJnZXQgfHwgZG9jdW1lbnQuaGVhZDtcblx0ICB2YXIgYWZ0ZXIgPSBjb250ZXh0Tm9kZSAmJiBjb250ZXh0Tm9kZS5uZXh0U2libGluZyB8fCB0YXJnZXQuZmlyc3RDaGlsZDtcblx0ICBsYXN0SGVhZEFwcGx5Tm9kZSA9IHN0eWxlO1xuXHQgIHJldHVybiB0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBhZnRlcik7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGNyZWF0ZVNjb3BlU3R5bGUoY3NzVGV4dCwgbW9uaWtlcikge1xuXHQgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cdCAgaWYgKG1vbmlrZXIpIHtcblx0ICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnc2NvcGUnLCBtb25pa2VyKTtcblx0ICB9XG5cdCAgc3R5bGUudGV4dENvbnRlbnQgPSBjc3NUZXh0O1xuXHQgIHJldHVybiBzdHlsZTtcblx0fVxuXHRcblx0dmFyIGxhc3RIZWFkQXBwbHlOb2RlID0gbnVsbDtcblx0XG5cdC8vIGluc2VydCBhIGNvbW1lbnQgbm9kZSBhcyBhIHN0eWxpbmcgcG9zaXRpb24gcGxhY2Vob2xkZXIuXG5cdGZ1bmN0aW9uIGFwcGx5U3R5bGVQbGFjZUhvbGRlcihtb25pa2VyKSB7XG5cdCAgdmFyIHBsYWNlSG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnIFNoYWR5IERPTSBzdHlsZXMgZm9yICcgKyBtb25pa2VyICsgJyAnKTtcblx0ICB2YXIgYWZ0ZXIgPSBsYXN0SGVhZEFwcGx5Tm9kZSA/IGxhc3RIZWFkQXBwbHlOb2RlLm5leHRTaWJsaW5nIDogbnVsbDtcblx0ICB2YXIgc2NvcGUgPSBkb2N1bWVudC5oZWFkO1xuXHQgIHNjb3BlLmluc2VydEJlZm9yZShwbGFjZUhvbGRlciwgYWZ0ZXIgfHwgc2NvcGUuZmlyc3RDaGlsZCk7XG5cdCAgbGFzdEhlYWRBcHBseU5vZGUgPSBwbGFjZUhvbGRlcjtcblx0ICByZXR1cm4gcGxhY2VIb2xkZXI7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGlzVGFyZ2V0ZWRCdWlsZChidWlsZFR5cGUpIHtcblx0ICByZXR1cm4gX3N0eWxlU2V0dGluZ3MubmF0aXZlU2hhZG93ID8gYnVpbGRUeXBlID09PSAnc2hhZG93JyA6IGJ1aWxkVHlwZSA9PT0gJ3NoYWR5Jztcblx0fVxuXHRcblx0Ly8gY3NzQnVpbGRUeXBlRm9yTW9kdWxlOiBmdW5jdGlvbiAobW9kdWxlKSB7XG5cdC8vICAgbGV0IGRtID0gUG9seW1lci5Eb21Nb2R1bGUuaW1wb3J0KG1vZHVsZSk7XG5cdC8vICAgaWYgKGRtKSB7XG5cdC8vICAgICByZXR1cm4gZ2V0Q3NzQnVpbGRUeXBlKGRtKTtcblx0Ly8gICB9XG5cdC8vIH0sXG5cdC8vXG5cdGZ1bmN0aW9uIGdldENzc0J1aWxkVHlwZShlbGVtZW50KSB7XG5cdCAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjc3MtYnVpbGQnKTtcblx0fVxuXHRcblx0Ly8gV2FsayBmcm9tIHRleHRbc3RhcnRdIG1hdGNoaW5nIHBhcmVuc1xuXHQvLyByZXR1cm5zIHBvc2l0aW9uIG9mIHRoZSBvdXRlciBlbmQgcGFyZW5cblx0ZnVuY3Rpb24gZmluZE1hdGNoaW5nUGFyZW4odGV4dCwgc3RhcnQpIHtcblx0ICB2YXIgbGV2ZWwgPSAwO1xuXHQgIGZvciAodmFyIGkgPSBzdGFydCwgbCA9IHRleHQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdCAgICBpZiAodGV4dFtpXSA9PT0gJygnKSB7XG5cdCAgICAgIGxldmVsKys7XG5cdCAgICB9IGVsc2UgaWYgKHRleHRbaV0gPT09ICcpJykge1xuXHQgICAgICBpZiAoLS1sZXZlbCA9PT0gMCkge1xuXHQgICAgICAgIHJldHVybiBpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiAtMTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gcHJvY2Vzc1ZhcmlhYmxlQW5kRmFsbGJhY2soc3RyLCBjYWxsYmFjaykge1xuXHQgIC8vIGZpbmQgJ3ZhcignXG5cdCAgdmFyIHN0YXJ0ID0gc3RyLmluZGV4T2YoJ3ZhcignKTtcblx0ICBpZiAoc3RhcnQgPT09IC0xKSB7XG5cdCAgICAvLyBubyB2YXI/LCBldmVyeXRoaW5nIGlzIHByZWZpeFxuXHQgICAgcmV0dXJuIGNhbGxiYWNrKHN0ciwgJycsICcnLCAnJyk7XG5cdCAgfVxuXHQgIC8vJHtwcmVmaXh9dmFyKCR7aW5uZXJ9KSR7c3VmZml4fVxuXHQgIHZhciBlbmQgPSBmaW5kTWF0Y2hpbmdQYXJlbihzdHIsIHN0YXJ0ICsgMyk7XG5cdCAgdmFyIGlubmVyID0gc3RyLnN1YnN0cmluZyhzdGFydCArIDQsIGVuZCk7XG5cdCAgdmFyIHByZWZpeCA9IHN0ci5zdWJzdHJpbmcoMCwgc3RhcnQpO1xuXHQgIC8vIHN1ZmZpeCBtYXkgaGF2ZSBvdGhlciB2YXJpYWJsZXNcblx0ICB2YXIgc3VmZml4ID0gcHJvY2Vzc1ZhcmlhYmxlQW5kRmFsbGJhY2soc3RyLnN1YnN0cmluZyhlbmQgKyAxKSwgY2FsbGJhY2spO1xuXHQgIHZhciBjb21tYSA9IGlubmVyLmluZGV4T2YoJywnKTtcblx0ICAvLyB2YWx1ZSBhbmQgZmFsbGJhY2sgYXJncyBzaG91bGQgYmUgdHJpbW1lZCB0byBtYXRjaCBpbiBwcm9wZXJ0eSBsb29rdXBcblx0ICBpZiAoY29tbWEgPT09IC0xKSB7XG5cdCAgICAvLyB2YXJpYWJsZSwgbm8gZmFsbGJhY2tcblx0ICAgIHJldHVybiBjYWxsYmFjayhwcmVmaXgsIGlubmVyLnRyaW0oKSwgJycsIHN1ZmZpeCk7XG5cdCAgfVxuXHQgIC8vIHZhcigke3ZhbHVlfSwke2ZhbGxiYWNrfSlcblx0ICB2YXIgdmFsdWUgPSBpbm5lci5zdWJzdHJpbmcoMCwgY29tbWEpLnRyaW0oKTtcblx0ICB2YXIgZmFsbGJhY2sgPSBpbm5lci5zdWJzdHJpbmcoY29tbWEgKyAxKS50cmltKCk7XG5cdCAgcmV0dXJuIGNhbGxiYWNrKHByZWZpeCwgdmFsdWUsIGZhbGxiYWNrLCBzdWZmaXgpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBzZXRFbGVtZW50Q2xhc3NSYXcoZWxlbWVudCwgdmFsdWUpIHtcblx0ICAvLyB1c2UgbmF0aXZlIHNldEF0dHJpYnV0ZSBwcm92aWRlZCBieSBTaGFkeURPTSB3aGVuIHNldEF0dHJpYnV0ZSBpcyBwYXRjaGVkXG5cdCAgaWYgKHdpbmRvdy5TaGFkeURPTSkge1xuXHQgICAgd2luZG93LlNoYWR5RE9NLm5hdGl2ZU1ldGhvZHMuc2V0QXR0cmlidXRlLmNhbGwoZWxlbWVudCwgJ2NsYXNzJywgdmFsdWUpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB2YWx1ZSk7XG5cdCAgfVxuXHR9XG5cdFxuXHR2YXIgcnggPSBleHBvcnRzLnJ4ID0ge1xuXHQgIFZBUl9BU1NJR046IC8oPzpefFs7XFxze11cXHMqKSgtLVtcXHctXSo/KVxccyo6XFxzKig/OihbXjt7XSopfHsoW159XSopfSkoPzooPz1bO1xcc31dKXwkKS9naSxcblx0ICBNSVhJTl9NQVRDSDogLyg/Ol58XFxXKylAYXBwbHlcXHMqXFwoPyhbXik7XFxuXSopXFwpPy9naSxcblx0ICBWQVJfQ09OU1VNRUQ6IC8oLS1bXFx3LV0rKVxccyooWzosOyldfCQpL2dpLFxuXHQgIEFOSU1BVElPTl9NQVRDSDogLyhhbmltYXRpb25cXHMqOil8KGFuaW1hdGlvbi1uYW1lXFxzKjopLyxcblx0ICBNRURJQV9NQVRDSDogL0BtZWRpYVteKF0qKFxcKFteKV0qXFwpKS8sXG5cdCAgSVNfVkFSOiAvXi0tLyxcblx0ICBCUkFDS0VURUQ6IC9cXHtbXn1dKlxcfS9nLFxuXHQgIEhPU1RfUFJFRklYOiAnKD86XnxbXi4jWzpdKScsXG5cdCAgSE9TVF9TVUZGSVg6ICcoJHxbLjpbXFxcXHM+K35dKSdcblx0fTtcblxuLyoqKi8gfSxcbi8qIDczICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKipcblx0QGxpY2Vuc2Vcblx0Q29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0VGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuXHRUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuXHRUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcblx0Q29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cblx0c3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcblx0Ki9cblx0XG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblx0XG5cdHZhciBfY3NzUGFyc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KTtcblx0XG5cdHZhciBfc3R5bGVTZXR0aW5ncyA9IF9fd2VicGFja19yZXF1aXJlX18oNzApO1xuXHRcblx0dmFyIF9zdHlsZVRyYW5zZm9ybWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cdFxuXHR2YXIgX3N0eWxlVHJhbnNmb3JtZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3R5bGVUcmFuc2Zvcm1lcik7XG5cdFxuXHR2YXIgX3N0eWxlVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oNzIpO1xuXHRcblx0dmFyIFN0eWxlVXRpbCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9zdHlsZVV0aWwpO1xuXHRcblx0dmFyIF9zdHlsZUluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblx0XG5cdHZhciBfc3R5bGVJbmZvMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0eWxlSW5mbyk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cdFxuXHQvLyBUT0RPOiBkZWR1cGUgd2l0aCBzaGFkeVxuXHR2YXIgcCA9IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZTtcblx0dmFyIG1hdGNoZXNTZWxlY3RvciA9IHAubWF0Y2hlcyB8fCBwLm1hdGNoZXNTZWxlY3RvciB8fCBwLm1vek1hdGNoZXNTZWxlY3RvciB8fCBwLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IHAub01hdGNoZXNTZWxlY3RvciB8fCBwLndlYmtpdE1hdGNoZXNTZWxlY3Rvcjtcblx0XG5cdHZhciBJU19JRSA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goJ1RyaWRlbnQnKTtcblx0XG5cdHZhciBYU0NPUEVfTkFNRSA9ICd4LXNjb3BlJztcblx0XG5cdHZhciBTdHlsZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgZnVuY3Rpb24gU3R5bGVQcm9wZXJ0aWVzKCkge1xuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0eWxlUHJvcGVydGllcyk7XG5cdCAgfVxuXHRcblx0ICBfY3JlYXRlQ2xhc3MoU3R5bGVQcm9wZXJ0aWVzLCBbe1xuXHQgICAga2V5OiAnZGVjb3JhdGVTdHlsZXMnLFxuXHRcblx0ICAgIC8vIGRlY29yYXRlcyBzdHlsZXMgd2l0aCBydWxlIGluZm8gYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdXNlZCBzdHlsZVxuXHQgICAgLy8gcHJvcGVydHkgbmFtZXNcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvcmF0ZVN0eWxlcyhydWxlcykge1xuXHQgICAgICB2YXIgc2VsZiA9IHRoaXMsXG5cdCAgICAgICAgICBwcm9wcyA9IHt9LFxuXHQgICAgICAgICAga2V5ZnJhbWVzID0gW10sXG5cdCAgICAgICAgICBydWxlSW5kZXggPSAwO1xuXHQgICAgICBTdHlsZVV0aWwuZm9yRWFjaFJ1bGUocnVsZXMsIGZ1bmN0aW9uIChydWxlKSB7XG5cdCAgICAgICAgc2VsZi5kZWNvcmF0ZVJ1bGUocnVsZSk7XG5cdCAgICAgICAgLy8gbWFyayBpbi1vcmRlciBwb3NpdGlvbiBvZiBhc3QgcnVsZSBpbiBzdHlsZXMgYmxvY2ssIHVzZWQgZm9yIGNhY2hlIGtleVxuXHQgICAgICAgIHJ1bGUuaW5kZXggPSBydWxlSW5kZXgrKztcblx0ICAgICAgICBzZWxmLmNvbGxlY3RQcm9wZXJ0aWVzSW5Dc3NUZXh0KHJ1bGUucHJvcGVydHlJbmZvLmNzc1RleHQsIHByb3BzKTtcblx0ICAgICAgfSwgZnVuY3Rpb24gb25LZXlmcmFtZXNSdWxlKHJ1bGUpIHtcblx0ICAgICAgICBrZXlmcmFtZXMucHVzaChydWxlKTtcblx0ICAgICAgfSk7XG5cdCAgICAgIC8vIENhY2hlIGFsbCBmb3VuZCBrZXlmcmFtZXMgcnVsZXMgZm9yIGxhdGVyIHJlZmVyZW5jZTpcblx0ICAgICAgcnVsZXMuX2tleWZyYW1lcyA9IGtleWZyYW1lcztcblx0ICAgICAgLy8gcmV0dXJuIHRoaXMgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcyAqY29uc3VtZXMqIGluIHRoZXNlIHN0eWxlcy5cblx0ICAgICAgdmFyIG5hbWVzID0gW107XG5cdCAgICAgIGZvciAodmFyIGkgaW4gcHJvcHMpIHtcblx0ICAgICAgICBuYW1lcy5wdXNoKGkpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBuYW1lcztcblx0ICAgIH1cblx0XG5cdCAgICAvLyBkZWNvcmF0ZSBhIHNpbmdsZSBydWxlIHdpdGggcHJvcGVydHkgaW5mb1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdkZWNvcmF0ZVJ1bGUnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29yYXRlUnVsZShydWxlKSB7XG5cdCAgICAgIGlmIChydWxlLnByb3BlcnR5SW5mbykge1xuXHQgICAgICAgIHJldHVybiBydWxlLnByb3BlcnR5SW5mbztcblx0ICAgICAgfVxuXHQgICAgICB2YXIgaW5mbyA9IHt9LFxuXHQgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuXHQgICAgICB2YXIgaGFzUHJvcGVydGllcyA9IHRoaXMuY29sbGVjdFByb3BlcnRpZXMocnVsZSwgcHJvcGVydGllcyk7XG5cdCAgICAgIGlmIChoYXNQcm9wZXJ0aWVzKSB7XG5cdCAgICAgICAgaW5mby5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcblx0ICAgICAgICAvLyBUT0RPKHNvcnZlbGwpOiB3b3JrYXJvdW5kIHBhcnNlciBzZWVpbmcgbWl4aW5zIGFzIGFkZGl0aW9uYWwgcnVsZXNcblx0ICAgICAgICBydWxlLnJ1bGVzID0gbnVsbDtcblx0ICAgICAgfVxuXHQgICAgICBpbmZvLmNzc1RleHQgPSB0aGlzLmNvbGxlY3RDc3NUZXh0KHJ1bGUpO1xuXHQgICAgICBydWxlLnByb3BlcnR5SW5mbyA9IGluZm87XG5cdCAgICAgIHJldHVybiBpbmZvO1xuXHQgICAgfVxuXHRcblx0ICAgIC8vIGNvbGxlY3RzIHRoZSBjdXN0b20gcHJvcGVydGllcyBmcm9tIGEgcnVsZSdzIGNzc1RleHRcblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnY29sbGVjdFByb3BlcnRpZXMnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbGxlY3RQcm9wZXJ0aWVzKHJ1bGUsIHByb3BlcnRpZXMpIHtcblx0ICAgICAgdmFyIGluZm8gPSBydWxlLnByb3BlcnR5SW5mbztcblx0ICAgICAgaWYgKGluZm8pIHtcblx0ICAgICAgICBpZiAoaW5mby5wcm9wZXJ0aWVzKSB7XG5cdCAgICAgICAgICBPYmplY3QuYXNzaWduKHByb3BlcnRpZXMsIGluZm8ucHJvcGVydGllcyk7XG5cdCAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdmFyIG0gPSB2b2lkIDAsXG5cdCAgICAgICAgICAgIHJ4ID0gU3R5bGVVdGlsLnJ4LlZBUl9BU1NJR047XG5cdCAgICAgICAgdmFyIGNzc1RleHQgPSBydWxlLnBhcnNlZENzc1RleHQ7XG5cdCAgICAgICAgdmFyIHZhbHVlID0gdm9pZCAwO1xuXHQgICAgICAgIHZhciBhbnkgPSB2b2lkIDA7XG5cdCAgICAgICAgd2hpbGUgKG0gPSByeC5leGVjKGNzc1RleHQpKSB7XG5cdCAgICAgICAgICAvLyBub3RlOiBncm91cCAyIGlzIHZhciwgMyBpcyBtaXhpblxuXHQgICAgICAgICAgdmFsdWUgPSAobVsyXSB8fCBtWzNdKS50cmltKCk7XG5cdCAgICAgICAgICAvLyB2YWx1ZSBvZiAnaW5oZXJpdCcgb3IgJ3Vuc2V0JyBpcyBlcXVpdmFsZW50IHRvIG5vdCBzZXR0aW5nIHRoZSBwcm9wZXJ0eSBoZXJlXG5cdCAgICAgICAgICBpZiAodmFsdWUgIT09ICdpbmhlcml0JyB8fCB2YWx1ZSAhPT0gJ3Vuc2V0Jykge1xuXHQgICAgICAgICAgICBwcm9wZXJ0aWVzW21bMV0udHJpbSgpXSA9IHZhbHVlO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgYW55ID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGFueTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIC8vIHJldHVybnMgY3NzVGV4dCBvZiBwcm9wZXJ0aWVzIHRoYXQgY29uc3VtZSB2YXJpYWJsZXMvbWl4aW5zXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2NvbGxlY3RDc3NUZXh0Jyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBjb2xsZWN0Q3NzVGV4dChydWxlKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmNvbGxlY3RDb25zdW1pbmdDc3NUZXh0KHJ1bGUucGFyc2VkQ3NzVGV4dCk7XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gTk9URTogd2Ugc3VwcG9ydCBjb25zdW1wdGlvbiBpbnNpZGUgbWl4aW4gYXNzaWdubWVudFxuXHQgICAgLy8gYnV0IG5vdCBwcm9kdWN0aW9uLCBzbyBzdHJpcCBvdXQgey4uLn1cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnY29sbGVjdENvbnN1bWluZ0Nzc1RleHQnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbGxlY3RDb25zdW1pbmdDc3NUZXh0KGNzc1RleHQpIHtcblx0ICAgICAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShTdHlsZVV0aWwucnguQlJBQ0tFVEVELCAnJykucmVwbGFjZShTdHlsZVV0aWwucnguVkFSX0FTU0lHTiwgJycpO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2NvbGxlY3RQcm9wZXJ0aWVzSW5Dc3NUZXh0Jyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBjb2xsZWN0UHJvcGVydGllc0luQ3NzVGV4dChjc3NUZXh0LCBwcm9wcykge1xuXHQgICAgICB2YXIgbSA9IHZvaWQgMDtcblx0ICAgICAgd2hpbGUgKG0gPSBTdHlsZVV0aWwucnguVkFSX0NPTlNVTUVELmV4ZWMoY3NzVGV4dCkpIHtcblx0ICAgICAgICB2YXIgbmFtZSA9IG1bMV07XG5cdCAgICAgICAgLy8gVGhpcyByZWdleCBjYXRjaGVzIGFsbCB2YXJpYWJsZSBuYW1lcywgYW5kIGZvbGxvd2luZyBub24td2hpdGVzcGFjZSBjaGFyXG5cdCAgICAgICAgLy8gSWYgbmV4dCBjaGFyIGlzIG5vdCAnOicsIHRoZW4gdmFyaWFibGUgaXMgYSBjb25zdW1lclxuXHQgICAgICAgIGlmIChtWzJdICE9PSAnOicpIHtcblx0ICAgICAgICAgIHByb3BzW25hbWVdID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICAvLyB0dXJucyBjdXN0b20gcHJvcGVydGllcyBpbnRvIHJlYWxpemVkIHZhbHVlcy5cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAncmVpZnknLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHJlaWZ5KHByb3BzKSB7XG5cdCAgICAgIC8vIGJpZyBwZXJmIG9wdGltaXphdGlvbiBoZXJlOiByZWlmeSBvbmx5ICpvd24qIHByb3BlcnRpZXNcblx0ICAgICAgLy8gc2luY2UgdGhpcyBvYmplY3QgaGFzIF9fcHJvdG9fXyBvZiB0aGUgZWxlbWVudCdzIHNjb3BlIHByb3BlcnRpZXNcblx0ICAgICAgdmFyIG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcHMpO1xuXHQgICAgICBmb3IgKHZhciBpID0gMCwgbjsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgbiA9IG5hbWVzW2ldO1xuXHQgICAgICAgIHByb3BzW25dID0gdGhpcy52YWx1ZUZvclByb3BlcnR5KHByb3BzW25dLCBwcm9wcyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICAvLyBnaXZlbiBhIHByb3BlcnR5IHZhbHVlLCByZXR1cm5zIHRoZSByZWlmaWVkIHZhbHVlXG5cdCAgICAvLyBhIHByb3BlcnR5IHZhbHVlIG1heSBiZTpcblx0ICAgIC8vICgxKSBhIGxpdGVyYWwgdmFsdWUgbGlrZTogcmVkIG9yIDVweDtcblx0ICAgIC8vICgyKSBhIHZhcmlhYmxlIHZhbHVlIGxpa2U6IHZhcigtLWEpLCB2YXIoLS1hLCByZWQpLCBvciB2YXIoLS1hLCAtLWIpIG9yXG5cdCAgICAvLyB2YXIoLS1hLCB2YXIoLS1iKSk7XG5cdCAgICAvLyAoMykgYSBsaXRlcmFsIG1peGluIHZhbHVlIGxpa2UgeyBwcm9wZXJ0aWVzIH0uIEVhY2ggb2YgdGhlc2UgcHJvcGVydGllc1xuXHQgICAgLy8gY2FuIGhhdmUgdmFsdWVzIHRoYXQgYXJlOiAoYSkgbGl0ZXJhbCwgKGIpIHZhcmlhYmxlcywgKGMpIEBhcHBseSBtaXhpbnMuXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ3ZhbHVlRm9yUHJvcGVydHknLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlRm9yUHJvcGVydHkocHJvcGVydHksIHByb3BzKSB7XG5cdCAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdFxuXHQgICAgICAvLyBjYXNlICgxKSBkZWZhdWx0XG5cdCAgICAgIC8vIGNhc2UgKDMpIGRlZmluZXMgYSBtaXhpbiBhbmQgd2UgaGF2ZSB0byByZWlmeSB0aGUgaW50ZXJuYWxzXG5cdCAgICAgIGlmIChwcm9wZXJ0eSkge1xuXHQgICAgICAgIGlmIChwcm9wZXJ0eS5pbmRleE9mKCc7JykgPj0gMCkge1xuXHQgICAgICAgICAgcHJvcGVydHkgPSB0aGlzLnZhbHVlRm9yUHJvcGVydGllcyhwcm9wZXJ0eSwgcHJvcHMpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBjYXNlICgyKSB2YXJpYWJsZVxuXHQgICAgICAgICAgICB2YXIgc2VsZiA9IF90aGlzO1xuXHQgICAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiBmbihwcmVmaXgsIHZhbHVlLCBmYWxsYmFjaywgc3VmZml4KSB7XG5cdCAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArIHN1ZmZpeDtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgdmFyIHByb3BlcnR5VmFsdWUgPSBzZWxmLnZhbHVlRm9yUHJvcGVydHkocHJvcHNbdmFsdWVdLCBwcm9wcyk7XG5cdCAgICAgICAgICAgICAgLy8gaWYgdmFsdWUgaXMgXCJpbml0aWFsXCIsIHRoZW4gdGhlIHZhcmlhYmxlIHNob3VsZCBiZSB0cmVhdGVkIGFzIHVuc2V0XG5cdCAgICAgICAgICAgICAgaWYgKCFwcm9wZXJ0eVZhbHVlIHx8IHByb3BlcnR5VmFsdWUgPT09ICdpbml0aWFsJykge1xuXHQgICAgICAgICAgICAgICAgLy8gZmFsbGJhY2sgbWF5IGJlIC0tYSBvciB2YXIoLS1hKSBvciBsaXRlcmFsXG5cdCAgICAgICAgICAgICAgICBwcm9wZXJ0eVZhbHVlID0gc2VsZi52YWx1ZUZvclByb3BlcnR5KHByb3BzW2ZhbGxiYWNrXSB8fCBmYWxsYmFjaywgcHJvcHMpIHx8IGZhbGxiYWNrO1xuXHQgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlWYWx1ZSA9PT0gJ2FwcGx5LXNoaW0taW5oZXJpdCcpIHtcblx0ICAgICAgICAgICAgICAgIC8vIENTUyBidWlsZCB3aWxsIHJlcGxhY2UgYGluaGVyaXRgIHdpdGggYGFwcGx5LXNoaW0taW5oZXJpdGBcblx0ICAgICAgICAgICAgICAgIC8vIGZvciB1c2Ugd2l0aCBuYXRpdmUgY3NzIHZhcmlhYmxlcy5cblx0ICAgICAgICAgICAgICAgIC8vIFNpbmNlIHdlIGhhdmUgZnVsbCBjb250cm9sLCB3ZSBjYW4gdXNlIGBpbmhlcml0YCBkaXJlY3RseS5cblx0ICAgICAgICAgICAgICAgIHByb3BlcnR5VmFsdWUgPSAnaW5oZXJpdCc7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyAocHJvcGVydHlWYWx1ZSB8fCAnJykgKyBzdWZmaXg7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHByb3BlcnR5ID0gU3R5bGVVdGlsLnByb2Nlc3NWYXJpYWJsZUFuZEZhbGxiYWNrKHByb3BlcnR5LCBmbik7XG5cdCAgICAgICAgICB9KSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gcHJvcGVydHkgJiYgcHJvcGVydHkudHJpbSgpIHx8ICcnO1xuXHQgICAgfVxuXHRcblx0ICAgIC8vIG5vdGU6IHdlIGRvIG5vdCB5ZXQgc3VwcG9ydCBtaXhpbiB3aXRoaW4gbWl4aW5cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAndmFsdWVGb3JQcm9wZXJ0aWVzJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZUZvclByb3BlcnRpZXMocHJvcGVydHksIHByb3BzKSB7XG5cdCAgICAgIHZhciBwYXJ0cyA9IHByb3BlcnR5LnNwbGl0KCc7Jyk7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwLCBfcCwgbTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgaWYgKF9wID0gcGFydHNbaV0pIHtcblx0ICAgICAgICAgIFN0eWxlVXRpbC5yeC5NSVhJTl9NQVRDSC5sYXN0SW5kZXggPSAwO1xuXHQgICAgICAgICAgbSA9IFN0eWxlVXRpbC5yeC5NSVhJTl9NQVRDSC5leGVjKF9wKTtcblx0ICAgICAgICAgIGlmIChtKSB7XG5cdCAgICAgICAgICAgIF9wID0gdGhpcy52YWx1ZUZvclByb3BlcnR5KHByb3BzW21bMV1dLCBwcm9wcyk7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgY29sb24gPSBfcC5pbmRleE9mKCc6Jyk7XG5cdCAgICAgICAgICAgIGlmIChjb2xvbiAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgICB2YXIgcHAgPSBfcC5zdWJzdHJpbmcoY29sb24pO1xuXHQgICAgICAgICAgICAgIHBwID0gcHAudHJpbSgpO1xuXHQgICAgICAgICAgICAgIHBwID0gdGhpcy52YWx1ZUZvclByb3BlcnR5KHBwLCBwcm9wcykgfHwgcHA7XG5cdCAgICAgICAgICAgICAgX3AgPSBfcC5zdWJzdHJpbmcoMCwgY29sb24pICsgcHA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHBhcnRzW2ldID0gX3AgJiYgX3AubGFzdEluZGV4T2YoJzsnKSA9PT0gX3AubGVuZ3RoIC0gMSA/XG5cdCAgICAgICAgICAvLyBzdHJpcCB0cmFpbGluZyA7XG5cdCAgICAgICAgICBfcC5zbGljZSgwLCAtMSkgOiBfcCB8fCAnJztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJzsnKTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdhcHBseVByb3BlcnRpZXMnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5UHJvcGVydGllcyhydWxlLCBwcm9wcykge1xuXHQgICAgICB2YXIgb3V0cHV0ID0gJyc7XG5cdCAgICAgIC8vIGR5bmFtaWNhbGx5IGFkZGVkIHNoZWV0cyBtYXkgbm90IGJlIGRlY29yYXRlZCBzbyBlbnN1cmUgdGhleSBhcmUuXG5cdCAgICAgIGlmICghcnVsZS5wcm9wZXJ0eUluZm8pIHtcblx0ICAgICAgICB0aGlzLmRlY29yYXRlUnVsZShydWxlKTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAocnVsZS5wcm9wZXJ0eUluZm8uY3NzVGV4dCkge1xuXHQgICAgICAgIG91dHB1dCA9IHRoaXMudmFsdWVGb3JQcm9wZXJ0aWVzKHJ1bGUucHJvcGVydHlJbmZvLmNzc1RleHQsIHByb3BzKTtcblx0ICAgICAgfVxuXHQgICAgICBydWxlLmNzc1RleHQgPSBvdXRwdXQ7XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gQXBwbHkga2V5ZnJhbWUgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSBjc3NUZXh0IG9mIGEgZ2l2ZW4gcnVsZS4gVGhlXG5cdCAgICAvLyBrZXlmcmFtZVRyYW5zZm9ybXMgb2JqZWN0IGlzIGEgbWFwIG9mIGtleWZyYW1lIG5hbWVzIHRvIHRyYW5zZm9ybWVyXG5cdCAgICAvLyBmdW5jdGlvbnMgd2hpY2ggdGFrZSBpbiBjc3NUZXh0IGFuZCBzcGl0IG91dCB0cmFuc2Zvcm1lZCBjc3NUZXh0LlxuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdhcHBseUtleWZyYW1lVHJhbnNmb3JtcycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlLZXlmcmFtZVRyYW5zZm9ybXMocnVsZSwga2V5ZnJhbWVUcmFuc2Zvcm1zKSB7XG5cdCAgICAgIHZhciBpbnB1dCA9IHJ1bGUuY3NzVGV4dDtcblx0ICAgICAgdmFyIG91dHB1dCA9IHJ1bGUuY3NzVGV4dDtcblx0ICAgICAgaWYgKHJ1bGUuaGFzQW5pbWF0aW9ucyA9PSBudWxsKSB7XG5cdCAgICAgICAgLy8gQ2FjaGUgd2hldGhlciBvciBub3QgdGhlIHJ1bGUgaGFzIGFueSBhbmltYXRpb25zIHRvIGJlZ2luIHdpdGg6XG5cdCAgICAgICAgcnVsZS5oYXNBbmltYXRpb25zID0gU3R5bGVVdGlsLnJ4LkFOSU1BVElPTl9NQVRDSC50ZXN0KGlucHV0KTtcblx0ICAgICAgfVxuXHQgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gYW5pbWF0aW9ucyByZWZlcmVuY2VkLCB3ZSBjYW4gc2tpcCB0cmFuc2Zvcm1zOlxuXHQgICAgICBpZiAocnVsZS5oYXNBbmltYXRpb25zKSB7XG5cdCAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHZvaWQgMDtcblx0ICAgICAgICAvLyBJZiB3ZSBoYXZlbid0IHRyYW5zZm9ybWVkIHRoaXMgcnVsZSBiZWZvcmUsIHdlIGl0ZXJhdGUgb3ZlciBhbGxcblx0ICAgICAgICAvLyB0cmFuc2Zvcm1zOlxuXHQgICAgICAgIGlmIChydWxlLmtleWZyYW1lTmFtZXNUb1RyYW5zZm9ybSA9PSBudWxsKSB7XG5cdCAgICAgICAgICBydWxlLmtleWZyYW1lTmFtZXNUb1RyYW5zZm9ybSA9IFtdO1xuXHQgICAgICAgICAgZm9yICh2YXIga2V5ZnJhbWUgaW4ga2V5ZnJhbWVUcmFuc2Zvcm1zKSB7XG5cdCAgICAgICAgICAgIHRyYW5zZm9ybSA9IGtleWZyYW1lVHJhbnNmb3Jtc1trZXlmcmFtZV07XG5cdCAgICAgICAgICAgIG91dHB1dCA9IHRyYW5zZm9ybShpbnB1dCk7XG5cdCAgICAgICAgICAgIC8vIElmIHRoZSB0cmFuc2Zvcm0gYWN0dWFsbHkgY2hhbmdlZCB0aGUgQ1NTIHRleHQsIHdlIGNhY2hlIHRoZVxuXHQgICAgICAgICAgICAvLyB0cmFuc2Zvcm0gbmFtZSBmb3IgZnV0dXJlIHVzZTpcblx0ICAgICAgICAgICAgaWYgKGlucHV0ICE9PSBvdXRwdXQpIHtcblx0ICAgICAgICAgICAgICBpbnB1dCA9IG91dHB1dDtcblx0ICAgICAgICAgICAgICBydWxlLmtleWZyYW1lTmFtZXNUb1RyYW5zZm9ybS5wdXNoKGtleWZyYW1lKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgYSBsaXN0IG9mIGtleWZyYW1lIG5hbWVzIHRoYXQgYXBwbHkgdG8gdGhpc1xuXHQgICAgICAgICAgLy8gcnVsZSwgd2UgYXBwbHkgb25seSB0aG9zZSBrZXlmcmFtZSBuYW1lIHRyYW5zZm9ybXM6XG5cdCAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGUua2V5ZnJhbWVOYW1lc1RvVHJhbnNmb3JtLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgICAgIHRyYW5zZm9ybSA9IGtleWZyYW1lVHJhbnNmb3Jtc1tydWxlLmtleWZyYW1lTmFtZXNUb1RyYW5zZm9ybVtpXV07XG5cdCAgICAgICAgICAgIGlucHV0ID0gdHJhbnNmb3JtKGlucHV0KTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIG91dHB1dCA9IGlucHV0O1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICBydWxlLmNzc1RleHQgPSBvdXRwdXQ7XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gVGVzdCBpZiB0aGUgcnVsZXMgaW4gdGhlc2Ugc3R5bGVzIG1hdGNoZXMgdGhlIGdpdmVuIGBlbGVtZW50YCBhbmQgaWYgc28sXG5cdCAgICAvLyBjb2xsZWN0IGFueSBjdXN0b20gcHJvcGVydGllcyBpbnRvIGBwcm9wc2AuXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ3Byb3BlcnR5RGF0YUZyb21TdHlsZXMnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHByb3BlcnR5RGF0YUZyb21TdHlsZXMocnVsZXMsIGVsZW1lbnQpIHtcblx0ICAgICAgdmFyIHByb3BzID0ge30sXG5cdCAgICAgICAgICBzZWxmID0gdGhpcztcblx0ICAgICAgLy8gZ2VuZXJhdGVzIGEgdW5pcXVlIGtleSBmb3IgdGhlc2UgbWF0Y2hlc1xuXHQgICAgICB2YXIgbyA9IFtdO1xuXHQgICAgICAvLyBub3RlOiBhY3RpdmUgcnVsZXMgZXhjbHVkZXMgbm9uLW1hdGNoaW5nIEBtZWRpYSBydWxlc1xuXHQgICAgICBTdHlsZVV0aWwuZm9yRWFjaFJ1bGUocnVsZXMsIGZ1bmN0aW9uIChydWxlKSB7XG5cdCAgICAgICAgLy8gVE9ETyhzb3J2ZWxsKTogd2UgY291bGQgdHJpbSB0aGUgc2V0IG9mIHJ1bGVzIGF0IGRlY2xhcmF0aW9uXG5cdCAgICAgICAgLy8gdGltZSB0byBvbmx5IGluY2x1ZGUgb25lcyB0aGF0IGhhdmUgcHJvcGVydGllc1xuXHQgICAgICAgIGlmICghcnVsZS5wcm9wZXJ0eUluZm8pIHtcblx0ICAgICAgICAgIHNlbGYuZGVjb3JhdGVSdWxlKHJ1bGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBtYXRjaCBlbGVtZW50IGFnYWluc3QgdHJhbnNmb3JtZWRTZWxlY3Rvcjogc2VsZWN0b3IgbWF5IGNvbnRhaW5cblx0ICAgICAgICAvLyB1bndhbnRlZCB1bmlxdWlmaWNhdGlvbiBhbmQgcGFyc2VkU2VsZWN0b3IgZG9lcyBub3QgZGlyZWN0bHkgbWF0Y2hcblx0ICAgICAgICAvLyBmb3IgOmhvc3Qgc2VsZWN0b3JzLlxuXHQgICAgICAgIHZhciBzZWxlY3RvclRvTWF0Y2ggPSBydWxlLnRyYW5zZm9ybWVkU2VsZWN0b3IgfHwgcnVsZS5wYXJzZWRTZWxlY3Rvcjtcblx0ICAgICAgICBpZiAoZWxlbWVudCAmJiBydWxlLnByb3BlcnR5SW5mby5wcm9wZXJ0aWVzICYmIHNlbGVjdG9yVG9NYXRjaCkge1xuXHQgICAgICAgICAgaWYgKG1hdGNoZXNTZWxlY3Rvci5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yVG9NYXRjaCkpIHtcblx0ICAgICAgICAgICAgc2VsZi5jb2xsZWN0UHJvcGVydGllcyhydWxlLCBwcm9wcyk7XG5cdCAgICAgICAgICAgIC8vIHByb2R1Y2UgbnVtZXJpYyBrZXkgZm9yIHRoZXNlIG1hdGNoZXMgZm9yIGxvb2t1cFxuXHQgICAgICAgICAgICBhZGRUb0JpdE1hc2socnVsZS5pbmRleCwgbyk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9LCBudWxsLCB0cnVlKTtcblx0ICAgICAgcmV0dXJuIHsgcHJvcGVydGllczogcHJvcHMsIGtleTogbyB9O1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ3doZW5Ib3N0T3JSb290UnVsZScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gd2hlbkhvc3RPclJvb3RSdWxlKHNjb3BlLCBydWxlLCBjc3NCdWlsZCwgY2FsbGJhY2spIHtcblx0ICAgICAgaWYgKCFydWxlLnByb3BlcnR5SW5mbykge1xuXHQgICAgICAgIHRoaXMuZGVjb3JhdGVSdWxlKHJ1bGUpO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICghcnVsZS5wcm9wZXJ0eUluZm8ucHJvcGVydGllcykge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgaG9zdFNjb3BlID0gc2NvcGUuaXMgPyBfc3R5bGVUcmFuc2Zvcm1lcjIuZGVmYXVsdC5fY2FsY0hvc3RTY29wZShzY29wZS5pcywgc2NvcGUuZXh0ZW5kcykgOiAnaHRtbCc7XG5cdCAgICAgIHZhciBwYXJzZWRTZWxlY3RvciA9IHJ1bGUucGFyc2VkU2VsZWN0b3I7XG5cdCAgICAgIHZhciBpc1Jvb3QgPSBwYXJzZWRTZWxlY3RvciA9PT0gJzpob3N0ID4gKicgfHwgcGFyc2VkU2VsZWN0b3IgPT09ICdodG1sJztcblx0ICAgICAgdmFyIGlzSG9zdCA9IHBhcnNlZFNlbGVjdG9yLmluZGV4T2YoJzpob3N0JykgPT09IDAgJiYgIWlzUm9vdDtcblx0ICAgICAgLy8gYnVpbGQgaW5mbyBpcyBlaXRoZXIgaW4gc2NvcGUgKHdoZW4gc2NvcGUgaXMgYW4gZWxlbWVudCkgb3IgaW4gdGhlIHN0eWxlXG5cdCAgICAgIC8vIHdoZW4gc2NvcGUgaXMgdGhlIGRlZmF1bHQgc2NvcGU7IG5vdGU6IHRoaXMgYWxsb3dzIGRlZmF1bHQgc2NvcGUgdG8gaGF2ZVxuXHQgICAgICAvLyBtaXhlZCBtb2RlIGJ1aWx0IGFuZCB1bmJ1aWx0IHN0eWxlcy5cblx0ICAgICAgaWYgKGNzc0J1aWxkID09PSAnc2hhZHknKSB7XG5cdCAgICAgICAgLy8gOnJvb3QgLT4geC1mb28gPiAqLngtZm9vIGZvciBlbGVtZW50cyBhbmQgaHRtbCBmb3IgY3VzdG9tLXN0eWxlXG5cdCAgICAgICAgaXNSb290ID0gcGFyc2VkU2VsZWN0b3IgPT09IGhvc3RTY29wZSArICcgPiAqLicgKyBob3N0U2NvcGUgfHwgcGFyc2VkU2VsZWN0b3IuaW5kZXhPZignaHRtbCcpICE9PSAtMTtcblx0ICAgICAgICAvLyA6aG9zdCAtPiB4LWZvbyBmb3IgZWxlbWVudHMsIGJ1dCBzdWItcnVsZXMgaGF2ZSAueC1mb28gaW4gdGhlbVxuXHQgICAgICAgIGlzSG9zdCA9ICFpc1Jvb3QgJiYgcGFyc2VkU2VsZWN0b3IuaW5kZXhPZihob3N0U2NvcGUpID09PSAwO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChjc3NCdWlsZCA9PT0gJ3NoYWRvdycpIHtcblx0ICAgICAgICBpc1Jvb3QgPSBwYXJzZWRTZWxlY3RvciA9PT0gJzpob3N0ID4gKicgfHwgcGFyc2VkU2VsZWN0b3IgPT09ICdodG1sJztcblx0ICAgICAgICBpc0hvc3QgPSBpc0hvc3QgJiYgIWlzUm9vdDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoIWlzUm9vdCAmJiAhaXNIb3N0KSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBzZWxlY3RvclRvTWF0Y2ggPSBob3N0U2NvcGU7XG5cdCAgICAgIGlmIChpc0hvc3QpIHtcblx0ICAgICAgICAvLyBuZWVkIHRvIHRyYW5zZm9ybSA6aG9zdCB1bmRlciBTaGFkb3dET00gYmVjYXVzZSBgOmhvc3RgIGRvZXMgbm90IHdvcmsgd2l0aCBgbWF0Y2hlc2Bcblx0ICAgICAgICBpZiAoX3N0eWxlU2V0dGluZ3MubmF0aXZlU2hhZG93ICYmICFydWxlLnRyYW5zZm9ybWVkU2VsZWN0b3IpIHtcblx0ICAgICAgICAgIC8vIHRyYW5zZm9ybSA6aG9zdCBpbnRvIGEgbWF0Y2hhYmxlIHNlbGVjdG9yXG5cdCAgICAgICAgICBydWxlLnRyYW5zZm9ybWVkU2VsZWN0b3IgPSBfc3R5bGVUcmFuc2Zvcm1lcjIuZGVmYXVsdC5fdHJhbnNmb3JtUnVsZUNzcyhydWxlLCBfc3R5bGVUcmFuc2Zvcm1lcjIuZGVmYXVsdC5fdHJhbnNmb3JtQ29tcGxleFNlbGVjdG9yLCBfc3R5bGVUcmFuc2Zvcm1lcjIuZGVmYXVsdC5fY2FsY0VsZW1lbnRTY29wZShzY29wZS5pcyksIGhvc3RTY29wZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHNlbGVjdG9yVG9NYXRjaCA9IHJ1bGUudHJhbnNmb3JtZWRTZWxlY3RvciB8fCBob3N0U2NvcGU7XG5cdCAgICAgIH1cblx0ICAgICAgY2FsbGJhY2soe1xuXHQgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvclRvTWF0Y2gsXG5cdCAgICAgICAgaXNIb3N0OiBpc0hvc3QsXG5cdCAgICAgICAgaXNSb290OiBpc1Jvb3Rcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnaG9zdEFuZFJvb3RQcm9wZXJ0aWVzRm9yU2NvcGUnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGhvc3RBbmRSb290UHJvcGVydGllc0ZvclNjb3BlKHNjb3BlLCBydWxlcykge1xuXHQgICAgICB2YXIgaG9zdFByb3BzID0ge30sXG5cdCAgICAgICAgICByb290UHJvcHMgPSB7fSxcblx0ICAgICAgICAgIHNlbGYgPSB0aGlzO1xuXHQgICAgICAvLyBub3RlOiBhY3RpdmUgcnVsZXMgZXhjbHVkZXMgbm9uLW1hdGNoaW5nIEBtZWRpYSBydWxlc1xuXHQgICAgICB2YXIgY3NzQnVpbGQgPSBydWxlcyAmJiBydWxlcy5fX2Nzc0J1aWxkO1xuXHQgICAgICBTdHlsZVV0aWwuZm9yRWFjaFJ1bGUocnVsZXMsIGZ1bmN0aW9uIChydWxlKSB7XG5cdCAgICAgICAgLy8gaWYgc2NvcGUgaXMgU3R5bGVEZWZhdWx0cywgdXNlIF9lbGVtZW50IGZvciBtYXRjaGVzU2VsZWN0b3Jcblx0ICAgICAgICBzZWxmLndoZW5Ib3N0T3JSb290UnVsZShzY29wZSwgcnVsZSwgY3NzQnVpbGQsIGZ1bmN0aW9uIChpbmZvKSB7XG5cdCAgICAgICAgICB2YXIgZWxlbWVudCA9IHNjb3BlLl9lbGVtZW50IHx8IHNjb3BlO1xuXHQgICAgICAgICAgaWYgKG1hdGNoZXNTZWxlY3Rvci5jYWxsKGVsZW1lbnQsIGluZm8uc2VsZWN0b3IpKSB7XG5cdCAgICAgICAgICAgIGlmIChpbmZvLmlzSG9zdCkge1xuXHQgICAgICAgICAgICAgIHNlbGYuY29sbGVjdFByb3BlcnRpZXMocnVsZSwgaG9zdFByb3BzKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICBzZWxmLmNvbGxlY3RQcm9wZXJ0aWVzKHJ1bGUsIHJvb3RQcm9wcyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgfSwgbnVsbCwgdHJ1ZSk7XG5cdCAgICAgIHJldHVybiB7IHJvb3RQcm9wczogcm9vdFByb3BzLCBob3N0UHJvcHM6IGhvc3RQcm9wcyB9O1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ3RyYW5zZm9ybVN0eWxlcycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNmb3JtU3R5bGVzKGVsZW1lbnQsIHByb3BlcnRpZXMsIHNjb3BlU2VsZWN0b3IpIHtcblx0ICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgICAgICB2YXIgaG9zdFNlbGVjdG9yID0gX3N0eWxlVHJhbnNmb3JtZXIyLmRlZmF1bHQuX2NhbGNIb3N0U2NvcGUoZWxlbWVudC5pcywgZWxlbWVudC5leHRlbmRzKTtcblx0ICAgICAgdmFyIHJ4SG9zdFNlbGVjdG9yID0gZWxlbWVudC5leHRlbmRzID8gJ1xcXFwnICsgaG9zdFNlbGVjdG9yLnNsaWNlKDAsIC0xKSArICdcXFxcXScgOiBob3N0U2VsZWN0b3I7XG5cdCAgICAgIHZhciBob3N0UnggPSBuZXcgUmVnRXhwKFN0eWxlVXRpbC5yeC5IT1NUX1BSRUZJWCArIHJ4SG9zdFNlbGVjdG9yICsgU3R5bGVVdGlsLnJ4LkhPU1RfU1VGRklYKTtcblx0ICAgICAgdmFyIHJ1bGVzID0gX3N0eWxlSW5mbzIuZGVmYXVsdC5nZXQoZWxlbWVudCkuc3R5bGVSdWxlcztcblx0ICAgICAgdmFyIGtleWZyYW1lVHJhbnNmb3JtcyA9IHRoaXMuX2VsZW1lbnRLZXlmcmFtZVRyYW5zZm9ybXMoZWxlbWVudCwgcnVsZXMsIHNjb3BlU2VsZWN0b3IpO1xuXHQgICAgICByZXR1cm4gX3N0eWxlVHJhbnNmb3JtZXIyLmRlZmF1bHQuZWxlbWVudFN0eWxlcyhlbGVtZW50LCBydWxlcywgZnVuY3Rpb24gKHJ1bGUpIHtcblx0ICAgICAgICBzZWxmLmFwcGx5UHJvcGVydGllcyhydWxlLCBwcm9wZXJ0aWVzKTtcblx0ICAgICAgICBpZiAoIV9zdHlsZVNldHRpbmdzLm5hdGl2ZVNoYWRvdyAmJiAhU3R5bGVVdGlsLmlzS2V5ZnJhbWVzU2VsZWN0b3IocnVsZSkgJiYgcnVsZS5jc3NUZXh0KSB7XG5cdCAgICAgICAgICAvLyBOT1RFOiBrZXlmcmFtZSB0cmFuc2Zvcm1zIG9ubHkgc2NvcGUgbXVuZ2UgYW5pbWF0aW9uIG5hbWVzLCBzbyBpdFxuXHQgICAgICAgICAgLy8gaXMgbm90IG5lY2Vzc2FyeSB0byBhcHBseSB0aGVtIGluIFNoYWRvd0RPTS5cblx0ICAgICAgICAgIHNlbGYuYXBwbHlLZXlmcmFtZVRyYW5zZm9ybXMocnVsZSwga2V5ZnJhbWVUcmFuc2Zvcm1zKTtcblx0ICAgICAgICAgIHNlbGYuX3Njb3BlU2VsZWN0b3IocnVsZSwgaG9zdFJ4LCBob3N0U2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX2VsZW1lbnRLZXlmcmFtZVRyYW5zZm9ybXMnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF9lbGVtZW50S2V5ZnJhbWVUcmFuc2Zvcm1zKGVsZW1lbnQsIHJ1bGVzLCBzY29wZVNlbGVjdG9yKSB7XG5cdCAgICAgIHZhciBrZXlmcmFtZXNSdWxlcyA9IHJ1bGVzLl9rZXlmcmFtZXM7XG5cdCAgICAgIHZhciBrZXlmcmFtZVRyYW5zZm9ybXMgPSB7fTtcblx0ICAgICAgaWYgKCFfc3R5bGVTZXR0aW5ncy5uYXRpdmVTaGFkb3cgJiYga2V5ZnJhbWVzUnVsZXMpIHtcblx0ICAgICAgICAvLyBGb3Igbm9uLVNoYWRvd0RPTSwgd2UgdHJhbnNmb3JtIGFsbCBrbm93biBrZXlmcmFtZXMgcnVsZXMgaW5cblx0ICAgICAgICAvLyBhZHZhbmNlIGZvciB0aGUgY3VycmVudCBzY29wZS4gVGhpcyBhbGxvd3MgdXMgdG8gY2F0Y2gga2V5ZnJhbWVzXG5cdCAgICAgICAgLy8gcnVsZXMgdGhhdCBhcHBlYXIgYW55d2hlcmUgaW4gdGhlIHN0eWxlc2hlZXQ6XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDAsIGtleWZyYW1lc1J1bGUgPSBrZXlmcmFtZXNSdWxlc1tpXTsgaSA8IGtleWZyYW1lc1J1bGVzLmxlbmd0aDsga2V5ZnJhbWVzUnVsZSA9IGtleWZyYW1lc1J1bGVzWysraV0pIHtcblx0ICAgICAgICAgIHRoaXMuX3Njb3BlS2V5ZnJhbWVzKGtleWZyYW1lc1J1bGUsIHNjb3BlU2VsZWN0b3IpO1xuXHQgICAgICAgICAga2V5ZnJhbWVUcmFuc2Zvcm1zW2tleWZyYW1lc1J1bGUua2V5ZnJhbWVzTmFtZV0gPSB0aGlzLl9rZXlmcmFtZXNSdWxlVHJhbnNmb3JtZXIoa2V5ZnJhbWVzUnVsZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBrZXlmcmFtZVRyYW5zZm9ybXM7XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gR2VuZXJhdGUgYSBmYWN0b3J5IGZvciB0cmFuc2Zvcm1pbmcgYSBjaHVuayBvZiBDU1MgdGV4dCB0byBoYW5kbGUgYVxuXHQgICAgLy8gcGFydGljdWxhciBzY29wZWQga2V5ZnJhbWVzIHJ1bGUuXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ19rZXlmcmFtZXNSdWxlVHJhbnNmb3JtZXInLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF9rZXlmcmFtZXNSdWxlVHJhbnNmb3JtZXIoa2V5ZnJhbWVzUnVsZSkge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24gKGNzc1RleHQpIHtcblx0ICAgICAgICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKGtleWZyYW1lc1J1bGUua2V5ZnJhbWVzTmFtZVJ4LCBrZXlmcmFtZXNSdWxlLnRyYW5zZm9ybWVkS2V5ZnJhbWVzTmFtZSk7XG5cdCAgICAgIH07XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gVHJhbnNmb3JtcyBgQGtleWZyYW1lc2AgbmFtZXMgdG8gYmUgdW5pcXVlIGZvciB0aGUgY3VycmVudCBob3N0LlxuXHQgICAgLy8gRXhhbXBsZTogQGtleWZyYW1lcyBmb28tYW5pbSAtPiBAa2V5ZnJhbWVzIGZvby1hbmltLXgtZm9vLTBcblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX3Njb3BlS2V5ZnJhbWVzJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBfc2NvcGVLZXlmcmFtZXMocnVsZSwgc2NvcGVJZCkge1xuXHQgICAgICBydWxlLmtleWZyYW1lc05hbWVSeCA9IG5ldyBSZWdFeHAocnVsZS5rZXlmcmFtZXNOYW1lLCAnZycpO1xuXHQgICAgICBydWxlLnRyYW5zZm9ybWVkS2V5ZnJhbWVzTmFtZSA9IHJ1bGUua2V5ZnJhbWVzTmFtZSArICctJyArIHNjb3BlSWQ7XG5cdCAgICAgIHJ1bGUudHJhbnNmb3JtZWRTZWxlY3RvciA9IHJ1bGUudHJhbnNmb3JtZWRTZWxlY3RvciB8fCBydWxlLnNlbGVjdG9yO1xuXHQgICAgICBydWxlLnNlbGVjdG9yID0gcnVsZS50cmFuc2Zvcm1lZFNlbGVjdG9yLnJlcGxhY2UocnVsZS5rZXlmcmFtZXNOYW1lLCBydWxlLnRyYW5zZm9ybWVkS2V5ZnJhbWVzTmFtZSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gU3RyYXRlZ3k6IHggc2NvcGUgc2hpbSBhIHNlbGVjdG9yIGUuZy4gdG8gc2NvcGUgYC54LWZvby00MmAgKHZpYSBjbGFzc2VzKTpcblx0ICAgIC8vIG5vbi1ob3N0IHNlbGVjdG9yOiAuYS54LWZvbyAtPiAueC1mb28tNDIgLmEueC1mb29cblx0ICAgIC8vIGhvc3Qgc2VsZWN0b3I6IHgtZm9vLndpZGUgLT4gLngtZm9vLTQyLndpZGVcblx0ICAgIC8vIG5vdGU6IHdlIHVzZSBvbmx5IHRoZSBzY29wZSBjbGFzcyAoLngtZm9vLTQyKSBhbmQgbm90IHRoZSBob3N0U2VsZWN0b3Jcblx0ICAgIC8vICh4LWZvbykgdG8gc2NvcGUgOmhvc3QgcnVsZXM7IHRoaXMgaGVscHMgbWFrZSBwcm9wZXJ0eSBob3N0IHJ1bGVzXG5cdCAgICAvLyBoYXZlIGxvdyBzcGVjaWZpY2l0eS4gVGhleSBhcmUgb3ZlcnJpZGVhYmxlIGJ5IGNsYXNzIHNlbGVjdG9ycyBidXQsXG5cdCAgICAvLyB1bmZvcnR1bmF0ZWx5LCBub3QgYnkgdHlwZSBzZWxlY3RvcnMgKGUuZy4gb3ZlcnJpZGluZyB2aWFcblx0ICAgIC8vIGAuc3BlY2lhbGAgaXMgb2ssIGJ1dCBub3QgYnkgYHgtZm9vYCkuXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ19zY29wZVNlbGVjdG9yJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBfc2NvcGVTZWxlY3RvcihydWxlLCBob3N0UngsIGhvc3RTZWxlY3Rvciwgc2NvcGVJZCkge1xuXHQgICAgICBydWxlLnRyYW5zZm9ybWVkU2VsZWN0b3IgPSBydWxlLnRyYW5zZm9ybWVkU2VsZWN0b3IgfHwgcnVsZS5zZWxlY3Rvcjtcblx0ICAgICAgdmFyIHNlbGVjdG9yID0gcnVsZS50cmFuc2Zvcm1lZFNlbGVjdG9yO1xuXHQgICAgICB2YXIgc2NvcGUgPSAnLicgKyBzY29wZUlkO1xuXHQgICAgICB2YXIgcGFydHMgPSBzZWxlY3Rvci5zcGxpdCgnLCcpO1xuXHQgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcnRzLmxlbmd0aCwgX3AyOyBpIDwgbCAmJiAoX3AyID0gcGFydHNbaV0pOyBpKyspIHtcblx0ICAgICAgICBwYXJ0c1tpXSA9IF9wMi5tYXRjaChob3N0UngpID8gX3AyLnJlcGxhY2UoaG9zdFNlbGVjdG9yLCBzY29wZSkgOiBzY29wZSArICcgJyArIF9wMjtcblx0ICAgICAgfVxuXHQgICAgICBydWxlLnNlbGVjdG9yID0gcGFydHMuam9pbignLCcpO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2FwcGx5RWxlbWVudFNjb3BlU2VsZWN0b3InLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5RWxlbWVudFNjb3BlU2VsZWN0b3IoZWxlbWVudCwgc2VsZWN0b3IsIG9sZCkge1xuXHQgICAgICB2YXIgYyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnO1xuXHQgICAgICB2YXIgdiA9IGM7XG5cdCAgICAgIGlmIChvbGQpIHtcblx0ICAgICAgICB2ID0gYy5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFxzKicgKyBYU0NPUEVfTkFNRSArICdcXFxccyonICsgb2xkICsgJ1xcXFxzKicsICdnJyksICcgJyk7XG5cdCAgICAgIH1cblx0ICAgICAgdiArPSAodiA/ICcgJyA6ICcnKSArIFhTQ09QRV9OQU1FICsgJyAnICsgc2VsZWN0b3I7XG5cdCAgICAgIGlmIChjICE9PSB2KSB7XG5cdCAgICAgICAgU3R5bGVVdGlsLnNldEVsZW1lbnRDbGFzc1JhdyhlbGVtZW50LCB2KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2FwcGx5RWxlbWVudFN0eWxlJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseUVsZW1lbnRTdHlsZShlbGVtZW50LCBwcm9wZXJ0aWVzLCBzZWxlY3Rvciwgc3R5bGUpIHtcblx0ICAgICAgLy8gY2FsY3VsYXRlIGNzc1RleHQgdG8gYXBwbHlcblx0ICAgICAgdmFyIGNzc1RleHQgPSBzdHlsZSA/IHN0eWxlLnRleHRDb250ZW50IHx8ICcnIDogdGhpcy50cmFuc2Zvcm1TdHlsZXMoZWxlbWVudCwgcHJvcGVydGllcywgc2VsZWN0b3IpO1xuXHQgICAgICAvLyBpZiBzaGFkeSBhbmQgd2UgaGF2ZSBhIGNhY2hlZCBzdHlsZSB0aGF0IGlzIG5vdCBzdHlsZSwgZGVjcmVtZW50XG5cdCAgICAgIHZhciBzdHlsZUluZm8gPSBfc3R5bGVJbmZvMi5kZWZhdWx0LmdldChlbGVtZW50KTtcblx0ICAgICAgdmFyIHMgPSBzdHlsZUluZm8uY3VzdG9tU3R5bGU7XG5cdCAgICAgIGlmIChzICYmICFfc3R5bGVTZXR0aW5ncy5uYXRpdmVTaGFkb3cgJiYgcyAhPT0gc3R5bGUpIHtcblx0ICAgICAgICBzLl91c2VDb3VudC0tO1xuXHQgICAgICAgIGlmIChzLl91c2VDb3VudCA8PSAwICYmIHMucGFyZW50Tm9kZSkge1xuXHQgICAgICAgICAgcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICAvLyBhcHBseSBzdHlsaW5nIGFsd2F5cyB1bmRlciBuYXRpdmUgb3IgaWYgd2UgZ2VuZXJhdGVkIHN0eWxlXG5cdCAgICAgIC8vIG9yIHRoZSBjYWNoZWQgc3R5bGUgaXMgbm90IGluIGRvY3VtZW50KCEpXG5cdCAgICAgIGlmIChfc3R5bGVTZXR0aW5ncy5uYXRpdmVTaGFkb3cpIHtcblx0ICAgICAgICAvLyB1cGRhdGUgZXhpc3Rpbmcgc3R5bGUgb25seSB1bmRlciBuYXRpdmVcblx0ICAgICAgICBpZiAoc3R5bGVJbmZvLmN1c3RvbVN0eWxlKSB7XG5cdCAgICAgICAgICBzdHlsZUluZm8uY3VzdG9tU3R5bGUudGV4dENvbnRlbnQgPSBjc3NUZXh0O1xuXHQgICAgICAgICAgc3R5bGUgPSBzdHlsZUluZm8uY3VzdG9tU3R5bGU7XG5cdCAgICAgICAgICAvLyBvdGhlcndpc2UsIGlmIHdlIGhhdmUgY3NzIHRvIGFwcGx5LCBkbyBzb1xuXHQgICAgICAgIH0gZWxzZSBpZiAoY3NzVGV4dCkge1xuXHQgICAgICAgICAgLy8gYXBwbHkgY3NzIGFmdGVyIHRoZSBzY29wZSBzdHlsZSBvZiB0aGUgZWxlbWVudCB0byBoZWxwIHdpdGhcblx0ICAgICAgICAgIC8vIHN0eWxlIHByZWNlZGVuY2UgcnVsZXMuXG5cdCAgICAgICAgICBzdHlsZSA9IFN0eWxlVXRpbC5hcHBseUNzcyhjc3NUZXh0LCBzZWxlY3RvciwgZWxlbWVudC5zaGFkb3dSb290LCBzdHlsZUluZm8ucGxhY2Vob2xkZXIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAvLyBzaGFkeSBhbmQgbm8gY2FjaGUgaGl0XG5cdCAgICAgICAgaWYgKCFzdHlsZSkge1xuXHQgICAgICAgICAgLy8gYXBwbHkgY3NzIGFmdGVyIHRoZSBzY29wZSBzdHlsZSBvZiB0aGUgZWxlbWVudCB0byBoZWxwIHdpdGhcblx0ICAgICAgICAgIC8vIHN0eWxlIHByZWNlZGVuY2UgcnVsZXMuXG5cdCAgICAgICAgICBpZiAoY3NzVGV4dCkge1xuXHQgICAgICAgICAgICBzdHlsZSA9IFN0eWxlVXRpbC5hcHBseUNzcyhjc3NUZXh0LCBzZWxlY3RvciwgbnVsbCwgc3R5bGVJbmZvLnBsYWNlaG9sZGVyKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIC8vIHNoYWR5IGFuZCBjYWNoZSBoaXQgYnV0IG5vdCBpbiBkb2N1bWVudFxuXHQgICAgICAgIH0gZWxzZSBpZiAoIXN0eWxlLnBhcmVudE5vZGUpIHtcblx0ICAgICAgICAgIFN0eWxlVXRpbC5hcHBseVN0eWxlKHN0eWxlLCBudWxsLCBzdHlsZUluZm8ucGxhY2Vob2xkZXIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICAvLyBlbnN1cmUgdGhpcyBzdHlsZSBpcyBvdXIgY3VzdG9tIHN0eWxlIGFuZCBpbmNyZW1lbnQgaXRzIHVzZSBjb3VudC5cblx0ICAgICAgaWYgKHN0eWxlKSB7XG5cdCAgICAgICAgc3R5bGUuX3VzZUNvdW50ID0gc3R5bGUuX3VzZUNvdW50IHx8IDA7XG5cdCAgICAgICAgLy8gaW5jcmVtZW50IHVzZSBjb3VudCBpZiB3ZSBjaGFuZ2VkIHN0eWxlc1xuXHQgICAgICAgIGlmIChzdHlsZUluZm8uY3VzdG9tU3R5bGUgIT0gc3R5bGUpIHtcblx0ICAgICAgICAgIHN0eWxlLl91c2VDb3VudCsrO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBzdHlsZUluZm8uY3VzdG9tU3R5bGUgPSBzdHlsZTtcblx0ICAgICAgfVxuXHQgICAgICAvLyBAbWVkaWEgcnVsZXMgbWF5IGJlIHN0YWxlIGluIElFIDEwIGFuZCAxMVxuXHQgICAgICBpZiAoSVNfSUUpIHtcblx0ICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IHN0eWxlLnRleHRDb250ZW50O1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBzdHlsZTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdhcHBseUN1c3RvbVN0eWxlJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseUN1c3RvbVN0eWxlKHN0eWxlLCBwcm9wZXJ0aWVzKSB7XG5cdCAgICAgIHZhciBydWxlcyA9IFN0eWxlVXRpbC5ydWxlc0ZvclN0eWxlKHN0eWxlKTtcblx0ICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IFN0eWxlVXRpbC50b0Nzc1RleHQocnVsZXMsIGZ1bmN0aW9uIChydWxlKSB7XG5cdCAgICAgICAgdmFyIGNzcyA9IHJ1bGUuY3NzVGV4dCA9IHJ1bGUucGFyc2VkQ3NzVGV4dDtcblx0ICAgICAgICBpZiAocnVsZS5wcm9wZXJ0eUluZm8gJiYgcnVsZS5wcm9wZXJ0eUluZm8uY3NzVGV4dCkge1xuXHQgICAgICAgICAgLy8gcmVtb3ZlIHByb3BlcnR5IGFzc2lnbm1lbnRzXG5cdCAgICAgICAgICAvLyBzbyBuZXh0IGZ1bmN0aW9uIGlzbid0IGNvbmZ1c2VkXG5cdCAgICAgICAgICAvLyBOT1RFOiB3ZSBoYXZlIDMgY2F0ZWdvcmllcyBvZiBjc3M6XG5cdCAgICAgICAgICAvLyAoMSkgbm9ybWFsIHByb3BlcnRpZXMsXG5cdCAgICAgICAgICAvLyAoMikgY3VzdG9tIHByb3BlcnR5IGFzc2lnbm1lbnRzICgtLWZvbzogcmVkOyksXG5cdCAgICAgICAgICAvLyAoMykgY3VzdG9tIHByb3BlcnR5IHVzYWdlOiBib3JkZXI6IHZhcigtLWZvbyk7IEBhcHBseSgtLWZvbyk7XG5cdCAgICAgICAgICAvLyBJbiBlbGVtZW50cywgMSBhbmQgMyBhcmUgc2VwYXJhdGVkIGZvciBlZmZpY2llbmN5OyBoZXJlIHRoZXlcblx0ICAgICAgICAgIC8vIGFyZSBub3QgYW5kIHRoaXMgbWFrZXMgdGhpcyBjYXNlIHVuaXF1ZS5cblx0ICAgICAgICAgIGNzcyA9ICgwLCBfY3NzUGFyc2UucmVtb3ZlQ3VzdG9tUHJvcEFzc2lnbm1lbnQpKGNzcyk7XG5cdCAgICAgICAgICAvLyByZXBsYWNlIHdpdGggcmVpZmllZCBwcm9wZXJ0aWVzLCBzY2VuYXJpbyBpcyBzYW1lIGFzIG1peGluXG5cdCAgICAgICAgICBydWxlLmNzc1RleHQgPSBzZWxmLnZhbHVlRm9yUHJvcGVydGllcyhjc3MsIHByb3BlcnRpZXMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnWFNDT1BFX05BTUUnLFxuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgIHJldHVybiBYU0NPUEVfTkFNRTtcblx0ICAgIH1cblx0ICB9XSk7XG5cdFxuXHQgIHJldHVybiBTdHlsZVByb3BlcnRpZXM7XG5cdH0oKTtcblx0XG5cdGZ1bmN0aW9uIGFkZFRvQml0TWFzayhuLCBiaXRzKSB7XG5cdCAgdmFyIG8gPSBwYXJzZUludChuIC8gMzIpO1xuXHQgIHZhciB2ID0gMSA8PCBuICUgMzI7XG5cdCAgYml0c1tvXSA9IChiaXRzW29dIHx8IDApIHwgdjtcblx0fVxuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gbmV3IFN0eWxlUHJvcGVydGllcygpO1xuXG4vKioqLyB9LFxuLyogNzQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qKlxuXHRAbGljZW5zZVxuXHRDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXHRUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5cdFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5cdFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuXHRDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuXHRzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuXHQqL1xuXHRcblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdFxuXHR2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXHRcblx0dmFyIF90ZW1wbGF0ZU1hcCA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpO1xuXHRcblx0dmFyIF90ZW1wbGF0ZU1hcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90ZW1wbGF0ZU1hcCk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblx0XG5cdHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFxuXHR2YXIgU3R5bGVJbmZvID0gZnVuY3Rpb24gKCkge1xuXHQgIF9jcmVhdGVDbGFzcyhTdHlsZUluZm8sIG51bGwsIFt7XG5cdCAgICBrZXk6ICdnZXQnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGdldChub2RlKSB7XG5cdCAgICAgIHJldHVybiBub2RlLl9fc3R5bGVJbmZvO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ3NldCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KG5vZGUsIHN0eWxlSW5mbykge1xuXHQgICAgICBub2RlLl9fc3R5bGVJbmZvID0gc3R5bGVJbmZvO1xuXHQgICAgICByZXR1cm4gc3R5bGVJbmZvO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2ludmFsaWRhdGUnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGludmFsaWRhdGUoZWxlbWVudE5hbWUpIHtcblx0ICAgICAgaWYgKF90ZW1wbGF0ZU1hcDIuZGVmYXVsdFtlbGVtZW50TmFtZV0pIHtcblx0ICAgICAgICBfdGVtcGxhdGVNYXAyLmRlZmF1bHRbZWxlbWVudE5hbWVdLl9hcHBseVNoaW1JbnZhbGlkID0gdHJ1ZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgLypcblx0ICAgIHRoZSB0ZW1wbGF0ZSBpcyBtYXJrZWQgYXMgYHZhbGlkYXRpbmdgIGZvciBvbmUgbWljcm90YXNrIHNvIHRoYXQgYWxsIGluc3RhbmNlc1xuXHQgICAgZm91bmQgaW4gdGhlIHRyZWUgY3Jhd2wgb2YgYGFwcGx5U3R5bGVgIHdpbGwgdXBkYXRlIHRoZW1zZWx2ZXMsXG5cdCAgICBidXQgdGhlIHRlbXBsYXRlIHdpbGwgb25seSBiZSB1cGRhdGVkIG9uY2UuXG5cdCAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdzdGFydFZhbGlkYXRpbmcnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0VmFsaWRhdGluZyhlbGVtZW50TmFtZSkge1xuXHQgICAgICB2YXIgdGVtcGxhdGUgPSBfdGVtcGxhdGVNYXAyLmRlZmF1bHRbZWxlbWVudE5hbWVdO1xuXHQgICAgICBpZiAoIXRlbXBsYXRlLl92YWxpZGF0aW5nKSB7XG5cdCAgICAgICAgdGVtcGxhdGUuX3ZhbGlkYXRpbmcgPSB0cnVlO1xuXHQgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICB0ZW1wbGF0ZS5fYXBwbHlTaGltSW52YWxpZCA9IGZhbHNlO1xuXHQgICAgICAgICAgdGVtcGxhdGUuX3ZhbGlkYXRpbmcgPSBmYWxzZTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1dKTtcblx0XG5cdCAgZnVuY3Rpb24gU3R5bGVJbmZvKGFzdCwgcGxhY2Vob2xkZXIsIG93blN0eWxlUHJvcGVydHlOYW1lcywgZWxlbWVudE5hbWUsIHR5cGVFeHRlbnNpb24sIGNzc0J1aWxkKSB7XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3R5bGVJbmZvKTtcblx0XG5cdCAgICB0aGlzLnN0eWxlUnVsZXMgPSBhc3QgfHwgbnVsbDtcblx0ICAgIHRoaXMucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlciB8fCBudWxsO1xuXHQgICAgdGhpcy5vd25TdHlsZVByb3BlcnR5TmFtZXMgPSBvd25TdHlsZVByb3BlcnR5TmFtZXMgfHwgW107XG5cdCAgICB0aGlzLm92ZXJyaWRlU3R5bGVQcm9wZXJ0aWVzID0gbnVsbDtcblx0ICAgIHRoaXMuZWxlbWVudE5hbWUgPSBlbGVtZW50TmFtZSB8fCAnJztcblx0ICAgIHRoaXMuY3NzQnVpbGQgPSBjc3NCdWlsZCB8fCAnJztcblx0ICAgIHRoaXMudHlwZUV4dGVuc2lvbiA9IHR5cGVFeHRlbnNpb24gfHwgJyc7XG5cdCAgICB0aGlzLnN0eWxlUHJvcGVydGllcyA9IG51bGw7XG5cdCAgICB0aGlzLnNjb3BlU2VsZWN0b3IgPSBudWxsO1xuXHQgICAgdGhpcy5jdXN0b21TdHlsZSA9IG51bGw7XG5cdCAgfVxuXHRcblx0ICByZXR1cm4gU3R5bGVJbmZvO1xuXHR9KCk7XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBTdHlsZUluZm87XG5cbi8qKiovIH0sXG4vKiA3NSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0LyoqXG5cdEBsaWNlbnNlXG5cdENvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cdFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblx0VGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblx0VGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5cdENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5cdHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG5cdCovXG5cdFxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge307XG5cbi8qKiovIH0sXG4vKiA3NiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyoqXG5cdEBsaWNlbnNlXG5cdENvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cdFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblx0VGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblx0VGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5cdENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5cdHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG5cdCovXG5cdFxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfc3R5bGVVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Mik7XG5cdFxuXHR2YXIgX3N0eWxlU2V0dGluZ3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcblx0XG5cdHZhciBwbGFjZWhvbGRlck1hcCA9IHt9O1xuXHRcblx0dmFyIGNlID0gd2luZG93LmN1c3RvbUVsZW1lbnRzO1xuXHRpZiAoY2UgJiYgIV9zdHlsZVNldHRpbmdzLm5hdGl2ZVNoYWRvdykge1xuXHQgIChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgb3JpZ0RlZmluZSA9IGNlLmRlZmluZTtcblx0ICAgIGNlLmRlZmluZSA9IGZ1bmN0aW9uIChuYW1lLCBjbGF6eiwgb3B0aW9ucykge1xuXHQgICAgICBwbGFjZWhvbGRlck1hcFtuYW1lXSA9ICgwLCBfc3R5bGVVdGlsLmFwcGx5U3R5bGVQbGFjZUhvbGRlcikobmFtZSk7XG5cdCAgICAgIHJldHVybiBvcmlnRGVmaW5lLmNhbGwoY2UsIG5hbWUsIGNsYXp6LCBvcHRpb25zKTtcblx0ICAgIH07XG5cdCAgfSkoKTtcblx0fVxuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gcGxhY2Vob2xkZXJNYXA7XG5cbi8qKiovIH0sXG4vKiA3NyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0LyoqXG5cdEBsaWNlbnNlXG5cdENvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cdFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblx0VGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblx0VGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5cdENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5cdHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG5cdCovXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblx0XG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cdFxuXHR2YXIgU3R5bGVDYWNoZSA9IGZ1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBTdHlsZUNhY2hlKCkge1xuXHQgICAgdmFyIHR5cGVNYXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDEwMDtcblx0XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3R5bGVDYWNoZSk7XG5cdFxuXHQgICAgLy8gbWFwIGVsZW1lbnQgbmFtZSAtPiBbe3Byb3BlcnRpZXMsIHN0eWxlRWxlbWVudCwgc2NvcGVTZWxlY3Rvcn1dXG5cdCAgICB0aGlzLmNhY2hlID0ge307XG5cdCAgICB0aGlzLnR5cGVNYXggPSB0eXBlTWF4O1xuXHQgIH1cblx0XG5cdCAgX2NyZWF0ZUNsYXNzKFN0eWxlQ2FjaGUsIFt7XG5cdCAgICBrZXk6ICdfdmFsaWRhdGUnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF92YWxpZGF0ZShjYWNoZUVudHJ5LCBwcm9wZXJ0aWVzLCBvd25Qcm9wZXJ0eU5hbWVzKSB7XG5cdCAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IG93blByb3BlcnR5TmFtZXMubGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgIHZhciBwbiA9IG93blByb3BlcnR5TmFtZXNbaWR4XTtcblx0ICAgICAgICBpZiAoY2FjaGVFbnRyeS5wcm9wZXJ0aWVzW3BuXSAhPT0gcHJvcGVydGllc1twbl0pIHtcblx0ICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnc3RvcmUnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3JlKHRhZ25hbWUsIHByb3BlcnRpZXMsIHN0eWxlRWxlbWVudCwgc2NvcGVTZWxlY3Rvcikge1xuXHQgICAgICB2YXIgbGlzdCA9IHRoaXMuY2FjaGVbdGFnbmFtZV0gfHwgW107XG5cdCAgICAgIGxpc3QucHVzaCh7IHByb3BlcnRpZXM6IHByb3BlcnRpZXMsIHN0eWxlRWxlbWVudDogc3R5bGVFbGVtZW50LCBzY29wZVNlbGVjdG9yOiBzY29wZVNlbGVjdG9yIH0pO1xuXHQgICAgICBpZiAobGlzdC5sZW5ndGggPiB0aGlzLnR5cGVNYXgpIHtcblx0ICAgICAgICBsaXN0LnNoaWZ0KCk7XG5cdCAgICAgIH1cblx0ICAgICAgdGhpcy5jYWNoZVt0YWduYW1lXSA9IGxpc3Q7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnZmV0Y2gnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGZldGNoKHRhZ25hbWUsIHByb3BlcnRpZXMsIG93blByb3BlcnR5TmFtZXMpIHtcblx0ICAgICAgdmFyIGxpc3QgPSB0aGlzLmNhY2hlW3RhZ25hbWVdO1xuXHQgICAgICBpZiAoIWxpc3QpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgICAgLy8gcmV2ZXJzZSBsaXN0IGZvciBtb3N0LXJlY2VudCBsb29rdXBzXG5cdCAgICAgIGZvciAodmFyIGlkeCA9IGxpc3QubGVuZ3RoIC0gMTsgaWR4ID49IDA7IGlkeC0tKSB7XG5cdCAgICAgICAgdmFyIGVudHJ5ID0gbGlzdFtpZHhdO1xuXHQgICAgICAgIGlmICh0aGlzLl92YWxpZGF0ZShlbnRyeSwgcHJvcGVydGllcywgb3duUHJvcGVydHlOYW1lcykpIHtcblx0ICAgICAgICAgIHJldHVybiBlbnRyeTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XSk7XG5cdFxuXHQgIHJldHVybiBTdHlsZUNhY2hlO1xuXHR9KCk7XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBTdHlsZUNhY2hlO1xuXG4vKioqLyB9LFxuLyogNzggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qKlxuXHRAbGljZW5zZVxuXHRDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXHRUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5cdFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5cdFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuXHRDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuXHRzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuXHQqL1xuXHQvKipcblx0ICogVGhlIGFwcGx5IHNoaW0gc2ltdWxhdGVzIHRoZSBiZWhhdmlvciBvZiBgQGFwcGx5YCBwcm9wb3NlZCBhdFxuXHQgKiBodHRwczovL3RhYmF0a2lucy5naXRodWIuaW8vc3BlY3MvY3NzLWFwcGx5LXJ1bGUvLlxuXHQgKiBUaGUgYXBwcm9hY2ggaXMgdG8gY29udmVydCBhIHByb3BlcnR5IGxpa2UgdGhpczpcblx0ICpcblx0ICogICAgLS1mb286IHtjb2xvcjogcmVkOyBiYWNrZ3JvdW5kOiBibHVlO31cblx0ICpcblx0ICogdG8gdGhpczpcblx0ICpcblx0ICogICAgLS1mb29fLV9jb2xvcjogcmVkO1xuXHQgKiAgICAtLWZvb18tX2JhY2tncm91bmQ6IGJsdWU7XG5cdCAqXG5cdCAqIFRoZW4gd2hlcmUgYEBhcHBseSAtLWZvb2AgaXMgdXNlZCwgdGhhdCBpcyBjb252ZXJ0ZWQgdG86XG5cdCAqXG5cdCAqICAgIGNvbG9yOiB2YXIoLS1mb29fLV9jb2xvcik7XG5cdCAqICAgIGJhY2tncm91bmQ6IHZhcigtLWZvb18tX2JhY2tncm91bmQpO1xuXHQgKlxuXHQgKiBUaGlzIGFwcHJvYWNoIGdlbmVyYWxseSB3b3JrcyBidXQgdGhlcmUgYXJlIHNvbWUgaXNzdWVzIGFuZCBsaW1pdGF0aW9ucy5cblx0ICogQ29uc2lkZXIsIGZvciBleGFtcGxlLCB0aGF0IHNvbWV3aGVyZSAqYmV0d2Vlbiogd2hlcmUgYC0tZm9vYCBpcyBzZXQgYW5kIHVzZWQsXG5cdCAqIGFub3RoZXIgZWxlbWVudCBzZXRzIGl0IHRvOlxuXHQgKlxuXHQgKiAgICAtLWZvbzogeyBib3JkZXI6IDJweCBzb2xpZCByZWQ7IH1cblx0ICpcblx0ICogV2UgbXVzdCBub3cgZW5zdXJlIHRoYXQgdGhlIGNvbG9yIGFuZCBiYWNrZ3JvdW5kIGZyb20gdGhlIHByZXZpb3VzIHNldHRpbmdcblx0ICogZG8gbm90IGFwcGx5LiBUaGlzIGlzIGFjY29tcGxpc2hlZCBieSBjaGFuZ2luZyB0aGUgcHJvcGVydHkgc2V0IHRvIHRoaXM6XG5cdCAqXG5cdCAqICAgIC0tZm9vXy1fYm9yZGVyOiAycHggc29saWQgcmVkO1xuXHQgKiAgICAtLWZvb18tX2NvbG9yOiBpbml0aWFsO1xuXHQgKiAgICAtLWZvb18tX2JhY2tncm91bmQ6IGluaXRpYWw7XG5cdCAqXG5cdCAqIFRoaXMgd29ya3MgYnV0IGludHJvZHVjZXMgb25lIG5ldyBpc3N1ZS5cblx0ICogQ29uc2lkZXIgdGhpcyBzZXR1cCBhdCB0aGUgcG9pbnQgd2hlcmUgdGhlIGBAYXBwbHlgIGlzIHVzZWQ6XG5cdCAqXG5cdCAqICAgIGJhY2tncm91bmQ6IG9yYW5nZTtcblx0ICogICAgQGFwcGx5IC0tZm9vO1xuXHQgKlxuXHQgKiBJbiB0aGlzIGNhc2UgdGhlIGJhY2tncm91bmQgd2lsbCBiZSB1bnNldCAoaW5pdGlhbCkgcmF0aGVyIHRoYW4gdGhlIGRlc2lyZWRcblx0ICogYG9yYW5nZWAuIFdlIGFkZHJlc3MgdGhpcyBieSBhbHRlcmluZyB0aGUgcHJvcGVydHkgc2V0IHRvIHVzZSBhIGZhbGxiYWNrXG5cdCAqIHZhbHVlIGxpa2UgdGhpczpcblx0ICpcblx0ICogICAgY29sb3I6IHZhcigtLWZvb18tX2NvbG9yKTtcblx0ICogICAgYmFja2dyb3VuZDogdmFyKC0tZm9vXy1fYmFja2dyb3VuZCwgb3JhbmdlKTtcblx0ICogICAgYm9yZGVyOiB2YXIoLS1mb29fLV9ib3JkZXIpO1xuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIGRlZmF1bHQgaXMgcmV0YWluZWQgaW4gdGhlIHByb3BlcnR5IHNldCBhbmQgdGhlIGBiYWNrZ3JvdW5kYCBpc1xuXHQgKiB0aGUgZGVzaXJlZCBgb3JhbmdlYC4gVGhpcyBsZWFkcyB1cyB0byBhIGxpbWl0YXRpb24uXG5cdCAqXG5cdCAqIExpbWl0YXRpb24gMTpcblx0XG5cdCAqIE9ubHkgcHJvcGVydGllcyBpbiB0aGUgcnVsZSB3aGVyZSB0aGUgYEBhcHBseWBcblx0ICogaXMgdXNlZCBhcmUgY29uc2lkZXJlZCBhcyBkZWZhdWx0IHZhbHVlcy5cblx0ICogSWYgYW5vdGhlciBydWxlIG1hdGNoZXMgdGhlIGVsZW1lbnQgYW5kIHNldHMgYGJhY2tncm91bmRgIHdpdGhcblx0ICogbGVzcyBzcGVjaWZpY2l0eSB0aGFuIHRoZSBydWxlIGluIHdoaWNoIGBAYXBwbHlgIGFwcGVhcnMsXG5cdCAqIHRoZSBgYmFja2dyb3VuZGAgd2lsbCBub3QgYmUgc2V0LlxuXHQgKlxuXHQgKiBMaW1pdGF0aW9uIDI6XG5cdCAqXG5cdCAqIFdoZW4gdXNpbmcgUG9seW1lcidzIGB1cGRhdGVTdHlsZXNgIGFwaSwgbmV3IHByb3BlcnRpZXMgbWF5IG5vdCBiZSBzZXQgZm9yXG5cdCAqIGBAYXBwbHlgIHByb3BlcnRpZXMuXG5cdFxuXHQqL1xuXHRcblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdFxuXHR2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXHRcblx0dmFyIF9zdHlsZVV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcblx0XG5cdHZhciBfdGVtcGxhdGVNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1KTtcblx0XG5cdHZhciBfdGVtcGxhdGVNYXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGVtcGxhdGVNYXApO1xuXHRcblx0dmFyIF9zdHlsZUluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblx0XG5cdHZhciBfc3R5bGVJbmZvMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0eWxlSW5mbyk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblx0XG5cdHZhciBNSVhJTl9NQVRDSCA9IF9zdHlsZVV0aWwucnguTUlYSU5fTUFUQ0g7XG5cdHZhciBWQVJfQVNTSUdOID0gX3N0eWxlVXRpbC5yeC5WQVJfQVNTSUdOO1xuXHRcblx0dmFyIEFQUExZX05BTUVfQ0xFQU4gPSAvO1xccyovbTtcblx0dmFyIElOSVRJQUxfSU5IRVJJVCA9IC9eXFxzKihpbml0aWFsKXwoaW5oZXJpdClcXHMqJC87XG5cdFxuXHQvLyBzZXBhcmF0b3IgdXNlZCBiZXR3ZWVuIG1peGluLW5hbWUgYW5kIG1peGluLXByb3BlcnR5LW5hbWUgd2hlbiBwcm9kdWNpbmcgcHJvcGVydGllc1xuXHQvLyBOT1RFOiBwbGFpbiAnLScgbWF5IGNhdXNlIGNvbGxpc2lvbnMgaW4gdXNlciBzdHlsZXNcblx0dmFyIE1JWElOX1ZBUl9TRVAgPSAnXy1fJztcblx0XG5cdC8vIG1hcCBvZiBtaXhpbiB0byBwcm9wZXJ0eSBuYW1lc1xuXHQvLyAtLWZvbzoge2JvcmRlcjogMnB4fSAtPiB7cHJvcGVydGllczogeygtLWZvbywgWydib3JkZXInXSl9LCBkZXBlbmRhbnRzOiB7J2VsZW1lbnQtbmFtZSc6IHByb3RvfX1cblx0XG5cdHZhciBNaXhpbk1hcCA9IGZ1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBNaXhpbk1hcCgpIHtcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNaXhpbk1hcCk7XG5cdFxuXHQgICAgdGhpcy5fbWFwID0ge307XG5cdCAgfVxuXHRcblx0ICBfY3JlYXRlQ2xhc3MoTWl4aW5NYXAsIFt7XG5cdCAgICBrZXk6ICdzZXQnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHNldChuYW1lLCBwcm9wcykge1xuXHQgICAgICBuYW1lID0gbmFtZS50cmltKCk7XG5cdCAgICAgIHRoaXMuX21hcFtuYW1lXSA9IHtcblx0ICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wcyxcblx0ICAgICAgICBkZXBlbmRhbnRzOiB7fVxuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2dldCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KG5hbWUpIHtcblx0ICAgICAgbmFtZSA9IG5hbWUudHJpbSgpO1xuXHQgICAgICByZXR1cm4gdGhpcy5fbWFwW25hbWVdO1xuXHQgICAgfVxuXHQgIH1dKTtcblx0XG5cdCAgcmV0dXJuIE1peGluTWFwO1xuXHR9KCk7XG5cdFxuXHR2YXIgQXBwbHlTaGltID0gZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIEFwcGx5U2hpbSgpIHtcblx0ICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdFxuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFwcGx5U2hpbSk7XG5cdFxuXHQgICAgdGhpcy5fY3VycmVudFRlbXBsYXRlID0gbnVsbDtcblx0ICAgIHRoaXMuX21lYXN1cmVFbGVtZW50ID0gbnVsbDtcblx0ICAgIHRoaXMuX21hcCA9IG5ldyBNaXhpbk1hcCgpO1xuXHQgICAgdGhpcy5fc2VwYXJhdG9yID0gTUlYSU5fVkFSX1NFUDtcblx0ICAgIHRoaXMuX2JvdW5kUHJvZHVjZUNzc1Byb3BlcnRpZXMgPSBmdW5jdGlvbiAobWF0Y2hUZXh0LCBwcm9wZXJ0eU5hbWUsIHZhbHVlUHJvcGVydHksIHZhbHVlTWl4aW4pIHtcblx0ICAgICAgcmV0dXJuIF90aGlzLl9wcm9kdWNlQ3NzUHJvcGVydGllcyhtYXRjaFRleHQsIHByb3BlcnR5TmFtZSwgdmFsdWVQcm9wZXJ0eSwgdmFsdWVNaXhpbik7XG5cdCAgICB9O1xuXHQgIH1cblx0ICAvLyByZXR1cm4gdHJ1ZSBpZiBgY3NzVGV4dGAgY29udGFpbnMgYSBtaXhpbiBkZWZpbml0aW9uIG9yIGNvbnN1bXB0aW9uXG5cdFxuXHRcblx0ICBfY3JlYXRlQ2xhc3MoQXBwbHlTaGltLCBbe1xuXHQgICAga2V5OiAnZGV0ZWN0TWl4aW4nLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGRldGVjdE1peGluKGNzc1RleHQpIHtcblx0ICAgICAgdmFyIGhhcyA9IE1JWElOX01BVENILnRlc3QoY3NzVGV4dCkgfHwgVkFSX0FTU0lHTi50ZXN0KGNzc1RleHQpO1xuXHQgICAgICAvLyByZXNldCBzdGF0ZSBvZiB0aGUgcmVnZXhlc1xuXHQgICAgICBNSVhJTl9NQVRDSC5sYXN0SW5kZXggPSAwO1xuXHQgICAgICBWQVJfQVNTSUdOLmxhc3RJbmRleCA9IDA7XG5cdCAgICAgIHJldHVybiBoYXM7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAndHJhbnNmb3JtU3R5bGUnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zZm9ybVN0eWxlKHN0eWxlLCBlbGVtZW50TmFtZSkge1xuXHQgICAgICB2YXIgYXN0ID0gKDAsIF9zdHlsZVV0aWwucnVsZXNGb3JTdHlsZSkoc3R5bGUpO1xuXHQgICAgICB0aGlzLnRyYW5zZm9ybVJ1bGVzKGFzdCwgZWxlbWVudE5hbWUpO1xuXHQgICAgICByZXR1cm4gYXN0O1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ3RyYW5zZm9ybVJ1bGVzJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2Zvcm1SdWxlcyhydWxlcywgZWxlbWVudE5hbWUpIHtcblx0ICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cdFxuXHQgICAgICB0aGlzLl9jdXJyZW50VGVtcGxhdGUgPSBfdGVtcGxhdGVNYXAyLmRlZmF1bHRbZWxlbWVudE5hbWVdO1xuXHQgICAgICAoMCwgX3N0eWxlVXRpbC5mb3JFYWNoUnVsZSkocnVsZXMsIGZ1bmN0aW9uIChyKSB7XG5cdCAgICAgICAgX3RoaXMyLnRyYW5zZm9ybVJ1bGUocik7XG5cdCAgICAgIH0pO1xuXHQgICAgICB0aGlzLl9jdXJyZW50VGVtcGxhdGUgPSBudWxsO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ3RyYW5zZm9ybVJ1bGUnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zZm9ybVJ1bGUocnVsZSkge1xuXHQgICAgICBydWxlLmNzc1RleHQgPSB0aGlzLnRyYW5zZm9ybUNzc1RleHQocnVsZS5wYXJzZWRDc3NUZXh0KTtcblx0ICAgICAgLy8gOnJvb3Qgd2FzIG9ubHkgdXNlZCBmb3IgdmFyaWFibGUgYXNzaWdubWVudCBpbiBwcm9wZXJ0eSBzaGltLFxuXHQgICAgICAvLyBidXQgZ2VuZXJhdGVzIGludmFsaWQgc2VsZWN0b3JzIHdpdGggcmVhbCBwcm9wZXJ0aWVzLlxuXHQgICAgICAvLyByZXBsYWNlIHdpdGggYDpob3N0ID4gKmAsIHdoaWNoIHNlcnZlcyB0aGUgc2FtZSBlZmZlY3Rcblx0ICAgICAgaWYgKHJ1bGUuc2VsZWN0b3IgPT09ICc6cm9vdCcpIHtcblx0ICAgICAgICBydWxlLnNlbGVjdG9yID0gJzpob3N0ID4gKic7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICd0cmFuc2Zvcm1Dc3NUZXh0Jyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2Zvcm1Dc3NUZXh0KGNzc1RleHQpIHtcblx0ICAgICAgLy8gcHJvZHVjZSB2YXJpYWJsZXNcblx0ICAgICAgY3NzVGV4dCA9IGNzc1RleHQucmVwbGFjZShWQVJfQVNTSUdOLCB0aGlzLl9ib3VuZFByb2R1Y2VDc3NQcm9wZXJ0aWVzKTtcblx0ICAgICAgLy8gY29uc3VtZSBtaXhpbnNcblx0ICAgICAgcmV0dXJuIHRoaXMuX2NvbnN1bWVDc3NQcm9wZXJ0aWVzKGNzc1RleHQpO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ19nZXRJbml0aWFsVmFsdWVGb3JQcm9wZXJ0eScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEluaXRpYWxWYWx1ZUZvclByb3BlcnR5KHByb3BlcnR5KSB7XG5cdCAgICAgIGlmICghdGhpcy5fbWVhc3VyZUVsZW1lbnQpIHtcblx0ICAgICAgICB0aGlzLl9tZWFzdXJlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21ldGEnKTtcblx0ICAgICAgICB0aGlzLl9tZWFzdXJlRWxlbWVudC5zdHlsZS5hbGwgPSAnaW5pdGlhbCc7XG5cdCAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh0aGlzLl9tZWFzdXJlRWxlbWVudCk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuX21lYXN1cmVFbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcblx0ICAgIH1cblx0ICAgIC8vIHJlcGxhY2UgbWl4aW4gY29uc3VtcHRpb24gd2l0aCB2YXJpYWJsZSBjb25zdW1wdGlvblxuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdfY29uc3VtZUNzc1Byb3BlcnRpZXMnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF9jb25zdW1lQ3NzUHJvcGVydGllcyh0ZXh0KSB7XG5cdCAgICAgIHZhciBtID0gdm9pZCAwO1xuXHQgICAgICAvLyBsb29wIG92ZXIgdGV4dCB1bnRpbCBhbGwgbWl4aW5zIHdpdGggZGVmaW50aW9ucyBoYXZlIGJlZW4gYXBwbGllZFxuXHQgICAgICB3aGlsZSAobSA9IE1JWElOX01BVENILmV4ZWModGV4dCkpIHtcblx0ICAgICAgICB2YXIgbWF0Y2hUZXh0ID0gbVswXTtcblx0ICAgICAgICB2YXIgbWl4aW5OYW1lID0gbVsxXTtcblx0ICAgICAgICB2YXIgaWR4ID0gbS5pbmRleDtcblx0ICAgICAgICAvLyBjb2xsZWN0IHByb3BlcnRpZXMgYmVmb3JlIGFwcGx5IHRvIGJlIFwiZGVmYXVsdHNcIiBpZiBtaXhpbiBtaWdodCBvdmVycmlkZSB0aGVtXG5cdCAgICAgICAgLy8gbWF0Y2ggaW5jbHVkZXMgYSBcInByZWZpeFwiLCBzbyBmaW5kIHRoZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucyBvZiBAYXBwbHlcblx0ICAgICAgICB2YXIgYXBwbHlQb3MgPSBpZHggKyBtYXRjaFRleHQuaW5kZXhPZignQGFwcGx5Jyk7XG5cdCAgICAgICAgdmFyIGFmdGVyQXBwbHlQb3MgPSBpZHggKyBtYXRjaFRleHQubGVuZ3RoO1xuXHQgICAgICAgIC8vIGZpbmQgcHJvcHMgZGVmaW5lZCBiZWZvcmUgdGhpcyBAYXBwbHlcblx0ICAgICAgICB2YXIgdGV4dEJlZm9yZUFwcGx5ID0gdGV4dC5zbGljZSgwLCBhcHBseVBvcyk7XG5cdCAgICAgICAgdmFyIHRleHRBZnRlckFwcGx5ID0gdGV4dC5zbGljZShhZnRlckFwcGx5UG9zKTtcblx0ICAgICAgICB2YXIgZGVmYXVsdHMgPSB0aGlzLl9jc3NUZXh0VG9NYXAodGV4dEJlZm9yZUFwcGx5KTtcblx0ICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSB0aGlzLl9hdEFwcGx5VG9Dc3NQcm9wZXJ0aWVzKG1peGluTmFtZSwgZGVmYXVsdHMpO1xuXHQgICAgICAgIC8vIHVzZSByZWdleCBtYXRjaCBwb3NpdGlvbiB0byByZXBsYWNlIG1peGluLCBrZWVwIGxpbmVhciBwcm9jZXNzaW5nIHRpbWVcblx0ICAgICAgICB0ZXh0ID0gW3RleHRCZWZvcmVBcHBseSwgcmVwbGFjZW1lbnQsIHRleHRBZnRlckFwcGx5XS5qb2luKCcnKTtcblx0ICAgICAgICAvLyBtb3ZlIHJlZ2V4IHNlYXJjaCB0byBfYWZ0ZXJfIHJlcGxhY2VtZW50XG5cdCAgICAgICAgTUlYSU5fTUFUQ0gubGFzdEluZGV4ID0gaWR4ICsgcmVwbGFjZW1lbnQubGVuZ3RoO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB0ZXh0O1xuXHQgICAgfVxuXHQgICAgLy8gcHJvZHVjZSB2YXJpYWJsZSBjb25zdW1wdGlvbiBhdCB0aGUgc2l0ZSBvZiBtaXhpbiBjb25zdW1wdGlvblxuXHQgICAgLy8gQGFwcGx5IC0tZm9vOyAtPiBmb3IgYWxsIHByb3BzICgke3Byb3BuYW1lfTogdmFyKC0tZm9vXy1fJHtwcm9wbmFtZX0sICR7ZmFsbGJhY2tbcHJvcG5hbWVdfX0pKVxuXHQgICAgLy8gRXhhbXBsZTpcblx0ICAgIC8vIGJvcmRlcjogdmFyKC0tZm9vXy1fYm9yZGVyKTsgcGFkZGluZzogdmFyKC0tZm9vXy1fcGFkZGluZywgMnB4KVxuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdfYXRBcHBseVRvQ3NzUHJvcGVydGllcycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX2F0QXBwbHlUb0Nzc1Byb3BlcnRpZXMobWl4aW5OYW1lLCBmYWxsYmFja3MpIHtcblx0ICAgICAgbWl4aW5OYW1lID0gbWl4aW5OYW1lLnJlcGxhY2UoQVBQTFlfTkFNRV9DTEVBTiwgJycpO1xuXHQgICAgICB2YXIgdmFycyA9IFtdO1xuXHQgICAgICB2YXIgbWl4aW5FbnRyeSA9IHRoaXMuX21hcC5nZXQobWl4aW5OYW1lKTtcblx0ICAgICAgLy8gaWYgd2UgZGVwZW5kIG9uIGEgbWl4aW4gYmVmb3JlIGl0IGlzIGNyZWF0ZWRcblx0ICAgICAgLy8gbWFrZSBhIHNlbnRpbmVsIGVudHJ5IGluIHRoZSBtYXAgdG8gYWRkIHRoaXMgZWxlbWVudCBhcyBhIGRlcGVuZGVuY3kgZm9yIHdoZW4gaXQgaXMgZGVmaW5lZC5cblx0ICAgICAgaWYgKCFtaXhpbkVudHJ5KSB7XG5cdCAgICAgICAgdGhpcy5fbWFwLnNldChtaXhpbk5hbWUsIHt9KTtcblx0ICAgICAgICBtaXhpbkVudHJ5ID0gdGhpcy5fbWFwLmdldChtaXhpbk5hbWUpO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChtaXhpbkVudHJ5KSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRUZW1wbGF0ZSkge1xuXHQgICAgICAgICAgbWl4aW5FbnRyeS5kZXBlbmRhbnRzW3RoaXMuX2N1cnJlbnRUZW1wbGF0ZS5uYW1lXSA9IHRoaXMuX2N1cnJlbnRUZW1wbGF0ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHAgPSB2b2lkIDAsXG5cdCAgICAgICAgICAgIHBhcnRzID0gdm9pZCAwLFxuXHQgICAgICAgICAgICBmID0gdm9pZCAwO1xuXHQgICAgICAgIGZvciAocCBpbiBtaXhpbkVudHJ5LnByb3BlcnRpZXMpIHtcblx0ICAgICAgICAgIGYgPSBmYWxsYmFja3MgJiYgZmFsbGJhY2tzW3BdO1xuXHQgICAgICAgICAgcGFydHMgPSBbcCwgJzogdmFyKCcsIG1peGluTmFtZSwgTUlYSU5fVkFSX1NFUCwgcF07XG5cdCAgICAgICAgICBpZiAoZikge1xuXHQgICAgICAgICAgICBwYXJ0cy5wdXNoKCcsJywgZik7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBwYXJ0cy5wdXNoKCcpJyk7XG5cdCAgICAgICAgICB2YXJzLnB1c2gocGFydHMuam9pbignJykpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gdmFycy5qb2luKCc7ICcpO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ19yZXBsYWNlSW5pdGlhbE9ySW5oZXJpdCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX3JlcGxhY2VJbml0aWFsT3JJbmhlcml0KHByb3BlcnR5LCB2YWx1ZSkge1xuXHQgICAgICB2YXIgbWF0Y2ggPSBJTklUSUFMX0lOSEVSSVQuZXhlYyh2YWx1ZSk7XG5cdCAgICAgIGlmIChtYXRjaCkge1xuXHQgICAgICAgIGlmIChtYXRjaFsxXSkge1xuXHQgICAgICAgICAgLy8gaW5pdGlhbFxuXHQgICAgICAgICAgLy8gcmVwbGFjZSBgaW5pdGlhbGAgd2l0aCB0aGUgY29uY3JldGUgaW5pdGlhbCB2YWx1ZSBmb3IgdGhpcyBwcm9wZXJ0eVxuXHQgICAgICAgICAgdmFsdWUgPSBBcHBseVNoaW0uX2dldEluaXRpYWxWYWx1ZUZvclByb3BlcnR5KHByb3BlcnR5KTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgLy8gaW5oZXJpdFxuXHQgICAgICAgICAgLy8gd2l0aCB0aGlzIHB1cnBvc2Z1bGx5IGlsbGVnYWwgdmFsdWUsIHRoZSB2YXJpYWJsZSB3aWxsIGJlIGludmFsaWQgYXRcblx0ICAgICAgICAgIC8vIGNvbXB1dGUgdGltZSAoaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy12YXJpYWJsZXMvI2ludmFsaWQtYXQtY29tcHV0ZWQtdmFsdWUtdGltZSlcblx0ICAgICAgICAgIC8vIGFuZCBmb3IgaW5oZXJpdGluZyB2YWx1ZXMsIHdpbGwgYmVoYXZlIHNpbWlsYXJseVxuXHQgICAgICAgICAgLy8gd2UgY2Fubm90IHN1cHBvcnQgdGhlIHNhbWUgYmVoYXZpb3IgZm9yIG5vbiBpbmhlcml0aW5nIHZhbHVlcyBsaWtlICdib3JkZXInXG5cdCAgICAgICAgICB2YWx1ZSA9ICdhcHBseS1zaGltLWluaGVyaXQnO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gXCJwYXJzZVwiIGEgbWl4aW4gZGVmaW5pdGlvbiBpbnRvIGEgbWFwIG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlc1xuXHQgICAgLy8gY3NzVGV4dFRvTWFwKCdib3JkZXI6IDJweCBzb2xpZCBibGFjaycpIC0+ICgnYm9yZGVyJywgJzJweCBzb2xpZCBibGFjaycpXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ19jc3NUZXh0VG9NYXAnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF9jc3NUZXh0VG9NYXAodGV4dCkge1xuXHQgICAgICB2YXIgcHJvcHMgPSB0ZXh0LnNwbGl0KCc7Jyk7XG5cdCAgICAgIHZhciBwcm9wZXJ0eSA9IHZvaWQgMCxcblx0ICAgICAgICAgIHZhbHVlID0gdm9pZCAwO1xuXHQgICAgICB2YXIgb3V0ID0ge307XG5cdCAgICAgIGZvciAodmFyIGkgPSAwLCBwLCBzcDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgcCA9IHByb3BzW2ldO1xuXHQgICAgICAgIGlmIChwKSB7XG5cdCAgICAgICAgICBzcCA9IHAuc3BsaXQoJzonKTtcblx0ICAgICAgICAgIC8vIGlnbm9yZSBsaW5lcyB0aGF0IGFyZW4ndCBkZWZpbml0aW9ucyBsaWtlIEBtZWRpYVxuXHQgICAgICAgICAgaWYgKHNwLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgICAgICAgcHJvcGVydHkgPSBzcFswXS50cmltKCk7XG5cdCAgICAgICAgICAgIC8vIHNvbWUgcHJvcGVydGllcyBtYXkgaGF2ZSAnOicgaW4gdGhlIHZhbHVlLCBsaWtlIGRhdGEgdXJsc1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3JlcGxhY2VJbml0aWFsT3JJbmhlcml0KHByb3BlcnR5LCBzcC5zbGljZSgxKS5qb2luKCc6JykpO1xuXHQgICAgICAgICAgICBvdXRbcHJvcGVydHldID0gdmFsdWU7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBvdXQ7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX2ludmFsaWRhdGVNaXhpbkVudHJ5Jyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBfaW52YWxpZGF0ZU1peGluRW50cnkobWl4aW5FbnRyeSkge1xuXHQgICAgICBmb3IgKHZhciBlbGVtZW50TmFtZSBpbiBtaXhpbkVudHJ5LmRlcGVuZGFudHMpIHtcblx0ICAgICAgICBpZiAoIXRoaXMuX2N1cnJlbnRUZW1wbGF0ZSB8fCBlbGVtZW50TmFtZSAhPT0gdGhpcy5fY3VycmVudFRlbXBsYXRlLm5hbWUpIHtcblx0ICAgICAgICAgIF9zdHlsZUluZm8yLmRlZmF1bHQuaW52YWxpZGF0ZShlbGVtZW50TmFtZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX3Byb2R1Y2VDc3NQcm9wZXJ0aWVzJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJvZHVjZUNzc1Byb3BlcnRpZXMobWF0Y2hUZXh0LCBwcm9wZXJ0eU5hbWUsIHZhbHVlUHJvcGVydHksIHZhbHVlTWl4aW4pIHtcblx0ICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cdFxuXHQgICAgICAvLyBoYW5kbGUgY2FzZSB3aGVyZSBwcm9wZXJ0eSB2YWx1ZSBpcyBhIG1peGluXG5cdCAgICAgIGlmICh2YWx1ZVByb3BlcnR5KSB7XG5cdCAgICAgICAgLy8gZm9ybTogLS1taXhpbjI6IHZhcigtLW1peGluMSksIHdoZXJlIC0tbWl4aW4xIGlzIGluIHRoZSBtYXBcblx0ICAgICAgICAoMCwgX3N0eWxlVXRpbC5wcm9jZXNzVmFyaWFibGVBbmRGYWxsYmFjaykodmFsdWVQcm9wZXJ0eSwgZnVuY3Rpb24gKHByZWZpeCwgdmFsdWUpIHtcblx0ICAgICAgICAgIGlmICh2YWx1ZSAmJiBfdGhpczMuX21hcC5nZXQodmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHZhbHVlTWl4aW4gPSAnQGFwcGx5ICcgKyB2YWx1ZSArICc7Jztcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoIXZhbHVlTWl4aW4pIHtcblx0ICAgICAgICByZXR1cm4gbWF0Y2hUZXh0O1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBtaXhpbkFzUHJvcGVydGllcyA9IHRoaXMuX2NvbnN1bWVDc3NQcm9wZXJ0aWVzKHZhbHVlTWl4aW4pO1xuXHQgICAgICB2YXIgcHJlZml4ID0gbWF0Y2hUZXh0LnNsaWNlKDAsIG1hdGNoVGV4dC5pbmRleE9mKCctLScpKTtcblx0ICAgICAgdmFyIG1peGluVmFsdWVzID0gdGhpcy5fY3NzVGV4dFRvTWFwKG1peGluQXNQcm9wZXJ0aWVzKTtcblx0ICAgICAgdmFyIGNvbWJpbmVkUHJvcHMgPSBtaXhpblZhbHVlcztcblx0ICAgICAgdmFyIG1peGluRW50cnkgPSB0aGlzLl9tYXAuZ2V0KHByb3BlcnR5TmFtZSk7XG5cdCAgICAgIHZhciBvbGRQcm9wcyA9IG1peGluRW50cnkgJiYgbWl4aW5FbnRyeS5wcm9wZXJ0aWVzO1xuXHQgICAgICBpZiAob2xkUHJvcHMpIHtcblx0ICAgICAgICAvLyBOT1RFOiBzaW5jZSB3ZSB1c2UgbWl4aW4sIHRoZSBtYXAgb2YgcHJvcGVydGllcyBpcyB1cGRhdGVkIGhlcmVcblx0ICAgICAgICAvLyBhbmQgdGhpcyBpcyB3aGF0IHdlIHdhbnQuXG5cdCAgICAgICAgY29tYmluZWRQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShvbGRQcm9wcyksIG1peGluVmFsdWVzKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLl9tYXAuc2V0KHByb3BlcnR5TmFtZSwgY29tYmluZWRQcm9wcyk7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIG91dCA9IFtdO1xuXHQgICAgICB2YXIgcCA9IHZvaWQgMCxcblx0ICAgICAgICAgIHYgPSB2b2lkIDA7XG5cdCAgICAgIC8vIHNldCB2YXJpYWJsZXMgZGVmaW5lZCBieSBjdXJyZW50IG1peGluXG5cdCAgICAgIHZhciBuZWVkVG9JbnZhbGlkYXRlID0gZmFsc2U7XG5cdCAgICAgIGZvciAocCBpbiBjb21iaW5lZFByb3BzKSB7XG5cdCAgICAgICAgdiA9IG1peGluVmFsdWVzW3BdO1xuXHQgICAgICAgIC8vIGlmIHByb3BlcnR5IG5vdCBkZWZpbmVkIGJ5IGN1cnJlbnQgbWl4aW4sIHNldCBpbml0aWFsXG5cdCAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgdiA9ICdpbml0aWFsJztcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKG9sZFByb3BzICYmICEocCBpbiBvbGRQcm9wcykpIHtcblx0ICAgICAgICAgIG5lZWRUb0ludmFsaWRhdGUgPSB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBvdXQucHVzaChwcm9wZXJ0eU5hbWUgKyBNSVhJTl9WQVJfU0VQICsgcCArICc6ICcgKyB2KTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAobmVlZFRvSW52YWxpZGF0ZSkge1xuXHQgICAgICAgIHRoaXMuX2ludmFsaWRhdGVNaXhpbkVudHJ5KG1peGluRW50cnkpO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChtaXhpbkVudHJ5KSB7XG5cdCAgICAgICAgbWl4aW5FbnRyeS5wcm9wZXJ0aWVzID0gY29tYmluZWRQcm9wcztcblx0ICAgICAgfVxuXHQgICAgICAvLyBiZWNhdXNlIHRoZSBtaXhpbk1hcCBpcyBnbG9iYWwsIHRoZSBtaXhpbiBtaWdodCBjb25mbGljdCB3aXRoXG5cdCAgICAgIC8vIGEgZGlmZmVyZW50IHNjb3BlJ3Mgc2ltcGxlIHZhcmlhYmxlIGRlZmluaXRpb246XG5cdCAgICAgIC8vIEV4YW1wbGU6XG5cdCAgICAgIC8vIHNvbWUgc3R5bGUgc29tZXdoZXJlOlxuXHQgICAgICAvLyAtLW1peGluMTp7IC4uLiB9XG5cdCAgICAgIC8vIC0tbWl4aW4yOiB2YXIoLS1taXhpbjEpO1xuXHQgICAgICAvLyBzb21lIG90aGVyIGVsZW1lbnQ6XG5cdCAgICAgIC8vIC0tbWl4aW4xOiAxMHB4IHNvbGlkIHJlZDtcblx0ICAgICAgLy8gLS1mb286IHZhcigtLW1peGluMSk7XG5cdCAgICAgIC8vIEluIHRoaXMgY2FzZSwgd2UgbGVhdmUgdGhlIG9yaWdpbmFsIHZhcmlhYmxlIGRlZmluaXRpb24gaW4gcGxhY2UuXG5cdCAgICAgIGlmICh2YWx1ZVByb3BlcnR5KSB7XG5cdCAgICAgICAgcHJlZml4ID0gbWF0Y2hUZXh0ICsgJzsnICsgcHJlZml4O1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBwcmVmaXggKyBvdXQuam9pbignOyAnKSArICc7Jztcblx0ICAgIH1cblx0ICB9XSk7XG5cdFxuXHQgIHJldHVybiBBcHBseVNoaW07XG5cdH0oKTtcblx0XG5cdHZhciBhcHBseVNoaW0gPSBuZXcgQXBwbHlTaGltKCk7XG5cdHdpbmRvd1snQXBwbHlTaGltJ10gPSBhcHBseVNoaW07XG5cdGV4cG9ydHMuZGVmYXVsdCA9IGFwcGx5U2hpbTtcblxuLyoqKi8gfSxcbi8qIDc5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKipcblx0QGxpY2Vuc2Vcblx0Q29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0VGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuXHRUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuXHRUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcblx0Q29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cblx0c3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcblx0Ki9cblx0XG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRleHBvcnRzLmZsdXNoID0gdW5kZWZpbmVkO1xuXHRcblx0dmFyIF9zdHlsZVNldHRpbmdzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MCk7XG5cdFxuXHR2YXIgX3N0eWxlVHJhbnNmb3JtZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcblx0XG5cdHZhciBfc3R5bGVUcmFuc2Zvcm1lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdHlsZVRyYW5zZm9ybWVyKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHR2YXIgZmx1c2ggPSBleHBvcnRzLmZsdXNoID0gZnVuY3Rpb24gZmx1c2goKSB7fTtcblx0XG5cdGlmICghX3N0eWxlU2V0dGluZ3MubmF0aXZlU2hhZG93KSB7XG5cdCAgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBlbGVtZW50TmVlZHNTY29waW5nID0gZnVuY3Rpb24gZWxlbWVudE5lZWRzU2NvcGluZyhlbGVtZW50KSB7XG5cdCAgICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdCAmJiAhZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoX3N0eWxlVHJhbnNmb3JtZXIyLmRlZmF1bHQuU0NPUEVfTkFNRSkgfHxcblx0ICAgICAgLy8gbm90ZTogbmVjZXNzYXJ5IGZvciBJRTExXG5cdCAgICAgIGVsZW1lbnQgaW5zdGFuY2VvZiBTVkdFbGVtZW50ICYmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykuaW5kZXhPZihfc3R5bGVUcmFuc2Zvcm1lcjIuZGVmYXVsdC5TQ09QRV9OQU1FKSA8IDApO1xuXHQgICAgfTtcblx0XG5cdCAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIobXhucykge1xuXHQgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IG14bnMubGVuZ3RoOyB4KyspIHtcblx0ICAgICAgICB2YXIgbXhuID0gbXhuc1t4XTtcblx0ICAgICAgICBpZiAobXhuLnRhcmdldCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IG14bi50YXJnZXQgPT09IGRvY3VtZW50LmhlYWQpIHtcblx0ICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG14bi5hZGRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICB2YXIgbiA9IG14bi5hZGRlZE5vZGVzW2ldO1xuXHQgICAgICAgICAgaWYgKGVsZW1lbnROZWVkc1Njb3BpbmcobikpIHtcblx0ICAgICAgICAgICAgdmFyIHJvb3QgPSBuLmdldFJvb3ROb2RlKCk7XG5cdCAgICAgICAgICAgIGlmIChyb290Lm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcblx0ICAgICAgICAgICAgICAvLyBtYXkgbm8gbG9uZ2VyIGJlIGluIGEgc2hhZG93cm9vdFxuXHQgICAgICAgICAgICAgIHZhciBob3N0ID0gcm9vdC5ob3N0O1xuXHQgICAgICAgICAgICAgIGlmIChob3N0KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2NvcGUgPSBob3N0LmlzIHx8IGhvc3QubG9jYWxOYW1lO1xuXHQgICAgICAgICAgICAgICAgX3N0eWxlVHJhbnNmb3JtZXIyLmRlZmF1bHQuZG9tKG4sIHNjb3BlKTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG14bi5yZW1vdmVkTm9kZXMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICB2YXIgX24gPSBteG4ucmVtb3ZlZE5vZGVzW19pXTtcblx0ICAgICAgICAgIGlmIChfbi5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcblx0ICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgIGlmIChfbi5jbGFzc0xpc3QpIHtcblx0ICAgICAgICAgICAgICBjbGFzc2VzID0gQXJyYXkuZnJvbShfbi5jbGFzc0xpc3QpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKF9uLmhhc0F0dHJpYnV0ZSgnY2xhc3MnKSkge1xuXHQgICAgICAgICAgICAgIGNsYXNzZXMgPSBfbi5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykuc3BsaXQoL1xccysvKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoY2xhc3NlcyAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgLy8gTk9URTogcmVsaWVzIG9uIHRoZSBzY29waW5nIGNsYXNzIGFsd2F5cyBiZWluZyBhZGphY2VudCB0byB0aGVcblx0ICAgICAgICAgICAgICAvLyBTQ09QRV9OQU1FIGNsYXNzLlxuXHQgICAgICAgICAgICAgIHZhciBjbGFzc0lkeCA9IGNsYXNzZXMuaW5kZXhPZihfc3R5bGVUcmFuc2Zvcm1lcjIuZGVmYXVsdC5TQ09QRV9OQU1FKTtcblx0ICAgICAgICAgICAgICBpZiAoY2xhc3NJZHggPj0gMCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIF9zY29wZSA9IGNsYXNzZXNbY2xhc3NJZHggKyAxXTtcblx0ICAgICAgICAgICAgICAgIGlmIChfc2NvcGUpIHtcblx0ICAgICAgICAgICAgICAgICAgX3N0eWxlVHJhbnNmb3JtZXIyLmRlZmF1bHQuZG9tKF9uLCBfc2NvcGUsIHRydWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfTtcblx0XG5cdCAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihoYW5kbGVyKTtcblx0ICAgIHZhciBzdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KG5vZGUpIHtcblx0ICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7IGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSB9KTtcblx0ICAgIH07XG5cdCAgICB2YXIgbmF0aXZlQ3VzdG9tRWxlbWVudHMgPSB3aW5kb3cuY3VzdG9tRWxlbWVudHMgJiYgIXdpbmRvdy5jdXN0b21FbGVtZW50cy5mbHVzaDtcblx0ICAgIC8vIG5lZWQgdG8gc3RhcnQgaW1tZWRpYXRlbHkgd2l0aCBuYXRpdmUgY3VzdG9tIGVsZW1lbnRzXG5cdCAgICAvLyBUT0RPKGRmcmVlZG0pOiB3aXRoIHBvbHlmaWxsZWQgSFRNTEltcG9ydHMgYW5kIG5hdGl2ZSBjdXN0b20gZWxlbWVudHNcblx0ICAgIC8vIGV4Y2Vzc2l2ZSBtdXRhdGlvbnMgbWF5IGJlIG9ic2VydmVkOyB0aGlzIGNhbiBiZSBvcHRpbWl6ZWQgdmlhIGNvb3BlcmF0aW9uXG5cdCAgICAvLyB3aXRoIHRoZSBIVE1MSW1wb3J0cyBwb2x5ZmlsbC5cblx0ICAgIGlmIChuYXRpdmVDdXN0b21FbGVtZW50cykge1xuXHQgICAgICBzdGFydChkb2N1bWVudCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBkZWxheWVkU3RhcnQgPSBmdW5jdGlvbiBkZWxheWVkU3RhcnQoKSB7XG5cdCAgICAgICAgICBzdGFydChkb2N1bWVudC5ib2R5KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIC8vIHVzZSBwb2x5ZmlsbCB0aW1pbmcgaWYgaXQncyBhdmFpbGFibGVcblx0ICAgICAgICBpZiAod2luZG93LkhUTUxJbXBvcnRzKSB7XG5cdCAgICAgICAgICB3aW5kb3cuSFRNTEltcG9ydHMud2hlblJlYWR5KGRlbGF5ZWRTdGFydCk7XG5cdCAgICAgICAgICAvLyBvdGhlcndpc2UgcHVzaCBiZXlvbmQgbmF0aXZlIGltcG9ydHMgYmVpbmcgcmVhZHlcblx0ICAgICAgICAgIC8vIHdoaWNoIHJlcXVpcmVzIFJBRiArIHJlYWR5c3RhdGUgaW50ZXJhY3RpdmUuXG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcblx0ICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gbGlzdGVuZXIoKSB7XG5cdCAgICAgICAgICAgICAgICAgIGRlbGF5ZWRTdGFydCgpO1xuXHQgICAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZWFkeXN0YXRlY2hhbmdlJywgbGlzdGVuZXIpO1xuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3JlYWR5c3RhdGVjaGFuZ2UnLCBsaXN0ZW5lcik7XG5cdCAgICAgICAgICAgICAgfSkoKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICBkZWxheWVkU3RhcnQoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KSgpO1xuXHQgICAgfVxuXHRcblx0ICAgIGV4cG9ydHMuZmx1c2ggPSBmbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuXHQgICAgICBoYW5kbGVyKG9ic2VydmVyLnRha2VSZWNvcmRzKCkpO1xuXHQgICAgfTtcblx0ICB9KSgpO1xuXHR9XG5cbi8qKiovIH0sXG4vKiA4MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0LyoqXG5cdEBsaWNlbnNlXG5cdENvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cdFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblx0VGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblx0VGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5cdENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5cdHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG5cdCovXG5cdFxuXHQvKlxuXHRXcmFwcGVyIG92ZXIgPHN0eWxlPiBlbGVtZW50cyB0byBjby1vcGVyYXRlIHdpdGggU2hhZHlDU1Ncblx0XG5cdEV4YW1wbGU6XG5cdDxjdXN0b20tc3R5bGU+XG5cdCAgPHN0eWxlPlxuXHQgIC4uLlxuXHQgIDwvc3R5bGU+XG5cdDwvY3VzdG9tLXN0eWxlPlxuXHQqL1xuXHRcblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblx0XG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cdFxuXHRmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblx0XG5cdGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXHRcblx0dmFyIFNoYWR5Q1NTID0gd2luZG93LlNoYWR5Q1NTO1xuXHRcblx0dmFyIGVucXVldWVkID0gZmFsc2U7XG5cdFxuXHR2YXIgY3VzdG9tU3R5bGVzID0gW107XG5cdFxuXHR2YXIgaG9va0ZuID0gbnVsbDtcblx0XG5cdC8qXG5cdElmIGEgcGFnZSBvbmx5IGhhcyA8Y3VzdG9tLXN0eWxlPiBlbGVtZW50cywgaXQgd2lsbCBmbGFzaCB1bnN0eWxlZCBjb250ZW50LFxuXHRhcyBhbGwgdGhlIGluc3RhbmNlcyB3aWxsIGJvb3QgYXN5bmNocm9ub3VzbHkgYWZ0ZXIgcGFnZSBsb2FkLlxuXHRcblx0Q2FsbGluZyBTaGFkeUNTUy51cGRhdGVTdHlsZXMoKSB3aWxsIGZvcmNlIHRoZSB3b3JrIHRvIGhhcHBlbiBzeW5jaHJvbm91c2x5XG5cdCovXG5cdGZ1bmN0aW9uIGVucXVldWVEb2N1bWVudFZhbGlkYXRpb24oKSB7XG5cdCAgaWYgKGVucXVldWVkKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHQgIGVucXVldWVkID0gdHJ1ZTtcblx0ICBpZiAod2luZG93LkhUTUxJbXBvcnRzKSB7XG5cdCAgICB3aW5kb3cuSFRNTEltcG9ydHMud2hlblJlYWR5KHZhbGlkYXRlRG9jdW1lbnQpO1xuXHQgIH0gZWxzZSBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuXHQgICAgdmFsaWRhdGVEb2N1bWVudCgpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWFkeXN0YXRlY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuXHQgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuXHQgICAgICAgIHZhbGlkYXRlRG9jdW1lbnQoKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfVxuXHR9XG5cdFxuXHRmdW5jdGlvbiB2YWxpZGF0ZURvY3VtZW50KCkge1xuXHQgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoZW5xdWV1ZWQgfHwgU2hhZHlDU1MuX2VsZW1lbnRzSGF2ZUFwcGxpZWQpIHtcblx0ICAgICAgU2hhZHlDU1MudXBkYXRlU3R5bGVzKCk7XG5cdCAgICB9XG5cdCAgICBlbnF1ZXVlZCA9IGZhbHNlO1xuXHQgIH0pO1xuXHR9XG5cdFxuXHR2YXIgQ3VzdG9tU3R5bGUgPSBmdW5jdGlvbiAoX0hUTUxFbGVtZW50KSB7XG5cdCAgX2luaGVyaXRzKEN1c3RvbVN0eWxlLCBfSFRNTEVsZW1lbnQpO1xuXHRcblx0ICBfY3JlYXRlQ2xhc3MoQ3VzdG9tU3R5bGUsIG51bGwsIFt7XG5cdCAgICBrZXk6ICdmaW5kU3R5bGVzJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kU3R5bGVzKCkge1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1c3RvbVN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBjID0gY3VzdG9tU3R5bGVzW2ldO1xuXHQgICAgICAgIGlmICghYy5fc3R5bGUpIHtcblx0ICAgICAgICAgIHZhciBzdHlsZSA9IGMucXVlcnlTZWxlY3Rvcignc3R5bGUnKTtcblx0ICAgICAgICAgIGlmICghc3R5bGUpIHtcblx0ICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICAvLyBIVE1MSW1wb3J0cyBwb2x5ZmlsbCBtYXkgaGF2ZSBjbG9uZWQgdGhlIHN0eWxlIGludG8gdGhlIG1haW4gZG9jdW1lbnQsXG5cdCAgICAgICAgICAvLyB3aGljaCBpcyByZWZlcmVuY2VkIHdpdGggX19hcHBsaWVkRWxlbWVudC5cblx0ICAgICAgICAgIC8vIEFsc28sIHdlIG11c3QgY29weSBvdmVyIHRoZSBhdHRyaWJ1dGVzLlxuXHQgICAgICAgICAgaWYgKHN0eWxlLl9fYXBwbGllZEVsZW1lbnQpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHN0eWxlLmF0dHJpYnV0ZXMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgICAgdmFyIGF0dHIgPSBzdHlsZS5hdHRyaWJ1dGVzW19pXTtcblx0ICAgICAgICAgICAgICBzdHlsZS5fX2FwcGxpZWRFbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyLm5hbWUsIGF0dHIudmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBjLl9zdHlsZSA9IHN0eWxlLl9fYXBwbGllZEVsZW1lbnQgfHwgc3R5bGU7XG5cdCAgICAgICAgICBpZiAoaG9va0ZuKSB7XG5cdCAgICAgICAgICAgIGhvb2tGbihjLl9zdHlsZSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBTaGFkeUNTUy5fdHJhbnNmb3JtQ3VzdG9tU3R5bGVGb3JEb2N1bWVudChjLl9zdHlsZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX3JldmFsaWRhdGVBcHBseVNoaW0nLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXZhbGlkYXRlQXBwbHlTaGltKCkge1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1c3RvbVN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBjID0gY3VzdG9tU3R5bGVzW2ldO1xuXHQgICAgICAgIGlmIChjLl9zdHlsZSkge1xuXHQgICAgICAgICAgU2hhZHlDU1MuX3JldmFsaWRhdGVBcHBseVNoaW0oYy5fc3R5bGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2FwcGx5U3R5bGVzJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseVN0eWxlcygpIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXN0b21TdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgYyA9IGN1c3RvbVN0eWxlc1tpXTtcblx0ICAgICAgICBpZiAoYy5fc3R5bGUpIHtcblx0ICAgICAgICAgIFNoYWR5Q1NTLl9hcHBseUN1c3RvbVN0eWxlVG9Eb2N1bWVudChjLl9zdHlsZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGVucXVldWVkID0gZmFsc2U7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX2N1c3RvbVN0eWxlcycsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgcmV0dXJuIGN1c3RvbVN0eWxlcztcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdwcm9jZXNzSG9vaycsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgcmV0dXJuIGhvb2tGbjtcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uIHNldChmbikge1xuXHQgICAgICBob29rRm4gPSBmbjtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdfZG9jdW1lbnREaXJ0eScsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgcmV0dXJuIGVucXVldWVkO1xuXHQgICAgfVxuXHQgIH1dKTtcblx0XG5cdCAgZnVuY3Rpb24gQ3VzdG9tU3R5bGUoKSB7XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3VzdG9tU3R5bGUpO1xuXHRcblx0ICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDdXN0b21TdHlsZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEN1c3RvbVN0eWxlKSkuY2FsbCh0aGlzKSk7XG5cdFxuXHQgICAgY3VzdG9tU3R5bGVzLnB1c2goX3RoaXMpO1xuXHQgICAgZW5xdWV1ZURvY3VtZW50VmFsaWRhdGlvbigpO1xuXHQgICAgcmV0dXJuIF90aGlzO1xuXHQgIH1cblx0XG5cdCAgcmV0dXJuIEN1c3RvbVN0eWxlO1xuXHR9KEhUTUxFbGVtZW50KTtcblx0XG5cdHdpbmRvd1snQ3VzdG9tU3R5bGUnXSA9IEN1c3RvbVN0eWxlO1xuXHR3aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdjdXN0b20tc3R5bGUnLCBDdXN0b21TdHlsZSk7XG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTUgVGhlIEluY3JlbWVudGFsIERPTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDE1IFRoZSBJbmNyZW1lbnRhbCBET00gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQSBjYWNoZWQgcmVmZXJlbmNlIHRvIHRoZSBoYXNPd25Qcm9wZXJ0eSBmdW5jdGlvbi5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIGNhY2hlZCByZWZlcmVuY2UgdG8gdGhlIGNyZWF0ZSBmdW5jdGlvbi5cbiAqL1xudmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogVXNlZCB0byBwcmV2ZW50IHByb3BlcnR5IGNvbGxpc2lvbnMgYmV0d2VlbiBvdXIgXCJtYXBcIiBhbmQgaXRzIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsICo+fSBtYXAgVGhlIG1hcCB0byBjaGVjay5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgcHJvcGVydHkgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG1hcCBoYXMgcHJvcGVydHkuXG4gKi9cbnZhciBoYXMgPSBmdW5jdGlvbiAobWFwLCBwcm9wZXJ0eSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIHByb3BlcnR5KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBtYXAgb2JqZWN0IHdpdGhvdXQgYSBwcm90b3R5cGUuXG4gKiBAcmV0dXJuIHshT2JqZWN0fVxuICovXG52YXIgY3JlYXRlTWFwID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY3JlYXRlKG51bGwpO1xufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiBpbmZvcm1hdGlvbiBuZWVkZWQgdG8gcGVyZm9ybSBkaWZmcyBmb3IgYSBnaXZlbiBET00gbm9kZS5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbm9kZU5hbWVcbiAqIEBwYXJhbSB7P3N0cmluZz19IGtleVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE5vZGVEYXRhKG5vZGVOYW1lLCBrZXkpIHtcbiAgLyoqXG4gICAqIFRoZSBhdHRyaWJ1dGVzIGFuZCB0aGVpciB2YWx1ZXMuXG4gICAqIEBjb25zdCB7IU9iamVjdDxzdHJpbmcsICo+fVxuICAgKi9cbiAgdGhpcy5hdHRycyA9IGNyZWF0ZU1hcCgpO1xuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycywgdXNlZCBmb3IgcXVpY2tseSBkaWZmaW5nIHRoZVxuICAgKiBpbmNvbW1pbmcgYXR0cmlidXRlcyB0byBzZWUgaWYgdGhlIERPTSBub2RlJ3MgYXR0cmlidXRlcyBuZWVkIHRvIGJlXG4gICAqIHVwZGF0ZWQuXG4gICAqIEBjb25zdCB7QXJyYXk8Kj59XG4gICAqL1xuICB0aGlzLmF0dHJzQXJyID0gW107XG5cbiAgLyoqXG4gICAqIFRoZSBpbmNvbWluZyBhdHRyaWJ1dGVzIGZvciB0aGlzIE5vZGUsIGJlZm9yZSB0aGV5IGFyZSB1cGRhdGVkLlxuICAgKiBAY29uc3QgeyFPYmplY3Q8c3RyaW5nLCAqPn1cbiAgICovXG4gIHRoaXMubmV3QXR0cnMgPSBjcmVhdGVNYXAoKTtcblxuICAvKipcbiAgICogVGhlIGtleSB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgbm9kZSwgdXNlZCB0byBwcmVzZXJ2ZSBET00gbm9kZXMgd2hlbiB0aGV5XG4gICAqIG1vdmUgd2l0aGluIHRoZWlyIHBhcmVudC5cbiAgICogQGNvbnN0XG4gICAqL1xuICB0aGlzLmtleSA9IGtleTtcblxuICAvKipcbiAgICogS2VlcHMgdHJhY2sgb2YgY2hpbGRyZW4gd2l0aGluIHRoaXMgbm9kZSBieSB0aGVpciBrZXkuXG4gICAqIHs/T2JqZWN0PHN0cmluZywgIUVsZW1lbnQ+fVxuICAgKi9cbiAgdGhpcy5rZXlNYXAgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUga2V5TWFwIGlzIGN1cnJlbnRseSB2YWxpZC5cbiAgICoge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmtleU1hcFZhbGlkID0gdHJ1ZTtcblxuICAvKipcbiAgICogVGhlIG5vZGUgbmFtZSBmb3IgdGhpcyBub2RlLlxuICAgKiBAY29uc3Qge3N0cmluZ31cbiAgICovXG4gIHRoaXMubm9kZU5hbWUgPSBub2RlTmFtZTtcblxuICAvKipcbiAgICogQHR5cGUgez9zdHJpbmd9XG4gICAqL1xuICB0aGlzLnRleHQgPSBudWxsO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGEgTm9kZURhdGEgb2JqZWN0IGZvciBhIE5vZGUuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIGluaXRpYWxpemUgZGF0YSBmb3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gbm9kZU5hbWUgVGhlIG5vZGUgbmFtZSBvZiBub2RlLlxuICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5IFRoZSBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBub2RlLlxuICogQHJldHVybiB7IU5vZGVEYXRhfSBUaGUgbmV3bHkgaW5pdGlhbGl6ZWQgZGF0YSBvYmplY3RcbiAqL1xudmFyIGluaXREYXRhID0gZnVuY3Rpb24gKG5vZGUsIG5vZGVOYW1lLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBuZXcgTm9kZURhdGEobm9kZU5hbWUsIGtleSk7XG4gIG5vZGVbJ19faW5jcmVtZW50YWxET01EYXRhJ10gPSBkYXRhO1xuICByZXR1cm4gZGF0YTtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBOb2RlRGF0YSBvYmplY3QgZm9yIGEgTm9kZSwgY3JlYXRpbmcgaXQgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byByZXRyaWV2ZSB0aGUgZGF0YSBmb3IuXG4gKiBAcmV0dXJuIHshTm9kZURhdGF9IFRoZSBOb2RlRGF0YSBmb3IgdGhpcyBOb2RlLlxuICovXG52YXIgZ2V0RGF0YSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBkYXRhID0gbm9kZVsnX19pbmNyZW1lbnRhbERPTURhdGEnXTtcblxuICBpZiAoIWRhdGEpIHtcbiAgICB2YXIgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIGtleSA9IG51bGw7XG5cbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgIGtleSA9IG5vZGUuZ2V0QXR0cmlidXRlKCdrZXknKTtcbiAgICB9XG5cbiAgICBkYXRhID0gaW5pdERhdGEobm9kZSwgbm9kZU5hbWUsIGtleSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTUgVGhlIEluY3JlbWVudGFsIERPTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBjb25zdCAqL1xudmFyIHN5bWJvbHMgPSB7XG4gIGRlZmF1bHQ6ICdfX2RlZmF1bHQnLFxuXG4gIHBsYWNlaG9sZGVyOiAnX19wbGFjZWhvbGRlcidcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9IFRoZSBuYW1lc3BhY2UgdG8gdXNlIGZvciB0aGUgYXR0cmlidXRlLlxuICovXG52YXIgZ2V0TmFtZXNwYWNlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKG5hbWUubGFzdEluZGV4T2YoJ3htbDonLCAwKSA9PT0gMCkge1xuICAgIHJldHVybiAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJztcbiAgfVxuXG4gIGlmIChuYW1lLmxhc3RJbmRleE9mKCd4bGluazonLCAwKSA9PT0gMCkge1xuICAgIHJldHVybiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG4gIH1cbn07XG5cbi8qKlxuICogQXBwbGllcyBhbiBhdHRyaWJ1dGUgb3IgcHJvcGVydHkgdG8gYSBnaXZlbiBFbGVtZW50LiBJZiB0aGUgdmFsdWUgaXMgbnVsbFxuICogb3IgdW5kZWZpbmVkLCBpdCBpcyByZW1vdmVkIGZyb20gdGhlIEVsZW1lbnQuIE90aGVyd2lzZSwgdGhlIHZhbHVlIGlzIHNldFxuICogYXMgYW4gYXR0cmlidXRlLlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBhdHRyaWJ1dGUncyBuYW1lLlxuICogQHBhcmFtIHs/KGJvb2xlYW58bnVtYmVyfHN0cmluZyk9fSB2YWx1ZSBUaGUgYXR0cmlidXRlJ3MgdmFsdWUuXG4gKi9cbnZhciBhcHBseUF0dHIgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBhdHRyTlMgPSBnZXROYW1lc3BhY2UobmFtZSk7XG4gICAgaWYgKGF0dHJOUykge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoYXR0ck5TLCBuYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgYSBwcm9wZXJ0eSB0byBhIGdpdmVuIEVsZW1lbnQuXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHByb3BlcnR5J3MgbmFtZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHByb3BlcnR5J3MgdmFsdWUuXG4gKi9cbnZhciBhcHBseVByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIGVsW25hbWVdID0gdmFsdWU7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgYSBzdHlsZSB0byBhbiBFbGVtZW50LiBObyB2ZW5kb3IgcHJlZml4IGV4cGFuc2lvbiBpcyBkb25lIGZvclxuICogcHJvcGVydHkgbmFtZXMvdmFsdWVzLlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBhdHRyaWJ1dGUncyBuYW1lLlxuICogQHBhcmFtIHsqfSBzdHlsZSBUaGUgc3R5bGUgdG8gc2V0LiBFaXRoZXIgYSBzdHJpbmcgb2YgY3NzIG9yIGFuIG9iamVjdFxuICogICAgIGNvbnRhaW5pbmcgcHJvcGVydHktdmFsdWUgcGFpcnMuXG4gKi9cbnZhciBhcHBseVN0eWxlID0gZnVuY3Rpb24gKGVsLCBuYW1lLCBzdHlsZSkge1xuICBpZiAodHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJykge1xuICAgIGVsLnN0eWxlLmNzc1RleHQgPSBzdHlsZTtcbiAgfSBlbHNlIHtcbiAgICBlbC5zdHlsZS5jc3NUZXh0ID0gJyc7XG4gICAgdmFyIGVsU3R5bGUgPSBlbC5zdHlsZTtcbiAgICB2YXIgb2JqID0gLyoqIEB0eXBlIHshT2JqZWN0PHN0cmluZyxzdHJpbmc+fSAqL3N0eWxlO1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgIGlmIChoYXMob2JqLCBwcm9wKSkge1xuICAgICAgICBlbFN0eWxlW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGVzIGEgc2luZ2xlIGF0dHJpYnV0ZSBvbiBhbiBFbGVtZW50LlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBhdHRyaWJ1dGUncyBuYW1lLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgYXR0cmlidXRlJ3MgdmFsdWUuIElmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3Qgb3JcbiAqICAgICBmdW5jdGlvbiBpdCBpcyBzZXQgb24gdGhlIEVsZW1lbnQsIG90aGVyd2lzZSwgaXQgaXMgc2V0IGFzIGFuIEhUTUxcbiAqICAgICBhdHRyaWJ1dGUuXG4gKi9cbnZhciBhcHBseUF0dHJpYnV0ZVR5cGVkID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5UHJvcChlbCwgbmFtZSwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGFwcGx5QXR0cihlbCwgbmFtZSwgLyoqIEB0eXBlIHs/KGJvb2xlYW58bnVtYmVyfHN0cmluZyl9ICovdmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxzIHRoZSBhcHByb3ByaWF0ZSBhdHRyaWJ1dGUgbXV0YXRvciBmb3IgdGhpcyBhdHRyaWJ1dGUuXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGF0dHJpYnV0ZSdzIG5hbWUuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBhdHRyaWJ1dGUncyB2YWx1ZS5cbiAqL1xudmFyIHVwZGF0ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXREYXRhKGVsKTtcbiAgdmFyIGF0dHJzID0gZGF0YS5hdHRycztcblxuICBpZiAoYXR0cnNbbmFtZV0gPT09IHZhbHVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG11dGF0b3IgPSBhdHRyaWJ1dGVzW25hbWVdIHx8IGF0dHJpYnV0ZXNbc3ltYm9scy5kZWZhdWx0XTtcbiAgbXV0YXRvcihlbCwgbmFtZSwgdmFsdWUpO1xuXG4gIGF0dHJzW25hbWVdID0gdmFsdWU7XG59O1xuXG4vKipcbiAqIEEgcHVibGljbHkgbXV0YWJsZSBvYmplY3QgdG8gcHJvdmlkZSBjdXN0b20gbXV0YXRvcnMgZm9yIGF0dHJpYnV0ZXMuXG4gKiBAY29uc3QgeyFPYmplY3Q8c3RyaW5nLCBmdW5jdGlvbighRWxlbWVudCwgc3RyaW5nLCAqKT59XG4gKi9cbnZhciBhdHRyaWJ1dGVzID0gY3JlYXRlTWFwKCk7XG5cbi8vIFNwZWNpYWwgZ2VuZXJpYyBtdXRhdG9yIHRoYXQncyBjYWxsZWQgZm9yIGFueSBhdHRyaWJ1dGUgdGhhdCBkb2VzIG5vdFxuLy8gaGF2ZSBhIHNwZWNpZmljIG11dGF0b3IuXG5hdHRyaWJ1dGVzW3N5bWJvbHMuZGVmYXVsdF0gPSBhcHBseUF0dHJpYnV0ZVR5cGVkO1xuXG5hdHRyaWJ1dGVzW3N5bWJvbHMucGxhY2Vob2xkZXJdID0gZnVuY3Rpb24gKCkge307XG5cbmF0dHJpYnV0ZXNbJ3N0eWxlJ10gPSBhcHBseVN0eWxlO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hbWVzcGFjZSB0byBjcmVhdGUgYW4gZWxlbWVudCAob2YgYSBnaXZlbiB0YWcpIGluLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgdGFnIHRvIGdldCB0aGUgbmFtZXNwYWNlIGZvci5cbiAqIEBwYXJhbSB7P05vZGV9IHBhcmVudFxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIG5hbWVzcGFjZSB0byBjcmVhdGUgdGhlIHRhZyBpbi5cbiAqL1xudmFyIGdldE5hbWVzcGFjZUZvclRhZyA9IGZ1bmN0aW9uICh0YWcsIHBhcmVudCkge1xuICBpZiAodGFnID09PSAnc3ZnJykge1xuICAgIHJldHVybiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICB9XG5cbiAgaWYgKGdldERhdGEocGFyZW50KS5ub2RlTmFtZSA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gcGFyZW50Lm5hbWVzcGFjZVVSSTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBFbGVtZW50LlxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jIFRoZSBkb2N1bWVudCB3aXRoIHdoaWNoIHRvIGNyZWF0ZSB0aGUgRWxlbWVudC5cbiAqIEBwYXJhbSB7P05vZGV9IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgdGFnIGZvciB0aGUgRWxlbWVudC5cbiAqIEBwYXJhbSB7P3N0cmluZz19IGtleSBBIGtleSB0byBpZGVudGlmeSB0aGUgRWxlbWVudC5cbiAqIEBwYXJhbSB7P0FycmF5PCo+PX0gc3RhdGljcyBBbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBvZiB0aGVcbiAqICAgICBzdGF0aWMgYXR0cmlidXRlcyBmb3IgdGhlIEVsZW1lbnQuXG4gKiBAcmV0dXJuIHshRWxlbWVudH1cbiAqL1xudmFyIGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoZG9jLCBwYXJlbnQsIHRhZywga2V5LCBzdGF0aWNzKSB7XG4gIHZhciBuYW1lc3BhY2UgPSBnZXROYW1lc3BhY2VGb3JUYWcodGFnLCBwYXJlbnQpO1xuICB2YXIgZWwgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKG5hbWVzcGFjZSkge1xuICAgIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsIHRhZyk7XG4gIH0gZWxzZSB7XG4gICAgZWwgPSBkb2MuY3JlYXRlRWxlbWVudCh0YWcpO1xuICB9XG5cbiAgaW5pdERhdGEoZWwsIHRhZywga2V5KTtcblxuICBpZiAoc3RhdGljcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGljcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgdXBkYXRlQXR0cmlidXRlKGVsLCAvKiogQHR5cGUgeyFzdHJpbmd9Ki9zdGF0aWNzW2ldLCBzdGF0aWNzW2kgKyAxXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgVGV4dCBOb2RlLlxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jIFRoZSBkb2N1bWVudCB3aXRoIHdoaWNoIHRvIGNyZWF0ZSB0aGUgRWxlbWVudC5cbiAqIEByZXR1cm4geyFUZXh0fVxuICovXG52YXIgY3JlYXRlVGV4dCA9IGZ1bmN0aW9uIChkb2MpIHtcbiAgdmFyIG5vZGUgPSBkb2MuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBpbml0RGF0YShub2RlLCAnI3RleHQnLCBudWxsKTtcbiAgcmV0dXJuIG5vZGU7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXBwaW5nIHRoYXQgY2FuIGJlIHVzZWQgdG8gbG9vayB1cCBjaGlsZHJlbiB1c2luZyBhIGtleS5cbiAqIEBwYXJhbSB7P05vZGV9IGVsXG4gKiBAcmV0dXJuIHshT2JqZWN0PHN0cmluZywgIUVsZW1lbnQ+fSBBIG1hcHBpbmcgb2Yga2V5cyB0byB0aGUgY2hpbGRyZW4gb2YgdGhlXG4gKiAgICAgRWxlbWVudC5cbiAqL1xudmFyIGNyZWF0ZUtleU1hcCA9IGZ1bmN0aW9uIChlbCkge1xuICB2YXIgbWFwID0gY3JlYXRlTWFwKCk7XG4gIHZhciBjaGlsZCA9IGVsLmZpcnN0RWxlbWVudENoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCkge1xuICAgIHZhciBrZXkgPSBnZXREYXRhKGNoaWxkKS5rZXk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBtYXBba2V5XSA9IGNoaWxkO1xuICAgIH1cblxuICAgIGNoaWxkID0gY2hpbGQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICB9XG5cbiAgcmV0dXJuIG1hcDtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBtYXBwaW5nIG9mIGtleSB0byBjaGlsZCBub2RlIGZvciBhIGdpdmVuIEVsZW1lbnQsIGNyZWF0aW5nIGl0XG4gKiBpZiBuZWNlc3NhcnkuXG4gKiBAcGFyYW0gez9Ob2RlfSBlbFxuICogQHJldHVybiB7IU9iamVjdDxzdHJpbmcsICFOb2RlPn0gQSBtYXBwaW5nIG9mIGtleXMgdG8gY2hpbGQgRWxlbWVudHNcbiAqL1xudmFyIGdldEtleU1hcCA9IGZ1bmN0aW9uIChlbCkge1xuICB2YXIgZGF0YSA9IGdldERhdGEoZWwpO1xuXG4gIGlmICghZGF0YS5rZXlNYXApIHtcbiAgICBkYXRhLmtleU1hcCA9IGNyZWF0ZUtleU1hcChlbCk7XG4gIH1cblxuICByZXR1cm4gZGF0YS5rZXlNYXA7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBhIGNoaWxkIGZyb20gdGhlIHBhcmVudCB3aXRoIHRoZSBnaXZlbiBrZXkuXG4gKiBAcGFyYW0gez9Ob2RlfSBwYXJlbnRcbiAqIEBwYXJhbSB7P3N0cmluZz19IGtleVxuICogQHJldHVybiB7P05vZGV9IFRoZSBjaGlsZCBjb3JyZXNwb25kaW5nIHRvIHRoZSBrZXkuXG4gKi9cbnZhciBnZXRDaGlsZCA9IGZ1bmN0aW9uIChwYXJlbnQsIGtleSkge1xuICByZXR1cm4ga2V5ID8gZ2V0S2V5TWFwKHBhcmVudClba2V5XSA6IG51bGw7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhbiBlbGVtZW50IGFzIGJlaW5nIGEgY2hpbGQuIFRoZSBwYXJlbnQgd2lsbCBrZWVwIHRyYWNrIG9mIHRoZVxuICogY2hpbGQgdXNpbmcgdGhlIGtleS4gVGhlIGNoaWxkIGNhbiBiZSByZXRyaWV2ZWQgdXNpbmcgdGhlIHNhbWUga2V5IHVzaW5nXG4gKiBnZXRLZXlNYXAuIFRoZSBwcm92aWRlZCBrZXkgc2hvdWxkIGJlIHVuaXF1ZSB3aXRoaW4gdGhlIHBhcmVudCBFbGVtZW50LlxuICogQHBhcmFtIHs/Tm9kZX0gcGFyZW50IFRoZSBwYXJlbnQgb2YgY2hpbGQuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IEEga2V5IHRvIGlkZW50aWZ5IHRoZSBjaGlsZCB3aXRoLlxuICogQHBhcmFtIHshTm9kZX0gY2hpbGQgVGhlIGNoaWxkIHRvIHJlZ2lzdGVyLlxuICovXG52YXIgcmVnaXN0ZXJDaGlsZCA9IGZ1bmN0aW9uIChwYXJlbnQsIGtleSwgY2hpbGQpIHtcbiAgZ2V0S2V5TWFwKHBhcmVudClba2V5XSA9IGNoaWxkO1xufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSBUaGUgSW5jcmVtZW50YWwgRE9NIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGNvbnN0ICovXG52YXIgbm90aWZpY2F0aW9ucyA9IHtcbiAgLyoqXG4gICAqIENhbGxlZCBhZnRlciBwYXRjaCBoYXMgY29tcGxlYXRlZCB3aXRoIGFueSBOb2RlcyB0aGF0IGhhdmUgYmVlbiBjcmVhdGVkXG4gICAqIGFuZCBhZGRlZCB0byB0aGUgRE9NLlxuICAgKiBAdHlwZSB7P2Z1bmN0aW9uKEFycmF5PCFOb2RlPil9XG4gICAqL1xuICBub2Rlc0NyZWF0ZWQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIENhbGxlZCBhZnRlciBwYXRjaCBoYXMgY29tcGxlYXRlZCB3aXRoIGFueSBOb2RlcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkXG4gICAqIGZyb20gdGhlIERPTS5cbiAgICogTm90ZSBpdCdzIGFuIGFwcGxpY2F0aW9ucyByZXNwb25zaWJpbGl0eSB0byBoYW5kbGUgYW55IGNoaWxkTm9kZXMuXG4gICAqIEB0eXBlIHs/ZnVuY3Rpb24oQXJyYXk8IU5vZGU+KX1cbiAgICovXG4gIG5vZGVzRGVsZXRlZDogbnVsbFxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgc3RhdGUgb2YgYSBwYXRjaC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDb250ZXh0KCkge1xuICAvKipcbiAgICogQHR5cGUgeyhBcnJheTwhTm9kZT58dW5kZWZpbmVkKX1cbiAgICovXG4gIHRoaXMuY3JlYXRlZCA9IG5vdGlmaWNhdGlvbnMubm9kZXNDcmVhdGVkICYmIFtdO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7KEFycmF5PCFOb2RlPnx1bmRlZmluZWQpfVxuICAgKi9cbiAgdGhpcy5kZWxldGVkID0gbm90aWZpY2F0aW9ucy5ub2Rlc0RlbGV0ZWQgJiYgW107XG59XG5cbi8qKlxuICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICovXG5Db250ZXh0LnByb3RvdHlwZS5tYXJrQ3JlYXRlZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICh0aGlzLmNyZWF0ZWQpIHtcbiAgICB0aGlzLmNyZWF0ZWQucHVzaChub2RlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLm1hcmtEZWxldGVkID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgIHRoaXMuZGVsZXRlZC5wdXNoKG5vZGUpO1xuICB9XG59O1xuXG4vKipcbiAqIE5vdGlmaWVzIGFib3V0IG5vZGVzIHRoYXQgd2VyZSBjcmVhdGVkIGR1cmluZyB0aGUgcGF0Y2ggb3BlYXJhdGlvbi5cbiAqL1xuQ29udGV4dC5wcm90b3R5cGUubm90aWZ5Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY3JlYXRlZCAmJiB0aGlzLmNyZWF0ZWQubGVuZ3RoID4gMCkge1xuICAgIG5vdGlmaWNhdGlvbnMubm9kZXNDcmVhdGVkKHRoaXMuY3JlYXRlZCk7XG4gIH1cblxuICBpZiAodGhpcy5kZWxldGVkICYmIHRoaXMuZGVsZXRlZC5sZW5ndGggPiAwKSB7XG4gICAgbm90aWZpY2F0aW9ucy5ub2Rlc0RlbGV0ZWQodGhpcy5kZWxldGVkKTtcbiAgfVxufTtcblxuLyoqXG4qIE1ha2VzIHN1cmUgdGhhdCBrZXllZCBFbGVtZW50IG1hdGNoZXMgdGhlIHRhZyBuYW1lIHByb3ZpZGVkLlxuKiBAcGFyYW0geyFzdHJpbmd9IG5vZGVOYW1lIFRoZSBub2RlTmFtZSBvZiB0aGUgbm9kZSB0aGF0IGlzIGJlaW5nIG1hdGNoZWQuXG4qIEBwYXJhbSB7c3RyaW5nPX0gdGFnIFRoZSB0YWcgbmFtZSBvZiB0aGUgRWxlbWVudC5cbiogQHBhcmFtIHs/c3RyaW5nPX0ga2V5IFRoZSBrZXkgb2YgdGhlIEVsZW1lbnQuXG4qL1xudmFyIGFzc2VydEtleWVkVGFnTWF0Y2hlcyA9IGZ1bmN0aW9uIChub2RlTmFtZSwgdGFnLCBrZXkpIHtcbiAgaWYgKG5vZGVOYW1lICE9PSB0YWcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dhcyBleHBlY3Rpbmcgbm9kZSB3aXRoIGtleSBcIicgKyBrZXkgKyAnXCIgdG8gYmUgYSAnICsgdGFnICsgJywgbm90IGEgJyArIG5vZGVOYW1lICsgJy4nKTtcbiAgfVxufTtcblxuLyoqIEB0eXBlIHs/Q29udGV4dH0gKi9cbnZhciBjb250ZXh0ID0gbnVsbDtcblxuLyoqIEB0eXBlIHs/Tm9kZX0gKi9cbnZhciBjdXJyZW50Tm9kZSA9IG51bGw7XG5cbi8qKiBAdHlwZSB7P05vZGV9ICovXG52YXIgY3VycmVudFBhcmVudCA9IG51bGw7XG5cbi8qKiBAdHlwZSB7P0VsZW1lbnR8P0RvY3VtZW50RnJhZ21lbnR9ICovXG52YXIgcm9vdCA9IG51bGw7XG5cbi8qKiBAdHlwZSB7P0RvY3VtZW50fSAqL1xudmFyIGRvYyA9IG51bGw7XG5cbi8qKlxuICogUmV0dXJucyBhIHBhdGNoZXIgZnVuY3Rpb24gdGhhdCBzZXRzIHVwIGFuZCByZXN0b3JlcyBhIHBhdGNoIGNvbnRleHQsXG4gKiBydW5uaW5nIHRoZSBydW4gZnVuY3Rpb24gd2l0aCB0aGUgcHJvdmlkZWQgZGF0YS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKCFFbGVtZW50fCFEb2N1bWVudEZyYWdtZW50KSwhZnVuY3Rpb24oVCksVD0pfSBydW5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCghRWxlbWVudHwhRG9jdW1lbnRGcmFnbWVudCksIWZ1bmN0aW9uKFQpLFQ9KX1cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbnZhciBwYXRjaEZhY3RvcnkgPSBmdW5jdGlvbiAocnVuKSB7XG4gIC8qKlxuICAgKiBUT0RPKG1veik6IFRoZXNlIGFubm90YXRpb25zIHdvbid0IGJlIG5lY2Vzc2FyeSBvbmNlIHdlIHN3aXRjaCB0byBDbG9zdXJlXG4gICAqIENvbXBpbGVyJ3MgbmV3IHR5cGUgaW5mZXJlbmNlLiBSZW1vdmUgdGhlc2Ugb25jZSB0aGUgc3dpdGNoIGlzIGRvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7KCFFbGVtZW50fCFEb2N1bWVudEZyYWdtZW50KX0gbm9kZVxuICAgKiBAcGFyYW0geyFmdW5jdGlvbihUKX0gZm5cbiAgICogQHBhcmFtIHtUPX0gZGF0YVxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cbiAgdmFyIGYgPSBmdW5jdGlvbiAobm9kZSwgZm4sIGRhdGEpIHtcbiAgICB2YXIgcHJldkNvbnRleHQgPSBjb250ZXh0O1xuICAgIHZhciBwcmV2Um9vdCA9IHJvb3Q7XG4gICAgdmFyIHByZXZEb2MgPSBkb2M7XG4gICAgdmFyIHByZXZDdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlO1xuICAgIHZhciBwcmV2Q3VycmVudFBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgdmFyIHByZXZpb3VzSW5BdHRyaWJ1dGVzID0gZmFsc2U7XG4gICAgdmFyIHByZXZpb3VzSW5Ta2lwID0gZmFsc2U7XG5cbiAgICBjb250ZXh0ID0gbmV3IENvbnRleHQoKTtcbiAgICByb290ID0gbm9kZTtcbiAgICBkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgY3VycmVudFBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcblxuICAgIGlmICgncHJvZHVjdGlvbicgIT09ICdwcm9kdWN0aW9uJykge31cblxuICAgIHJ1bihub2RlLCBmbiwgZGF0YSk7XG5cbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSAncHJvZHVjdGlvbicpIHt9XG5cbiAgICBjb250ZXh0Lm5vdGlmeUNoYW5nZXMoKTtcblxuICAgIGNvbnRleHQgPSBwcmV2Q29udGV4dDtcbiAgICByb290ID0gcHJldlJvb3Q7XG4gICAgZG9jID0gcHJldkRvYztcbiAgICBjdXJyZW50Tm9kZSA9IHByZXZDdXJyZW50Tm9kZTtcbiAgICBjdXJyZW50UGFyZW50ID0gcHJldkN1cnJlbnRQYXJlbnQ7XG4gIH07XG4gIHJldHVybiBmO1xufTtcblxuLyoqXG4gKiBQYXRjaGVzIHRoZSBkb2N1bWVudCBzdGFydGluZyBhdCBub2RlIHdpdGggdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLiBUaGlzXG4gKiBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGR1cmluZyBhbiBleGlzdGluZyBwYXRjaCBvcGVyYXRpb24uXG4gKiBAcGFyYW0geyFFbGVtZW50fCFEb2N1bWVudEZyYWdtZW50fSBub2RlIFRoZSBFbGVtZW50IG9yIERvY3VtZW50XG4gKiAgICAgdG8gcGF0Y2guXG4gKiBAcGFyYW0geyFmdW5jdGlvbihUKX0gZm4gQSBmdW5jdGlvbiBjb250YWluaW5nIGVsZW1lbnRPcGVuL2VsZW1lbnRDbG9zZS9ldGMuXG4gKiAgICAgY2FsbHMgdGhhdCBkZXNjcmliZSB0aGUgRE9NLlxuICogQHBhcmFtIHtUPX0gZGF0YSBBbiBhcmd1bWVudCBwYXNzZWQgdG8gZm4gdG8gcmVwcmVzZW50IERPTSBzdGF0ZS5cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbnZhciBwYXRjaElubmVyID0gcGF0Y2hGYWN0b3J5KGZ1bmN0aW9uIChub2RlLCBmbiwgZGF0YSkge1xuICBjdXJyZW50Tm9kZSA9IG5vZGU7XG5cbiAgZW50ZXJOb2RlKCk7XG4gIGZuKGRhdGEpO1xuICBleGl0Tm9kZSgpO1xuXG4gIGlmICgncHJvZHVjdGlvbicgIT09ICdwcm9kdWN0aW9uJykge31cbn0pO1xuXG4vKipcbiAqIFBhdGNoZXMgYW4gRWxlbWVudCB3aXRoIHRoZSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uIEV4YWN0bHkgb25lIHRvcCBsZXZlbFxuICogZWxlbWVudCBjYWxsIHNob3VsZCBiZSBtYWRlIGNvcnJlc3BvbmRpbmcgdG8gYG5vZGVgLlxuICogQHBhcmFtIHshRWxlbWVudH0gbm9kZSBUaGUgRWxlbWVudCB3aGVyZSB0aGUgcGF0Y2ggc2hvdWxkIHN0YXJ0LlxuICogQHBhcmFtIHshZnVuY3Rpb24oVCl9IGZuIEEgZnVuY3Rpb24gY29udGFpbmluZyBlbGVtZW50T3Blbi9lbGVtZW50Q2xvc2UvZXRjLlxuICogICAgIGNhbGxzIHRoYXQgZGVzY3JpYmUgdGhlIERPTS4gVGhpcyBzaG91bGQgaGF2ZSBhdCBtb3N0IG9uZSB0b3AgbGV2ZWxcbiAqICAgICBlbGVtZW50IGNhbGwuXG4gKiBAcGFyYW0ge1Q9fSBkYXRhIEFuIGFyZ3VtZW50IHBhc3NlZCB0byBmbiB0byByZXByZXNlbnQgRE9NIHN0YXRlLlxuICogQHRlbXBsYXRlIFRcbiAqL1xudmFyIHBhdGNoT3V0ZXIgPSBwYXRjaEZhY3RvcnkoZnVuY3Rpb24gKG5vZGUsIGZuLCBkYXRhKSB7XG4gIGN1cnJlbnROb2RlID0gLyoqIEB0eXBlIHshRWxlbWVudH0gKi97IG5leHRTaWJsaW5nOiBub2RlIH07XG5cbiAgZm4oZGF0YSk7XG5cbiAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gJ3Byb2R1Y3Rpb24nKSB7fVxufSk7XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoZSBjdXJyZW50IG5vZGUgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIG5vZGVOYW1lIGFuZFxuICoga2V5LlxuICpcbiAqIEBwYXJhbSB7P3N0cmluZ30gbm9kZU5hbWUgVGhlIG5vZGVOYW1lIGZvciB0aGlzIG5vZGUuXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBrZXkgQW4gb3B0aW9uYWwga2V5IHRoYXQgaWRlbnRpZmllcyBhIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBub2RlIG1hdGNoZXMsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xudmFyIG1hdGNoZXMgPSBmdW5jdGlvbiAobm9kZU5hbWUsIGtleSkge1xuICB2YXIgZGF0YSA9IGdldERhdGEoY3VycmVudE5vZGUpO1xuXG4gIC8vIEtleSBjaGVjayBpcyBkb25lIHVzaW5nIGRvdWJsZSBlcXVhbHMgYXMgd2Ugd2FudCB0byB0cmVhdCBhIG51bGwga2V5IHRoZVxuICAvLyBzYW1lIGFzIHVuZGVmaW5lZC4gVGhpcyBzaG91bGQgYmUgb2theSBhcyB0aGUgb25seSB2YWx1ZXMgYWxsb3dlZCBhcmVcbiAgLy8gc3RyaW5ncywgbnVsbCBhbmQgdW5kZWZpbmVkIHNvIHRoZSA9PSBzZW1hbnRpY3MgYXJlIG5vdCB0b28gd2VpcmQuXG4gIHJldHVybiBub2RlTmFtZSA9PT0gZGF0YS5ub2RlTmFtZSAmJiBrZXkgPT0gZGF0YS5rZXk7XG59O1xuXG4vKipcbiAqIEFsaWducyB0aGUgdmlydHVhbCBFbGVtZW50IGRlZmluaXRpb24gd2l0aCB0aGUgYWN0dWFsIERPTSwgbW92aW5nIHRoZVxuICogY29ycmVzcG9uZGluZyBET00gbm9kZSB0byB0aGUgY29ycmVjdCBsb2NhdGlvbiBvciBjcmVhdGluZyBpdCBpZiBuZWNlc3NhcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30gbm9kZU5hbWUgRm9yIGFuIEVsZW1lbnQsIHRoaXMgc2hvdWxkIGJlIGEgdmFsaWQgdGFnIHN0cmluZy5cbiAqICAgICBGb3IgYSBUZXh0LCB0aGlzIHNob3VsZCBiZSAjdGV4dC5cbiAqIEBwYXJhbSB7P3N0cmluZz19IGtleSBUaGUga2V5IHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBlbGVtZW50LlxuICogQHBhcmFtIHs/QXJyYXk8Kj49fSBzdGF0aWNzIEZvciBhbiBFbGVtZW50LCB0aGlzIHNob3VsZCBiZSBhbiBhcnJheSBvZlxuICogICAgIG5hbWUtdmFsdWUgcGFpcnMuXG4gKi9cbnZhciBhbGlnbldpdGhET00gPSBmdW5jdGlvbiAobm9kZU5hbWUsIGtleSwgc3RhdGljcykge1xuICBpZiAoY3VycmVudE5vZGUgJiYgbWF0Y2hlcyhub2RlTmFtZSwga2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBub2RlID0gdW5kZWZpbmVkO1xuXG4gIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgbm9kZSBoYXMgbW92ZWQgd2l0aGluIHRoZSBwYXJlbnQuXG4gIGlmIChrZXkpIHtcbiAgICBub2RlID0gZ2V0Q2hpbGQoY3VycmVudFBhcmVudCwga2V5KTtcbiAgICBpZiAobm9kZSAmJiAncHJvZHVjdGlvbicgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0S2V5ZWRUYWdNYXRjaGVzKGdldERhdGEobm9kZSkubm9kZU5hbWUsIG5vZGVOYW1lLCBrZXkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENyZWF0ZSB0aGUgbm9kZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICBpZiAoIW5vZGUpIHtcbiAgICBpZiAobm9kZU5hbWUgPT09ICcjdGV4dCcpIHtcbiAgICAgIG5vZGUgPSBjcmVhdGVUZXh0KGRvYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSBjcmVhdGVFbGVtZW50KGRvYywgY3VycmVudFBhcmVudCwgbm9kZU5hbWUsIGtleSwgc3RhdGljcyk7XG4gICAgfVxuXG4gICAgaWYgKGtleSkge1xuICAgICAgcmVnaXN0ZXJDaGlsZChjdXJyZW50UGFyZW50LCBrZXksIG5vZGUpO1xuICAgIH1cblxuICAgIGNvbnRleHQubWFya0NyZWF0ZWQobm9kZSk7XG4gIH1cblxuICAvLyBJZiB0aGUgbm9kZSBoYXMgYSBrZXksIHJlbW92ZSBpdCBmcm9tIHRoZSBET00gdG8gcHJldmVudCBhIGxhcmdlIG51bWJlclxuICAvLyBvZiByZS1vcmRlcnMgaW4gdGhlIGNhc2UgdGhhdCBpdCBtb3ZlZCBmYXIgb3Igd2FzIGNvbXBsZXRlbHkgcmVtb3ZlZC5cbiAgLy8gU2luY2Ugd2UgaG9sZCBvbiB0byBhIHJlZmVyZW5jZSB0aHJvdWdoIHRoZSBrZXlNYXAsIHdlIGNhbiBhbHdheXMgYWRkIGl0XG4gIC8vIGJhY2suXG4gIGlmIChjdXJyZW50Tm9kZSAmJiBnZXREYXRhKGN1cnJlbnROb2RlKS5rZXkpIHtcbiAgICBjdXJyZW50UGFyZW50LnJlcGxhY2VDaGlsZChub2RlLCBjdXJyZW50Tm9kZSk7XG4gICAgZ2V0RGF0YShjdXJyZW50UGFyZW50KS5rZXlNYXBWYWxpZCA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGN1cnJlbnRQYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIGN1cnJlbnROb2RlKTtcbiAgfVxuXG4gIGN1cnJlbnROb2RlID0gbm9kZTtcbn07XG5cbi8qKlxuICogQ2xlYXJzIG91dCBhbnkgdW52aXNpdGVkIE5vZGVzLCBhcyB0aGUgY29ycmVzcG9uZGluZyB2aXJ0dWFsIGVsZW1lbnRcbiAqIGZ1bmN0aW9ucyB3ZXJlIG5ldmVyIGNhbGxlZCBmb3IgdGhlbS5cbiAqL1xudmFyIGNsZWFyVW52aXNpdGVkRE9NID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG4gIHZhciBkYXRhID0gZ2V0RGF0YShub2RlKTtcbiAgdmFyIGtleU1hcCA9IGRhdGEua2V5TWFwO1xuICB2YXIga2V5TWFwVmFsaWQgPSBkYXRhLmtleU1hcFZhbGlkO1xuICB2YXIgY2hpbGQgPSBub2RlLmxhc3RDaGlsZDtcbiAgdmFyIGtleSA9IHVuZGVmaW5lZDtcblxuICBpZiAoY2hpbGQgPT09IGN1cnJlbnROb2RlICYmIGtleU1hcFZhbGlkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGRhdGEuYXR0cnNbc3ltYm9scy5wbGFjZWhvbGRlcl0gJiYgbm9kZSAhPT0gcm9vdCkge1xuICAgIGlmICgncHJvZHVjdGlvbicgIT09ICdwcm9kdWN0aW9uJykge31cbiAgICByZXR1cm47XG4gIH1cblxuICB3aGlsZSAoY2hpbGQgIT09IGN1cnJlbnROb2RlKSB7XG4gICAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgY29udGV4dC5tYXJrRGVsZXRlZCggLyoqIEB0eXBlIHshTm9kZX0qL2NoaWxkKTtcblxuICAgIGtleSA9IGdldERhdGEoY2hpbGQpLmtleTtcbiAgICBpZiAoa2V5KSB7XG4gICAgICBkZWxldGUga2V5TWFwW2tleV07XG4gICAgfVxuICAgIGNoaWxkID0gbm9kZS5sYXN0Q2hpbGQ7XG4gIH1cblxuICAvLyBDbGVhbiB0aGUga2V5TWFwLCByZW1vdmluZyBhbnkgdW51c3VlZCBrZXlzLlxuICBpZiAoIWtleU1hcFZhbGlkKSB7XG4gICAgZm9yIChrZXkgaW4ga2V5TWFwKSB7XG4gICAgICBjaGlsZCA9IGtleU1hcFtrZXldO1xuICAgICAgaWYgKGNoaWxkLnBhcmVudE5vZGUgIT09IG5vZGUpIHtcbiAgICAgICAgY29udGV4dC5tYXJrRGVsZXRlZChjaGlsZCk7XG4gICAgICAgIGRlbGV0ZSBrZXlNYXBba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkYXRhLmtleU1hcFZhbGlkID0gdHJ1ZTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGFuZ2VzIHRvIHRoZSBmaXJzdCBjaGlsZCBvZiB0aGUgY3VycmVudCBub2RlLlxuICovXG52YXIgZW50ZXJOb2RlID0gZnVuY3Rpb24gKCkge1xuICBjdXJyZW50UGFyZW50ID0gY3VycmVudE5vZGU7XG4gIGN1cnJlbnROb2RlID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2hhbmdlcyB0byB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBjdXJyZW50IG5vZGUuXG4gKi9cbnZhciBuZXh0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGN1cnJlbnROb2RlKSB7XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5uZXh0U2libGluZztcbiAgfSBlbHNlIHtcbiAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnRQYXJlbnQuZmlyc3RDaGlsZDtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGFuZ2VzIHRvIHRoZSBwYXJlbnQgb2YgdGhlIGN1cnJlbnQgbm9kZSwgcmVtb3ZpbmcgYW55IHVudmlzaXRlZCBjaGlsZHJlbi5cbiAqL1xudmFyIGV4aXROb2RlID0gZnVuY3Rpb24gKCkge1xuICBjbGVhclVudmlzaXRlZERPTSgpO1xuXG4gIGN1cnJlbnROb2RlID0gY3VycmVudFBhcmVudDtcbiAgY3VycmVudFBhcmVudCA9IGN1cnJlbnRQYXJlbnQucGFyZW50Tm9kZTtcbn07XG5cbi8qKlxuICogTWFrZXMgc3VyZSB0aGF0IHRoZSBjdXJyZW50IG5vZGUgaXMgYW4gRWxlbWVudCB3aXRoIGEgbWF0Y2hpbmcgdGFnTmFtZSBhbmRcbiAqIGtleS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBlbGVtZW50J3MgdGFnLlxuICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5IFRoZSBrZXkgdXNlZCB0byBpZGVudGlmeSB0aGlzIGVsZW1lbnQuIFRoaXMgY2FuIGJlIGFuXG4gKiAgICAgZW1wdHkgc3RyaW5nLCBidXQgcGVyZm9ybWFuY2UgbWF5IGJlIGJldHRlciBpZiBhIHVuaXF1ZSB2YWx1ZSBpcyB1c2VkXG4gKiAgICAgd2hlbiBpdGVyYXRpbmcgb3ZlciBhbiBhcnJheSBvZiBpdGVtcy5cbiAqIEBwYXJhbSB7P0FycmF5PCo+PX0gc3RhdGljcyBBbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBvZiB0aGVcbiAqICAgICBzdGF0aWMgYXR0cmlidXRlcyBmb3IgdGhlIEVsZW1lbnQuIFRoZXNlIHdpbGwgb25seSBiZSBzZXQgb25jZSB3aGVuIHRoZVxuICogICAgIEVsZW1lbnQgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4geyFFbGVtZW50fSBUaGUgY29ycmVzcG9uZGluZyBFbGVtZW50LlxuICovXG52YXIgY29yZUVsZW1lbnRPcGVuID0gZnVuY3Rpb24gKHRhZywga2V5LCBzdGF0aWNzKSB7XG4gIG5leHROb2RlKCk7XG4gIGFsaWduV2l0aERPTSh0YWcsIGtleSwgc3RhdGljcyk7XG4gIGVudGVyTm9kZSgpO1xuICByZXR1cm4gKC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovY3VycmVudFBhcmVudFxuICApO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIGN1cnJlbnRseSBvcGVuIEVsZW1lbnQsIHJlbW92aW5nIGFueSB1bnZpc2l0ZWQgY2hpbGRyZW4gaWZcbiAqIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcmV0dXJuIHshRWxlbWVudH0gVGhlIGNvcnJlc3BvbmRpbmcgRWxlbWVudC5cbiAqL1xudmFyIGNvcmVFbGVtZW50Q2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgncHJvZHVjdGlvbicgIT09ICdwcm9kdWN0aW9uJykge31cblxuICBleGl0Tm9kZSgpO1xuICByZXR1cm4gKC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovY3VycmVudE5vZGVcbiAgKTtcbn07XG5cbi8qKlxuICogTWFrZXMgc3VyZSB0aGUgY3VycmVudCBub2RlIGlzIGEgVGV4dCBub2RlIGFuZCBjcmVhdGVzIGEgVGV4dCBub2RlIGlmIGl0IGlzXG4gKiBub3QuXG4gKlxuICogQHJldHVybiB7IVRleHR9IFRoZSBjb3JyZXNwb25kaW5nIFRleHQgTm9kZS5cbiAqL1xudmFyIGNvcmVUZXh0ID0gZnVuY3Rpb24gKCkge1xuICBuZXh0Tm9kZSgpO1xuICBhbGlnbldpdGhET00oJyN0ZXh0JywgbnVsbCwgbnVsbCk7XG4gIHJldHVybiAoLyoqIEB0eXBlIHshVGV4dH0gKi9jdXJyZW50Tm9kZVxuICApO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBjdXJyZW50IEVsZW1lbnQgYmVpbmcgcGF0Y2hlZC5cbiAqIEByZXR1cm4geyFFbGVtZW50fVxuICovXG52YXIgY3VycmVudEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgncHJvZHVjdGlvbicgIT09ICdwcm9kdWN0aW9uJykge31cbiAgcmV0dXJuICgvKiogQHR5cGUgeyFFbGVtZW50fSAqL2N1cnJlbnRQYXJlbnRcbiAgKTtcbn07XG5cbi8qKlxuICogU2tpcHMgdGhlIGNoaWxkcmVuIGluIGEgc3VidHJlZSwgYWxsb3dpbmcgYW4gRWxlbWVudCB0byBiZSBjbG9zZWQgd2l0aG91dFxuICogY2xlYXJpbmcgb3V0IHRoZSBjaGlsZHJlbi5cbiAqL1xudmFyIHNraXAgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgncHJvZHVjdGlvbicgIT09ICdwcm9kdWN0aW9uJykge31cbiAgY3VycmVudE5vZGUgPSBjdXJyZW50UGFyZW50Lmxhc3RDaGlsZDtcbn07XG5cbi8qKlxuICogVGhlIG9mZnNldCBpbiB0aGUgdmlydHVhbCBlbGVtZW50IGRlY2xhcmF0aW9uIHdoZXJlIHRoZSBhdHRyaWJ1dGVzIGFyZVxuICogc3BlY2lmaWVkLlxuICogQGNvbnN0XG4gKi9cbnZhciBBVFRSSUJVVEVTX09GRlNFVCA9IDM7XG5cbi8qKlxuICogQnVpbGRzIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBmb3IgdXNlIHdpdGggZWxlbWVudE9wZW5TdGFydCwgYXR0ciBhbmRcbiAqIGVsZW1lbnRPcGVuRW5kLlxuICogQGNvbnN0IHtBcnJheTwqPn1cbiAqL1xudmFyIGFyZ3NCdWlsZGVyID0gW107XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgZWxlbWVudCdzIHRhZy5cbiAqIEBwYXJhbSB7P3N0cmluZz19IGtleSBUaGUga2V5IHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBlbGVtZW50LiBUaGlzIGNhbiBiZSBhblxuICogICAgIGVtcHR5IHN0cmluZywgYnV0IHBlcmZvcm1hbmNlIG1heSBiZSBiZXR0ZXIgaWYgYSB1bmlxdWUgdmFsdWUgaXMgdXNlZFxuICogICAgIHdoZW4gaXRlcmF0aW5nIG92ZXIgYW4gYXJyYXkgb2YgaXRlbXMuXG4gKiBAcGFyYW0gez9BcnJheTwqPj19IHN0YXRpY3MgQW4gYXJyYXkgb2YgYXR0cmlidXRlIG5hbWUvdmFsdWUgcGFpcnMgb2YgdGhlXG4gKiAgICAgc3RhdGljIGF0dHJpYnV0ZXMgZm9yIHRoZSBFbGVtZW50LiBUaGVzZSB3aWxsIG9ubHkgYmUgc2V0IG9uY2Ugd2hlbiB0aGVcbiAqICAgICBFbGVtZW50IGlzIGNyZWF0ZWQuXG4gKiBAcGFyYW0gey4uLip9IGNvbnN0X2FyZ3MgQXR0cmlidXRlIG5hbWUvdmFsdWUgcGFpcnMgb2YgdGhlIGR5bmFtaWMgYXR0cmlidXRlc1xuICogICAgIGZvciB0aGUgRWxlbWVudC5cbiAqIEByZXR1cm4geyFFbGVtZW50fSBUaGUgY29ycmVzcG9uZGluZyBFbGVtZW50LlxuICovXG52YXIgZWxlbWVudE9wZW4gPSBmdW5jdGlvbiAodGFnLCBrZXksIHN0YXRpY3MsIGNvbnN0X2FyZ3MpIHtcbiAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gJ3Byb2R1Y3Rpb24nKSB7fVxuXG4gIHZhciBub2RlID0gY29yZUVsZW1lbnRPcGVuKHRhZywga2V5LCBzdGF0aWNzKTtcbiAgdmFyIGRhdGEgPSBnZXREYXRhKG5vZGUpO1xuXG4gIC8qXG4gICAqIENoZWNrcyB0byBzZWUgaWYgb25lIG9yIG1vcmUgYXR0cmlidXRlcyBoYXZlIGNoYW5nZWQgZm9yIGEgZ2l2ZW4gRWxlbWVudC5cbiAgICogV2hlbiBubyBhdHRyaWJ1dGVzIGhhdmUgY2hhbmdlZCwgdGhpcyBpcyBtdWNoIGZhc3RlciB0aGFuIGNoZWNraW5nIGVhY2hcbiAgICogaW5kaXZpZHVhbCBhcmd1bWVudC4gV2hlbiBhdHRyaWJ1dGVzIGhhdmUgY2hhbmdlZCwgdGhlIG92ZXJoZWFkIG9mIHRoaXMgaXNcbiAgICogbWluaW1hbC5cbiAgICovXG4gIHZhciBhdHRyc0FyciA9IGRhdGEuYXR0cnNBcnI7XG4gIHZhciBuZXdBdHRycyA9IGRhdGEubmV3QXR0cnM7XG4gIHZhciBhdHRyc0NoYW5nZWQgPSBmYWxzZTtcbiAgdmFyIGkgPSBBVFRSSUJVVEVTX09GRlNFVDtcbiAgdmFyIGogPSAwO1xuXG4gIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArPSAxLCBqICs9IDEpIHtcbiAgICBpZiAoYXR0cnNBcnJbal0gIT09IGFyZ3VtZW50c1tpXSkge1xuICAgICAgYXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArPSAxLCBqICs9IDEpIHtcbiAgICBhdHRyc0FycltqXSA9IGFyZ3VtZW50c1tpXTtcbiAgfVxuXG4gIGlmIChqIDwgYXR0cnNBcnIubGVuZ3RoKSB7XG4gICAgYXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICBhdHRyc0Fyci5sZW5ndGggPSBqO1xuICB9XG5cbiAgLypcbiAgICogQWN0dWFsbHkgcGVyZm9ybSB0aGUgYXR0cmlidXRlIHVwZGF0ZS5cbiAgICovXG4gIGlmIChhdHRyc0NoYW5nZWQpIHtcbiAgICBmb3IgKGkgPSBBVFRSSUJVVEVTX09GRlNFVDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgbmV3QXR0cnNbYXJndW1lbnRzW2ldXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2F0dHIgaW4gbmV3QXR0cnMpIHtcbiAgICAgIHVwZGF0ZUF0dHJpYnV0ZShub2RlLCBfYXR0ciwgbmV3QXR0cnNbX2F0dHJdKTtcbiAgICAgIG5ld0F0dHJzW19hdHRyXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07XG5cbi8qKlxuICogRGVjbGFyZXMgYSB2aXJ0dWFsIEVsZW1lbnQgYXQgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gdGhlIGRvY3VtZW50LiBUaGlzXG4gKiBjb3JyZXNwb25kcyB0byBhbiBvcGVuaW5nIHRhZyBhbmQgYSBlbGVtZW50Q2xvc2UgdGFnIGlzIHJlcXVpcmVkLiBUaGlzIGlzXG4gKiBsaWtlIGVsZW1lbnRPcGVuLCBidXQgdGhlIGF0dHJpYnV0ZXMgYXJlIGRlZmluZWQgdXNpbmcgdGhlIGF0dHIgZnVuY3Rpb25cbiAqIHJhdGhlciB0aGFuIGJlaW5nIHBhc3NlZCBhcyBhcmd1bWVudHMuIE11c3QgYmUgZm9sbGxvd2VkIGJ5IDAgb3IgbW9yZSBjYWxsc1xuICogdG8gYXR0ciwgdGhlbiBhIGNhbGwgdG8gZWxlbWVudE9wZW5FbmQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBlbGVtZW50J3MgdGFnLlxuICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5IFRoZSBrZXkgdXNlZCB0byBpZGVudGlmeSB0aGlzIGVsZW1lbnQuIFRoaXMgY2FuIGJlIGFuXG4gKiAgICAgZW1wdHkgc3RyaW5nLCBidXQgcGVyZm9ybWFuY2UgbWF5IGJlIGJldHRlciBpZiBhIHVuaXF1ZSB2YWx1ZSBpcyB1c2VkXG4gKiAgICAgd2hlbiBpdGVyYXRpbmcgb3ZlciBhbiBhcnJheSBvZiBpdGVtcy5cbiAqIEBwYXJhbSB7P0FycmF5PCo+PX0gc3RhdGljcyBBbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBvZiB0aGVcbiAqICAgICBzdGF0aWMgYXR0cmlidXRlcyBmb3IgdGhlIEVsZW1lbnQuIFRoZXNlIHdpbGwgb25seSBiZSBzZXQgb25jZSB3aGVuIHRoZVxuICogICAgIEVsZW1lbnQgaXMgY3JlYXRlZC5cbiAqL1xudmFyIGVsZW1lbnRPcGVuU3RhcnQgPSBmdW5jdGlvbiAodGFnLCBrZXksIHN0YXRpY3MpIHtcbiAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gJ3Byb2R1Y3Rpb24nKSB7fVxuXG4gIGFyZ3NCdWlsZGVyWzBdID0gdGFnO1xuICBhcmdzQnVpbGRlclsxXSA9IGtleTtcbiAgYXJnc0J1aWxkZXJbMl0gPSBzdGF0aWNzO1xufTtcblxuLyoqKlxuICogRGVmaW5lcyBhIHZpcnR1YWwgYXR0cmlidXRlIGF0IHRoaXMgcG9pbnQgb2YgdGhlIERPTS4gVGhpcyBpcyBvbmx5IHZhbGlkXG4gKiB3aGVuIGNhbGxlZCBiZXR3ZWVuIGVsZW1lbnRPcGVuU3RhcnQgYW5kIGVsZW1lbnRPcGVuRW5kLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cbnZhciBhdHRyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIGlmICgncHJvZHVjdGlvbicgIT09ICdwcm9kdWN0aW9uJykge31cblxuICBhcmdzQnVpbGRlci5wdXNoKG5hbWUsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIGFuIG9wZW4gdGFnIHN0YXJ0ZWQgd2l0aCBlbGVtZW50T3BlblN0YXJ0LlxuICogQHJldHVybiB7IUVsZW1lbnR9IFRoZSBjb3JyZXNwb25kaW5nIEVsZW1lbnQuXG4gKi9cbnZhciBlbGVtZW50T3BlbkVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gJ3Byb2R1Y3Rpb24nKSB7fVxuXG4gIHZhciBub2RlID0gZWxlbWVudE9wZW4uYXBwbHkobnVsbCwgYXJnc0J1aWxkZXIpO1xuICBhcmdzQnVpbGRlci5sZW5ndGggPSAwO1xuICByZXR1cm4gbm9kZTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIGFuIG9wZW4gdmlydHVhbCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGVsZW1lbnQncyB0YWcuXG4gKiBAcmV0dXJuIHshRWxlbWVudH0gVGhlIGNvcnJlc3BvbmRpbmcgRWxlbWVudC5cbiAqL1xudmFyIGVsZW1lbnRDbG9zZSA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gJ3Byb2R1Y3Rpb24nKSB7fVxuXG4gIHZhciBub2RlID0gY29yZUVsZW1lbnRDbG9zZSgpO1xuXG4gIGlmICgncHJvZHVjdGlvbicgIT09ICdwcm9kdWN0aW9uJykge31cblxuICByZXR1cm4gbm9kZTtcbn07XG5cbi8qKlxuICogRGVjbGFyZXMgYSB2aXJ0dWFsIEVsZW1lbnQgYXQgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gdGhlIGRvY3VtZW50IHRoYXQgaGFzXG4gKiBubyBjaGlsZHJlbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGVsZW1lbnQncyB0YWcuXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBrZXkgVGhlIGtleSB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZWxlbWVudC4gVGhpcyBjYW4gYmUgYW5cbiAqICAgICBlbXB0eSBzdHJpbmcsIGJ1dCBwZXJmb3JtYW5jZSBtYXkgYmUgYmV0dGVyIGlmIGEgdW5pcXVlIHZhbHVlIGlzIHVzZWRcbiAqICAgICB3aGVuIGl0ZXJhdGluZyBvdmVyIGFuIGFycmF5IG9mIGl0ZW1zLlxuICogQHBhcmFtIHs/QXJyYXk8Kj49fSBzdGF0aWNzIEFuIGFycmF5IG9mIGF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzIG9mIHRoZVxuICogICAgIHN0YXRpYyBhdHRyaWJ1dGVzIGZvciB0aGUgRWxlbWVudC4gVGhlc2Ugd2lsbCBvbmx5IGJlIHNldCBvbmNlIHdoZW4gdGhlXG4gKiAgICAgRWxlbWVudCBpcyBjcmVhdGVkLlxuICogQHBhcmFtIHsuLi4qfSBjb25zdF9hcmdzIEF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzIG9mIHRoZSBkeW5hbWljIGF0dHJpYnV0ZXNcbiAqICAgICBmb3IgdGhlIEVsZW1lbnQuXG4gKiBAcmV0dXJuIHshRWxlbWVudH0gVGhlIGNvcnJlc3BvbmRpbmcgRWxlbWVudC5cbiAqL1xudmFyIGVsZW1lbnRWb2lkID0gZnVuY3Rpb24gKHRhZywga2V5LCBzdGF0aWNzLCBjb25zdF9hcmdzKSB7XG4gIGVsZW1lbnRPcGVuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIHJldHVybiBlbGVtZW50Q2xvc2UodGFnKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZXMgYSB2aXJ0dWFsIEVsZW1lbnQgYXQgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gdGhlIGRvY3VtZW50IHRoYXQgaXMgYVxuICogcGxhY2Vob2xkZXIgZWxlbWVudC4gQ2hpbGRyZW4gb2YgdGhpcyBFbGVtZW50IGNhbiBiZSBtYW51YWxseSBtYW5hZ2VkIGFuZFxuICogd2lsbCBub3QgYmUgY2xlYXJlZCBieSB0aGUgbGlicmFyeS5cbiAqXG4gKiBBIGtleSBtdXN0IGJlIHNwZWNpZmllZCB0byBtYWtlIHN1cmUgdGhhdCB0aGlzIG5vZGUgaXMgY29ycmVjdGx5IHByZXNlcnZlZFxuICogYWNyb3NzIGFsbCBjb25kaXRpb25hbHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgZWxlbWVudCdzIHRhZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZWxlbWVudC5cbiAqIEBwYXJhbSB7P0FycmF5PCo+PX0gc3RhdGljcyBBbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBvZiB0aGVcbiAqICAgICBzdGF0aWMgYXR0cmlidXRlcyBmb3IgdGhlIEVsZW1lbnQuIFRoZXNlIHdpbGwgb25seSBiZSBzZXQgb25jZSB3aGVuIHRoZVxuICogICAgIEVsZW1lbnQgaXMgY3JlYXRlZC5cbiAqIEBwYXJhbSB7Li4uKn0gY29uc3RfYXJncyBBdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBvZiB0aGUgZHluYW1pYyBhdHRyaWJ1dGVzXG4gKiAgICAgZm9yIHRoZSBFbGVtZW50LlxuICogQHJldHVybiB7IUVsZW1lbnR9IFRoZSBjb3JyZXNwb25kaW5nIEVsZW1lbnQuXG4gKi9cbnZhciBlbGVtZW50UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAodGFnLCBrZXksIHN0YXRpY3MsIGNvbnN0X2FyZ3MpIHtcbiAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gJ3Byb2R1Y3Rpb24nKSB7fVxuXG4gIGVsZW1lbnRPcGVuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIHNraXAoKTtcbiAgcmV0dXJuIGVsZW1lbnRDbG9zZSh0YWcpO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlcyBhIHZpcnR1YWwgVGV4dCBhdCB0aGlzIHBvaW50IGluIHRoZSBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8Ym9vbGVhbn0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBUZXh0LlxuICogQHBhcmFtIHsuLi4oZnVuY3Rpb24oKHN0cmluZ3xudW1iZXJ8Ym9vbGVhbikpOnN0cmluZyl9IGNvbnN0X2FyZ3NcbiAqICAgICBGdW5jdGlvbnMgdG8gZm9ybWF0IHRoZSB2YWx1ZSB3aGljaCBhcmUgY2FsbGVkIG9ubHkgd2hlbiB0aGUgdmFsdWUgaGFzXG4gKiAgICAgY2hhbmdlZC5cbiAqIEByZXR1cm4geyFUZXh0fSBUaGUgY29ycmVzcG9uZGluZyB0ZXh0IG5vZGUuXG4gKi9cbnZhciB0ZXh0ID0gZnVuY3Rpb24gKHZhbHVlLCBjb25zdF9hcmdzKSB7XG4gIGlmICgncHJvZHVjdGlvbicgIT09ICdwcm9kdWN0aW9uJykge31cblxuICB2YXIgbm9kZSA9IGNvcmVUZXh0KCk7XG4gIHZhciBkYXRhID0gZ2V0RGF0YShub2RlKTtcblxuICBpZiAoZGF0YS50ZXh0ICE9PSB2YWx1ZSkge1xuICAgIGRhdGEudGV4dCA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqL3ZhbHVlO1xuXG4gICAgdmFyIGZvcm1hdHRlZCA9IHZhbHVlO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAvKlxuICAgICAgICogQ2FsbCB0aGUgZm9ybWF0dGVyIGZ1bmN0aW9uIGRpcmVjdGx5IHRvIHByZXZlbnQgbGVha2luZyBhcmd1bWVudHMuXG4gICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2luY3JlbWVudGFsLWRvbS9wdWxsLzIwNCNpc3N1ZWNvbW1lbnQtMTc4MjIzNTc0XG4gICAgICAgKi9cbiAgICAgIHZhciBmbiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvcm1hdHRlZCA9IGZuKGZvcm1hdHRlZCk7XG4gICAgfVxuXG4gICAgbm9kZS5kYXRhID0gZm9ybWF0dGVkO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5leHBvcnRzLnBhdGNoID0gcGF0Y2hJbm5lcjtcbmV4cG9ydHMucGF0Y2hJbm5lciA9IHBhdGNoSW5uZXI7XG5leHBvcnRzLnBhdGNoT3V0ZXIgPSBwYXRjaE91dGVyO1xuZXhwb3J0cy5jdXJyZW50RWxlbWVudCA9IGN1cnJlbnRFbGVtZW50O1xuZXhwb3J0cy5za2lwID0gc2tpcDtcbmV4cG9ydHMuZWxlbWVudFZvaWQgPSBlbGVtZW50Vm9pZDtcbmV4cG9ydHMuZWxlbWVudE9wZW5TdGFydCA9IGVsZW1lbnRPcGVuU3RhcnQ7XG5leHBvcnRzLmVsZW1lbnRPcGVuRW5kID0gZWxlbWVudE9wZW5FbmQ7XG5leHBvcnRzLmVsZW1lbnRPcGVuID0gZWxlbWVudE9wZW47XG5leHBvcnRzLmVsZW1lbnRDbG9zZSA9IGVsZW1lbnRDbG9zZTtcbmV4cG9ydHMuZWxlbWVudFBsYWNlaG9sZGVyID0gZWxlbWVudFBsYWNlaG9sZGVyO1xuZXhwb3J0cy50ZXh0ID0gdGV4dDtcbmV4cG9ydHMuYXR0ciA9IGF0dHI7XG5leHBvcnRzLnN5bWJvbHMgPSBzeW1ib2xzO1xuZXhwb3J0cy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbmV4cG9ydHMuYXBwbHlBdHRyID0gYXBwbHlBdHRyO1xuZXhwb3J0cy5hcHBseVByb3AgPSBhcHBseVByb3A7XG5leHBvcnRzLm5vdGlmaWNhdGlvbnMgPSBub3RpZmljYXRpb25zO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmNyZW1lbnRhbC1kb20tY2pzLmpzLm1hcCIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImluY3JlbWVudGFsLWRvbVwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJpbmNyZW1lbnRhbC1kb21cIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wic2thdGVcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJpbmNyZW1lbnRhbC1kb21cIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInNrYXRlXCJdID0gZmFjdG9yeShyb290W1wiSW5jcmVtZW50YWxET01cIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xNF9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG5cblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG5cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcblxuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDM4KTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwialwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbm5lY3RlZDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNyZWF0ZWQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBuYW1lOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY3RvckNyZWF0ZUluaXRQcm9wczsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGN0b3JPYnNlcnZlZEF0dHJpYnV0ZXM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjdG9yUHJvcHM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjdG9yUHJvcHNNYXA7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm1cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBwcm9wczsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJlZjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJlbmRlcmVyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJrXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVuZGVyaW5nOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVuZGVyZXJEZWJvdW5jZWQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB1cGRhdGVkOyB9KTtcbnZhciBjb25uZWN0ZWQgPSAnX19fX3NrYXRlX2Nvbm5lY3RlZCc7XG52YXIgY3JlYXRlZCA9ICdfX19fc2thdGVfY3JlYXRlZCc7XG5cbi8vIERFUFJFQ0FURURcbi8vXG4vLyBUaGlzIGlzIHRoZSBvbmx5IFwic3ltYm9sXCIgdGhhdCBtdXN0IHN0YXkgYSBzdHJpbmcuIFRoaXMgaXMgYmVjYXVzZSBpdCBpc1xuLy8gcmVsaWVkIHVwb24gYWNyb3NzIHNldmVyYWwgdmVyc2lvbnMuIFdlIHNob3VsZCByZW1vdmUgaXQsIGJ1dCBlbnN1cmUgdGhhdFxuLy8gaXQncyBjb25zaWRlcmVkIGEgYnJlYWtpbmcgY2hhbmdlIHRoYXQgd2hhdGV2ZXIgdmVyc2lvbiByZW1vdmVzIGl0IGNhbm5vdFxuLy8gYmUgcGFzc2VkIHRvIHZkb20gZnVuY3Rpb25zIGFzIHRhZyBuYW1lcy5cbnZhciBuYW1lID0gJ19fX19za2F0ZV9uYW1lJztcblxuLy8gVXNlZCBvbiB0aGUgQ29uc3RydWN0b3JcbnZhciBjdG9yQ3JlYXRlSW5pdFByb3BzID0gJ19fX19za2F0ZV9jdG9yX2NyZWF0ZUluaXRQcm9wcyc7XG52YXIgY3Rvck9ic2VydmVkQXR0cmlidXRlcyA9ICdfX19fc2thdGVfY3Rvcl9vYnNlcnZlZEF0dHJpYnV0ZXMnO1xudmFyIGN0b3JQcm9wcyA9ICdfX19fc2thdGVfY3Rvcl9wcm9wcyc7XG52YXIgY3RvclByb3BzTWFwID0gJ19fX19za2F0ZV9jdG9yX3Byb3BzTWFwJztcblxuLy8gVXNlZCBvbiB0aGUgRWxlbWVudFxudmFyIHByb3BzID0gJ19fX19za2F0ZV9wcm9wcyc7XG52YXIgcmVmID0gJ19fX19za2F0ZV9yZWYnO1xudmFyIHJlbmRlcmVyID0gJ19fX19za2F0ZV9yZW5kZXJlcic7XG52YXIgcmVuZGVyaW5nID0gJ19fX19za2F0ZV9yZW5kZXJpbmcnO1xudmFyIHJlbmRlcmVyRGVib3VuY2VkID0gJ19fX19za2F0ZV9yZW5kZXJlckRlYm91bmNlZCc7XG52YXIgdXBkYXRlZCA9ICdfX19fc2thdGVfdXBkYXRlZCc7XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2lzX3R5cGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGV4cG9ydCAoaW1tdXRhYmxlKSAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IGdldFByb3BOYW1lc0FuZFN5bWJvbHM7XG5cbi8qKlxuICogUmV0dXJucyBhcnJheSBvZiBvd25lZCBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBmb3IgdGhlIGdpdmVuIG9iamVjdFxuICovXG5mdW5jdGlvbiBnZXRQcm9wTmFtZXNBbmRTeW1ib2xzKCkge1xuICB2YXIgb2JqID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICB2YXIgbGlzdE9mS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaik7XG4gIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19pc190eXBlX19bXCJhXCIgLyogaXNGdW5jdGlvbiAqL10pKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpID8gbGlzdE9mS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopKSA6IGxpc3RPZktleXM7XG59XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNGdW5jdGlvbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzT2JqZWN0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNTdHJpbmc7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc1N5bWJvbDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzVW5kZWZpbmVkOyB9KTtcbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcbn07XG52YXIgaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpKSA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsO1xufTtcbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59O1xudmFyIGlzU3ltYm9sID0gZnVuY3Rpb24gaXNTeW1ib2wodmFsKSB7XG4gIHJldHVybiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgPT09ICdzeW1ib2wnO1xufTtcbnZhciBpc1VuZGVmaW5lZCA9IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG59O1xuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93O1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18oMzcpKSlcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fZ2V0X3Byb3BfbmFtZXNfYW5kX3N5bWJvbHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cblxuLy8gV2UgYXJlIG5vdCB1c2luZyBPYmplY3QuYXNzaWduIGlmIGl0IGlzIGRlZmluZWQgc2luY2UgaXQgd2lsbCBjYXVzZSBwcm9ibGVtcyB3aGVuIFN5bWJvbCBpcyBwb2x5ZmlsbGVkLlxuLy8gQXBwYXJlbnRseSBPYmplY3QuYXNzaWduIChvciBhbnkgcG9seWZpbGwgZm9yIHRoaXMgbWV0aG9kKSBkb2VzIG5vdCBjb3B5IG5vbi1uYXRpdmUgU3ltYm9scy5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSBmdW5jdGlvbiAob2JqKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcbiAgICByZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fZ2V0X3Byb3BfbmFtZXNfYW5kX3N5bWJvbHNfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoYXJnKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lT3JTeW1ib2wpIHtcbiAgICAgIHJldHVybiBvYmpbbmFtZU9yU3ltYm9sXSA9IGFyZ1tuYW1lT3JTeW1ib2xdO1xuICAgIH0pO1xuICB9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXR1cm4tYXNzaWduXG4gIHJldHVybiBvYmo7XG59O1xuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdmFyIG5hbWVzcGFjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG5cbiAgdmFyIGRhdGEgPSBlbGVtZW50Ll9fU0tBVEVfREFUQSB8fCAoZWxlbWVudC5fX1NLQVRFX0RBVEEgPSB7fSk7XG4gIHJldHVybiBuYW1lc3BhY2UgJiYgKGRhdGFbbmFtZXNwYWNlXSB8fCAoZGF0YVtuYW1lc3BhY2VdID0ge30pKSB8fCBkYXRhOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW1peGVkLW9wZXJhdG9yc1xufTtcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnIHx8IHZhbCA9PT0gbnVsbDtcbn07XG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3V0aWxfc3ltYm9sc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3V0aWxfYXNzaWduX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fdXRpbF9nZXRfcHJvcF9uYW1lc19hbmRfc3ltYm9sc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX3V0aWxfZ2V0X3Byb3BzX21hcF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X191dGlsX2lzX3R5cGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cblxuXG5cblxuXG5mdW5jdGlvbiBnZXQoZWxlbSkge1xuICB2YXIgcHJvcHMgPSB7fTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX191dGlsX2dldF9wcm9wX25hbWVzX2FuZF9zeW1ib2xzX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX3V0aWxfZ2V0X3Byb3BzX21hcF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShlbGVtLmNvbnN0cnVjdG9yKSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZU9yU3ltYm9sKSB7XG4gICAgcHJvcHNbbmFtZU9yU3ltYm9sXSA9IGVsZW1bbmFtZU9yU3ltYm9sXTtcbiAgfSk7XG5cbiAgcmV0dXJuIHByb3BzO1xufVxuXG5mdW5jdGlvbiBzZXQoZWxlbSwgbmV3UHJvcHMpIHtcbiAgX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fdXRpbF9hc3NpZ25fX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoZWxlbSwgbmV3UHJvcHMpO1xuICBpZiAoZWxlbVtfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3V0aWxfc3ltYm9sc19fW1wiZFwiIC8qIHJlbmRlcmVyICovXV0pIHtcbiAgICBlbGVtW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fdXRpbF9zeW1ib2xzX19bXCJkXCIgLyogcmVuZGVyZXIgKi9dXSgpO1xuICB9XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSBmdW5jdGlvbiAoZWxlbSwgbmV3UHJvcHMpIHtcbiAgcmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX3V0aWxfaXNfdHlwZV9fW1wiYlwiIC8qIGlzVW5kZWZpbmVkICovXSkobmV3UHJvcHMpID8gZ2V0KGVsZW0pIDogc2V0KGVsZW0sIG5ld1Byb3BzKTtcbn07XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7LyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9pbmNyZW1lbnRhbF9kb21fXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9pbmNyZW1lbnRhbF9kb21fX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9pbmNyZW1lbnRhbF9kb21fXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX191dGlsX3N5bWJvbHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX191dGlsX2Fzc2lnbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX3V0aWxfY3JlYXRlX3N5bWJvbF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X191dGlsX2RhdGFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X191dGlsX2RlYm91bmNlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX3V0aWxfYXR0cmlidXRlc19tYW5hZ2VyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fdXRpbF9nZXRfb3duX3Byb3BlcnR5X2Rlc2NyaXB0b3JzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX3V0aWxfZ2V0X3Byb3BfbmFtZXNfYW5kX3N5bWJvbHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X191dGlsX2dldF9wcm9wc19tYXBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX3Byb3BzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX2xpZmVjeWNsZV9wcm9wc19pbml0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX191dGlsX2lzX3R5cGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fcG9seWZpbGxzX29iamVjdF9pc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fdXRpbF9zZXRfY3Rvcl9uYXRpdmVfcHJvcGVydHlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfX3V0aWxfcm9vdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIEhUTUxFbGVtZW50ID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNV9fdXRpbF9yb290X19bXCJhXCIgLyogZGVmYXVsdCAqL10uSFRNTEVsZW1lbnQgfHwgZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBfY2xhc3MoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9jbGFzcyk7XG4gIH1cblxuICByZXR1cm4gX2NsYXNzO1xufSgpO1xudmFyIF9wcmV2TmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX3V0aWxfY3JlYXRlX3N5bWJvbF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSgncHJldk5hbWUnKTtcbnZhciBfcHJldk9sZFZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fdXRpbF9jcmVhdGVfc3ltYm9sX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKCdwcmV2T2xkVmFsdWUnKTtcbnZhciBfcHJldk5ld1ZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fdXRpbF9jcmVhdGVfc3ltYm9sX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKCdwcmV2TmV3VmFsdWUnKTtcblxuLy8gVEVNUE9SQVJZOiBPbmNlIGRlcHJlY2F0aW9ucyBpbiB0aGlzIGZpbGUgYXJlIHJlbW92ZWQsIHRoaXMgY2FuIGJlIHJlbW92ZWQuXG5mdW5jdGlvbiBkZXByZWNhdGVkKGVsZW0sIG9sZFVzYWdlLCBuZXdVc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBvd25lck5hbWUgPSBlbGVtLmxvY2FsTmFtZSA/IGVsZW0ubG9jYWxOYW1lIDogU3RyaW5nKGVsZW0pO1xuICAgIGNvbnNvbGUud2Fybihvd25lck5hbWUgKyAnICcgKyBvbGRVc2FnZSArICcgaXMgZGVwcmVjYXRlZC4gVXNlICcgKyBuZXdVc2FnZSArICcuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJldmVudERvdWJsZUNhbGxpbmcoZWxlbSwgbmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gIHJldHVybiBuYW1lID09PSBlbGVtW19wcmV2TmFtZV0gJiYgb2xkVmFsdWUgPT09IGVsZW1bX3ByZXZPbGRWYWx1ZV0gJiYgbmV3VmFsdWUgPT09IGVsZW1bX3ByZXZOZXdWYWx1ZV07XG59XG5cbi8vIFRPRE8gcmVtb3ZlIHdoZW4gbm90IGNhdGVyaW5nIHRvIFNhZmFyaSA8IDEwLlxuZnVuY3Rpb24gY3JlYXRlTmF0aXZlUHJvcGVydHlEZXNjcmlwdG9ycyhDdG9yKSB7XG4gIHZhciBwcm9wRGVmcyA9IF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX3V0aWxfZ2V0X3Byb3BzX21hcF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShDdG9yKTtcbiAgcmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX3V0aWxfZ2V0X3Byb3BfbmFtZXNfYW5kX3N5bWJvbHNfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkocHJvcERlZnMpLnJlZHVjZShmdW5jdGlvbiAocHJvcERlc2NyaXB0b3JzLCBuYW1lT3JTeW1ib2wpIHtcbiAgICBwcm9wRGVzY3JpcHRvcnNbbmFtZU9yU3ltYm9sXSA9IF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19saWZlY3ljbGVfcHJvcHNfaW5pdF9fW1wiYVwiIC8qIGNyZWF0ZU5hdGl2ZVByb3BlcnR5RGVzY3JpcHRvciAqL10pKHByb3BEZWZzW25hbWVPclN5bWJvbF0pO1xuICAgIHJldHVybiBwcm9wRGVzY3JpcHRvcnM7XG4gIH0sIHt9KTtcbn1cblxuLy8gVE9ETyByZWZhY3RvciB3aGVuIG5vdCBjYXRlcmluZyB0byBTYWZhcmkgPCAxMC5cbi8vXG4vLyBXZSBzaG91bGQgYmUgYWJsZSB0byBzaW1wbGlmeSB0aGlzIHdoZXJlIGFsbCB3ZSBkbyBpcyBPYmplY3QuZGVmaW5lUHJvcGVydHkoKS5cbmZ1bmN0aW9uIGNyZWF0ZUluaXRQcm9wcyhDdG9yKSB7XG4gIHZhciBwcm9wRGVzY3JpcHRvcnMgPSBjcmVhdGVOYXRpdmVQcm9wZXJ0eURlc2NyaXB0b3JzKEN0b3IpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xuICAgIF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX3V0aWxfZ2V0X3Byb3BfbmFtZXNfYW5kX3N5bWJvbHNfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkocHJvcERlc2NyaXB0b3JzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lT3JTeW1ib2wpIHtcbiAgICAgIHZhciBwcm9wRGVzY3JpcHRvciA9IHByb3BEZXNjcmlwdG9yc1tuYW1lT3JTeW1ib2xdO1xuICAgICAgcHJvcERlc2NyaXB0b3IuYmVmb3JlRGVmaW5lUHJvcGVydHkoZWxlbSk7XG5cbiAgICAgIC8vIFdlIGNoZWNrIGhlcmUgYmVmb3JlIGRlZmluaW5nIHRvIHNlZSBpZiB0aGUgcHJvcCB3YXMgc3BlY2lmaWVkIHByaW9yXG4gICAgICAvLyB0byB1cGdyYWRpbmcuXG4gICAgICB2YXIgaGFzUHJvcEJlZm9yZVVwZ3JhZGluZyA9IG5hbWVPclN5bWJvbCBpbiBlbGVtO1xuXG4gICAgICAvLyBUaGlzIGlzIHNhdmVkIHByaW9yIHRvIGRlZmluaW5nIHNvIHRoYXQgd2UgY2FuIHNldCBpdCBhZnRlciBpdCBpdCB3YXNcbiAgICAgIC8vIGRlZmluZWQgcHJpb3IgdG8gdXBncmFkaW5nLiBXZSBkb24ndCB3YW50IHRvIGludm9rZSB0aGUgZ2V0dGVyIGlmIHdlXG4gICAgICAvLyBkb24ndCBuZWVkIHRvLCBzbyB3ZSBvbmx5IGdldCB0aGUgdmFsdWUgaWYgd2UgbmVlZCB0byByZS1zeW5jLlxuICAgICAgdmFyIHZhbHVlQmVmb3JlVXBncmFkaW5nID0gaGFzUHJvcEJlZm9yZVVwZ3JhZGluZyAmJiBlbGVtW25hbWVPclN5bWJvbF07XG5cbiAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD00OTczOVxuICAgICAgLy9cbiAgICAgIC8vIFdoZW4gV2Via2l0IGZpeGVzIHRoYXQgYnVnIHNvIHRoYXQgbmF0aXZlIHByb3BlcnR5IGFjY2Vzc29ycyBjYW4gYmVcbiAgICAgIC8vIHJldHJpZXZlZCwgd2UgY2FuIG1vdmUgZGVmaW5pbmcgdGhlIHByb3BlcnR5IHRvIHRoZSBwcm90b3R5cGUgYW5kIGF3YXlcbiAgICAgIC8vIGZyb20gaGF2aW5nIHRvIGRvIGlmIGZvciBldmVyeSBpbnN0YW5jZSBhcyBhbGwgb3RoZXIgYnJvd3NlcnMgc3VwcG9ydFxuICAgICAgLy8gdGhpcy5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtLCBuYW1lT3JTeW1ib2wsIHByb3BEZXNjcmlwdG9yKTtcblxuICAgICAgLy8gREVQUkVDQVRFRFxuICAgICAgLy9cbiAgICAgIC8vIFdlJ2xsIGJlIHJlbW92aW5nIGdldCAvIHNldCBjYWxsYmFja3Mgb24gcHJvcGVydGllcy4gVXNlIHRoZVxuICAgICAgLy8gdXBkYXRlZENhbGxiYWNrKCkgaW5zdGVhZC5cbiAgICAgIC8vXG4gICAgICAvLyBXZSByZS1zZXQgdGhlIHByb3AgaWYgaXQgd2FzIHNwZWNpZmllZCBwcmlvciB0byB1cGdyYWRpbmcgYmVjYXVzZSB3ZVxuICAgICAgLy8gbmVlZCB0byBlbnN1cmUgc2V0KCkgaXMgdHJpZ2dlcmVkIGJvdGggaW4gcG9seWZpbGxlZCBlbnZpcm9ubWVudHMgYW5kXG4gICAgICAvLyBpbiBuYXRpdmUgd2hlcmUgdGhlIGRlZmluaXRpb24gbWF5IGJlIHJlZ2lzdGVyZCBhZnRlciBlbGVtZW50cyBpdFxuICAgICAgLy8gcmVwcmVzZW50cyBoYXZlIGFscmVhZHkgYmVlbiBjcmVhdGVkLlxuICAgICAgaWYgKGhhc1Byb3BCZWZvcmVVcGdyYWRpbmcpIHtcbiAgICAgICAgZWxlbVtuYW1lT3JTeW1ib2xdID0gdmFsdWVCZWZvcmVVcGdyYWRpbmc7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59XG5cbnZhciBfY2xhc3MyID0gZnVuY3Rpb24gKF9IVE1MRWxlbWVudCkge1xuICBfaW5oZXJpdHMoX2NsYXNzMiwgX0hUTUxFbGVtZW50KTtcblxuICBfY3JlYXRlQ2xhc3MoX2NsYXNzMiwgbnVsbCwgW3tcbiAgICBrZXk6ICdvYnNlcnZlZEF0dHJpYnV0ZXMnLFxuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHVuaXF1ZSBhdHRyaWJ1dGUgbmFtZXMgY29uZmlndXJlZCB3aXRoIHByb3BzIGFuZFxuICAgICAqIHRob3NlIHNldCBvbiB0aGUgQ29tcG9uZW50IGNvbnN0cnVjdG9yIGlmIGFueVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGF0dHJzT25DdG9yID0gdGhpcy5oYXNPd25Qcm9wZXJ0eShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3V0aWxfc3ltYm9sc19fW1wiZlwiIC8qIGN0b3JPYnNlcnZlZEF0dHJpYnV0ZXMgKi9dKSA/IHRoaXNbX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX191dGlsX3N5bWJvbHNfX1tcImZcIiAvKiBjdG9yT2JzZXJ2ZWRBdHRyaWJ1dGVzICovXV0gOiBbXTtcbiAgICAgIHZhciBwcm9wRGVmcyA9IF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX3V0aWxfZ2V0X3Byb3BzX21hcF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSh0aGlzKTtcblxuICAgICAgLy8gVXNlIE9iamVjdC5rZXlzIHRvIHNraXBzIHN5bWJvbCBwcm9wcyBzaW5jZSB0aGV5IGhhdmUgbm8gbGlua2VkIGF0dHJpYnV0ZXNcbiAgICAgIHZhciBhdHRyc0Zyb21MaW5rZWRQcm9wcyA9IE9iamVjdC5rZXlzKHByb3BEZWZzKS5tYXAoZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgIHJldHVybiBwcm9wRGVmc1twcm9wTmFtZV0uYXR0clNvdXJjZTtcbiAgICAgIH0pLmZpbHRlcihCb29sZWFuKTtcblxuICAgICAgdmFyIGFsbCA9IGF0dHJzRnJvbUxpbmtlZFByb3BzLmNvbmNhdChhdHRyc09uQ3RvcikuY29uY2F0KF9nZXQoX2NsYXNzMi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKF9jbGFzczIpLCAnb2JzZXJ2ZWRBdHRyaWJ1dGVzJywgdGhpcykpO1xuICAgICAgcmV0dXJuIGFsbC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBhbGwuaW5kZXhPZihpdGVtKSA9PT0gaW5kZXg7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXTtcbiAgICAgIF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE0X191dGlsX3NldF9jdG9yX25hdGl2ZV9wcm9wZXJ0eV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSh0aGlzLCAnb2JzZXJ2ZWRBdHRyaWJ1dGVzJywgdmFsdWUpO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgc3VwZXJjbGFzcyBwcm9wcyBvdmVyd3JpdHRlbiB3aXRoIHRoaXMgQ29tcG9uZW50IHByb3BzXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb3BzJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX191dGlsX2Fzc2lnbl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSh7fSwgX2dldChfY2xhc3MyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoX2NsYXNzMiksICdwcm9wcycsIHRoaXMpLCB0aGlzW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fdXRpbF9zeW1ib2xzX19bXCJnXCIgLyogY3RvclByb3BzICovXV0pO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE0X191dGlsX3NldF9jdG9yX25hdGl2ZV9wcm9wZXJ0eV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSh0aGlzLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3V0aWxfc3ltYm9sc19fW1wiZ1wiIC8qIGN0b3JQcm9wcyAqL10sIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBQYXNzaW5nIGFyZ3MgaXMgZGVzaWduZWQgdG8gd29yayB3aXRoIGRvY3VtZW50LXJlZ2lzdGVyLWVsZW1lbnQuIEl0J3Mgbm90XG4gICAgLy8gbmVjZXNzYXJ5IGZvciB0aGUgd2ViY29tcG9uZW50cy9jdXN0b20tZWxlbWVudCBwb2x5ZmlsbC5cblxuICB9XSk7XG5cbiAgZnVuY3Rpb24gX2NsYXNzMigpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfY2xhc3MyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gX2NsYXNzMi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKF9jbGFzczIpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKTtcblxuICAgIHZhciBjb25zdHJ1Y3RvciA9IF90aGlzLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gVXNlZCBmb3IgdGhlIHJlYWR5KCkgZnVuY3Rpb24gc28gaXQga25vd3Mgd2hlbiBpdCBjYW4gY2FsbCBpdHMgY2FsbGJhY2suXG5cbiAgICBfdGhpc1tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3V0aWxfc3ltYm9sc19fW1wiY1wiIC8qIGNyZWF0ZWQgKi9dXSA9IHRydWU7XG5cbiAgICAvLyBUT0RPIHJlZmFjdG9yIHRvIG5vdCBjYXRlciB0byBTYWZhcmkgPCAxMC4gVGhpcyBtZWFucyB3ZSBjYW4gZGVwZW5kIG9uXG4gICAgLy8gYnVpbHQtaW4gcHJvcGVydHkgZGVzY3JpcHRvcnMuXG4gICAgLy8gTXVzdCBiZSBkZWZpbmVkIG9uIGNvbnN0cnVjdG9yIGFuZCBub3QgZnJvbSBhIHN1cGVyY2xhc3NcbiAgICBpZiAoIWNvbnN0cnVjdG9yLmhhc093blByb3BlcnR5KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fdXRpbF9zeW1ib2xzX19bXCJoXCIgLyogY3RvckNyZWF0ZUluaXRQcm9wcyAqL10pKSB7XG4gICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fdXRpbF9zZXRfY3Rvcl9uYXRpdmVfcHJvcGVydHlfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoY29uc3RydWN0b3IsIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fdXRpbF9zeW1ib2xzX19bXCJoXCIgLyogY3RvckNyZWF0ZUluaXRQcm9wcyAqL10sIGNyZWF0ZUluaXRQcm9wcyhjb25zdHJ1Y3RvcikpO1xuICAgIH1cblxuICAgIC8vIFNldCB1cCBhIHJlbmRlcmVyIHRoYXQgaXMgZGVib3VuY2VkIGZvciBwcm9wZXJ0eSBzZXRzIHRvIGNhbGwgZGlyZWN0bHkuXG4gICAgX3RoaXNbX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX191dGlsX3N5bWJvbHNfX1tcImlcIiAvKiByZW5kZXJlckRlYm91bmNlZCAqL11dID0gX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fdXRpbF9kZWJvdW5jZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShfdGhpc1tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3V0aWxfc3ltYm9sc19fW1wiZFwiIC8qIHJlbmRlcmVyICovXV0uYmluZChfdGhpcykpO1xuXG4gICAgLy8gU2V0IHVwIHByb3BlcnR5IGxpZmVjeWNsZS5cbiAgICB2YXIgcHJvcERlZnNDb3VudCA9IF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX3V0aWxfZ2V0X3Byb3BfbmFtZXNfYW5kX3N5bWJvbHNfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fdXRpbF9nZXRfcHJvcHNfbWFwX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKGNvbnN0cnVjdG9yKSkubGVuZ3RoO1xuICAgIGlmIChwcm9wRGVmc0NvdW50ICYmIGNvbnN0cnVjdG9yW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fdXRpbF9zeW1ib2xzX19bXCJoXCIgLyogY3RvckNyZWF0ZUluaXRQcm9wcyAqL11dKSB7XG4gICAgICBjb25zdHJ1Y3RvcltfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3V0aWxfc3ltYm9sc19fW1wiaFwiIC8qIGN0b3JDcmVhdGVJbml0UHJvcHMgKi9dXShfdGhpcyk7XG4gICAgfVxuXG4gICAgLy8gREVQUkVDQVRFRFxuICAgIC8vXG4gICAgLy8gc3RhdGljIHJlbmRlcigpXG4gICAgLy8gTm90ZSB0aGF0IHJlbmRlckNhbGxiYWNrIGlzIGFuIG9wdGlvbmFsIG1ldGhvZCFcbiAgICBpZiAoIV90aGlzLnJlbmRlckNhbGxiYWNrICYmIGNvbnN0cnVjdG9yLnJlbmRlcikge1xuICAgICAgZGVwcmVjYXRlZChfdGhpcywgJ3N0YXRpYyByZW5kZXInLCAncmVuZGVyQ2FsbGJhY2snKTtcbiAgICAgIF90aGlzLnJlbmRlckNhbGxiYWNrID0gY29uc3RydWN0b3IucmVuZGVyLmJpbmQoY29uc3RydWN0b3IsIF90aGlzKTtcbiAgICB9XG5cbiAgICAvLyBERVBSRUNBVEVEXG4gICAgLy9cbiAgICAvLyBzdGF0aWMgY3JlYXRlZCgpXG4gICAgLy9cbiAgICAvLyBQcm9wcyBzaG91bGQgYmUgc2V0IHVwIGJlZm9yZSBjYWxsaW5nIHRoaXMuXG4gICAgdmFyIGNyZWF0ZWQgPSBjb25zdHJ1Y3Rvci5jcmVhdGVkO1xuXG4gICAgaWYgKF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX191dGlsX2lzX3R5cGVfX1tcImFcIiAvKiBpc0Z1bmN0aW9uICovXSkoY3JlYXRlZCkpIHtcbiAgICAgIGRlcHJlY2F0ZWQoX3RoaXMsICdzdGF0aWMgY3JlYXRlZCcsICdjb25zdHJ1Y3RvcicpO1xuICAgICAgY3JlYXRlZChfdGhpcyk7XG4gICAgfVxuXG4gICAgLy8gREVQUkVDQVRFRFxuICAgIC8vXG4gICAgLy8gRmVhdHVyZSBoYXMgcmFyZWx5IGJlZW4gdXNlZC5cbiAgICAvL1xuICAgIC8vIENyZWF0ZWQgc2hvdWxkIGJlIHNldCBiZWZvcmUgaW52b2tpbmcgdGhlIHJlYWR5IGxpc3RlbmVycy5cbiAgICB2YXIgZWxlbURhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X191dGlsX2RhdGFfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoX3RoaXMpO1xuICAgIHZhciByZWFkeUNhbGxiYWNrcyA9IGVsZW1EYXRhLnJlYWR5Q2FsbGJhY2tzO1xuICAgIGlmIChyZWFkeUNhbGxiYWNrcykge1xuICAgICAgcmVhZHlDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgcmV0dXJuIGNiKF90aGlzKTtcbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIGVsZW1EYXRhLnJlYWR5Q2FsbGJhY2tzO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvLyBDdXN0b20gRWxlbWVudHMgdjFcblxuXG4gIF9jcmVhdGVDbGFzcyhfY2xhc3MyLCBbe1xuICAgIGtleTogJ2Nvbm5lY3RlZENhbGxiYWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAvLyBSZWZsZWN0IGF0dHJpYnV0ZXMgcGVuZGluZyB2YWx1ZXNcbiAgICAgIF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX3V0aWxfYXR0cmlidXRlc19tYW5hZ2VyX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKHRoaXMpLnJlc3VtZUF0dHJpYnV0ZXNVcGRhdGVzKCk7XG5cbiAgICAgIC8vIFVzZWQgdG8gY2hlY2sgd2hldGhlciBvciBub3QgdGhlIGNvbXBvbmVudCBjYW4gcmVuZGVyLlxuICAgICAgdGhpc1tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3V0aWxfc3ltYm9sc19fW1wialwiIC8qIGNvbm5lY3RlZCAqL11dID0gdHJ1ZTtcblxuICAgICAgLy8gUmVuZGVyIVxuICAgICAgdGhpc1tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3V0aWxfc3ltYm9sc19fW1wiaVwiIC8qIHJlbmRlcmVyRGVib3VuY2VkICovXV0oKTtcblxuICAgICAgLy8gREVQUkVDQVRFRFxuICAgICAgLy9cbiAgICAgIC8vIHN0YXRpYyBhdHRhY2hlZCgpXG4gICAgICB2YXIgYXR0YWNoZWQgPSB0aGlzLmNvbnN0cnVjdG9yLmF0dGFjaGVkO1xuXG4gICAgICBpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX3V0aWxfaXNfdHlwZV9fW1wiYVwiIC8qIGlzRnVuY3Rpb24gKi9dKShhdHRhY2hlZCkpIHtcbiAgICAgICAgZGVwcmVjYXRlZCh0aGlzLCAnc3RhdGljIGF0dGFjaGVkJywgJ2Nvbm5lY3RlZENhbGxiYWNrJyk7XG4gICAgICAgIGF0dGFjaGVkKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBERVBSRUNBVEVEXG4gICAgICAvL1xuICAgICAgLy8gV2UgY2FuIHJlbW92ZSB0aGlzIG9uY2UgYWxsIGJyb3dzZXJzIHN1cHBvcnQgOmRlZmluZWQuXG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnZGVmaW5lZCcsICcnKTtcbiAgICB9XG5cbiAgICAvLyBDdXN0b20gRWxlbWVudHMgdjFcblxuICB9LCB7XG4gICAga2V5OiAnZGlzY29ubmVjdGVkQ2FsbGJhY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIC8vIFN1c3BlbmQgdXBkYXRpbmcgYXR0cmlidXRlcyB1bnRpbCByZS1jb25uZWN0ZWRcbiAgICAgIF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX3V0aWxfYXR0cmlidXRlc19tYW5hZ2VyX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKHRoaXMpLnN1c3BlbmRBdHRyaWJ1dGVzVXBkYXRlcygpO1xuXG4gICAgICAvLyBFbnN1cmVzIHRoZSBjb21wb25lbnQgY2FuJ3QgYmUgcmVuZGVyZWQgd2hpbGUgZGlzY29ubmVjdGVkLlxuICAgICAgdGhpc1tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3V0aWxfc3ltYm9sc19fW1wialwiIC8qIGNvbm5lY3RlZCAqL11dID0gZmFsc2U7XG5cbiAgICAgIC8vIERFUFJFQ0FURURcbiAgICAgIC8vXG4gICAgICAvLyBzdGF0aWMgZGV0YWNoZWQoKVxuICAgICAgdmFyIGRldGFjaGVkID0gdGhpcy5jb25zdHJ1Y3Rvci5kZXRhY2hlZDtcblxuICAgICAgaWYgKF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX191dGlsX2lzX3R5cGVfX1tcImFcIiAvKiBpc0Z1bmN0aW9uICovXSkoZGV0YWNoZWQpKSB7XG4gICAgICAgIGRlcHJlY2F0ZWQodGhpcywgJ3N0YXRpYyBkZXRhY2hlZCcsICdkaXNjb25uZWN0ZWRDYWxsYmFjaycpO1xuICAgICAgICBkZXRhY2hlZCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDdXN0b20gRWxlbWVudHMgdjFcblxuICB9LCB7XG4gICAga2V5OiAnYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgLy8gUG9seWZpbGwgY2FsbHMgdGhpcyB0d2ljZS5cbiAgICAgIGlmIChwcmV2ZW50RG91YmxlQ2FsbGluZyh0aGlzLCBuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IGRhdGEgc28gd2UgY2FuIHByZXZlbnQgZG91YmxlIGNhbGxpbmcgaWYgdGhlIHBvbHlmaWxsLlxuICAgICAgdGhpc1tfcHJldk5hbWVdID0gbmFtZTtcbiAgICAgIHRoaXNbX3ByZXZPbGRWYWx1ZV0gPSBvbGRWYWx1ZTtcbiAgICAgIHRoaXNbX3ByZXZOZXdWYWx1ZV0gPSBuZXdWYWx1ZTtcblxuICAgICAgdmFyIHByb3BOYW1lT3JTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X191dGlsX2RhdGFfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkodGhpcywgJ2F0dHJTb3VyY2VMaW5rcycpW25hbWVdO1xuICAgICAgaWYgKHByb3BOYW1lT3JTeW1ib2wpIHtcbiAgICAgICAgdmFyIGNoYW5nZWRFeHRlcm5hbGx5ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fdXRpbF9hdHRyaWJ1dGVzX21hbmFnZXJfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkodGhpcykub25BdHRyaWJ1dGVDaGFuZ2VkKG5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgaWYgKGNoYW5nZWRFeHRlcm5hbGx5KSB7XG4gICAgICAgICAgLy8gU3luYyB1cCB0aGUgcHJvcGVydHkuXG4gICAgICAgICAgdmFyIHByb3BEZWYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X191dGlsX2dldF9wcm9wc19tYXBfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkodGhpcy5jb25zdHJ1Y3RvcilbcHJvcE5hbWVPclN5bWJvbF07XG4gICAgICAgICAgdmFyIG5ld1Byb3BWYWwgPSBuZXdWYWx1ZSAhPT0gbnVsbCAmJiBwcm9wRGVmLmRlc2VyaWFsaXplID8gcHJvcERlZi5kZXNlcmlhbGl6ZShuZXdWYWx1ZSkgOiBuZXdWYWx1ZTtcblxuICAgICAgICAgIHZhciBwcm9wRGF0YSA9IF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX3V0aWxfZGF0YV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSh0aGlzLCAncHJvcHMnKVtwcm9wTmFtZU9yU3ltYm9sXTtcbiAgICAgICAgICBwcm9wRGF0YS5zZXR0aW5nUHJvcEZyb21BdHRyU291cmNlID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzW3Byb3BOYW1lT3JTeW1ib2xdID0gbmV3UHJvcFZhbDtcbiAgICAgICAgICBwcm9wRGF0YS5zZXR0aW5nUHJvcEZyb21BdHRyU291cmNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gREVQUkVDQVRFRFxuICAgICAgLy9cbiAgICAgIC8vIHN0YXRpYyBhdHRyaWJ1dGVDaGFuZ2VkKClcbiAgICAgIHZhciBhdHRyaWJ1dGVDaGFuZ2VkID0gdGhpcy5jb25zdHJ1Y3Rvci5hdHRyaWJ1dGVDaGFuZ2VkO1xuXG4gICAgICBpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX3V0aWxfaXNfdHlwZV9fW1wiYVwiIC8qIGlzRnVuY3Rpb24gKi9dKShhdHRyaWJ1dGVDaGFuZ2VkKSkge1xuICAgICAgICBkZXByZWNhdGVkKHRoaXMsICdzdGF0aWMgYXR0cmlidXRlQ2hhbmdlZCcsICdhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2snKTtcbiAgICAgICAgYXR0cmlidXRlQ2hhbmdlZCh0aGlzLCB7IG5hbWU6IG5hbWUsIG5ld1ZhbHVlOiBuZXdWYWx1ZSwgb2xkVmFsdWU6IG9sZFZhbHVlIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNrYXRlXG5cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZWRDYWxsYmFjaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZWRDYWxsYmFjayhwcmV2UHJvcHMpIHtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLmhhc093blByb3BlcnR5KCd1cGRhdGVkJykpIHtcbiAgICAgICAgZGVwcmVjYXRlZCh0aGlzLCAnc3RhdGljIHVwZGF0ZWQnLCAndXBkYXRlZENhbGxiYWNrJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci51cGRhdGVkKHRoaXMsIHByZXZQcm9wcyk7XG4gICAgfVxuXG4gICAgLy8gU2thdGVcblxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyZWRDYWxsYmFjaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcmVkQ2FsbGJhY2soKSB7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5oYXNPd25Qcm9wZXJ0eSgncmVuZGVyZWQnKSkge1xuICAgICAgICBkZXByZWNhdGVkKHRoaXMsICdzdGF0aWMgcmVuZGVyZWQnLCAncmVuZGVyZWRDYWxsYmFjaycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IucmVuZGVyZWQodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gU2thdGVcbiAgICAvL1xuICAgIC8vIE1hcHMgdG8gdGhlIHN0YXRpYyByZW5kZXJlcigpIGNhbGxiYWNrLiBUaGF0IGxvZ2ljIHNob3VsZCBiZSBtb3ZlZCBoZXJlXG4gICAgLy8gd2hlbiB0aGF0IGlzIGZpbmFsbHkgcmVtb3ZlZC5cbiAgICAvLyBUT0RPOiBmaW5hbGl6ZSBob3cgdG8gc3VwcG9ydCBkaWZmZXJlbnQgcmVuZGVyaW5nIHN0cmF0ZWdpZXMuXG5cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlcmVyQ2FsbGJhY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJlckNhbGxiYWNrKCkge1xuICAgICAgLy8gVE9ETzogY2Fubm90IG1vdmUgY29kZSBoZXJlIGJlY2F1c2UgdGVzdHMgZXhwZWN0cyByZW5kZXJlciBmdW5jdGlvbiB0byBzdGlsbCBleGlzdCBvbiBjb25zdHJ1Y3RvciFcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnJlbmRlcmVyKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIFNrYXRlXG4gICAgLy8gQGludGVybmFsXG4gICAgLy8gSW52b2tlcyB0aGUgY29tcGxldGUgcmVuZGVyIGxpZmVjeWNsZS5cblxuICB9LCB7XG4gICAga2V5OiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3V0aWxfc3ltYm9sc19fW1wiZFwiIC8qIHJlbmRlcmVyICovXSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICBpZiAodGhpc1tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3V0aWxfc3ltYm9sc19fW1wia1wiIC8qIHJlbmRlcmluZyAqL11dIHx8ICF0aGlzW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fdXRpbF9zeW1ib2xzX19bXCJqXCIgLyogY29ubmVjdGVkICovXV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBGbGFnIGFzIHJlbmRlcmluZy4gVGhpcyBwcmV2ZW50cyBhbnl0aGluZyBmcm9tIHRyeWluZyB0byByZW5kZXIgLSBvclxuICAgICAgLy8gcXVldWVpbmcgYSByZW5kZXIgLSB3aGlsZSB0aGVyZSBpcyBhIHBlbmRpbmcgcmVuZGVyLlxuICAgICAgdGhpc1tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3V0aWxfc3ltYm9sc19fW1wia1wiIC8qIHJlbmRlcmluZyAqL11dID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fdXRpbF9zeW1ib2xzX19bXCJsXCIgLyogdXBkYXRlZCAqL11dKCkgJiYgX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX3V0aWxfaXNfdHlwZV9fW1wiYVwiIC8qIGlzRnVuY3Rpb24gKi9dKSh0aGlzLnJlbmRlckNhbGxiYWNrKSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyQ2FsbGJhY2soKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlZENhbGxiYWNrKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXNbX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX191dGlsX3N5bWJvbHNfX1tcImtcIiAvKiByZW5kZXJpbmcgKi9dXSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFNrYXRlXG4gICAgLy8gQGludGVybmFsXG4gICAgLy8gQ2FsbHMgdGhlIHVwZGF0ZWRDYWxsYmFjaygpIHdpdGggcHJldmlvdXMgcHJvcHMuXG5cbiAgfSwge1xuICAgIGtleTogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX191dGlsX3N5bWJvbHNfX1tcImxcIiAvKiB1cGRhdGVkICovXSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICB2YXIgcHJldlByb3BzID0gdGhpc1tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3V0aWxfc3ltYm9sc19fW1wibVwiIC8qIHByb3BzICovXV07XG4gICAgICB0aGlzW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fdXRpbF9zeW1ib2xzX19bXCJtXCIgLyogcHJvcHMgKi9dXSA9IF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19wcm9wc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZWRDYWxsYmFjayhwcmV2UHJvcHMpO1xuICAgIH1cblxuICAgIC8vIFNrYXRlXG5cbiAgfV0sIFt7XG4gICAga2V5OiAnZXh0ZW5kJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgICAgdmFyIGRlZmluaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgdmFyIEJhc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXM7XG5cbiAgICAgIC8vIENyZWF0ZSBjbGFzcyBmb3IgdGhlIHVzZXIuXG4gICAgICB2YXIgQ3RvciA9IGZ1bmN0aW9uIChfQmFzZSkge1xuICAgICAgICBfaW5oZXJpdHMoQ3RvciwgX0Jhc2UpO1xuXG4gICAgICAgIGZ1bmN0aW9uIEN0b3IoKSB7XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN0b3IpO1xuXG4gICAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDdG9yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ3RvcikpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEN0b3I7XG4gICAgICB9KEJhc2UpO1xuXG4gICAgICAvLyBGb3IgaW5oZXJpdGluZyBmcm9tIHRoZSBvYmplY3QgbGl0ZXJhbC5cblxuXG4gICAgICB2YXIgb3B0cyA9IF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX3V0aWxfZ2V0X293bl9wcm9wZXJ0eV9kZXNjcmlwdG9yc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShkZWZpbml0aW9uKTtcbiAgICAgIHZhciBwcm90ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fdXRpbF9nZXRfb3duX3Byb3BlcnR5X2Rlc2NyaXB0b3JzX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKGRlZmluaXRpb24ucHJvdG90eXBlKTtcblxuICAgICAgLy8gUHJvdG90eXBlIGlzIG5vbiBjb25maWd1cmFibGUgKGJ1dCBpcyB3cml0YWJsZSkuXG4gICAgICBkZWxldGUgb3B0cy5wcm90b3R5cGU7XG5cbiAgICAgIC8vIFBhc3Mgb24gc3RhdGljIGFuZCBpbnN0YW5jZSBtZW1iZXJzIGZyb20gdGhlIGRlZmluaXRpb24uXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDdG9yLCBvcHRzKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEN0b3IucHJvdG90eXBlLCBwcm90KTtcblxuICAgICAgcmV0dXJuIEN0b3I7XG4gICAgfVxuXG4gICAgLy8gU2thdGVcbiAgICAvL1xuICAgIC8vIERFUFJFQ0FURURcbiAgICAvL1xuICAgIC8vIFN0dWJiZWQgaW4gY2FzZSBhbnkgc3ViY2xhc3NlcyBhcmUgY2FsbGluZyBpdC5cblxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJlZCgpIHt9XG5cbiAgICAvLyBTa2F0ZVxuICAgIC8vXG4gICAgLy8gREVQUkVDQVRFRFxuICAgIC8vXG4gICAgLy8gTW92ZSB0aGlzIHRvIHJlbmRlcmVyQ2FsbGJhY2soKSBiZWZvcmUgcmVtb3ZpbmcuXG5cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlcmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyZXIoZWxlbSkge1xuICAgICAgaWYgKCFlbGVtLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgZWxlbS5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG4gICAgICB9XG4gICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2luY3JlbWVudGFsX2RvbV9fW1wicGF0Y2hJbm5lclwiXSkoZWxlbS5zaGFkb3dSb290LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwb3NzaWJsZUZuID0gZWxlbS5yZW5kZXJDYWxsYmFjayhlbGVtKTtcbiAgICAgICAgaWYgKF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX191dGlsX2lzX3R5cGVfX1tcImFcIiAvKiBpc0Z1bmN0aW9uICovXSkocG9zc2libGVGbikpIHtcbiAgICAgICAgICBwb3NzaWJsZUZuKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwb3NzaWJsZUZuKSkge1xuICAgICAgICAgIHBvc3NpYmxlRm4uZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fdXRpbF9pc190eXBlX19bXCJhXCIgLyogaXNGdW5jdGlvbiAqL10pKGZuKSkge1xuICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTa2F0ZVxuICAgIC8vXG4gICAgLy8gREVQUkVDQVRFRFxuICAgIC8vXG4gICAgLy8gTW92ZSB0aGlzIHRvIHVwZGF0ZWRDYWxsYmFjaygpIGJlZm9yZSByZW1vdmluZy5cblxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZWQoZWxlbSwgcHJldmlvdXNQcm9wcykge1xuICAgICAgLy8gVGhlICdwcmV2aW91c1Byb3BzJyB3aWxsIGJlIHVuZGVmaW5lZCBpZiBpdCBpcyB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgICBpZiAoIXByZXZpb3VzUHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSAncHJldmlvdXNQcm9wcycgd2lsbCBhbHdheXMgY29udGFpbiBhbGwgb2YgdGhlIGtleXMuXG4gICAgICAvL1xuICAgICAgLy8gVXNlIGNsYXNzaWMgbG9vcCBiZWNhdXNlOlxuICAgICAgLy8gJ2ZvciAuLi4gaW4nIHNraXBzIHN5bWJvbHMgYW5kICdmb3IgLi4uIG9mJyBpcyBub3Qgd29ya2luZyB5ZXQgd2l0aCBJRSE/XG4gICAgICAvLyBmb3IgKGxldCBuYW1lT3JTeW1ib2wgb2YgZ2V0UHJvcE5hbWVzQW5kU3ltYm9scyhwcmV2aW91c1Byb3BzKSkge1xuICAgICAgdmFyIG5hbWVzQW5kU3ltYm9scyA9IF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX3V0aWxfZ2V0X3Byb3BfbmFtZXNfYW5kX3N5bWJvbHNfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkocHJldmlvdXNQcm9wcyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzQW5kU3ltYm9scy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmFtZU9yU3ltYm9sID0gbmFtZXNBbmRTeW1ib2xzW2ldO1xuXG4gICAgICAgIC8vIFdpdGggT2JqZWN0LmlzIE5hTiBpcyBlcXVhbCB0byBOYU5cbiAgICAgICAgaWYgKCFfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fcG9seWZpbGxzX29iamVjdF9pc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShwcmV2aW91c1Byb3BzW25hbWVPclN5bWJvbF0sIGVsZW1bbmFtZU9yU3ltYm9sXSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIF9jbGFzczI7XG59KEhUTUxFbGVtZW50KTtcblxuX2NsYXNzMi5pcyA9ICcnO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IF9jbGFzczI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXygxMykpKVxuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX190b19udWxsX29yX3N0cmluZ19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19pc190eXBlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSBnZXRBdHRyTWdyO1xudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuXG5cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEF0dHJpYnV0ZXMgTWFuYWdlclxuICpcbiAqIFBvc3Rwb25lcyBhdHRyaWJ1dGVzIHVwZGF0ZXMgdW50aWwgd2hlbiBjb25uZWN0ZWQuXG4gKi9cblxudmFyIEF0dHJpYnV0ZXNNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBdHRyaWJ1dGVzTWFuYWdlcihlbGVtKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF0dHJpYnV0ZXNNYW5hZ2VyKTtcblxuICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBlbmRpbmdWYWx1ZXMgPSB7fTtcbiAgICB0aGlzLmxhc3RTZXRWYWx1ZXMgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgZnJvbSBkaXNjb25uZWN0ZWRDYWxsYmFja1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhBdHRyaWJ1dGVzTWFuYWdlciwgW3tcbiAgICBrZXk6ICdzdXNwZW5kQXR0cmlidXRlc1VwZGF0ZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdXNwZW5kQXR0cmlidXRlc1VwZGF0ZXMoKSB7XG4gICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBmcm9tIGNvbm5lY3RlZENhbGxiYWNrXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Jlc3VtZUF0dHJpYnV0ZXNVcGRhdGVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzdW1lQXR0cmlidXRlc1VwZGF0ZXMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLnBlbmRpbmdWYWx1ZXMpO1xuICAgICAgbmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBfdGhpcy5wZW5kaW5nVmFsdWVzW25hbWVdO1xuICAgICAgICAvLyBTa2lwIGlmIGFscmVhZHkgY2xlYXJlZFxuICAgICAgICBpZiAoIV9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2lzX3R5cGVfX1tcImJcIiAvKiBpc1VuZGVmaW5lZCAqL10pKHZhbHVlKSkge1xuICAgICAgICAgIGRlbGV0ZSBfdGhpcy5wZW5kaW5nVmFsdWVzW25hbWVdO1xuICAgICAgICAgIF90aGlzLl9zeW5jQXR0clZhbHVlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgb25lIHNldCBpbnRlcm5hbGx5XG4gICAgICogdXNpbmcgc2V0QXR0clZhbHVlKClcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb25BdHRyaWJ1dGVDaGFuZ2VkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25BdHRyaWJ1dGVDaGFuZ2VkKG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3RvX251bGxfb3Jfc3RyaW5nX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKHZhbHVlKTtcblxuICAgICAgLy8gQSBuZXcgYXR0cmlidXRlIHZhbHVlIHZvaWRzIHRoZSBwZW5kaW5nIG9uZVxuICAgICAgdGhpcy5fY2xlYXJQZW5kaW5nVmFsdWUobmFtZSk7XG5cbiAgICAgIHZhciBjaGFuZ2VkID0gdGhpcy5sYXN0U2V0VmFsdWVzW25hbWVdICE9PSB2YWx1ZTtcbiAgICAgIHRoaXMubGFzdFNldFZhbHVlc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBvciByZW1vdmVzIHRoZSBhdHRyaWJ1dGUgaWYgdmFsdWUgPT09IG51bGwuXG4gICAgICpcbiAgICAgKiBXaGVuIHRoZSBjb21wb25lbnQgaXMgbm90IGNvbm5lY3RlZCB0aGUgdmFsdWUgaXMgc2F2ZWQgYW5kXG4gICAgICogdGhlIGF0dHJpYnV0ZSBpcyBvbmx5IHVwZGF0ZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIHJlLWNvbm5lY3RlZC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0QXR0clZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QXR0clZhbHVlKG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3RvX251bGxfb3Jfc3RyaW5nX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKHZhbHVlKTtcblxuICAgICAgdGhpcy5sYXN0U2V0VmFsdWVzW25hbWVdID0gdmFsdWU7XG5cbiAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLl9jbGVhclBlbmRpbmdWYWx1ZShuYW1lKTtcbiAgICAgICAgdGhpcy5fc3luY0F0dHJWYWx1ZShuYW1lLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBlbmRpbmdWYWx1ZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfc3luY0F0dHJWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zeW5jQXR0clZhbHVlKG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgY3VyckF0dHJWYWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3RvX251bGxfb3Jfc3RyaW5nX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKHRoaXMuZWxlbS5nZXRBdHRyaWJ1dGUobmFtZSkpO1xuICAgICAgaWYgKHZhbHVlICE9PSBjdXJyQXR0clZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuZWxlbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lbGVtLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfY2xlYXJQZW5kaW5nVmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xlYXJQZW5kaW5nVmFsdWUobmFtZSkge1xuICAgICAgaWYgKG5hbWUgaW4gdGhpcy5wZW5kaW5nVmFsdWVzKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdWYWx1ZXNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEF0dHJpYnV0ZXNNYW5hZ2VyO1xufSgpO1xuXG4vLyBPbmx5IHVzZWQgYnkgZ2V0QXR0ck1nclxuXG5cbnZhciAkYXR0cmlidXRlc01nciA9ICdfX19fc2thdGVfYXR0cmlidXRlc01ncic7XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBSZXR1cm5zIGF0dHJpYnV0ZSBtYW5hZ2VyIGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gQ29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIGdldEF0dHJNZ3IoZWxlbSkge1xuICB2YXIgbWdyID0gZWxlbVskYXR0cmlidXRlc01ncl07XG4gIGlmICghbWdyKSB7XG4gICAgbWdyID0gbmV3IEF0dHJpYnV0ZXNNYW5hZ2VyKGVsZW0pO1xuICAgIGVsZW1bJGF0dHJpYnV0ZXNNZ3JdID0gbWdyO1xuICB9XG4gIHJldHVybiBtZ3I7XG59XG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19zeW1ib2xzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZ2V0X3Byb3BfbmFtZXNfYW5kX3N5bWJvbHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19wcm9wX2RlZmluaXRpb25fXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fc2V0X2N0b3JfbmF0aXZlX3Byb3BlcnR5X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gZ2V0UHJvcHNNYXA7XG5cblxuXG5cblxuLyoqXG4gKiBNZW1vaXplcyBhIG1hcCBvZiBQcm9wRGVmaW5pdGlvbiBmb3IgdGhlIGdpdmVuIGNvbXBvbmVudCBjbGFzcy5cbiAqIEtleXMgaW4gdGhlIG1hcCBhcmUgdGhlIHByb3BlcnRpZXMgbmFtZSB3aGljaCBjYW4gYSBzdHJpbmcgb3IgYSBzeW1ib2wuXG4gKlxuICogVGhlIG1hcCBpcyBjcmVhdGVkIGZyb20gdGhlIHJlc3VsdCBvZjogc3RhdGljIGdldCBwcm9wc1xuICovXG5mdW5jdGlvbiBnZXRQcm9wc01hcChDdG9yKSB7XG4gIC8vIE11c3QgYmUgZGVmaW5lZCBvbiBjb25zdHJ1Y3RvciBhbmQgbm90IGZyb20gYSBzdXBlcmNsYXNzXG4gIGlmICghQ3Rvci5oYXNPd25Qcm9wZXJ0eShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3N5bWJvbHNfX1tcImVcIiAvKiBjdG9yUHJvcHNNYXAgKi9dKSkge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcHJvcHMgPSBDdG9yLnByb3BzIHx8IHt9O1xuXG4gICAgICB2YXIgcHJvcHNNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19nZXRfcHJvcF9uYW1lc19hbmRfc3ltYm9sc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShwcm9wcykucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIG5hbWVPclN5bWJvbCkge1xuICAgICAgICByZXN1bHRbbmFtZU9yU3ltYm9sXSA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX3Byb3BfZGVmaW5pdGlvbl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG5hbWVPclN5bWJvbCwgcHJvcHNbbmFtZU9yU3ltYm9sXSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LCB7fSk7XG4gICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19zZXRfY3Rvcl9uYXRpdmVfcHJvcGVydHlfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoQ3RvciwgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19zeW1ib2xzX19bXCJlXCIgLyogY3RvclByb3BzTWFwICovXSwgcHJvcHNNYXApO1xuICAgIH0pKCk7XG4gIH1cblxuICByZXR1cm4gQ3RvcltfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3N5bWJvbHNfX1tcImVcIiAvKiBjdG9yUHJvcHNNYXAgKi9dXTtcbn1cblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gc2V0Q3Rvck5hdGl2ZVByb3BlcnR5O1xuLyoqXG4gKiBUaGlzIGlzIG5lZWRlZCB0byBhdm9pZCBJRTExIFwic3RhY2sgc2l6ZSBlcnJvcnNcIiB3aGVuIGNyZWF0aW5nXG4gKiBhIG5ldyBwcm9wZXJ0eSBvbiB0aGUgY29uc3RydWN0b3Igb2YgYW4gSFRNTEVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gc2V0Q3Rvck5hdGl2ZVByb3BlcnR5KEN0b3IsIHByb3BOYW1lLCB2YWx1ZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ3RvciwgcHJvcE5hbWUsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19lbXB0eV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuLyoqXG4gKiBBdHRyaWJ1dGVzIHZhbHVlIGNhbiBvbmx5IGJlIG51bGwgb3Igc3RyaW5nO1xuICovXG52YXIgdG9OdWxsT3JTdHJpbmcgPSBmdW5jdGlvbiB0b051bGxPclN0cmluZyh2YWwpIHtcbiAgcmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2VtcHR5X19bXCJhXCIgLyogZGVmYXVsdCAqL10pKHZhbCkgPyBudWxsIDogU3RyaW5nKHZhbCk7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gdG9OdWxsT3JTdHJpbmc7XG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xNF9fO1xuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYXBpX3Byb3BfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fYXBpX3N5bWJvbHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fYXBpX3Zkb21fXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fYXBpX2NvbXBvbmVudF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX2FwaV9kZWZpbmVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fYXBpX2VtaXRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fYXBpX2xpbmtfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fYXBpX3Byb3BzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fYXBpX3JlYWR5X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkNvbXBvbmVudFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fYXBpX2NvbXBvbmVudF9fW1wiYVwiXTsgfSk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZpbmVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX2FwaV9kZWZpbmVfX1tcImFcIl07IH0pO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZW1pdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fYXBpX2VtaXRfX1tcImFcIl07IH0pO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibGlua1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fYXBpX2xpbmtfX1tcImFcIl07IH0pO1xuLyogaGFybW9ueSByZWV4cG9ydCAobW9kdWxlIG9iamVjdCkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicHJvcFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYXBpX3Byb3BfXzsgfSk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJwcm9wc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fYXBpX3Byb3BzX19bXCJhXCJdOyB9KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInJlYWR5XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19hcGlfcmVhZHlfX1tcImFcIl07IH0pO1xuLyogaGFybW9ueSByZWV4cG9ydCAobW9kdWxlIG9iamVjdCkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwic3ltYm9sc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fYXBpX3N5bWJvbHNfXzsgfSk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChtb2R1bGUgb2JqZWN0KSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ2ZG9tXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19hcGlfdmRvbV9fOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaDsgfSk7XG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBoID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19hcGlfdmRvbV9fW1wiYnVpbGRlclwiXSgpO1xuXG5cblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7LyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fY29tcG9uZW50X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fdXRpbF91bmlxdWVfaWRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fdXRpbF9yb290X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjdXN0b21FbGVtZW50cyA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fdXRpbF9yb290X19bXCJhXCIgLyogZGVmYXVsdCAqL10uY3VzdG9tRWxlbWVudHMsXG4gICAgICBIVE1MRWxlbWVudCA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fdXRpbF9yb290X19bXCJhXCIgLyogZGVmYXVsdCAqL10uSFRNTEVsZW1lbnQ7XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIG5hbWUgPSBhcmdzWzBdLFxuICAgICAgQ3RvciA9IGFyZ3NbMV07XG5cblxuICBpZiAoIWN1c3RvbUVsZW1lbnRzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTa2F0ZSByZXF1aXJlcyBuYXRpdmUgY3VzdG9tIGVsZW1lbnQgc3VwcG9ydCBvciBhIHBvbHlmaWxsLicpO1xuICB9XG5cbiAgLy8gREVQUkVDQVRFRCByZW1vdmUgd2hlbiByZW1vdmluZyB0aGUgXCJuYW1lXCIgYXJndW1lbnQuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgY29uc29sZS53YXJuKCdUaGUgXCJuYW1lXCIgYXJndW1lbnQgdG8gZGVmaW5lKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIGRlZmluZSBhIGBzdGF0aWMgaXNgIHByb3BlcnR5IG9uIHRoZSBjb25zdHJ1Y3RvciBpbnN0ZWFkLicpO1xuICB9XG5cbiAgLy8gREVQUkVDQVRFRCByZW1vdmUgd2hlbiByZW1vdmluZyB0aGUgXCJuYW1lXCIgYXJndW1lbnQuXG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgIEN0b3IgPSBuYW1lO1xuICAgIG5hbWUgPSBudWxsO1xuICB9XG5cbiAgLy8gREVQUkVDQVRFRCBPYmplY3QgbGl0ZXJhbHMuXG4gIGlmICgodHlwZW9mIEN0b3IgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKEN0b3IpKSA9PT0gJ29iamVjdCcpIHtcbiAgICBDdG9yID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19jb21wb25lbnRfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICAvLyBFbnN1cmUgYSBjdXN0b20gZWxlbWVudCBpcyBwYXNzZWQuXG4gIGlmICghKEN0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwcm92aWRlIGEgY29uc3RydWN0b3IgdGhhdCBleHRlbmRzIEhUTUxFbGVtZW50IHRvIGRlZmluZSgpLicpO1xuICB9XG5cbiAgLy8gREVQUkVDQVRFRCB0d28gYXJndW1lbnRzXG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZShjdXN0b21FbGVtZW50cy5nZXQobmFtZSkgPyBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX191dGlsX3VuaXF1ZV9pZF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShuYW1lKSA6IG5hbWUsIEN0b3IpO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIG11c3QgdXNlIGhhc093blByb3BlcnR5KCkgYmVjYXVzZSB3ZSB3YW50IHRvIGtub3cgaWYgaXQgd2FzIHNwZWNpZmllZFxuICAgIC8vIGRpcmVjdGx5IG9uIHRoaXMgY2xhc3MsIG5vdCBzdWJjbGFzc2VzLCBhcyB3ZSBkb24ndCB3YW50IHRvIGluaGVyaXQgdGFnXG4gICAgLy8gbmFtZXMgZnJvbSBzdWJjbGFzc2VzLlxuICAgIGlmICghQ3Rvci5oYXNPd25Qcm9wZXJ0eSgnaXMnKSkge1xuICAgICAgLy8gSWYgd2UgdXNlZCBkZWZpbmVQcm9wZXJ0eSgpIHRoZW4gdGhlIGNvbnN1bWVyIG11c3QgYWxzbyB1c2UgaXQgYW5kXG4gICAgICAvLyBjYW5ub3QgdXNlIHByb3BlcnR5IGluaXRpYWxpc2Vycy4gSW5zdGVhZCB3ZSBqdXN0IHNldCBpdCBzbyB0aGV5IGNhblxuICAgICAgLy8gdXNlIHdoYXRldmVyIG1ldGhvZCBvZiBvdmVycmlkZGluZyB0aGF0IHRoZXkgd2FudC5cbiAgICAgIEN0b3IuaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX191dGlsX3VuaXF1ZV9pZF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSgpO1xuICAgIH1cbiAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoQ3Rvci5pcywgQ3Rvcik7XG4gIH1cblxuICAvLyBUaGUgc3BlYyBkb2Vzbid0IHJldHVybiBidXQgdGhpcyBhbGxvd3MgZm9yIGEgc2ltcGxlciwgbW9yZSBjb25jaXNlIEFQSS5cbiAgcmV0dXJuIEN0b3I7XG59O1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18oMTMpKSlcblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3V0aWxfcm9vdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXG52YXIgRXZlbnQgPSBmdW5jdGlvbiAoVGhlRXZlbnQpIHtcbiAgaWYgKFRoZUV2ZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBUaGVFdmVudCgnZW1pdC1pbml0Jyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFRoZUV2ZW50O1xufShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3V0aWxfcm9vdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkV2ZW50KTtcblxuZnVuY3Rpb24gY3JlYXRlQ3VzdG9tRXZlbnQobmFtZSkge1xuICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBkZXRhaWwgPSBvcHRzLmRldGFpbDtcblxuICBkZWxldGUgb3B0cy5kZXRhaWw7XG5cbiAgdmFyIGUgPSB2b2lkIDA7XG4gIGlmIChFdmVudCkge1xuICAgIGUgPSBuZXcgRXZlbnQobmFtZSwgb3B0cyk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsICdkZXRhaWwnLCB7IHZhbHVlOiBkZXRhaWwgfSk7XG4gIH0gZWxzZSB7XG4gICAgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAnY29tcG9zZWQnLCB7IHZhbHVlOiBvcHRzLmNvbXBvc2VkIH0pO1xuICAgIGUuaW5pdEN1c3RvbUV2ZW50KG5hbWUsIG9wdHMuYnViYmxlcywgb3B0cy5jYW5jZWxhYmxlLCBkZXRhaWwpO1xuICB9XG4gIHJldHVybiBlO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gZnVuY3Rpb24gKGVsZW0sIG5hbWUpIHtcbiAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gIGlmIChvcHRzLmJ1YmJsZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdHMuYnViYmxlcyA9IHRydWU7XG4gIH1cbiAgaWYgKG9wdHMuY2FuY2VsYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0cy5jYW5jZWxhYmxlID0gdHJ1ZTtcbiAgfVxuICBpZiAob3B0cy5jb21wb3NlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0cy5jb21wb3NlZCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGVsZW0uZGlzcGF0Y2hFdmVudChjcmVhdGVDdXN0b21FdmVudChuYW1lLCBvcHRzKSk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fcHJvcHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5cblxuZnVuY3Rpb24gZ2V0VmFsdWUoZWxlbSkge1xuICB2YXIgdHlwZSA9IGVsZW0udHlwZTtcbiAgaWYgKHR5cGUgPT09ICdjaGVja2JveCcgfHwgdHlwZSA9PT0gJ3JhZGlvJykge1xuICAgIHJldHVybiBlbGVtLmNoZWNrZWQgPyBlbGVtLnZhbHVlIHx8IHRydWUgOiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZWxlbS52YWx1ZTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IGZ1bmN0aW9uIChlbGVtLCB0YXJnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgLy8gV2UgZmFsbGJhY2sgdG8gY2hlY2tpbmcgdGhlIGNvbXBvc2VkIHBhdGguIFVuZm9ydHVuYXRlbHkgdGhpcyBiZWhhdmlvdXJcbiAgICAvLyBpcyBkaWZmaWN1bHQgdG8gaW1wb3NzaWJsZSB0byByZXByb2R1Y2UgYXMgaXQgc2VlbXMgdG8gYmUgYSBwb3NzaWJsZVxuICAgIC8vIHF1aXJrIGluIHRoZSBzaGFkeWRvbSBwb2x5ZmlsbCB0aGF0IGluY29ycmVjdGx5IHJldHVybnMgbnVsbCBmb3IgdGhlXG4gICAgLy8gdGFyZ2V0IGJ1dCBoYXMgdGhlIHRhcmdldCBhcyB0aGUgZmlyc3QgcG9pbnQgaW4gdGhlIHBhdGguXG4gICAgLy8gVE9ETyByZXZpc2l0IG9uY2UgYWxsIGJyb3dzZXJzIGhhdmUgbmF0aXZlIHN1cHBvcnQuXG4gICAgdmFyIGxvY2FsVGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5jb21wb3NlZFBhdGgoKVswXTtcbiAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShsb2NhbFRhcmdldCk7XG4gICAgdmFyIGxvY2FsVGFyZ2V0TmFtZSA9IHRhcmdldCB8fCBsb2NhbFRhcmdldC5uYW1lIHx8ICd2YWx1ZSc7XG5cbiAgICBpZiAobG9jYWxUYXJnZXROYW1lLmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICB2YXIgcGFydHMgPSBsb2NhbFRhcmdldE5hbWUuc3BsaXQoJy4nKTtcbiAgICAgIHZhciBmaXJzdFBhcnQgPSBwYXJ0c1swXTtcbiAgICAgIHZhciBwcm9wTmFtZSA9IHBhcnRzLnBvcCgpO1xuICAgICAgdmFyIG9iaiA9IHBhcnRzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xuICAgICAgICByZXR1cm4gcHJldiAmJiBwcmV2W2N1cnJdO1xuICAgICAgfSwgZWxlbSk7XG5cbiAgICAgIG9ialtwcm9wTmFtZSB8fCBlLnRhcmdldC5uYW1lXSA9IHZhbHVlO1xuICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fcHJvcHNfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoZWxlbSwgX2RlZmluZVByb3BlcnR5KHt9LCBmaXJzdFBhcnQsIGVsZW1bZmlyc3RQYXJ0XSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19wcm9wc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShlbGVtLCBfZGVmaW5lUHJvcGVydHkoe30sIGxvY2FsVGFyZ2V0TmFtZSwgdmFsdWUpKTtcbiAgICB9XG4gIH07XG59O1xuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fdXRpbF9hc3NpZ25fXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX191dGlsX2VtcHR5X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fdXRpbF90b19udWxsX29yX3N0cmluZ19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG4vKiBoYXJtb255IGV4cG9ydCAoaW1tdXRhYmxlKSAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiY3JlYXRlXCJdID0gY3JlYXRlO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFycmF5XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJyYXk7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJvb2xlYW5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBib29sZWFuOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJudW1iZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBudW1iZXI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInN0cmluZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHN0cmluZzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwib2JqZWN0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gb2JqZWN0OyB9KTtcblxuXG5cblxuZnVuY3Rpb24gY3JlYXRlKGRlZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGFyZ3MudW5zaGlmdCh7fSwgZGVmKTtcbiAgICByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX191dGlsX2Fzc2lnbl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gIH07XG59XG5cbnZhciBwYXJzZUlmTm90RW1wdHkgPSBmdW5jdGlvbiBwYXJzZUlmTm90RW1wdHkodmFsKSB7XG4gIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX191dGlsX2VtcHR5X19bXCJhXCIgLyogZGVmYXVsdCAqL10pKHZhbCkgPyBudWxsIDogSlNPTi5wYXJzZSh2YWwpO1xufTtcblxudmFyIGFycmF5ID0gY3JlYXRlKHtcbiAgY29lcmNlOiBmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbCA6IF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3V0aWxfZW1wdHlfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkodmFsKSA/IG51bGwgOiBbdmFsXTtcbiAgfSxcbiAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9LFxuICBkZXNlcmlhbGl6ZTogcGFyc2VJZk5vdEVtcHR5LFxuICBzZXJpYWxpemU6IEpTT04uc3RyaW5naWZ5XG59KTtcblxudmFyIGJvb2xlYW4gPSBjcmVhdGUoe1xuICBjb2VyY2U6IGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgICByZXR1cm4gISF2YWw7XG4gIH0sXG4gIGRlZmF1bHQ6IGZhbHNlLFxuICAvLyBUT0RPOiAnZmFsc2UnIHN0cmluZyBtdXN0IGRlc2VyaWFsaXplIHRvIGZhbHNlIGZvciBhbmd1bGFyIDEueCB0byB3b3JrXG4gIC8vIFRoaXMgYnJlYWtzIG9uZSBleGlzdGluZyB0ZXN0LlxuICAvLyBkZXNlcmlhbGl6ZTogdmFsID0+ICEodmFsID09PSBudWxsIHx8IHZhbCA9PT0gJ2ZhbHNlJyksXG4gIGRlc2VyaWFsaXplOiBmdW5jdGlvbiBkZXNlcmlhbGl6ZSh2YWwpIHtcbiAgICByZXR1cm4gISh2YWwgPT09IG51bGwpO1xuICB9LFxuICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWwpIHtcbiAgICByZXR1cm4gdmFsID8gJycgOiBudWxsO1xuICB9XG59KTtcblxuLy8gZGVmYXVsdHMgZW1wdHkgdG8gMCBhbmQgYWxsb3dzIE5hTlxudmFyIHplcm9JZkVtcHR5T3JOdW1iZXJJbmNsdWRlc05hTiA9IGZ1bmN0aW9uIHplcm9JZkVtcHR5T3JOdW1iZXJJbmNsdWRlc05hTih2YWwpIHtcbiAgcmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3V0aWxfZW1wdHlfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkodmFsKSA/IDAgOiBOdW1iZXIodmFsKTtcbn07XG5cbnZhciBudW1iZXIgPSBjcmVhdGUoe1xuICBkZWZhdWx0OiAwLFxuICBjb2VyY2U6IHplcm9JZkVtcHR5T3JOdW1iZXJJbmNsdWRlc05hTixcbiAgZGVzZXJpYWxpemU6IHplcm9JZkVtcHR5T3JOdW1iZXJJbmNsdWRlc05hTixcbiAgc2VyaWFsaXplOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX3V0aWxfdG9fbnVsbF9vcl9zdHJpbmdfX1tcImFcIiAvKiBkZWZhdWx0ICovXVxufSk7XG5cbnZhciBzdHJpbmcgPSBjcmVhdGUoe1xuICBkZWZhdWx0OiAnJyxcbiAgY29lcmNlOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX3V0aWxfdG9fbnVsbF9vcl9zdHJpbmdfX1tcImFcIiAvKiBkZWZhdWx0ICovXSxcbiAgZGVzZXJpYWxpemU6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fdXRpbF90b19udWxsX29yX3N0cmluZ19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLFxuICBzZXJpYWxpemU6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fdXRpbF90b19udWxsX29yX3N0cmluZ19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dXG59KTtcblxudmFyIG9iamVjdCA9IGNyZWF0ZSh7XG4gIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIHJldHVybiB7fTtcbiAgfSxcbiAgZGVzZXJpYWxpemU6IHBhcnNlSWZOb3RFbXB0eSxcbiAgc2VyaWFsaXplOiBKU09OLnN0cmluZ2lmeVxufSk7XG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX191dGlsX3N5bWJvbHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX191dGlsX2RhdGFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gZnVuY3Rpb24gKGVsZW0sIGRvbmUpIHtcbiAgdmFyIGluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX191dGlsX2RhdGFfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoZWxlbSk7XG4gIGlmIChlbGVtW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fdXRpbF9zeW1ib2xzX19bXCJjXCIgLyogY3JlYXRlZCAqL11dKSB7XG4gICAgZG9uZShlbGVtKTtcbiAgfSBlbHNlIGlmIChpbmZvLnJlYWR5Q2FsbGJhY2tzKSB7XG4gICAgaW5mby5yZWFkeUNhbGxiYWNrcy5wdXNoKGRvbmUpO1xuICB9IGVsc2Uge1xuICAgIGluZm8ucmVhZHlDYWxsYmFja3MgPSBbZG9uZV07XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX191dGlsX3N5bWJvbHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJuYW1lXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX191dGlsX3N5bWJvbHNfX1tcImJcIl07IH0pO1xuLy8gREVQUkVDVEFFRFxuLy9cbi8vIFdlIHNob3VsZCBub3QgYmUgcmVseWluZyBvbiBpbnRlcm5hbHMgZm9yIHN5bWJvbHMgYXMgdGhpcyBjcmVhdGVzIHZlcnNpb25cbi8vIGNvdXBsaW5nLiBXZSB3aWxsIG1vdmUgZm9yd2FyZCB3aXRoIHBsYXRmb3JtIGFnbm9zdGljIHdheXMgb2YgZG9pbmcgdGhpcy5cblxuXG4vKioqLyB9KSxcbi8qIDIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9pbmNyZW1lbnRhbF9kb21fXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9pbmNyZW1lbnRhbF9kb21fX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9pbmNyZW1lbnRhbF9kb21fXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX191dGlsX3N5bWJvbHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX191dGlsX3Byb3BfY29udGV4dF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX191dGlsX3Jvb3RfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG4vKiBoYXJtb255IGV4cG9ydCAoaW1tdXRhYmxlKSAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZWxlbWVudFwiXSA9IGVsZW1lbnQ7XG4vKiBoYXJtb255IGV4cG9ydCAoaW1tdXRhYmxlKSAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYnVpbGRlclwiXSA9IGJ1aWxkZXI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYXR0clwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG5ld0F0dHI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVsZW1lbnRDbG9zZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG5ld0VsZW1lbnRDbG9zZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZWxlbWVudE9wZW5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBuZXdFbGVtZW50T3BlbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZWxlbWVudE9wZW5FbmRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBuZXdFbGVtZW50T3BlbkVuZDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZWxlbWVudE9wZW5TdGFydFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG5ld0VsZW1lbnRPcGVuU3RhcnQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVsZW1lbnRWb2lkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3RWxlbWVudFZvaWQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInRleHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBuZXdUZXh0OyB9KTtcbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8qIGVzbGludCBuby1wbHVzcGx1czogMCAqL1xuXG5cblxuXG5cblxudmFyIGN1c3RvbUVsZW1lbnRzID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX191dGlsX3Jvb3RfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5jdXN0b21FbGVtZW50cyxcbiAgICBIVE1MRWxlbWVudCA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fdXRpbF9yb290X19bXCJhXCIgLyogZGVmYXVsdCAqL10uSFRNTEVsZW1lbnQ7XG5cbnZhciBhcHBseURlZmF1bHQgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfaW5jcmVtZW50YWxfZG9tX19bXCJhdHRyaWJ1dGVzXCJdW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9pbmNyZW1lbnRhbF9kb21fX1tcInN5bWJvbHNcIl0uZGVmYXVsdF07XG5cbi8vIEEgc3RhY2sgb2YgY2hpbGRyZW4gdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgY3VycmVudCBmdW5jdGlvbiBoZWxwZXIgYmVpbmdcbi8vIGV4ZWN1dGVkLlxudmFyIHN0YWNrQ2hyZW4gPSBbXTtcblxudmFyICRza2lwID0gJ19fc2tpcCc7XG52YXIgJGN1cnJlbnRFdmVudEhhbmRsZXJzID0gJ19fZXZlbnRzJztcbnZhciAkc3RhY2tDdXJyZW50SGVscGVyUHJvcHMgPSAnX19wcm9wcyc7XG5cbi8vIFRoZSBjdXJyZW50IGZ1bmN0aW9uIGhlbHBlciBpbiB0aGUgc3RhY2suXG52YXIgc3RhY2tDdXJyZW50SGVscGVyID0gdm9pZCAwO1xuXG4vLyBUaGlzIGlzIHVzZWQgZm9yIHRoZSBJbmNyZW1lbnRhbCBET00gb3ZlcnJpZGVzIHRvIGtlZXAgdHJhY2sgb2Ygd2hhdCBhcmdzXG4vLyB0byBwYXNzIHRoZSBtYWluIGVsZW1lbnRPcGVuKCkgZnVuY3Rpb24uXG52YXIgb3ZlcnJpZGVBcmdzID0gdm9pZCAwO1xuXG4vLyBUaGUgbnVtYmVyIG9mIGxldmVscyBkZWVwIGFmdGVyIHNraXBwaW5nIGEgdHJlZS5cbnZhciBza2lwcyA9IDA7XG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG4vLyBBZGRzIG9yIHJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIGFuIGVsZW1lbnQuXG5mdW5jdGlvbiBhcHBseUV2ZW50KGVsZW0sIGVuYW1lLCBuZXdGdW5jKSB7XG4gIHZhciBldmVudHMgPSBlbGVtWyRjdXJyZW50RXZlbnRIYW5kbGVyc107XG5cbiAgaWYgKCFldmVudHMpIHtcbiAgICBldmVudHMgPSBlbGVtWyRjdXJyZW50RXZlbnRIYW5kbGVyc10gPSB7fTtcbiAgfVxuXG4gIC8vIFVuZGVmaW5lZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBubyBsaXN0ZW5lciB5ZXQuXG4gIGlmICh0eXBlb2YgZXZlbnRzW2VuYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBXZSBvbmx5IGFkZCBhIHNpbmdsZSBsaXN0ZW5lciBvbmNlLiBPcmlnaW5hbGx5IHRoaXMgd2FzIGEgd29ya2Fyb3VuZCBmb3JcbiAgICAvLyB0aGUgV2ViY29tcG9uZW50cyBTaGFkeURPTSBwb2x5ZmlsbCBub3QgcmVtb3ZpbmcgbGlzdGVuZXJzLCBidXQgaXQnc1xuICAgIC8vIGFsc28gYSBzaW1wbGVyIG1vZGVsIGZvciBiaW5kaW5nIC8gdW5iaW5kaW5nIGV2ZW50cyBiZWNhdXNlIHlvdSBvbmx5XG4gICAgLy8gaGF2ZSBhIHNpbmdsZSBoYW5kbGVyIHlvdSBuZWVkIHRvIHdvcnJ5IGFib3V0IGFuZCBhIHNpbmdsZSBwbGFjZSB3aGVyZVxuICAgIC8vIHlvdSBvbmx5IHN0b3JlIG9uZSBldmVudCBoYW5kbGVyXG4gICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKGVuYW1lLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGV2ZW50c1tlbmFtZV0pIHtcbiAgICAgICAgZXZlbnRzW2VuYW1lXS5jYWxsKHRoaXMsIGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gTm90IHVuZGVmaW5lZCBpbmRpY2F0ZXMgdGhhdCB3ZSBoYXZlIHNldCBhIGxpc3RlbmVyLCBzbyBkZWZhdWx0IHRvIG51bGwuXG4gIGV2ZW50c1tlbmFtZV0gPSB0eXBlb2YgbmV3RnVuYyA9PT0gJ2Z1bmN0aW9uJyA/IG5ld0Z1bmMgOiBudWxsO1xufVxuXG52YXIgYXR0cmlidXRlc0NvbnRleHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX191dGlsX3Byb3BfY29udGV4dF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfaW5jcmVtZW50YWxfZG9tX19bXCJhdHRyaWJ1dGVzXCJdLCBfZGVmaW5lUHJvcGVydHkoe1xuICAvLyBBdHRyaWJ1dGVzIHRoYXQgc2hvdWxkbid0IGJlIGFwcGxpZWQgdG8gdGhlIERPTS5cbiAga2V5OiBub29wLFxuICBzdGF0aWNzOiBub29wLFxuXG4gIC8vIEF0dHJpYnV0ZXMgdGhhdCAqbXVzdCogYmUgc2V0IHZpYSBhIHByb3BlcnR5IG9uIGFsbCBlbGVtZW50cy5cbiAgY2hlY2tlZDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2luY3JlbWVudGFsX2RvbV9fW1wiYXBwbHlQcm9wXCJdLFxuICBjbGFzc05hbWU6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9pbmNyZW1lbnRhbF9kb21fX1tcImFwcGx5UHJvcFwiXSxcbiAgZGlzYWJsZWQ6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9pbmNyZW1lbnRhbF9kb21fX1tcImFwcGx5UHJvcFwiXSxcbiAgdmFsdWU6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9pbmNyZW1lbnRhbF9kb21fX1tcImFwcGx5UHJvcFwiXSxcblxuICAvLyBSZWYgaGFuZGxlci5cbiAgcmVmOiBmdW5jdGlvbiByZWYoZWxlbSwgbmFtZSwgdmFsdWUpIHtcbiAgICBlbGVtW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fdXRpbF9zeW1ib2xzX19bXCJhXCIgLyogcmVmICovXV0gPSB2YWx1ZTtcbiAgfSxcblxuXG4gIC8vIFNraXAgaGFuZGxlci5cbiAgc2tpcDogZnVuY3Rpb24gc2tpcChlbGVtLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZWxlbVskc2tpcF0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgZWxlbVskc2tpcF07XG4gICAgfVxuICB9XG59LCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfaW5jcmVtZW50YWxfZG9tX19bXCJzeW1ib2xzXCJdLmRlZmF1bHQsIGZ1bmN0aW9uIChlbGVtLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgY2UgPSBjdXN0b21FbGVtZW50cy5nZXQoZWxlbS5sb2NhbE5hbWUpO1xuICB2YXIgcHJvcHMgPSBjZSAmJiBjZS5wcm9wcyB8fCB7fTtcbiAgdmFyIHByb3RvdHlwZSA9IGNlICYmIGNlLnByb3RvdHlwZSB8fCB7fTtcblxuICAvLyBUT0RPIHdoZW4gcmVmYWN0b3JpbmcgcHJvcGVydGllcyB0byBub3QgaGF2ZSB0byB3b3JrYXJvdW5kIHRoZSBvbGRcbiAgLy8gV2ViS2l0IGJ1ZyB3ZSBjYW4gcmVtb3ZlIHRoZSBcIm5hbWUgaW4gcHJvcHNcIiBjaGVjayBiZWxvdy5cbiAgLy9cbiAgLy8gTk9URTogVGhhdCB0aGUgXCJuYW1lIGluIGVsZW1cIiBjaGVjayB3b24ndCB3b3JrIGZvciBwb2x5ZmlsbGVkIGN1c3RvbVxuICAvLyBlbGVtZW50cyB0aGF0IHNldCBhIHByb3BlcnR5IHRoYXQgaXNuJ3QgZXhwbGljaXRseSBzcGVjaWZpZWQgaW4gXCJwcm9wc1wiXG4gIC8vIG9yIFwicHJvdG90eXBlXCIgdW5sZXNzIGl0IGlzIGFkZGVkIHRvIHRoZSBlbGVtZW50IGV4cGxpY2l0bHkgYXMgYVxuICAvLyBwcm9wZXJ0eSBwcmlvciB0byBwYXNzaW5nIHRoZSBwcm9wIHRvIHRoZSB2ZG9tIGZ1bmN0aW9uLiBGb3IgZXhhbXBsZSwgaWZcbiAgLy8gaXQgd2VyZSBhZGRlZCBpbiBhIGxpZmVjeWNsZSBjYWxsYmFjayBiZWNhdXNlIGl0IHdvdWxkbid0IGhhdmUgYmVlblxuICAvLyB1cGdyYWRlZCB5ZXQuXG4gIC8vXG4gIC8vIFdlIHByZWZlciBzZXR0aW5nIHByb3BzLCBzbyB3ZSBkbyB0aGlzIGlmIHRoZXJlJ3MgYSBwcm9wZXJ0eSBtYXRjaGluZ1xuICAvLyBuYW1lIHRoYXQgd2FzIHBhc3NlZC4gSG93ZXZlciwgY2VydGFpbiBwcm9wcyBvbiBTVkcgZWxlbWVudHMgYXJlXG4gIC8vIHJlYWRvbmx5IGFuZCBlcnJvciB3aGVuIHlvdSB0cnkgdG8gc2V0IHRoZW0uXG4gIGlmICgobmFtZSBpbiBwcm9wcyB8fCBuYW1lIGluIGVsZW0gfHwgbmFtZSBpbiBwcm90b3R5cGUpICYmICEoJ293bmVyU1ZHRWxlbWVudCcgaW4gZWxlbSkpIHtcbiAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2luY3JlbWVudGFsX2RvbV9fW1wiYXBwbHlQcm9wXCJdKShlbGVtLCBuYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRXhwbGljaXQgZmFsc2UgcmVtb3ZlcyB0aGUgYXR0cmlidXRlLlxuICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgYXBwbHlEZWZhdWx0KGVsZW0sIG5hbWUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEhhbmRsZSBidWlsdC1pbiBhbmQgY3VzdG9tIGV2ZW50cy5cbiAgaWYgKG5hbWUuaW5kZXhPZignb24nKSA9PT0gMCkge1xuICAgIHZhciBmaXJzdENoYXIgPSBuYW1lWzJdO1xuICAgIHZhciBldmVudE5hbWUgPSB2b2lkIDA7XG5cbiAgICBpZiAoZmlyc3RDaGFyID09PSAnLScpIHtcbiAgICAgIGV2ZW50TmFtZSA9IG5hbWUuc3Vic3RyaW5nKDMpO1xuICAgIH0gZWxzZSBpZiAoZmlyc3RDaGFyID09PSBmaXJzdENoYXIudG9VcHBlckNhc2UoKSkge1xuICAgICAgZXZlbnROYW1lID0gZmlyc3RDaGFyLnRvTG93ZXJDYXNlKCkgKyBuYW1lLnN1YnN0cmluZygzKTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnROYW1lKSB7XG4gICAgICBhcHBseUV2ZW50KGVsZW0sIGV2ZW50TmFtZSwgdmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGFwcGx5RGVmYXVsdChlbGVtLCBuYW1lLCB2YWx1ZSk7XG59KSk7XG5cbmZ1bmN0aW9uIHJlc29sdmVUYWdOYW1lKG5hbWUpIHtcbiAgLy8gV2UgcmV0dXJuIGZhbHN5IHZhbHVlcyBhcyBzb21lIHdyYXBwZWQgSURPTSBmdW5jdGlvbnMgYWxsb3cgZW1wdHkgdmFsdWVzLlxuICBpZiAoIW5hbWUpIHtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuXG4gIC8vIFdlIHRyeSBhbmQgcmV0dXJuIHRoZSBjYWNoZWQgdGFnIG5hbWUsIGlmIG9uZSBleGlzdHMuIFRoaXMgd2lsbCB3b3JrIHdpdGhcbiAgLy8gKmFueSogd2ViIGNvbXBvbmVudCBvZiBhbnkgdmVyc2lvbiB0aGF0IGRlZmluZXMgYSBgc3RhdGljIGlzYCBwcm9wZXJ0eS5cbiAgaWYgKG5hbWUuaXMpIHtcbiAgICByZXR1cm4gbmFtZS5pcztcbiAgfVxuXG4gIC8vIEdldCB0aGUgbmFtZSBmb3IgdGhlIGN1c3RvbSBlbGVtZW50IGJ5IGNvbnN0cnVjdGluZyBpdCBhbmQgdXNpbmcgdGhlXG4gIC8vIGxvY2FsTmFtZSBwcm9wZXJ0eS4gQ2FjaGUgaXQgYW5kIGxvb2t1cCB0aGUgY2FjaGVkIHZhbHVlIGZvciBmdXR1cmUgY2FsbHMuXG4gIGlmIChuYW1lLnByb3RvdHlwZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgaWYgKG5hbWVbX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX191dGlsX3N5bWJvbHNfX1tcImJcIiAvKiBuYW1lICovXV0pIHtcbiAgICAgIHJldHVybiBuYW1lW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fdXRpbF9zeW1ib2xzX19bXCJiXCIgLyogbmFtZSAqL11dO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHZhciBlbGVtID0gbmV3IG5hbWUoKTtcbiAgICByZXR1cm4gZWxlbVtfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3V0aWxfc3ltYm9sc19fW1wiYlwiIC8qIG5hbWUgKi9dXSA9IGVsZW0ubG9jYWxOYW1lO1xuICB9XG5cbiAgLy8gUGFzcyBhbGwgb3RoZXIgdmFsdWVzIHRocm91Z2ggc28gSURPTSBnZXRzIHdoYXQgaXQncyBleHBlY3RpbmcuXG4gIHJldHVybiBuYW1lO1xufVxuXG4vLyBJbmNyZW1lbnRhbCBET00ncyBlbGVtZW50T3BlbiBpcyB3aGVyZSB0aGUgaG9va3MgaW4gYGF0dHJpYnV0ZXNgIGFyZSBhcHBsaWVkLFxuLy8gc28gaXQncyB0aGUgb25seSBmdW5jdGlvbiB3ZSBuZWVkIHRvIGV4ZWN1dGUgaW4gdGhlIGNvbnRleHQgb2Ygb3VyIGF0dHJpYnV0ZXMuXG52YXIgZWxlbWVudE9wZW4gPSBhdHRyaWJ1dGVzQ29udGV4dChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfaW5jcmVtZW50YWxfZG9tX19bXCJlbGVtZW50T3BlblwiXSk7XG5cbmZ1bmN0aW9uIGVsZW1lbnRPcGVuU3RhcnQodGFnKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gIHZhciBzdGF0aWNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuXG4gIG92ZXJyaWRlQXJncyA9IFt0YWcsIGtleSwgc3RhdGljc107XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRPcGVuRW5kKCkge1xuICB2YXIgbm9kZSA9IG5ld0VsZW1lbnRPcGVuLmFwcGx5KHVuZGVmaW5lZCwgX3RvQ29uc3VtYWJsZUFycmF5KG92ZXJyaWRlQXJncykpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gIG92ZXJyaWRlQXJncyA9IG51bGw7XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiB3cmFwSWRvbUZ1bmMoZnVuYykge1xuICB2YXIgdG5hbWVGdW5jSGFuZGxlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbm9vcDtcblxuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBhcmdzWzBdID0gcmVzb2x2ZVRhZ05hbWUoYXJnc1swXSk7XG4gICAgc3RhY2tDdXJyZW50SGVscGVyID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIElmIHdlJ3ZlIGVuY291bnRlcmVkIGEgZnVuY3Rpb24sIGhhbmRsZSBpdCBhY2NvcmRpbmcgdG8gdGhlIHR5cGUgb2ZcbiAgICAgIC8vIGZ1bmN0aW9uIHRoYXQgaXMgYmVpbmcgd3JhcHBlZC5cbiAgICAgIHN0YWNrQ3VycmVudEhlbHBlciA9IGFyZ3NbMF07XG4gICAgICByZXR1cm4gdG5hbWVGdW5jSGFuZGxlci5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAoc3RhY2tDaHJlbi5sZW5ndGgpIHtcbiAgICAgIC8vIFdlIHBhc3MgdGhlIHdyYXAoKSBmdW5jdGlvbiBpbiBoZXJlIHNvIHRoYXQgd2hlbiBpdCdzIGNhbGxlZCBhc1xuICAgICAgLy8gY2hpbGRyZW4sIGl0IHdpbGwgcXVldWUgdXAgZm9yIHRoZSBuZXh0IHN0YWNrLCBpZiB0aGVyZSBpcyBvbmUuXG4gICAgICBzdGFja0NocmVuW3N0YWNrQ2hyZW4ubGVuZ3RoIC0gMV0ucHVzaChbd3JhcCwgYXJnc10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZnVuYyA9PT0gZWxlbWVudE9wZW4pIHtcbiAgICAgICAgaWYgKHNraXBzKSB7XG4gICAgICAgICAgcmV0dXJuICsrc2tpcHM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxlbSA9IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcblxuICAgICAgICBpZiAoZWxlbVskc2tpcF0pIHtcbiAgICAgICAgICArK3NraXBzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICB9XG5cbiAgICAgIGlmIChmdW5jID09PSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfaW5jcmVtZW50YWxfZG9tX19bXCJlbGVtZW50Q2xvc2VcIl0pIHtcbiAgICAgICAgaWYgKHNraXBzID09PSAxKSB7XG4gICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9pbmNyZW1lbnRhbF9kb21fX1tcInNraXBcIl0pKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gc2tpcCBjbG9zaW5nIGlmIGl0J3Mgbm90IHRoZSBsYXN0IGNsb3NpbmcgdGFnIGluIHRoZVxuICAgICAgICAvLyBza2lwcGVkIHRyZWUgYmVjYXVzZSB3ZSBrZWVwIHRoZSBlbGVtZW50IHRoYXQgaW5pdGlhdGVkIHRoZSBza3BwaW5nLlxuICAgICAgICBpZiAoc2tpcHMgJiYgLS1za2lwcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfZWxlbSA9IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgdmFyIHJlZiA9IF9lbGVtW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fdXRpbF9zeW1ib2xzX19bXCJhXCIgLyogcmVmICovXV07XG5cbiAgICAgICAgLy8gV2UgZGVsZXRlIHNvIHRoYXQgaXQgaXNuJ3QgY2FsbGVkIGFnYWluIGZvciB0aGUgc2FtZSBlbGVtZW50LiBJZiB0aGVcbiAgICAgICAgLy8gcmVmIGNoYW5nZXMsIG9yIHRoZSBlbGVtZW50IGNoYW5nZXMsIHRoaXMgd2lsbCBiZSBkZWZpbmVkIGFnYWluLlxuICAgICAgICBkZWxldGUgX2VsZW1bX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX191dGlsX3N5bWJvbHNfX1tcImFcIiAvKiByZWYgKi9dXTtcblxuICAgICAgICAvLyBFeGVjdXRlIHRoZSBzYXZlZCByZWYgYWZ0ZXIgZXN1cmluZyB3ZSd2ZSBjbGVhbmQgdXAgYWZ0ZXIgaXQuXG4gICAgICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmVmKF9lbGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfZWxlbTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgbXVzdCBjYWxsIGVsZW1lbnRPcGVuU3RhcnQgYW5kIGVsZW1lbnRPcGVuRW5kIGV2ZW4gaWYgd2UgYXJlXG4gICAgICAvLyBza2lwcGluZyBiZWNhdXNlIHRoZXkgcXVldWUgdXAgYXR0cmlidXRlcyBhbmQgdGhlbiBjYWxsIGVsZW1lbnRDbG9zZS5cbiAgICAgIGlmICghc2tpcHMgfHwgZnVuYyA9PT0gZWxlbWVudE9wZW5TdGFydCB8fCBmdW5jID09PSBlbGVtZW50T3BlbkVuZCkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbmV3QXR0cigpIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cblxuICBpZiAoc3RhY2tDdXJyZW50SGVscGVyKSB7XG4gICAgc3RhY2tDdXJyZW50SGVscGVyWyRzdGFja0N1cnJlbnRIZWxwZXJQcm9wc11bYXJnc1swXV0gPSBhcmdzWzFdO1xuICB9IGVsc2UgaWYgKHN0YWNrQ2hyZW4ubGVuZ3RoKSB7XG4gICAgc3RhY2tDaHJlbltzdGFja0NocmVuLmxlbmd0aCAtIDFdLnB1c2goW25ld0F0dHIsIGFyZ3NdKTtcbiAgfSBlbHNlIHtcbiAgICBvdmVycmlkZUFyZ3MucHVzaChhcmdzWzBdKTtcbiAgICBvdmVycmlkZUFyZ3MucHVzaChhcmdzWzFdKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFja09wZW4odG5hbWUsIGtleSwgc3RhdGljcykge1xuICB2YXIgcHJvcHMgPSB7IGtleToga2V5LCBzdGF0aWNzOiBzdGF0aWNzIH07XG5cbiAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhdHRycyA9IEFycmF5KF9sZW4zID4gMyA/IF9sZW4zIC0gMyA6IDApLCBfa2V5MyA9IDM7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICBhdHRyc1tfa2V5MyAtIDNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgfVxuXG4gIGZvciAodmFyIGEgPSAwOyBhIDwgYXR0cnMubGVuZ3RoOyBhICs9IDIpIHtcbiAgICBwcm9wc1thdHRyc1thXV0gPSBhdHRyc1thICsgMV07XG4gIH1cbiAgdG5hbWVbJHN0YWNrQ3VycmVudEhlbHBlclByb3BzXSA9IHByb3BzO1xuICBzdGFja0NocmVuLnB1c2goW10pO1xufVxuXG5mdW5jdGlvbiBzdGFja0Nsb3NlKHRuYW1lKSB7XG4gIHZhciBjaHJlbiA9IHN0YWNrQ2hyZW4ucG9wKCk7XG4gIHZhciBwcm9wcyA9IHRuYW1lWyRzdGFja0N1cnJlbnRIZWxwZXJQcm9wc107XG4gIGRlbGV0ZSB0bmFtZVskc3RhY2tDdXJyZW50SGVscGVyUHJvcHNdO1xuICB2YXIgZWxlbU9yRm4gPSB0bmFtZShwcm9wcywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjaHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICByZXR1cm4gYXJnc1swXS5hcHBseShhcmdzLCBfdG9Db25zdW1hYmxlQXJyYXkoYXJnc1sxXSkpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHR5cGVvZiBlbGVtT3JGbiA9PT0gJ2Z1bmN0aW9uJyA/IGVsZW1PckZuKCkgOiBlbGVtT3JGbjtcbn1cblxuLy8gSW5jcmVtZW50YWwgRE9NIG92ZXJyaWRlc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBXZSBtdXN0IG92ZXJyaWRlIGludGVybmFsIGZ1bmN0aW9ucyB0aGF0IGNhbGwgaW50ZXJuYWwgSW5jcmVtZW50YWwgRE9NXG4vLyBmdW5jdGlvbnMgYmVjYXVzZSB3ZSBjYW4ndCBvdmVycmlkZSB0aGUgaW50ZXJuYWwgcmVmZXJlbmNlcy4gVGhpcyBtZWFuc1xuLy8gd2UgbXVzdCByb3VnaGx5IHJlLWltcGxlbWVudCB0aGVpciBiZWhhdmlvdXIuIEx1Y2tpbHksIHRoZXkncmUgZmFpcmx5XG4vLyBzaW1wbGUuXG52YXIgbmV3RWxlbWVudE9wZW5TdGFydCA9IHdyYXBJZG9tRnVuYyhlbGVtZW50T3BlblN0YXJ0LCBzdGFja09wZW4pO1xudmFyIG5ld0VsZW1lbnRPcGVuRW5kID0gd3JhcElkb21GdW5jKGVsZW1lbnRPcGVuRW5kKTtcblxuLy8gU3RhbmRhcmQgb3BlbiAvIGNsb3NlZCBvdmVycmlkZXMgZG9uJ3QgbmVlZCB0byByZXByb2R1Y2UgaW50ZXJuYWwgYmVoYXZpb3VyXG4vLyBiZWNhdXNlIHRoZXkgYXJlIHRoZSBvbmVzIHJlZmVyZW5jZWQgZnJvbSAqRW5kIGFuZCAqU3RhcnQuXG52YXIgbmV3RWxlbWVudE9wZW4gPSB3cmFwSWRvbUZ1bmMoZWxlbWVudE9wZW4sIHN0YWNrT3Blbik7XG52YXIgbmV3RWxlbWVudENsb3NlID0gd3JhcElkb21GdW5jKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9pbmNyZW1lbnRhbF9kb21fX1tcImVsZW1lbnRDbG9zZVwiXSwgc3RhY2tDbG9zZSk7XG5cbi8vIEVuc3VyZSB3ZSBjYWxsIG91ciBvdmVycmlkZGVuIGZ1bmN0aW9ucyBpbnN0ZWFkIG9mIHRoZSBpbnRlcm5hbCBvbmVzLlxuZnVuY3Rpb24gbmV3RWxlbWVudFZvaWQodGFnKSB7XG4gIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW40ID4gMSA/IF9sZW40IC0gMSA6IDApLCBfa2V5NCA9IDE7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICBhcmdzW19rZXk0IC0gMV0gPSBhcmd1bWVudHNbX2tleTRdO1xuICB9XG5cbiAgbmV3RWxlbWVudE9wZW4uYXBwbHkodW5kZWZpbmVkLCBbdGFnXS5jb25jYXQoYXJncykpO1xuICByZXR1cm4gbmV3RWxlbWVudENsb3NlKHRhZyk7XG59XG5cbi8vIFRleHQgb3ZlcnJpZGUgZW5zdXJlcyB0aGVpciBjYWxscyBjYW4gcXVldWUgaWYgdXNpbmcgZnVuY3Rpb24gaGVscGVycy5cbnZhciBuZXdUZXh0ID0gd3JhcElkb21GdW5jKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9pbmNyZW1lbnRhbF9kb21fX1tcInRleHRcIl0pO1xuXG4vLyBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgZGVjbGFyaW5nIGFuIEluY3JlbWVudGFsIERPTSBlbGVtZW50IHVzaW5nXG4vLyBoeXBlcnNjcmlwdC1zdHlsZSBzeW50YXguXG5mdW5jdGlvbiBlbGVtZW50KHRuYW1lLCBhdHRycykge1xuICB2YXIgYXR5cGUgPSB0eXBlb2YgYXR0cnMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGF0dHJzKTtcblxuICAvLyBJZiBhdHRyaWJ1dGVzIGFyZSBhIGZ1bmN0aW9uLCB0aGVuIHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgY2hpbGRyZW4uXG5cbiAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBjaHJlbiA9IEFycmF5KF9sZW41ID4gMiA/IF9sZW41IC0gMiA6IDApLCBfa2V5NSA9IDI7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICBjaHJlbltfa2V5NSAtIDJdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgfVxuXG4gIGlmIChhdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCBhdHlwZSA9PT0gJ3N0cmluZycgfHwgYXR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgY2hyZW4udW5zaGlmdChhdHRycyk7XG4gIH1cblxuICAvLyBFbnN1cmUgdGhlIGF0dHJpYnV0ZXMgYXJlIGFuIG9iamVjdC4gTnVsbCBpcyBjb25zaWRlcmVkIGFuIG9iamVjdCBzbyB3ZVxuICAvLyBoYXZlIHRvIHRlc3QgZm9yIHRoaXMgZXhwbGljaXRseS5cbiAgaWYgKGF0dHJzID09PSBudWxsIHx8IGF0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgIGF0dHJzID0ge307XG4gIH1cblxuICAvLyBXZSBvcGVuIHRoZSBlbGVtZW50IHNvIHdlIGNhbiBzZXQgYXR0cnMgYWZ0ZXIuXG4gIG5ld0VsZW1lbnRPcGVuU3RhcnQodG5hbWUsIGF0dHJzLmtleSwgYXR0cnMuc3RhdGljcyk7XG5cbiAgLy8gRGVsZXRlIHNvIHNwZWNpYWwgYXR0cnMgZG9uJ3QgYWN0dWFsbHkgZ2V0IHNldC5cbiAgZGVsZXRlIGF0dHJzLmtleTtcbiAgZGVsZXRlIGF0dHJzLnN0YXRpY3M7XG5cbiAgLy8gU2V0IGF0dHJpYnV0ZXMuXG4gIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIG5ld0F0dHIobmFtZSwgYXR0cnNbbmFtZV0pO1xuICB9KTtcblxuICAvLyBDbG9zZSBiZWZvcmUgd2UgcmVuZGVyIHRoZSBkZXNjZW5kYW50IHRyZWUuXG4gIG5ld0VsZW1lbnRPcGVuRW5kKHRuYW1lKTtcblxuICBjaHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaCkge1xuICAgIHZhciBjdHlwZSA9IHR5cGVvZiBjaCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY2gpO1xuICAgIGlmIChjdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2goKTtcbiAgICB9IGVsc2UgaWYgKGN0eXBlID09PSAnc3RyaW5nJyB8fCBjdHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIG5ld1RleHQoY2gpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjaCkpIHtcbiAgICAgIGNoLmZvckVhY2goZnVuY3Rpb24gKHNjaCkge1xuICAgICAgICByZXR1cm4gc2NoKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBuZXdFbGVtZW50Q2xvc2UodG5hbWUpO1xufVxuXG4vLyBFdmVuIGZ1cnRoZXIgY29udmVuaWVuY2UgZm9yIGJ1aWxkaW5nIGEgRFNMIG91dCBvZiBKYXZhU2NyaXB0IGZ1bmN0aW9ucyBvciBob29raW5nIGludG8gc3RhbmRhcmRcbi8vIHRyYW5zcGlsZXMgZm9yIEpTWCAoUmVhY3QuY3JlYXRlRWxlbWVudCgpIC8gaCkuXG5mdW5jdGlvbiBidWlsZGVyKCkge1xuICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIHRhZ3MgPSBBcnJheShfbGVuNiksIF9rZXk2ID0gMDsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgIHRhZ3NbX2tleTZdID0gYXJndW1lbnRzW19rZXk2XTtcbiAgfVxuXG4gIGlmICh0YWdzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuNyksIF9rZXk3ID0gMDsgX2tleTcgPCBfbGVuNzsgX2tleTcrKykge1xuICAgICAgICBhcmdzW19rZXk3XSA9IGFyZ3VtZW50c1tfa2V5N107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVtZW50LmJpbmQuYXBwbHkoZWxlbWVudCwgW251bGxdLmNvbmNhdChhcmdzKSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gdGFncy5tYXAoZnVuY3Rpb24gKHRhZykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuOCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuOCksIF9rZXk4ID0gMDsgX2tleTggPCBfbGVuODsgX2tleTgrKykge1xuICAgICAgICBhcmdzW19rZXk4XSA9IGFyZ3VtZW50c1tfa2V5OF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVtZW50LmJpbmQuYXBwbHkoZWxlbWVudCwgW251bGwsIHRhZ10uY29uY2F0KGFyZ3MpKTtcbiAgICB9O1xuICB9KTtcbn1cblxuLy8gV2UgZG9uJ3QgaGF2ZSB0byBkbyBhbnl0aGluZyBzcGVjaWFsIGZvciB0aGUgdGV4dCBmdW5jdGlvbjsgaXQncyBqdXN0IGFcbi8vIHN0cmFpZ2h0IGV4cG9ydCBmcm9tIEluY3JlbWVudGFsIERPTS5cblxuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fdXRpbF9zeW1ib2xzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fdXRpbF9kYXRhX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fdXRpbF9lbXB0eV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX3V0aWxfYXR0cmlidXRlc19tYW5hZ2VyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fdXRpbF9nZXRfZGVmYXVsdF92YWx1ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X191dGlsX2dldF9pbml0aWFsX3ZhbHVlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX3V0aWxfZ2V0X3Byb3BfZGF0YV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG4vKiBoYXJtb255IGV4cG9ydCAoaW1tdXRhYmxlKSAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IGNyZWF0ZU5hdGl2ZVByb3BlcnR5RGVzY3JpcHRvcjtcblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBjcmVhdGVOYXRpdmVQcm9wZXJ0eURlc2NyaXB0b3IocHJvcERlZikge1xuICB2YXIgbmFtZU9yU3ltYm9sID0gcHJvcERlZi5uYW1lT3JTeW1ib2w7XG5cblxuICB2YXIgcHJvcCA9IHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9O1xuXG4gIHByb3AuYmVmb3JlRGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgIHZhciBwcm9wRGF0YSA9IF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX3V0aWxfZ2V0X3Byb3BfZGF0YV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShlbGVtLCBuYW1lT3JTeW1ib2wpO1xuICAgIHZhciBhdHRyU291cmNlID0gcHJvcERlZi5hdHRyU291cmNlO1xuXG4gICAgLy8gU3RvcmUgYXR0clNvdXJjZSBuYW1lIHRvIHByb3BlcnR5IGxpbmsuXG4gICAgaWYgKGF0dHJTb3VyY2UpIHtcbiAgICAgIF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3V0aWxfZGF0YV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShlbGVtLCAnYXR0clNvdXJjZUxpbmtzJylbYXR0clNvdXJjZV0gPSBuYW1lT3JTeW1ib2w7XG4gICAgfVxuXG4gICAgLy8gcHJvcCB2YWx1ZSBiZWZvcmUgdXBncmFkaW5nXG4gICAgdmFyIGluaXRpYWxWYWx1ZSA9IGVsZW1bbmFtZU9yU3ltYm9sXTtcblxuICAgIC8vIFNldCB1cCBpbml0aWFsIHZhbHVlIGlmIGl0IHdhc24ndCBzcGVjaWZpZWQuXG4gICAgdmFyIHZhbHVlRnJvbUF0dHJTb3VyY2UgPSBmYWxzZTtcbiAgICBpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fdXRpbF9lbXB0eV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShpbml0aWFsVmFsdWUpKSB7XG4gICAgICBpZiAoYXR0clNvdXJjZSAmJiBlbGVtLmhhc0F0dHJpYnV0ZShhdHRyU291cmNlKSkge1xuICAgICAgICB2YWx1ZUZyb21BdHRyU291cmNlID0gdHJ1ZTtcbiAgICAgICAgaW5pdGlhbFZhbHVlID0gcHJvcERlZi5kZXNlcmlhbGl6ZShlbGVtLmdldEF0dHJpYnV0ZShhdHRyU291cmNlKSk7XG4gICAgICB9IGVsc2UgaWYgKCdpbml0aWFsJyBpbiBwcm9wRGVmKSB7XG4gICAgICAgIGluaXRpYWxWYWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX3V0aWxfZ2V0X2luaXRpYWxfdmFsdWVfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoZWxlbSwgcHJvcERlZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0aWFsVmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X191dGlsX2dldF9kZWZhdWx0X3ZhbHVlX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKGVsZW0sIHByb3BEZWYpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluaXRpYWxWYWx1ZSA9IHByb3BEZWYuY29lcmNlKGluaXRpYWxWYWx1ZSk7XG5cbiAgICBwcm9wRGF0YS5pbnRlcm5hbFZhbHVlID0gaW5pdGlhbFZhbHVlO1xuXG4gICAgLy8gUmVmbGVjdCB0byBUYXJnZXQgQXR0cmlidXRlXG4gICAgdmFyIG11c3RSZWZsZWN0ID0gcHJvcERlZi5hdHRyVGFyZ2V0ICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX191dGlsX2VtcHR5X19bXCJhXCIgLyogZGVmYXVsdCAqL10pKGluaXRpYWxWYWx1ZSkgJiYgKCF2YWx1ZUZyb21BdHRyU291cmNlIHx8IHByb3BEZWYuYXR0clRhcmdldElzTm90U291cmNlKTtcblxuICAgIGlmIChtdXN0UmVmbGVjdCkge1xuICAgICAgdmFyIHNlcmlhbGl6ZWRWYWx1ZSA9IHByb3BEZWYuc2VyaWFsaXplKGluaXRpYWxWYWx1ZSk7XG4gICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX191dGlsX2F0dHJpYnV0ZXNfbWFuYWdlcl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShlbGVtKS5zZXRBdHRyVmFsdWUocHJvcERlZi5hdHRyVGFyZ2V0LCBzZXJpYWxpemVkVmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBwcm9wLmdldCA9IGZ1bmN0aW9uIGdldCgpIHtcbiAgICB2YXIgcHJvcERhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X191dGlsX2dldF9wcm9wX2RhdGFfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkodGhpcywgbmFtZU9yU3ltYm9sKTtcbiAgICB2YXIgaW50ZXJuYWxWYWx1ZSA9IHByb3BEYXRhLmludGVybmFsVmFsdWU7XG5cbiAgICByZXR1cm4gcHJvcERlZi5nZXQgPyBwcm9wRGVmLmdldCh0aGlzLCB7IG5hbWU6IG5hbWVPclN5bWJvbCwgaW50ZXJuYWxWYWx1ZTogaW50ZXJuYWxWYWx1ZSB9KSA6IGludGVybmFsVmFsdWU7XG4gIH07XG5cbiAgcHJvcC5zZXQgPSBmdW5jdGlvbiBzZXQobmV3VmFsdWUpIHtcbiAgICB2YXIgcHJvcERhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X191dGlsX2dldF9wcm9wX2RhdGFfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkodGhpcywgbmFtZU9yU3ltYm9sKTtcblxuICAgIHZhciB1c2VEZWZhdWx0VmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX191dGlsX2VtcHR5X19bXCJhXCIgLyogZGVmYXVsdCAqL10pKG5ld1ZhbHVlKTtcbiAgICBpZiAodXNlRGVmYXVsdFZhbHVlKSB7XG4gICAgICBuZXdWYWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX3V0aWxfZ2V0X2RlZmF1bHRfdmFsdWVfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkodGhpcywgcHJvcERlZik7XG4gICAgfVxuXG4gICAgbmV3VmFsdWUgPSBwcm9wRGVmLmNvZXJjZShuZXdWYWx1ZSk7XG5cbiAgICBpZiAocHJvcERlZi5zZXQpIHtcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHByb3BEYXRhLm9sZFZhbHVlO1xuXG5cbiAgICAgIGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX191dGlsX2VtcHR5X19bXCJhXCIgLyogZGVmYXVsdCAqL10pKG9sZFZhbHVlKSkge1xuICAgICAgICBvbGRWYWx1ZSA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgY2hhbmdlRGF0YSA9IHsgbmFtZTogbmFtZU9yU3ltYm9sLCBuZXdWYWx1ZTogbmV3VmFsdWUsIG9sZFZhbHVlOiBvbGRWYWx1ZSB9O1xuICAgICAgcHJvcERlZi5zZXQodGhpcywgY2hhbmdlRGF0YSk7XG4gICAgfVxuXG4gICAgLy8gUXVldWUgYSByZS1yZW5kZXIuXG4gICAgdGhpc1tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3V0aWxfc3ltYm9sc19fW1wiaVwiIC8qIHJlbmRlcmVyRGVib3VuY2VkICovXV0odGhpcyk7XG5cbiAgICAvLyBVcGRhdGUgcHJvcCBkYXRhIHNvIHdlIGNhbiB1c2UgaXQgbmV4dCB0aW1lLlxuICAgIHByb3BEYXRhLmludGVybmFsVmFsdWUgPSBwcm9wRGF0YS5vbGRWYWx1ZSA9IG5ld1ZhbHVlO1xuXG4gICAgLy8gUmVmbGVjdCB0byBUYXJnZXQgYXR0cmlidXRlLlxuICAgIHZhciBtdXN0UmVmbGVjdCA9IHByb3BEZWYuYXR0clRhcmdldCAmJiAocHJvcERlZi5hdHRyVGFyZ2V0SXNOb3RTb3VyY2UgfHwgIXByb3BEYXRhLnNldHRpbmdQcm9wRnJvbUF0dHJTb3VyY2UpO1xuICAgIGlmIChtdXN0UmVmbGVjdCkge1xuICAgICAgLy8gTm90ZTogc2V0dGluZyB0aGUgcHJvcCB0byBlbXB0eSBpbXBsaWVzIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAgICAvLyBhbmQgdGhlcmVmb3JlIG5vIGF0dHJpYnV0ZSBzaG91bGQgYmUgcHJlc2VudCFcbiAgICAgIHZhciBzZXJpYWxpemVkVmFsdWUgPSB1c2VEZWZhdWx0VmFsdWUgPyBudWxsIDogcHJvcERlZi5zZXJpYWxpemUobmV3VmFsdWUpO1xuICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fdXRpbF9hdHRyaWJ1dGVzX21hbmFnZXJfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkodGhpcykuc2V0QXR0clZhbHVlKHByb3BEZWYuYXR0clRhcmdldCwgc2VyaWFsaXplZFZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHByb3A7XG59XG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFBvbHlmaWxsIE9iamVjdC5pcyBmb3IgSUVcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5pZiAoIU9iamVjdC5pcykge1xuICBPYmplY3QuaXMgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH07XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gT2JqZWN0LmlzO1xuXG4vKioqLyB9KSxcbi8qIDI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSBjcmVhdGVTeW1ib2w7XG5mdW5jdGlvbiBjcmVhdGVTeW1ib2woZGVzY3JpcHRpb24pIHtcbiAgcmV0dXJuIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgPyBTeW1ib2woZGVzY3JpcHRpb24pIDogZGVzY3JpcHRpb247XG59XG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KC8oW0EtWl0pLykucmVkdWNlKGZ1bmN0aW9uIChvbmUsIHR3bywgaWR4KSB7XG4gICAgdmFyIGRhc2ggPSAhb25lIHx8IGlkeCAlIDIgPT09IDAgPyAnJyA6ICctJztcbiAgICByZXR1cm4gJycgKyBvbmUgKyBkYXNoICsgdHdvLnRvTG93ZXJDYXNlKCk7XG4gIH0pO1xufTtcblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX25hdGl2ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19yb290X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cblxuXG5cbnZhciBNdXRhdGlvbk9ic2VydmVyID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19yb290X19bXCJhXCIgLyogZGVmYXVsdCAqL10uTXV0YXRpb25PYnNlcnZlcjtcblxuXG5mdW5jdGlvbiBtaWNyb3Rhc2tEZWJvdW5jZShjYkZ1bmMpIHtcbiAgdmFyIHNjaGVkdWxlZCA9IGZhbHNlO1xuICB2YXIgaSA9IDA7XG4gIHZhciBjYkFyZ3MgPSBbXTtcbiAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uICgpIHtcbiAgICBjYkZ1bmMuYXBwbHkodW5kZWZpbmVkLCBfdG9Db25zdW1hYmxlQXJyYXkoY2JBcmdzKSk7XG4gICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgY2JBcmdzID0gbnVsbDtcbiAgfSk7XG5cbiAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtLCB7IGNoaWxkTGlzdDogdHJ1ZSB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGNiQXJncyA9IGFyZ3M7XG4gICAgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICAgIHNjaGVkdWxlZCA9IHRydWU7XG4gICAgICBlbGVtLnRleHRDb250ZW50ID0gJycgKyBpO1xuICAgICAgaSArPSAxO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gV2UgaGF2ZSB0byB1c2Ugc2V0VGltZW91dCgpIGZvciBJRTkgYW5kIDEwIGJlY2F1c2UgdGhlIE11dGF0aW9uIE9ic2VydmVyXG4vLyBwb2x5ZmlsbCByZXF1aXJlcyB0aGF0IHRoZSBlbGVtZW50IGJlIGluIHRoZSBkb2N1bWVudCB0byB0cmlnZ2VyIE11dGF0aW9uXG4vLyBFdmVudHMuIE11dGF0aW9uIEV2ZW50cyBhcmUgYWxzbyBzeW5jaHJvbm91cyBhbmQgdGh1cyB3b3VsZG4ndCBkZWJvdW5jZS5cbi8vXG4vLyBUaGUgc29vbmVzdCB3ZSBjYW4gc2V0IHRoZSB0aW1lb3V0IGZvciBpbiBJRSBpcyAxIGFzIHRoZXkgaGF2ZSBpc3N1ZXMgd2hlblxuLy8gc2V0dGluZyB0byAwLlxuZnVuY3Rpb24gdGFza0RlYm91bmNlKGNiRnVuYykge1xuICB2YXIgc2NoZWR1bGVkID0gZmFsc2U7XG4gIHZhciBjYkFyZ3MgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIGNiQXJncyA9IGFyZ3M7XG4gICAgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICAgIHNjaGVkdWxlZCA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIGNiRnVuYy5hcHBseSh1bmRlZmluZWQsIF90b0NvbnN1bWFibGVBcnJheShjYkFyZ3MpKTtcbiAgICAgIH0sIDEpO1xuICAgIH1cbiAgfTtcbn1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19uYXRpdmVfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoTXV0YXRpb25PYnNlcnZlcikgPyBtaWNyb3Rhc2tEZWJvdW5jZSA6IHRhc2tEZWJvdW5jZTtcblxuLyoqKi8gfSksXG4vKiAyOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gZXJyb3I7XG5mdW5jdGlvbiBlcnJvcihtZXNzYWdlKSB7XG4gIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gZ2V0RGVmYXVsdFZhbHVlO1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFZhbHVlKGVsZW0sIHByb3BEZWYpIHtcbiAgcmV0dXJuIHR5cGVvZiBwcm9wRGVmLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgPyBwcm9wRGVmLmRlZmF1bHQoZWxlbSwgeyBuYW1lOiBwcm9wRGVmLm5hbWVPclN5bWJvbCB9KSA6IHByb3BEZWYuZGVmYXVsdDtcbn1cblxuLyoqKi8gfSksXG4vKiAzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gZ2V0SW5pdGlhbFZhbHVlO1xuZnVuY3Rpb24gZ2V0SW5pdGlhbFZhbHVlKGVsZW0sIHByb3BEZWYpIHtcbiAgcmV0dXJuIHR5cGVvZiBwcm9wRGVmLmluaXRpYWwgPT09ICdmdW5jdGlvbicgPyBwcm9wRGVmLmluaXRpYWwoZWxlbSwgeyBuYW1lOiBwcm9wRGVmLm5hbWVPclN5bWJvbCB9KSA6IHByb3BEZWYuaW5pdGlhbDtcbn1cblxuLyoqKi8gfSksXG4vKiAzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2dldF9wcm9wX25hbWVzX2FuZF9zeW1ib2xzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvYmogPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19nZXRfcHJvcF9uYW1lc19hbmRfc3ltYm9sc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShvYmopLnJlZHVjZShmdW5jdGlvbiAocHJldiwgbmFtZU9yU3ltYm9sKSB7XG4gICAgcHJldltuYW1lT3JTeW1ib2xdID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIG5hbWVPclN5bWJvbCk7XG4gICAgcmV0dXJuIHByZXY7XG4gIH0sIHt9KTtcbn07XG5cbi8qKiovIH0pLFxuLyogMzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19kYXRhX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSBnZXRQcm9wRGF0YTtcblxuXG5mdW5jdGlvbiBnZXRQcm9wRGF0YShlbGVtLCBuYW1lKSB7XG4gIHZhciBlbGVtRGF0YSA9IF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2RhdGFfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoZWxlbSwgJ3Byb3BzJyk7XG4gIHJldHVybiBlbGVtRGF0YVtuYW1lXSB8fCAoZWxlbURhdGFbbmFtZV0gPSB7fSk7XG59XG5cbi8qKiovIH0pLFxuLyogMzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbmF0aXZlSGludHMgPSBbJ25hdGl2ZSBjb2RlJywgJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXScgLy8gZm9yIG1vYmlsZSBzYWZhcmkgaU9TIDkuMFxuXTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIG5hdGl2ZUhpbnRzLm1hcChmdW5jdGlvbiAoaGludCkge1xuICAgIHJldHVybiAoZm4gfHwgJycpLnRvU3RyaW5nKCkuaW5kZXhPZihbaGludF0pID4gLTE7XG4gIH0pLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhIHx8IGI7XG4gIH0pO1xufTtcblxuLyoqKi8gfSksXG4vKiAzNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2Fzc2lnbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuXG5mdW5jdGlvbiBlbnRlcihvYmplY3QsIHByb3BzKSB7XG4gIHZhciBzYXZlZCA9IHt9O1xuICBPYmplY3Qua2V5cyhwcm9wcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgc2F2ZWRba2V5XSA9IG9iamVjdFtrZXldO1xuICAgIG9iamVjdFtrZXldID0gcHJvcHNba2V5XTtcbiAgfSk7XG4gIHJldHVybiBzYXZlZDtcbn1cblxuZnVuY3Rpb24gZXhpdChvYmplY3QsIHNhdmVkKSB7XG4gIF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2Fzc2lnbl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShvYmplY3QsIHNhdmVkKTtcbn1cblxuLy8gRGVjb3JhdGVzIGEgZnVuY3Rpb24gd2l0aCBhIHNpZGUgZWZmZWN0IHRoYXQgY2hhbmdlcyB0aGUgcHJvcGVydGllcyBvZiBhblxuLy8gb2JqZWN0IGR1cmluZyBpdHMgZXhlY3V0aW9uLCBhbmQgcmVzdG9yZXMgdGhlbSBhZnRlci4gVGhlcmUgaXMgbm8gZXJyb3Jcbi8vIGhhbmRsaW5nIGhlcmUsIGlmIHRoZSB3cmFwcGVkIGZ1bmN0aW9uIHRocm93cyBhbiBlcnJvciwgcHJvcGVydGllcyBhcmUgbm90XG4vLyByZXN0b3JlZCBhbmQgYWxsIGJldHMgYXJlIG9mZi5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSBmdW5jdGlvbiAob2JqZWN0LCBwcm9wcykge1xuICByZXR1cm4gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNhdmVkID0gZW50ZXIob2JqZWN0LCBwcm9wcyk7XG4gICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgICBleGl0KG9iamVjdCwgc2F2ZWQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xufTtcblxuLyoqKi8gfSksXG4vKiAzNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2Rhc2hfY2FzZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19lbXB0eV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX2Vycm9yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2lzX3R5cGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5cblxuXG5cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIFByb3BlcnR5IERlZmluaXRpb25cbiAqXG4gKiBJbnRlcm5hbCBtZXRhIGRhdGEgYW5kIHN0cmF0ZWdpZXMgZm9yIGEgcHJvcGVydHkuXG4gKiBDcmVhdGVkIGZyb20gdGhlIG9wdGlvbnMgb2YgYSBQcm9wT3B0aW9ucyBjb25maWcgb2JqZWN0LlxuICpcbiAqIE9uY2UgY3JlYXRlZCBhIFByb3BEZWZpbml0aW9uIHNob3VsZCBiZSB0cmVhdGVkIGFzIGltbXV0YWJsZSBhbmQgZmluYWwuXG4gKiAnZ2V0UHJvcHNNYXAnIGZ1bmN0aW9uIG1lbW9pemVzIFByb3BEZWZpbml0aW9ucyBieSBDb21wb25lbnQncyBDbGFzcy5cbiAqXG4gKiBUaGUgJ2F0dHJpYnV0ZScgb3B0aW9uIGlzIG5vcm1hbGl6ZWQgdG8gJ2F0dHJTb3VyY2UnIGFuZCAnYXR0clRhcmdldCcgcHJvcGVydGllcy5cbiAqL1xuXG52YXIgUHJvcERlZmluaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByb3BEZWZpbml0aW9uKG5hbWVPclN5bWJvbCwgcHJvcE9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByb3BEZWZpbml0aW9uKTtcblxuICAgIHRoaXMuX25hbWVPclN5bWJvbCA9IG5hbWVPclN5bWJvbDtcblxuICAgIHByb3BPcHRpb25zID0gcHJvcE9wdGlvbnMgfHwge307XG5cbiAgICAvLyBkZWZhdWx0ICdhdHRyU291cmNlJzogbm8gb2JzZXJ2ZWQgc291cmNlIGF0dHJpYnV0ZSAobmFtZSlcbiAgICB0aGlzLmF0dHJTb3VyY2UgPSBudWxsO1xuXG4gICAgLy8gZGVmYXVsdCAnYXR0clRhcmdldCc6IG5vIHJlZmxlY3RlZCB0YXJnZXQgYXR0cmlidXRlIChuYW1lKVxuICAgIHRoaXMuYXR0clRhcmdldCA9IG51bGw7XG5cbiAgICAvLyBkZWZhdWx0ICdhdHRyVGFyZ2V0SXNOb3RTb3VyY2UnXG4gICAgdGhpcy5hdHRyVGFyZ2V0SXNOb3RTb3VyY2UgPSBmYWxzZTtcblxuICAgIC8vIGRlZmF1bHQgJ2NvZXJjZSc6IGlkZW50aXR5IGZ1bmN0aW9uXG4gICAgdGhpcy5jb2VyY2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgLy8gZGVmYXVsdCAnZGVmYXVsdCc6IHNldCBwcm9wIHRvICdudWxsJ1xuICAgIHRoaXMuZGVmYXVsdCA9IG51bGw7XG5cbiAgICAvLyBkZWZhdWx0ICdkZXNlcmlhbGl6ZSc6IHJldHVybiBhdHRyaWJ1dGUncyB2YWx1ZSAoc3RyaW5nIG9yIG51bGwpXG4gICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICAvLyBkZWZhdWx0ICdnZXQnOiBubyBmdW5jdGlvblxuICAgIHRoaXMuZ2V0ID0gbnVsbDtcblxuICAgIC8vICdpbml0aWFsJyBkZWZhdWx0OiB1bnNwZWNpZmllZFxuICAgIC8vICdpbml0aWFsJyBvcHRpb24gaXMgdHJ1bHkgb3B0aW9uYWwgYW5kIGl0IGNhbm5vdCBiZSBpbml0aWFsaXplZC5cbiAgICAvLyBJdHMgcHJlc2VuY2UgaXMgdGVzdGVkIHVzaW5nOiAoJ2luaXRpYWwnIGluIHByb3BEZWYpXG5cbiAgICAvLyAnc2VyaWFsaXplJyBkZWZhdWx0OiByZXR1cm4gc3RyaW5nIHZhbHVlIG9yIG51bGxcbiAgICB0aGlzLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2VtcHR5X19bXCJhXCIgLyogZGVmYXVsdCAqL10pKHZhbHVlKSA/IG51bGwgOiBTdHJpbmcodmFsdWUpO1xuICAgIH07XG5cbiAgICAvLyBkZWZhdWx0ICdzZXQnOiBubyBmdW5jdGlvblxuICAgIHRoaXMuc2V0ID0gbnVsbDtcblxuICAgIC8vIE5vdGU6IG9wdGlvbiBrZXkgaXMgYWx3YXlzIGEgc3RyaW5nIChubyBzeW1ib2xzIGhlcmUpXG4gICAgT2JqZWN0LmtleXMocHJvcE9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgdmFyIG9wdFZhbCA9IHByb3BPcHRpb25zW29wdGlvbl07XG5cbiAgICAgIC8vIE9ubHkgYWNjZXB0IGRvY3VtZW50ZWQgb3B0aW9ucyBhbmQgcGVyZm9ybSBtaW5pbWFsIGlucHV0IHZhbGlkYXRpb24uXG4gICAgICBzd2l0Y2ggKG9wdGlvbikge1xuICAgICAgICBjYXNlICdhdHRyaWJ1dGUnOlxuICAgICAgICAgIGlmICghX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19faXNfdHlwZV9fW1wiY1wiIC8qIGlzT2JqZWN0ICovXSkob3B0VmFsKSkge1xuICAgICAgICAgICAgX3RoaXMuYXR0clNvdXJjZSA9IF90aGlzLmF0dHJUYXJnZXQgPSByZXNvbHZlQXR0ck5hbWUob3B0VmFsLCBuYW1lT3JTeW1ib2wpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gb3B0VmFsLnNvdXJjZSxcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBvcHRWYWwudGFyZ2V0O1xuXG4gICAgICAgICAgICBpZiAoIXNvdXJjZSAmJiAhdGFyZ2V0KSB7XG4gICAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX2Vycm9yX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKG9wdGlvbiArICcgXFwnc291cmNlXFwnIG9yIFxcJ3RhcmdldFxcJyBpcyBtaXNzaW5nLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuYXR0clNvdXJjZSA9IHJlc29sdmVBdHRyTmFtZShzb3VyY2UsIG5hbWVPclN5bWJvbCk7XG4gICAgICAgICAgICBfdGhpcy5hdHRyVGFyZ2V0ID0gcmVzb2x2ZUF0dHJOYW1lKHRhcmdldCwgbmFtZU9yU3ltYm9sKTtcbiAgICAgICAgICAgIF90aGlzLmF0dHJUYXJnZXRJc05vdFNvdXJjZSA9IF90aGlzLmF0dHJUYXJnZXQgIT09IF90aGlzLmF0dHJTb3VyY2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjb2VyY2UnOlxuICAgICAgICBjYXNlICdkZXNlcmlhbGl6ZSc6XG4gICAgICAgIGNhc2UgJ2dldCc6XG4gICAgICAgIGNhc2UgJ3NlcmlhbGl6ZSc6XG4gICAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgICAgaWYgKF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2lzX3R5cGVfX1tcImFcIiAvKiBpc0Z1bmN0aW9uICovXSkob3B0VmFsKSkge1xuICAgICAgICAgICAgX3RoaXNbb3B0aW9uXSA9IG9wdFZhbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fZXJyb3JfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkob3B0aW9uICsgJyBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkZWZhdWx0JzpcbiAgICAgICAgY2FzZSAnaW5pdGlhbCc6XG4gICAgICAgICAgX3RoaXNbb3B0aW9uXSA9IG9wdFZhbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBUT0RPOiB1bmRvY3VtZW50ZWQgb3B0aW9ucz9cbiAgICAgICAgICBfdGhpc1tvcHRpb25dID0gb3B0VmFsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFByb3BEZWZpbml0aW9uLCBbe1xuICAgIGtleTogJ25hbWVPclN5bWJvbCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbmFtZU9yU3ltYm9sO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQcm9wRGVmaW5pdGlvbjtcbn0oKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IFByb3BEZWZpbml0aW9uO1xuXG5cbmZ1bmN0aW9uIHJlc29sdmVBdHRyTmFtZShhdHRyT3B0aW9uLCBuYW1lT3JTeW1ib2wpIHtcbiAgaWYgKF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2lzX3R5cGVfX1tcImRcIiAvKiBpc1N5bWJvbCAqL10pKG5hbWVPclN5bWJvbCkpIHtcbiAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19lcnJvcl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShuYW1lT3JTeW1ib2wudG9TdHJpbmcoKSArICcgc3ltYm9sIHByb3BlcnR5IGNhbm5vdCBoYXZlIGFuIGF0dHJpYnV0ZS4nKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoYXR0ck9wdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2Rhc2hfY2FzZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShTdHJpbmcobmFtZU9yU3ltYm9sKSk7XG4gICAgfVxuICAgIGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19pc190eXBlX19bXCJlXCIgLyogaXNTdHJpbmcgKi9dKShhdHRyT3B0aW9uKSkge1xuICAgICAgcmV0dXJuIGF0dHJPcHRpb247XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKioqLyB9KSxcbi8qIDM2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSB1bmlxdWVJZDtcbi8vIERFUFJFQ0FURUQgcHJlZml4IHdoZW4gd2UgZGVwcmVjYXRlZCB0aGUgbmFtZSBhcmd1bWVudCB0byBkZWZpbmUoKVxuZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2NyZWF0ZS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdC8yMTE3NTIzIzIxMTc1MjNcbiAgdmFyIHJhbmQgPSAneHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1peGVkLW9wZXJhdG9yc1xuICAgIHZhciB2ID0gYyA9PT0gJ3gnID8gciA6IHIgJiAweDMgfCAweDg7XG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICB9KTtcbiAgcmV0dXJuIChwcmVmaXggfHwgJ3gnKSArICctJyArIHJhbmQ7XG59XG5cbi8qKiovIH0pLFxuLyogMzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cbi8qKiovIH0pLFxuLyogMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwibW9kdWxlIiwidGhpcyIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiZXhwb3J0cyIsImlkIiwibG9hZGVkIiwiY2FsbCIsIm0iLCJjIiwicCIsInNoaW0iLCJwb2x5ZmlsbCIsIl93aW5kb3ciLCJ3aW5kb3ciLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJzYWZhcmkiLCJpbmRleE9mIiwic2FmYXJpVmVyc2lvbiIsIm1hdGNoIiwic2FmYXJpVmVyc2lvbnMiLCJtYXAiLCJ2IiwiY29uY2F0IiwiU2hhZHlET00iLCJmb3JjZSIsImRlZmluZSIsImltcGxlbWVudGF0aW9uIiwiZ2V0UG9seWZpbGwiLCJib3VuZEZyb21TaGltIiwiZnJvbSIsImFycmF5IiwiYXBwbHkiLCJBcnJheSIsImFyZ3VtZW50cyIsIl90eXBlb2YiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm9iaiIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwia2V5cyIsImZvcmVhY2giLCJoYXNTeW1ib2xzIiwidG9TdHIiLCJPYmplY3QiLCJ0b1N0cmluZyIsImlzRnVuY3Rpb24iLCJmbiIsImFyZVByb3BlcnR5RGVzY3JpcHRvcnNTdXBwb3J0ZWQiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIl8iLCJ4IiwiZSIsInN1cHBvcnRzRGVzY3JpcHRvcnMiLCJvYmplY3QiLCJuYW1lIiwicHJlZGljYXRlIiwiZGVmaW5lUHJvcGVydGllcyIsInByZWRpY2F0ZXMiLCJsZW5ndGgiLCJwcm9wcyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImhhcyIsImhhc093blByb3BlcnR5Iiwic2xpY2UiLCJpc0FyZ3MiLCJpc0VudW1lcmFibGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImhhc0RvbnRFbnVtQnVnIiwiaGFzUHJvdG9FbnVtQnVnIiwiZG9udEVudW1zIiwiZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUiLCJvIiwiY3RvciIsImV4Y2x1ZGVkS2V5cyIsImhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1ZyIsImsiLCJlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kiLCJrZXlzU2hpbSIsImlzT2JqZWN0IiwiaXNBcmd1bWVudHMiLCJpc1N0cmluZyIsInRoZUtleXMiLCJUeXBlRXJyb3IiLCJza2lwUHJvdG8iLCJpIiwicHVzaCIsIlN0cmluZyIsImoiLCJza2lwQ29uc3RydWN0b3IiLCJzaGltT2JqZWN0S2V5cyIsImtleXNXb3Jrc1dpdGhBcmd1bWVudHMiLCJvcmlnaW5hbEtleXMiLCJzdHIiLCJjYWxsZWUiLCJoYXNPd24iLCJmb3JFYWNoIiwiY3R4IiwibCIsIkVTIiwiYXJyYXlMaWtlIiwicHV0Iiwia2V5IiwiZGVzY3JpcHRvciIsIkMiLCJpdGVtcyIsIlRvT2JqZWN0IiwibWFwRm4iLCJUIiwiSXNDYWxsYWJsZSIsImxlbiIsIlRvTGVuZ3RoIiwiQSIsImtWYWx1ZSIsIm1hcHBlZFZhbHVlIiwiQ2FsbCIsInN5bWJvbFRvU3RyIiwiJGlzTmFOIiwiJGlzRmluaXRlIiwiTUFYX1NBRkVfSU5URUdFUiIsIk51bWJlciIsIk1hdGgiLCJwb3ciLCJhc3NpZ24iLCJzaWduIiwibW9kIiwiaXNQcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsInBhcnNlSW50ZWdlciIsInBhcnNlSW50IiwiYmluZCIsInN0clNsaWNlIiwiRnVuY3Rpb24iLCJpc0JpbmFyeSIsIlJlZ0V4cCIsInRlc3QiLCJpc09jdGFsIiwibm9uV1MiLCJqb2luIiwibm9uV1NyZWdleCIsImhhc05vbldTIiwiaW52YWxpZEhleExpdGVyYWwiLCJpc0ludmFsaWRIZXhMaXRlcmFsIiwid3MiLCJ0cmltUmVnZXgiLCJyZXBsYWNlIiwidHJpbSIsIkVTNSIsImhhc1JlZ0V4cE1hdGNoZXIiLCJFUzYiLCJGIiwiViIsImFyZ3MiLCJUb051bWJlciIsImFyZ3VtZW50IiwiTmFOIiwidHJpbW1lZCIsIlRvSW50MTYiLCJpbnQxNmJpdCIsIlRvVWludDE2IiwiVG9JbnQ4IiwiaW50OGJpdCIsIlRvVWludDgiLCJudW1iZXIiLCJwb3NJbnQiLCJmbG9vciIsImFicyIsIlRvVWludDhDbGFtcCIsImYiLCJUb1N0cmluZyIsIlJlcXVpcmVPYmplY3RDb2VyY2libGUiLCJUb1Byb3BlcnR5S2V5IiwiVG9QcmltaXRpdmUiLCJUb0ludGVnZXIiLCJDYW5vbmljYWxOdW1lcmljSW5kZXhTdHJpbmciLCJuIiwiU2FtZVZhbHVlIiwiQ2hlY2tPYmplY3RDb2VyY2libGUiLCJpc0FycmF5IiwiSXNBcnJheSIsIklzQ29uc3RydWN0b3IiLCJJc0V4dGVuc2libGUiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsImlzRXh0ZW5zaWJsZSIsIklzSW50ZWdlciIsIklzUHJvcGVydHlLZXkiLCJJc1JlZ0V4cCIsImlzUmVnRXhwIiwiVG9Cb29sZWFuIiwiU2FtZVZhbHVlWmVybyIsInkiLCJUeXBlIiwiU3BlY2llc0NvbnN0cnVjdG9yIiwiTyIsImRlZmF1bHRDb25zdHJ1Y3RvciIsIlMiLCJzcGVjaWVzIiwidW5kZWZpbmVkIiwiaXNOYU4iLCJhIiwiaXNGaW5pdGUiLCJJbmZpbml0eSIsInRhcmdldCIsInNvdXJjZSIsIm1vZHVsbyIsInJlbWFpbiIsImlzQ2FsbGFibGUiLCJpc0RhdGUiLCJpc1N5bWJvbCIsIm9yZGluYXJ5VG9QcmltaXRpdmUiLCJPcmRpbmFyeVRvUHJpbWl0aXZlIiwiaGludCIsIm1ldGhvZE5hbWVzIiwibWV0aG9kIiwicmVzdWx0IiwiR2V0TWV0aG9kIiwiUCIsImZ1bmMiLCJpbnB1dCIsIlByZWZlcnJlZFR5cGUiLCJleG90aWNUb1ByaW0iLCJ2YWx1ZU9mIiwiZm5Ub1N0ciIsImNvbnN0cnVjdG9yUmVnZXgiLCJpc0VTNkNsYXNzRm4iLCJmblN0ciIsInNpbmdsZVN0cmlwcGVkIiwibXVsdGlTdHJpcHBlZCIsInNwYWNlU3RyaXBwZWQiLCJ0cnlGdW5jdGlvbk9iamVjdCIsImZuQ2xhc3MiLCJnZW5DbGFzcyIsImhhc1RvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJzdHJDbGFzcyIsImdldERheSIsIkRhdGUiLCJ0cnlEYXRlT2JqZWN0IiwiZGF0ZUNsYXNzIiwiaXNEYXRlT2JqZWN0Iiwic3ltVG9TdHIiLCJzeW1TdHJpbmdSZWdleCIsImlzU3ltYm9sT2JqZWN0IiwiRVJST1JfTUVTU0FHRSIsImZ1bmNUeXBlIiwidGhhdCIsImJvdW5kIiwiYmluZGVyIiwiYm91bmRMZW5ndGgiLCJtYXgiLCJib3VuZEFyZ3MiLCJFbXB0eSIsIkJvb2xlYW4iLCJUb0ludDMyIiwiVG9VaW50MzIiLCJvcHRNZXNzYWdlIiwiRVM1aW50ZXJuYWxTbG90cyIsIkRlZmF1bHRWYWx1ZSIsImFjdHVhbEhpbnQiLCJtZXRob2RzIiwicmVnZXhFeGVjIiwiZXhlYyIsInRyeVJlZ2V4RXhlYyIsInJlZ2V4Q2xhc3MiLCJpc1JlZ2V4IiwidHJ5Q2FsbCIsImltcGxlbWVudGVkIiwic2hpbUFycmF5RnJvbSIsImNhbkJlT2JqZWN0IiwidG9PYmplY3QiLCJwcm9wSXNFbnVtZXJhYmxlIiwib3JpZ2luYWxHZXRTeW1ib2xzIiwic291cmNlMSIsIm9ialRhcmdldCIsInMiLCJzeW1zIiwiZ2V0U3ltYm9scyIsInN5bSIsInN5bU9iaiIsInN5bVZhbCIsImdldE93blByb3BlcnR5TmFtZXMiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJsYWNrc1Byb3BlckVudW1lcmF0aW9uT3JkZXIiLCJsZXR0ZXJzIiwic3BsaXQiLCJhY3R1YWwiLCJhc3NpZ25IYXNQZW5kaW5nRXhjZXB0aW9ucyIsInRocm93ZXIiLCJzaGltQXNzaWduIiwicmVxdWlyZSIsIl9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyIsIl9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fIiwicHJvY2VzcyIsImdsb2JhbCIsIm9iamVjdE9yRnVuY3Rpb24iLCJfaXNBcnJheSIsInZlcnR4TmV4dCIsImN1c3RvbVNjaGVkdWxlckZuIiwiYXNhcCIsImNhbGxiYWNrIiwiYXJnIiwiZmx1c2giLCJzZXRTY2hlZHVsZXIiLCJzY2hlZHVsZUZuIiwic2V0QXNhcCIsImFzYXBGbiIsImJyb3dzZXJXaW5kb3ciLCJicm93c2VyR2xvYmFsIiwiQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwiV2ViS2l0TXV0YXRpb25PYnNlcnZlciIsImlzTm9kZSIsInNlbGYiLCJpc1dvcmtlciIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiaW1wb3J0U2NyaXB0cyIsIk1lc3NhZ2VDaGFubmVsIiwidXNlTmV4dFRpY2siLCJuZXh0VGljayIsInVzZVZlcnR4VGltZXIiLCJ1c2VTZXRUaW1lb3V0IiwidXNlTXV0YXRpb25PYnNlcnZlciIsIml0ZXJhdGlvbnMiLCJvYnNlcnZlciIsIm5vZGUiLCJkb2N1bWVudCIsImNyZWF0ZVRleHROb2RlIiwib2JzZXJ2ZSIsImNoYXJhY3RlckRhdGEiLCJkYXRhIiwidXNlTWVzc2FnZUNoYW5uZWwiLCJjaGFubmVsIiwicG9ydDEiLCJvbm1lc3NhZ2UiLCJwb3J0MiIsInBvc3RNZXNzYWdlIiwiZ2xvYmFsU2V0VGltZW91dCIsInNldFRpbWVvdXQiLCJxdWV1ZSIsImF0dGVtcHRWZXJ0eCIsInIiLCJ2ZXJ0eCIsInJ1bk9uTG9vcCIsInJ1bk9uQ29udGV4dCIsInNjaGVkdWxlRmx1c2giLCJ0aGVuIiwib25GdWxmaWxsbWVudCIsIm9uUmVqZWN0aW9uIiwiX2FyZ3VtZW50cyIsInBhcmVudCIsImNoaWxkIiwibm9vcCIsIlBST01JU0VfSUQiLCJfc3RhdGUiLCJpbnZva2VDYWxsYmFjayIsIl9yZXN1bHQiLCJyZXNvbHZlIiwiQ29uc3RydWN0b3IiLCJwcm9taXNlIiwicmFuZG9tIiwic3Vic3RyaW5nIiwiUEVORElORyIsIkZVTEZJTExFRCIsIlJFSkVDVEVEIiwiR0VUX1RIRU5fRVJST1IiLCJFcnJvck9iamVjdCIsInNlbGZGdWxmaWxsbWVudCIsImNhbm5vdFJldHVybk93biIsImdldFRoZW4iLCJlcnJvciIsInRyeVRoZW4iLCJmdWxmaWxsbWVudEhhbmRsZXIiLCJyZWplY3Rpb25IYW5kbGVyIiwiaGFuZGxlRm9yZWlnblRoZW5hYmxlIiwidGhlbmFibGUiLCJzZWFsZWQiLCJyZWFzb24iLCJfbGFiZWwiLCJoYW5kbGVPd25UaGVuYWJsZSIsIl9yZXNvbHZlIiwiX3JlamVjdCIsImhhbmRsZU1heWJlVGhlbmFibGUiLCJtYXliZVRoZW5hYmxlIiwidGhlbiQkIiwicHVibGlzaFJlamVjdGlvbiIsIl9vbmVycm9yIiwiZnVsZmlsbCIsIl9zdWJzY3JpYmVycyIsInB1Ymxpc2giLCJzdWJzY3JpYmUiLCJzdWJzY3JpYmVycyIsInNldHRsZWQiLCJkZXRhaWwiLCJUUllfQ0FUQ0hfRVJST1IiLCJ0cnlDYXRjaCIsImhhc0NhbGxiYWNrIiwic3VjY2VlZGVkIiwiZmFpbGVkIiwiaW5pdGlhbGl6ZVByb21pc2UiLCJyZXNvbHZlciIsInJlc29sdmVQcm9taXNlIiwicmVqZWN0UHJvbWlzZSIsIm5leHRJZCIsIm1ha2VQcm9taXNlIiwiRW51bWVyYXRvciIsIl9pbnN0YW5jZUNvbnN0cnVjdG9yIiwiX2lucHV0IiwiX3JlbWFpbmluZyIsIl9lbnVtZXJhdGUiLCJ2YWxpZGF0aW9uRXJyb3IiLCJFcnJvciIsIl9lYWNoRW50cnkiLCJlbnRyeSIsInJlc29sdmUkJCIsIl90aGVuIiwiX3NldHRsZWRBdCIsIlByb21pc2UiLCJfd2lsbFNldHRsZUF0Iiwic3RhdGUiLCJlbnVtZXJhdG9yIiwiYWxsIiwiZW50cmllcyIsInJhY2UiLCJyZWplY3QiLCJuZWVkc1Jlc29sdmVyIiwibmVlZHNOZXciLCJfc2V0U2NoZWR1bGVyIiwiX3NldEFzYXAiLCJfYXNhcCIsIl9jYXRjaCIsImxvY2FsIiwicHJvbWlzZVRvU3RyaW5nIiwiY2FzdCIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiZGVmYXVsdENsZWFyVGltZW91dCIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJkcmFpblF1ZXVlIiwidGltZW91dCIsInJ1biIsIkl0ZW0iLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJiaW5kaW5nIiwiY3dkIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayIsImN1c3RvbUVsZW1lbnRzIiwiZXZhbCIsIm5lZWRzVGVtcGxhdGUiLCJIVE1MVGVtcGxhdGVFbGVtZW50IiwiTmF0aXZlX2ltcG9ydE5vZGUiLCJEb2N1bWVudCIsImltcG9ydE5vZGUiLCJub2RlVHlwZSIsIk5vZGUiLCJET0NVTUVOVF9GUkFHTUVOVF9OT0RFIiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsImFwcGVuZENoaWxkIiwiTmF0aXZlX2Nsb25lTm9kZSIsImNsb25lTm9kZSIsIk5hdGl2ZV9jcmVhdGVFbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsIm5lZWRzQ2xvbmluZyIsInQiLCJ0MiIsImNvbnRlbnQiLCJjbG9uZSIsImNoaWxkTm9kZXMiLCJmaXJzdENoaWxkIiwiRG9jdW1lbnRGcmFnbWVudCIsIlRFTVBMQVRFX1RBRyIsIlBvbHlmaWxsZWRIVE1MVGVtcGxhdGVFbGVtZW50IiwiY29udGVudERvYyIsImNhbkRlY29yYXRlIiwidGVtcGxhdGVTdHlsZSIsImhlYWQiLCJjYW5Qcm90b1BhdGNoIiwiZXNjYXBlRGF0YVJlZ0V4cCIsImRlZmluZUlubmVySFRNTCIsImdldCIsIm5leHRTaWJsaW5nIiwib3V0ZXJIVE1MIiwiZXNjYXBlRGF0YSIsInNldCIsInRleHQiLCJib2R5IiwiaW5uZXJIVE1MIiwiYm9vdHN0cmFwIiwicmVtb3ZlQ2hpbGQiLCJlc2NhcGVSZXBsYWNlIiwiY3JlYXRlSFRNTERvY3VtZW50IiwidGV4dENvbnRlbnQiLCJpbnNlcnRCZWZvcmUiLCJmaXJzdEVsZW1lbnRDaGlsZCIsImNyZWF0ZSIsIkhUTUxFbGVtZW50IiwiZGVjb3JhdGUiLCJ0ZW1wbGF0ZSIsIl9fcHJvdG9fXyIsImRlZXAiLCJfY2xvbmVOb2RlIiwiZXJyIiwiZG9jIiwidGVtcGxhdGVzIiwicXVlcnlTZWxlY3RvckFsbCIsImFkZEV2ZW50TGlzdGVuZXIiLCJlbCIsImxvY2FsTmFtZSIsImZpeENsb25lZERvbSIsInMkIiwidCQiLCJwYXJlbnROb2RlIiwicmVwbGFjZUNoaWxkIiwiZG9tIiwib3duZXJEb2N1bWVudCIsImVsZW1lbnQiLCJfQ3VzdG9tRWxlbWVudEludGVybmFscyIsIl9DdXN0b21FbGVtZW50SW50ZXJuYWxzMiIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5IiwiX0N1c3RvbUVsZW1lbnRSZWdpc3RyeTIiLCJfSFRNTEVsZW1lbnQiLCJfSFRNTEVsZW1lbnQyIiwiX0RvY3VtZW50IiwiX0RvY3VtZW50MiIsIl9Ob2RlIiwiX05vZGUyIiwiX0VsZW1lbnQiLCJfRWxlbWVudDIiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsInByaW9yQ3VzdG9tRWxlbWVudHMiLCJpbnRlcm5hbHMiLCJfX0NFX2hhc1JlZ2lzdHJ5IiwiX2NyZWF0ZUNsYXNzIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfVXRpbGl0aWVzIiwiVXRpbGl0aWVzIiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJfQ3VzdG9tRWxlbWVudFN0YXRlIiwiX0N1c3RvbUVsZW1lbnRTdGF0ZTIiLCJuZXdPYmoiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkN1c3RvbUVsZW1lbnRJbnRlcm5hbHMiLCJfbG9jYWxOYW1lVG9EZWZpbml0aW9uIiwiTWFwIiwiX2NvbnN0cnVjdG9yVG9EZWZpbml0aW9uIiwiX3BhdGNoZXMiLCJfaGFzUGF0Y2hlcyIsInNldERlZmluaXRpb24iLCJkZWZpbml0aW9uIiwibG9jYWxOYW1lVG9EZWZpbml0aW9uIiwiY29uc3RydWN0b3JUb0RlZmluaXRpb24iLCJhZGRQYXRjaCIsImxpc3RlbmVyIiwicGF0Y2hUcmVlIiwiX3RoaXMiLCJ3YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50cyIsInBhdGNoIiwiX19DRV9wYXRjaGVkIiwiY29ubmVjdFRyZWUiLCJlbGVtZW50cyIsIl9fQ0Vfc3RhdGUiLCJjdXN0b20iLCJjb25uZWN0ZWRDYWxsYmFjayIsInVwZ3JhZGVFbGVtZW50IiwiZGlzY29ubmVjdFRyZWUiLCJkaXNjb25uZWN0ZWRDYWxsYmFjayIsInBhdGNoQW5kVXBncmFkZVRyZWUiLCJfdGhpczIiLCJ2aXNpdGVkSW1wb3J0cyIsIlNldCIsImdhdGhlckVsZW1lbnRzIiwiZ2V0QXR0cmlidXRlIiwiaW1wb3J0IiwicmVhZHlTdGF0ZSIsIl9fQ0VfaXNJbXBvcnREb2N1bWVudCIsIl9fQ0VfZG9jdW1lbnRMb2FkSGFuZGxlZCIsImNsb25lZFZpc2l0ZWRJbXBvcnRzIiwiZGVsZXRlIiwiX2kiLCJjdXJyZW50U3RhdGUiLCJjb25zdHJ1Y3Rpb25TdGFjayIsInBvcCIsIl9fQ0VfZGVmaW5pdGlvbiIsImF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayIsIm9ic2VydmVkQXR0cmlidXRlcyIsImlzQ29ubmVjdGVkIiwib2xkVmFsdWUiLCJuZXdWYWx1ZSIsIm5hbWVzcGFjZSIsImlzVmFsaWRDdXN0b21FbGVtZW50TmFtZSIsInNldFByb3BlcnR5VW5jaGVja2VkIiwicmVzZXJ2ZWRUYWdMaXN0IiwicmVzZXJ2ZWQiLCJ2YWxpZEZvcm0iLCJuYXRpdmVWYWx1ZSIsImN1cnJlbnQiLCJTaGFkb3dSb290IiwiaG9zdCIsIm5leHRTaWJsaW5nT3JBbmNlc3RvclNpYmxpbmciLCJzdGFydCIsIm5leHROb2RlIiwiRUxFTUVOVF9OT0RFIiwiYWRkIiwic2hhZG93Um9vdCIsIl9fQ0Vfc2hhZG93Um9vdCIsIl9jaGlsZCIsImRlc3RpbmF0aW9uIiwiQ3VzdG9tRWxlbWVudFN0YXRlIiwiX0RvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXIiLCJfRG9jdW1lbnRDb25zdHJ1Y3Rpb25PYnNlcnZlcjIiLCJfRGVmZXJyZWQiLCJfRGVmZXJyZWQyIiwiQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5IiwiX2VsZW1lbnREZWZpbml0aW9uSXNSdW5uaW5nIiwiX2ludGVybmFscyIsIl93aGVuRGVmaW5lZERlZmVycmVkIiwiX2ZsdXNoQ2FsbGJhY2siLCJfZmx1c2hQZW5kaW5nIiwiX3VuZmx1c2hlZExvY2FsTmFtZXMiLCJfZG9jdW1lbnRDb25zdHJ1Y3Rpb25PYnNlcnZlciIsIlN5bnRheEVycm9yIiwiYWRvcHRlZENhbGxiYWNrIiwiZ2V0Q2FsbGJhY2siLCJjYWxsYmFja1ZhbHVlIiwiX2ZsdXNoIiwic2hpZnQiLCJkZWZlcnJlZCIsIndoZW5EZWZpbmVkIiwicHJpb3IiLCJ0b1Byb21pc2UiLCJwb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrIiwib3V0ZXIiLCJkaXNjb25uZWN0IiwiaW5uZXIiLCJEb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyIiwiX2RvY3VtZW50IiwiX29ic2VydmVyIiwiX2hhbmRsZU11dGF0aW9ucyIsIm11dGF0aW9ucyIsImFkZGVkTm9kZXMiLCJEZWZlcnJlZCIsIl92YWx1ZSIsIl9wcm9taXNlIiwiX2VsZW1lbnQiLCJfTmF0aXZlMiIsIkRvY3VtZW50X2NyZWF0ZUVsZW1lbnQiLCJzZXRQcm90b3R5cGVPZiIsImxhc3RJbmRleCIsIl9BbHJlYWR5Q29uc3RydWN0ZWRNYXJrZXIyIiwiX05hdGl2ZSIsIl9BbHJlYWR5Q29uc3RydWN0ZWRNYXJrZXIiLCJjcmVhdGVFbGVtZW50TlMiLCJFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlTlMiLCJzZXRBdHRyaWJ1dGVOUyIsInJlbW92ZUF0dHJpYnV0ZU5TIiwiQWxyZWFkeUNvbnN0cnVjdGVkTWFya2VyIiwiRG9jdW1lbnRfaW1wb3J0Tm9kZSIsIk5TX0hUTUwiLCJEb2N1bWVudF9jcmVhdGVFbGVtZW50TlMiLCJfUGFyZW50Tm9kZTIiLCJEb2N1bWVudF9wcmVwZW5kIiwiRG9jdW1lbnRfYXBwZW5kIiwiX1BhcmVudE5vZGUiLCJidWlsdEluIiwiX2xlbiIsIm5vZGVzIiwiX2tleSIsImNvbm5lY3RlZEJlZm9yZSIsImZpbHRlciIsInByZXBlbmQiLCJfbGVuMiIsIl9rZXkyIiwiYXBwZW5kIiwiX2kyIiwiUGFyZW50Tm9kZU5hdGl2ZU1ldGhvZHMiLCJyZWZOb2RlIiwiaW5zZXJ0ZWROb2RlcyIsIl9uYXRpdmVSZXN1bHQiLCJOb2RlX2luc2VydEJlZm9yZSIsIm5vZGVXYXNDb25uZWN0ZWQiLCJuYXRpdmVSZXN1bHQiLCJfbmF0aXZlUmVzdWx0MiIsIk5vZGVfYXBwZW5kQ2hpbGQiLCJOb2RlX2Nsb25lTm9kZSIsIk5vZGVfcmVtb3ZlQ2hpbGQiLCJub2RlVG9JbnNlcnQiLCJub2RlVG9SZW1vdmUiLCJfbmF0aXZlUmVzdWx0MyIsIk5vZGVfcmVwbGFjZUNoaWxkIiwibm9kZVRvSW5zZXJ0V2FzQ29ubmVjdGVkIiwidGhpc0lzQ29ubmVjdGVkIiwicGF0Y2hfdGV4dENvbnRlbnQiLCJiYXNlRGVzY3JpcHRvciIsImFzc2lnbmVkVmFsdWUiLCJURVhUX05PREUiLCJyZW1vdmVkTm9kZXMiLCJjaGlsZE5vZGVzTGVuZ3RoIiwiTm9kZV90ZXh0Q29udGVudCIsInBhcnRzIiwiRWxlbWVudF9hdHRhY2hTaGFkb3ciLCJpbml0Iiwid2FybiIsInBhdGNoX2lubmVySFRNTCIsImh0bWxTdHJpbmciLCJyZW1vdmVkRWxlbWVudHMiLCJFbGVtZW50X2lubmVySFRNTCIsIkhUTUxFbGVtZW50X2lubmVySFRNTCIsInJhd0RpdiIsIkVsZW1lbnRfc2V0QXR0cmlidXRlIiwiRWxlbWVudF9nZXRBdHRyaWJ1dGUiLCJFbGVtZW50X3NldEF0dHJpYnV0ZU5TIiwiRWxlbWVudF9nZXRBdHRyaWJ1dGVOUyIsIkVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlIiwiRWxlbWVudF9yZW1vdmVBdHRyaWJ1dGVOUyIsInBhdGNoX2luc2VydEFkamFjZW50RWxlbWVudCIsImJhc2VNZXRob2QiLCJ3aGVyZSIsIndhc0Nvbm5lY3RlZCIsImluc2VydGVkRWxlbWVudCIsIkhUTUxFbGVtZW50X2luc2VydEFkamFjZW50RWxlbWVudCIsIkVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRFbGVtZW50IiwiRWxlbWVudF9wcmVwZW5kIiwiRWxlbWVudF9hcHBlbmQiLCJfQ2hpbGROb2RlMiIsIkVsZW1lbnRfYmVmb3JlIiwiRWxlbWVudF9hZnRlciIsIkVsZW1lbnRfcmVwbGFjZVdpdGgiLCJFbGVtZW50X3JlbW92ZSIsIl9DaGlsZE5vZGUiLCJiZWZvcmUiLCJhZnRlciIsIl9sZW4zIiwiX2tleTMiLCJyZXBsYWNlV2l0aCIsIl9pMyIsInJlbW92ZSIsIkNoaWxkTm9kZU5hdGl2ZU1ldGhvZHMiLCJfdXRpbHMiLCJ1dGlscyIsIl9vYnNlcnZlQ2hhbmdlcyIsIl9uYXRpdmVNZXRob2RzIiwibmF0aXZlTWV0aG9kcyIsIl9uYXRpdmVUcmVlIiwibmF0aXZlVHJlZSIsIl9wYXRjaEJ1aWx0aW5zIiwiX3BhdGNoRXZlbnRzIiwiX2F0dGFjaFNoYWRvdyIsInNldHRpbmdzIiwiaW5Vc2UiLCJpc1NoYWR5Um9vdCIsImVucXVldWUiLCJmaWx0ZXJNdXRhdGlvbnMiLCJvYnNlcnZlQ2hpbGRyZW4iLCJ1bm9ic2VydmVDaGlsZHJlbiIsInBhdGNoRXZlbnRzIiwicGF0Y2hCdWlsdGlucyIsIlNoYWR5Um9vdCIsIm93bmVyU2hhZHlSb290Rm9yTm9kZSIsIm1hdGNoZXNTZWxlY3RvciIsImV4dGVuZCIsImV4dGVuZEFsbCIsIm1peGluIiwicGF0Y2hQcm90b3R5cGUiLCJtaWNyb3Rhc2siLCJoYXNOYXRpdmVTaGFkb3dET00iLCJhdHRhY2hTaGFkb3ciLCJnZXRSb290Tm9kZSIsImRlc2MiLCJoYXNEZXNjcmlwdG9ycyIsIl9fbG9jYWxOYW1lIiwibWF0Y2hlcyIsIm1vek1hdGNoZXNTZWxlY3RvciIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwib01hdGNoZXNTZWxlY3RvciIsIndlYmtpdE1hdGNoZXNTZWxlY3RvciIsInNlbGVjdG9yIiwiY29weU93blByb3BlcnR5IiwicGQiLCJuJCIsInNvdXJjZXMiLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwicGF0Y2hQcm90byIsIl9fc291cmNlUHJvdG8iLCJfX3BhdGNoUHJvdG8iLCJ0d2lkZGxlIiwiZmx1c2hMaXN0Iiwic2NoZWR1bGVkIiwiZGlkRmx1c2giLCJsaXN0IiwiQXN5bmNPYnNlcnZlciIsIl9zY2hlZHVsZWQiLCJjYWxsYmFja3MiLCJzY2hlZHVsZSIsInRha2VSZWNvcmRzIiwiY2IiLCJfX3NoYWR5IiwiaGFuZGxlIiwiX2NhbGxiYWNrIiwic2l6ZSIsIl9ub2RlIiwidGFyZ2V0Um9vdE5vZGUiLCJtdXRhdGlvbiIsIm11dGF0aW9uSW5TY29wZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJsYXN0Q2hpbGQiLCJwcmV2aW91c1NpYmxpbmciLCJwYXJlbnRFbGVtZW50IiwibGFzdEVsZW1lbnRDaGlsZCIsInByZXZpb3VzRWxlbWVudFNpYmxpbmciLCJuZXh0RWxlbWVudFNpYmxpbmciLCJjaGlsZHJlbiIsIl9pbm5lckhUTUwiLCJub2RlV2Fsa2VyIiwiY3JlYXRlVHJlZVdhbGtlciIsIk5vZGVGaWx0ZXIiLCJTSE9XX0FMTCIsImVsZW1lbnRXYWxrZXIiLCJTSE9XX0VMRU1FTlQiLCJjdXJyZW50Tm9kZSIsImdldElubmVySFRNTCIsIm5vZGVWYWx1ZSIsInRleHRXYWxrZXIiLCJTSE9XX1RFWFQiLCJnZXRPdXRlckhUTUwiLCJlc2NhcGVBdHRyUmVnRXhwIiwiZXNjYXBlQXR0ciIsIm1ha2VTZXQiLCJhcnIiLCJ2b2lkRWxlbWVudHMiLCJwbGFpbnRleHRQYXJlbnRzIiwiY29tcG9zZWQiLCJ0YWdOYW1lIiwiYXR0cnMiLCJhdHRyaWJ1dGVzIiwiYXR0ciIsIkNPTU1FTlRfTk9ERSIsImNvbnNvbGUiLCJjJCIsIl9sb2dpY2FsTXV0YXRpb24iLCJfcGF0Y2hBY2Nlc3NvcnMiLCJfbG9naWNhbFByb3BlcnRpZXMiLCJfYXR0YWNoU2hhZG93MiIsImdldEFzc2lnbmVkU2xvdCIsInJlbmRlclJvb3ROb2RlIiwiZ2V0UHJvcGVydHkiLCJub2RlTWl4aW4iLCJyZWZfbm9kZSIsIm9wdGlvbnMiLCJjb250YWlucyIsIm93bmVyRG9jdW1lbnRFbGVtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwidGV4dE1peGluIiwiYXNzaWduZWRTbG90IiwiZnJhZ21lbnRNaXhpbiIsInF1ZXJ5U2VsZWN0b3IiLCJxdWVyeSIsInNsb3RNaXhpbiIsImFzc2lnbmVkTm9kZXMiLCJmbGF0dGVuIiwiZGlzdHJpYnV0ZWROb2RlcyIsImVsZW1lbnRNaXhpbiIsInNsb3QiLCJTaGFkb3dSb290QWNjZXNzb3IiLCJkb2N1bWVudE1peGluIiwiQWN0aXZlRWxlbWVudEFjY2Vzc29yIiwiYWN0aXZlRWxlbWVudCIsInBhdGNoQnVpbHRpbiIsImQiLCJUZXh0IiwiSFRNTFNsb3RFbGVtZW50IiwicGF0Y2hBY2Nlc3NvcnMiLCJuYXRpdmVIVE1MRWxlbWVudCIsIl9sb2dpY2FsVHJlZSIsImxvZ2ljYWxUcmVlIiwiYWRkTm9kZSIsImNvbnRhaW5lciIsIm93bmVyUm9vdCIsImlwQWRkZWQiLCJfX25vSW5zZXJ0aW9uUG9pbnQiLCJfY2hhbmdlUGVuZGluZyIsIl9za2lwVXBkYXRlSW5zZXJ0aW9uUG9pbnRzIiwiX21heWJlQWRkSW5zZXJ0aW9uUG9pbnQiLCJoYXNQcm9wZXJ0eSIsInJlY29yZEluc2VydEJlZm9yZSIsImhhbmRsZWQiLCJfbWF5YmVEaXN0cmlidXRlIiwic2hhZHlSb290IiwicmVtb3ZlTm9kZSIsImxvZ2ljYWxQYXJlbnQiLCJkaXN0cmlidXRlZCIsIm1heWJlRGlzdHJpYnV0ZVBhcmVudCIsInJlY29yZFJlbW92ZUNoaWxkIiwicmVtb3ZlZERpc3RyaWJ1dGVkIiwiX3JlbW92ZURpc3RyaWJ1dGVkQ2hpbGRyZW4iLCJhZGRlZEluc2VydGlvblBvaW50IiwiZ2V0SW5zZXJ0aW9uUG9pbnRUYWciLCJfc2NoZWR1bGVPYnNlcnZlciIsImFkZGVkTm9kZSIsInJlbW92ZWROb2RlIiwicmVtb3ZlTm9kZUZyb21QYXJlbnQiLCJfaGFzQ2FjaGVkT3duZXJSb290IiwiX19vd25lclNoYWR5Um9vdCIsImluc2VydGlvblBvaW50VGFnIiwiZnJhZ0NvbnRlbnQiLCJ3cmFwcGVkQ29udGVudCIsImhhc0NvbnRlbnQiLCJuZWVkc0Rpc3QiLCJfbm9kZU5lZWRzRGlzdHJpYnV0aW9uIiwiYWRkZWQiLCJucCIsIm5hIiwicmVjb3JkQ2hpbGROb2RlcyIsImhhc0luc2VydGlvblBvaW50IiwiaG9zdE5lZWRzRGlzdCIsImlwJCIsIl9pbnNlcnRpb25Qb2ludHMiLCJpbnNlcnRpb25Qb2ludCIsIl9jb250YWlucyIsImRjJCIsIl9yZW1vdmVPd25lclNoYWR5Um9vdCIsImZpcnN0Q29tcG9zZWROb2RlIiwiaXNGaW5hbERlc3RpbmF0aW9uIiwidXBkYXRlUm9vdFZpYUNvbnRlbnRDaGFuZ2UiLCJ1cGRhdGUiLCJkaXN0cmlidXRlQXR0cmlidXRlQ2hhbmdlIiwibWF0Y2hlciIsImhhbHRlciIsIl9xdWVyeUVsZW1lbnRzIiwiX3F1ZXJ5RWxlbWVudCIsInJlbmRlciIsInNjb3BpbmdTaGltIiwiU2hhZHlDU1MiLCJTY29waW5nU2hpbSIsInNldEVsZW1lbnRDbGFzcyIsIl9wYXJlbnQiLCJuYXRpdmVQYXJlbnQiLCJuYyIsInByb3AiLCJwYXRjaEluc2lkZUVsZW1lbnRBY2Nlc3NvcnMiLCJyZXNldFRvIiwibGlua05vZGUiLCJwYXRjaE91dHNpZGVFbGVtZW50QWNjZXNzb3JzIiwicHMiLCJucyIsInBhdGNoU2hhZG93Um9vdEFjY2Vzc29ycyIsImdlbmVyYXRlU2ltcGxlRGVzY3JpcHRvciIsImNsZWFyTm9kZSIsIm5hdGl2ZUlubmVySFRNTERlc2MiLCJpbmVydERvYyIsImh0bWxDb250YWluZXIiLCJuYXRpdmVBY3RpdmVFbGVtZW50RGVzY3JpcHRvciIsImdldERvY3VtZW50QWN0aXZlRWxlbWVudCIsImFjdGl2ZUVsZW1lbnRGb3JOb2RlIiwiYWN0aXZlIiwiYWN0aXZlUm9vdCIsIk91dHNpZGVBY2Nlc3NvcnMiLCJJbnNpZGVBY2Nlc3NvcnMiLCJ0YyIsImNuIiwicGF0Y2hBY2Nlc3Nvckdyb3VwIiwiZGVzY3JpcHRvcnMiLCJvYmpEZXNjIiwiX19vdXRzaWRlQWNjZXNzb3JzIiwiX19pbnNpZGVBY2Nlc3NvcnMiLCJhbHdheXNDb21wb3NlZCIsInBhdGhDb21wb3NlciIsInN0YXJ0Tm9kZSIsImNvbXBvc2VkUGF0aCIsInN0YXJ0Um9vdCIsInJldGFyZ2V0IiwicGF0aCIsInJlZk5vZGVQYXRoIiwicCQiLCJhbmNlc3RvciIsImxhc3RSb290Iiwicm9vdElkeCIsImV2ZW50TWl4aW4iLCJpc1RydXN0ZWQiLCJfX2NvbXBvc2VkIiwidHlwZSIsIl9fY29tcG9zZWRQYXRoIiwiX190YXJnZXQiLCJjdXJyZW50VGFyZ2V0IiwicmVsYXRlZFRhcmdldCIsIl9fcmVsYXRlZFRhcmdldCIsIl9fcmVsYXRlZFRhcmdldENvbXBvc2VkUGF0aCIsInN0b3BQcm9wYWdhdGlvbiIsIl9fcHJvcGFnYXRpb25TdG9wcGVkIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwiX19pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQiLCJtaXhpbkNvbXBvc2VkRmxhZyIsIkJhc2UiLCJrbGF6eiIsImV2ZW50Iiwibm9uQnViYmxpbmdFdmVudHNUb1JldGFyZ2V0IiwiZmlyZUhhbmRsZXJzIiwicGhhc2UiLCJocyIsIl9faGFuZGxlcnMiLCJyZXRhcmdldE5vbkJ1YmJsaW5nRXZlbnQiLCJFdmVudCIsIkFUX1RBUkdFVCIsImxhc3RGaXJlZFJvb3QiLCJvcHRpb25zT3JDYXB0dXJlIiwiY2FwdHVyZSIsInBhc3NpdmUiLCJfX2V2ZW50V3JhcHBlcnMiLCJ3cmFwcGVyRm4iLCJldmVudFBoYXNlIiwiQlVCQkxJTkdfUEhBU0UiLCJidWJibGUiLCJzcGxpY2UiLCJpZHgiLCJhY3RpdmF0ZUZvY3VzRXZlbnRPdmVycmlkZXMiLCJldiIsInBhdGNoRXZlbnQiLCJQYXRjaGVkRXZlbnQiLCJQYXRjaGVkQ3VzdG9tRXZlbnQiLCJDdXN0b21FdmVudCIsIlBhdGNoZWRNb3VzZUV2ZW50IiwiTW91c2VFdmVudCIsIl9hcnJheVNwbGljZSIsIl9kaXN0cmlidXRvciIsIl9kaXN0cmlidXRvcjIiLCJTaGFkeVJvb3RDb25zdHJ1Y3Rpb25Ub2tlbiIsInRva2VuIiwiX2luaXQiLCJfcmVuZGVyUGVuZGluZyIsIl9oYXNSZW5kZXJlZCIsIl9nZXRSZW5kZXJSb290IiwicmVuZGVyUm9vdCIsIl9yZW5kZXJlckZvckhvc3QiLCJpc0luc2VydGlvblBvaW50IiwiX3JlbmRlciIsInVwZGF0ZUluc2VydGlvblBvaW50cyIsImRpc3RyaWJ1dGUiLCJjb21wb3NlIiwiZm9yY2VSZW5kZXIiLCJkaXJ0eVJvb3RzIiwiaSQiLCJfX2luc2VydGlvblBvaW50cyIsImNsZWFyQXNzaWduZWRTbG90cyIsImdldEluc2VydGlvblBvaW50cyIsIl9jIiwiaW5zZXJ0aW9uUG9pbnRzIiwiX2NvbXBvc2VUcmVlIiwiX3VwZGF0ZUNoaWxkTm9kZXMiLCJfY29tcG9zZU5vZGUiLCJkaXN0cmlidXRlZE5vZGUiLCJzcGxpY2VzIiwiY2FsY3VsYXRlU3BsaWNlcyIsInJlbW92ZWQiLCJpbmRleCIsImFkZGVkQ291bnQiLCJfcyIsIm5leHQiLCJfaiIsIl9uIiwibmV3U3BsaWNlIiwiRURJVF9MRUFWRSIsIkVESVRfVVBEQVRFIiwiRURJVF9BREQiLCJFRElUX0RFTEVURSIsIkFycmF5U3BsaWNlIiwiY2FsY0VkaXREaXN0YW5jZXMiLCJjdXJyZW50U3RhcnQiLCJjdXJyZW50RW5kIiwib2xkIiwib2xkU3RhcnQiLCJvbGRFbmQiLCJyb3dDb3VudCIsImNvbHVtbkNvdW50IiwiZGlzdGFuY2VzIiwiZXF1YWxzIiwibm9ydGgiLCJ3ZXN0Iiwic3BsaWNlT3BlcmF0aW9uc0Zyb21FZGl0RGlzdGFuY2VzIiwiZWRpdHMiLCJub3J0aFdlc3QiLCJtaW4iLCJyZXZlcnNlIiwiY2FsY1NwbGljZXMiLCJwcmVmaXhDb3VudCIsInN1ZmZpeENvdW50IiwibWluTGVuZ3RoIiwic2hhcmVkUHJlZml4Iiwic2hhcmVkU3VmZml4Iiwib3BzIiwib2xkSW5kZXgiLCJzZWFyY2hMZW5ndGgiLCJpbmRleDEiLCJpbmRleDIiLCJjb3VudCIsInByZXZpb3VzIiwiY3VycmVudFZhbHVlIiwicHJldmlvdXNWYWx1ZSIsIk5vcm1hbGl6ZWRFdmVudCIsImluVHlwZSIsInBhcmFtcyIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJfY2xhc3MiLCJkaXN0cmlidXRlUG9vbCIsImNvbGxlY3RQb29sIiwicG9vbCIsImRpc3RyaWJ1dGVJbnNlcnRpb25Qb2ludCIsIl9wIiwicHJldkFzc2lnbmVkTm9kZXMiLCJuZWVkc1Nsb3RDaGFuZ2UiLCJhbnlEaXN0cmlidXRlZCIsIm1hdGNoZXNJbnNlcnRpb25Qb2ludCIsIl9wcmV2QXNzaWduZWRTbG90IiwiZGlzdHJpYnV0ZU5vZGVJbnRvIiwic2V0RGlzdHJpYnV0ZWROb2Rlc09uSW5zZXJ0aW9uUG9pbnQiLCJfZmlyZVNsb3RDaGFuZ2UiLCJzYXZlUHJldmlvdXMiLCJzbG90TmFtZSIsImQkIiwiZGlzcGF0Y2hFdmVudCIsIl9jc3NQYXJzZSIsIl9zdHlsZVNldHRpbmdzIiwiX3N0eWxlVHJhbnNmb3JtZXIiLCJfc3R5bGVUcmFuc2Zvcm1lcjIiLCJfc3R5bGVVdGlsIiwiU3R5bGVVdGlsIiwiX3N0eWxlUHJvcGVydGllcyIsIl9zdHlsZVByb3BlcnRpZXMyIiwiX3RlbXBsYXRlTWFwIiwiX3RlbXBsYXRlTWFwMiIsIl9zdHlsZVBsYWNlaG9sZGVyIiwiX3N0eWxlUGxhY2Vob2xkZXIyIiwiX3N0eWxlSW5mbyIsIl9zdHlsZUluZm8yIiwiX3N0eWxlQ2FjaGUiLCJfc3R5bGVDYWNoZTIiLCJfYXBwbHlTaGltIiwiX2FwcGx5U2hpbTIiLCJfZG9jdW1lbnRXYXRjaGVyIiwic3R5bGVDYWNoZSIsIl9zY29wZUNvdW50ZXIiLCJfZG9jdW1lbnRPd25lciIsIl9kb2N1bWVudE93bmVyU3R5bGVJbmZvIiwicnVsZXMiLCJfZWxlbWVudHNIYXZlQXBwbGllZCIsIl9nZW5lcmF0ZVNjb3BlU2VsZWN0b3IiLCJnZXRTdHlsZUFzdCIsInN0eWxlIiwicnVsZXNGb3JTdHlsZSIsInN0eWxlQXN0VG9TdHJpbmciLCJhc3QiLCJ0b0Nzc1RleHQiLCJfZ2F0aGVyU3R5bGVzIiwic3R5bGVzIiwiY3NzVGV4dCIsIl9nZXRDc3NCdWlsZCIsInByZXBhcmVUZW1wbGF0ZSIsImVsZW1lbnROYW1lIiwidHlwZUV4dGVuc2lvbiIsIl9wcmVwYXJlZCIsImV4dGVuZHMiLCJjc3NCdWlsZCIsImluZm8iLCJuYXRpdmVTaGFkb3ciLCJoYXNNaXhpbnMiLCJkZXRlY3RNaXhpbiIsInBhcnNlIiwibmF0aXZlQ3NzIiwibmF0aXZlQ3NzQXBwbHkiLCJ0cmFuc2Zvcm1SdWxlcyIsIl9zdHlsZUFzdCIsIm93blByb3BlcnR5TmFtZXMiLCJkZWNvcmF0ZVN0eWxlcyIsInBsYWNlaG9sZGVyIiwiX2dlbmVyYXRlU3RhdGljU3R5bGUiLCJfc3R5bGUiLCJfb3duUHJvcGVydHlOYW1lcyIsInNoYWRvd3Jvb3QiLCJlbGVtZW50U3R5bGVzIiwiYXBwbHlDc3MiLCJpcyIsIl9wcmVwYXJlSG9zdCIsIm93blN0eWxlUHJvcGVydHlOYW1lcyIsIl9jc3NCdWlsZCIsImFwcGx5U3R5bGUiLCJvdmVycmlkZVByb3BzIiwic3R5bGVJbmZvIiwiaGFzQXBwbGllZCIsIl9pc1Jvb3RPd25lciIsIkN1c3RvbVN0eWxlIiwiQ1MiLCJfZG9jdW1lbnREaXJ0eSIsImZpbmRTdHlsZXMiLCJfdXBkYXRlUHJvcGVydGllcyIsIl9yZXZhbGlkYXRlQXBwbHlTaGltIiwiYXBwbHlTdHlsZXMiLCJ1cGRhdGVTdHlsZXMiLCJvdmVycmlkZVN0eWxlUHJvcGVydGllcyIsIl91cGRhdGVOYXRpdmVQcm9wZXJ0aWVzIiwiX2FwcGx5U2hpbUludmFsaWQiLCJfdmFsaWRhdGluZyIsInN0eWxlUnVsZXMiLCJzdGFydFZhbGlkYXRpbmciLCJfYXBwbHlTdHlsZVByb3BlcnRpZXMiLCJfcm9vdCIsIl9hcHBseVRvRGVzY2VuZGFudHMiLCJfc3R5bGVPd25lckZvck5vZGUiLCJjYWNoZUVudHJ5IiwiZmV0Y2giLCJzdHlsZVByb3BlcnRpZXMiLCJjYWNoZWRTY29wZVNlbGVjdG9yIiwic2NvcGVTZWxlY3RvciIsImNhY2hlZFN0eWxlIiwic3R5bGVFbGVtZW50Iiwib2xkU2NvcGVTZWxlY3RvciIsImFwcGx5RWxlbWVudFN0eWxlIiwiYXBwbHlFbGVtZW50U2NvcGVTZWxlY3RvciIsInN0b3JlIiwib3duZXIiLCJvd25lclN0eWxlSW5mbyIsIm93bmVyUHJvcGVydGllcyIsImhvc3RBbmRSb290UHJvcHMiLCJob3N0QW5kUm9vdFByb3BlcnRpZXNGb3JTY29wZSIsInByb3BlcnR5RGF0YSIsInByb3BlcnR5RGF0YUZyb21TdHlsZXMiLCJwcm9wZXJ0aWVzTWF0Y2hpbmdIb3N0IiwicHJvcGVydGllcyIsImhvc3RQcm9wcyIsInJvb3RQcm9wcyIsIl9taXhpbk92ZXJyaWRlU3R5bGVzIiwicmVpZnkiLCJvdmVycmlkZXMiLCJyZW1vdmVQcm9wZXJ0eSIsInNldFByb3BlcnR5IiwiX3RyYW5zZm9ybUN1c3RvbVN0eWxlRm9yRG9jdW1lbnQiLCJmb3JFYWNoUnVsZSIsInJ1bGUiLCJub3JtYWxpemVSb290U2VsZWN0b3IiLCJkb2N1bWVudFJ1bGUiLCJ0cmFuc2Zvcm1SdWxlIiwiX2FwcGx5Q3VzdG9tU3R5bGVUb0RvY3VtZW50IiwiYXBwbHlDdXN0b21TdHlsZSIsImdldENvbXB1dGVkU3R5bGVWYWx1ZSIsInByb3BlcnR5IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJjbGFzc1N0cmluZyIsImNsYXNzZXMiLCJzY29wZU5hbWUiLCJjbGFzc0F0dHIiLCJrJCIsIlNDT1BFX05BTUUiLCJYU0NPUEVfTkFNRSIsInNldEVsZW1lbnRDbGFzc1JhdyIsIl9zdHlsZUluZm9Gb3JOb2RlIiwibmF0aXZlQ3NzVmFyaWFibGVzIiwic3RyaW5naWZ5IiwicmVtb3ZlQ3VzdG9tUHJvcEFzc2lnbm1lbnQiLCJjbGVhbiIsInBhcnNlQ3NzIiwibGV4IiwiUlgiLCJjb21tZW50cyIsInBvcnQiLCJPUEVOX0JSQUNFIiwiQ0xPU0VfQlJBQ0UiLCJlbmQiLCJwYXJzZWRDc3NUZXh0Iiwic3MiLCJfZXhwYW5kVW5pY29kZUVzY2FwZXMiLCJtdWx0aXBsZVNwYWNlcyIsImxhc3RJbmRleE9mIiwicGFyc2VkU2VsZWN0b3IiLCJhdFJ1bGUiLCJBVF9TVEFSVCIsIk1FRElBX1NUQVJUIiwidHlwZXMiLCJNRURJQV9SVUxFIiwia2V5ZnJhbWVzUnVsZSIsIktFWUZSQU1FU19SVUxFIiwia2V5ZnJhbWVzTmFtZSIsIlZBUl9TVEFSVCIsIk1JWElOX1JVTEUiLCJTVFlMRV9SVUxFIiwiciQiLCJjb2RlIiwicmVwZWF0IiwicHJlc2VydmVQcm9wZXJ0aWVzIiwiX2hhc01peGluUnVsZXMiLCJyZW1vdmVDdXN0b21Qcm9wcyIsInJlbW92ZUN1c3RvbVByb3BBcHBseSIsImN1c3RvbVByb3AiLCJtaXhpblByb3AiLCJtaXhpbkFwcGx5IiwidmFyQXBwbHkiLCJDU1MiLCJzdXBwb3J0cyIsImRldGVjdE5hdGl2ZUFwcGx5Iiwic2hlZXQiLCJjc3NSdWxlcyIsInBhcnNlU2V0dGluZ3MiLCJzaGltY3NzcHJvcGVydGllcyIsInNoaW1zaGFkb3ciLCJXZWJDb21wb25lbnRzIiwiZmxhZ3MiLCJTdHlsZVRyYW5zZm9ybWVyIiwic2NvcGUiLCJzaG91bGRSZW1vdmVTY29wZSIsIl9fc3R5bGVTY29wZWQiLCJfdHJhbnNmb3JtRG9tIiwiX2NvbnRlbnQiLCJjbGFzc0xpc3QiLCJDTEFTUyIsIl9uZXdWYWx1ZSIsImNzc0J1aWxkVHlwZSIsIl9fY3NzQnVpbGQiLCJjc3MiLCJleHQiLCJob3N0U2NvcGUiLCJfY2FsY0hvc3RTY29wZSIsIl9jYWxjRWxlbWVudFNjb3BlIiwiaXNTY29wZWQiLCJDU1NfQ0xBU1NfUFJFRklYIiwiX3J1bGUiLCJfdHJhbnNmb3JtUnVsZSIsIl90cmFuc2Zvcm1Db21wbGV4U2VsZWN0b3IiLCJ0cmFuc2Zvcm1lciIsInRyYW5zZm9ybWVkU2VsZWN0b3IiLCJfdHJhbnNmb3JtUnVsZUNzcyIsIkNPTVBMRVhfU0VMRUNUT1JfU0VQIiwiaXNLZXlmcmFtZXNTZWxlY3RvciIsInN0b3AiLCJOVEgiLCJTTE9UVEVEX1NUQVJUIiwiSE9TVCIsIlNJTVBMRV9TRUxFQ1RPUl9TRVAiLCJfdHJhbnNmb3JtQ29tcG91bmRTZWxlY3RvciIsImNvbWJpbmF0b3IiLCJzbG90dGVkSW5kZXgiLCJTTE9UVEVEIiwiX3RyYW5zZm9ybUhvc3RTZWxlY3RvciIsIl90cmFuc2Zvcm1TaW1wbGVTZWxlY3RvciIsInNsb3R0ZWQiLCJTTE9UVEVEX1BBUkVOIiwicGFyZW4iLCJESVJfUEFSRU4iLCJQU0VVRE9fUFJFRklYIiwiSE9TVF9QQVJFTiIsIlNJTVBMRV9TRUxFQ1RPUl9QUkVGSVgiLCJ0eXBlU2VsZWN0b3IiLCJTRUxFQ1RPUl9OT19NQVRDSCIsIl90cmFuc2Zvcm1Eb2N1bWVudFNlbGVjdG9yIiwiUk9PVCIsIlNDT1BFX0RPQ19TRUxFQ1RPUiIsInJ4IiwiY3JlYXRlU2NvcGVTdHlsZSIsImFwcGx5U3R5bGVQbGFjZUhvbGRlciIsImlzVGFyZ2V0ZWRCdWlsZCIsImdldENzc0J1aWxkVHlwZSIsInByb2Nlc3NWYXJpYWJsZUFuZEZhbGxiYWNrIiwiX19jc3NSdWxlcyIsInN0eWxlUnVsZUNhbGxiYWNrIiwia2V5ZnJhbWVzUnVsZUNhbGxiYWNrIiwib25seUFjdGl2ZVJ1bGVzIiwic2tpcFJ1bGVzIiwibWF0Y2hNZWRpYSIsIk1FRElBX01BVENIIiwibW9uaWtlciIsImNvbnRleHROb2RlIiwibGFzdEhlYWRBcHBseU5vZGUiLCJwbGFjZUhvbGRlciIsImNyZWF0ZUNvbW1lbnQiLCJidWlsZFR5cGUiLCJmaW5kTWF0Y2hpbmdQYXJlbiIsImxldmVsIiwicHJlZml4Iiwic3VmZml4IiwiY29tbWEiLCJmYWxsYmFjayIsIklTX0lFIiwiU3R5bGVQcm9wZXJ0aWVzIiwia2V5ZnJhbWVzIiwicnVsZUluZGV4IiwiZGVjb3JhdGVSdWxlIiwiY29sbGVjdFByb3BlcnRpZXNJbkNzc1RleHQiLCJwcm9wZXJ0eUluZm8iLCJvbktleWZyYW1lc1J1bGUiLCJfa2V5ZnJhbWVzIiwibmFtZXMiLCJoYXNQcm9wZXJ0aWVzIiwiY29sbGVjdFByb3BlcnRpZXMiLCJjb2xsZWN0Q3NzVGV4dCIsIlZBUl9BU1NJR04iLCJhbnkiLCJjb2xsZWN0Q29uc3VtaW5nQ3NzVGV4dCIsIkJSQUNLRVRFRCIsIlZBUl9DT05TVU1FRCIsInZhbHVlRm9yUHJvcGVydHkiLCJ2YWx1ZUZvclByb3BlcnRpZXMiLCJwcm9wZXJ0eVZhbHVlIiwiTUlYSU5fTUFUQ0giLCJjb2xvbiIsInBwIiwiYXBwbHlQcm9wZXJ0aWVzIiwib3V0cHV0IiwiYXBwbHlLZXlmcmFtZVRyYW5zZm9ybXMiLCJrZXlmcmFtZVRyYW5zZm9ybXMiLCJoYXNBbmltYXRpb25zIiwiQU5JTUFUSU9OX01BVENIIiwidHJhbnNmb3JtIiwia2V5ZnJhbWVOYW1lc1RvVHJhbnNmb3JtIiwia2V5ZnJhbWUiLCJzZWxlY3RvclRvTWF0Y2giLCJ3aGVuSG9zdE9yUm9vdFJ1bGUiLCJpc1Jvb3QiLCJpc0hvc3QiLCJ0cmFuc2Zvcm1TdHlsZXMiLCJob3N0U2VsZWN0b3IiLCJyeEhvc3RTZWxlY3RvciIsImhvc3RSeCIsIkhPU1RfUFJFRklYIiwiSE9TVF9TVUZGSVgiLCJfZWxlbWVudEtleWZyYW1lVHJhbnNmb3JtcyIsIl9zY29wZVNlbGVjdG9yIiwia2V5ZnJhbWVzUnVsZXMiLCJfc2NvcGVLZXlmcmFtZXMiLCJfa2V5ZnJhbWVzUnVsZVRyYW5zZm9ybWVyIiwia2V5ZnJhbWVzTmFtZVJ4IiwidHJhbnNmb3JtZWRLZXlmcmFtZXNOYW1lIiwic2NvcGVJZCIsIl9wMiIsImN1c3RvbVN0eWxlIiwiX3VzZUNvdW50IiwiYWRkVG9CaXRNYXNrIiwiYml0cyIsIlN0eWxlSW5mbyIsIl9fc3R5bGVJbmZvIiwiaW52YWxpZGF0ZSIsInBsYWNlaG9sZGVyTWFwIiwiY2UiLCJvcmlnRGVmaW5lIiwiY2xhenoiLCJTdHlsZUNhY2hlIiwidHlwZU1heCIsImNhY2hlIiwiX3ZhbGlkYXRlIiwicG4iLCJ0YWduYW1lIiwiQVBQTFlfTkFNRV9DTEVBTiIsIklOSVRJQUxfSU5IRVJJVCIsIk1JWElOX1ZBUl9TRVAiLCJNaXhpbk1hcCIsIl9tYXAiLCJBcHBseVNoaW0iLCJfY3VycmVudFRlbXBsYXRlIiwiX21lYXN1cmVFbGVtZW50IiwiX3NlcGFyYXRvciIsIl9ib3VuZFByb2R1Y2VDc3NQcm9wZXJ0aWVzIiwibWF0Y2hUZXh0IiwicHJvcGVydHlOYW1lIiwidmFsdWVQcm9wZXJ0eSIsInZhbHVlTWl4aW4iLCJfcHJvZHVjZUNzc1Byb3BlcnRpZXMiLCJ0cmFuc2Zvcm1TdHlsZSIsInRyYW5zZm9ybUNzc1RleHQiLCJfY29uc3VtZUNzc1Byb3BlcnRpZXMiLCJfZ2V0SW5pdGlhbFZhbHVlRm9yUHJvcGVydHkiLCJtaXhpbk5hbWUiLCJhcHBseVBvcyIsImFmdGVyQXBwbHlQb3MiLCJ0ZXh0QmVmb3JlQXBwbHkiLCJ0ZXh0QWZ0ZXJBcHBseSIsImRlZmF1bHRzIiwiX2Nzc1RleHRUb01hcCIsInJlcGxhY2VtZW50IiwiX2F0QXBwbHlUb0Nzc1Byb3BlcnRpZXMiLCJmYWxsYmFja3MiLCJ2YXJzIiwibWl4aW5FbnRyeSIsImRlcGVuZGFudHMiLCJfcmVwbGFjZUluaXRpYWxPckluaGVyaXQiLCJvdXQiLCJzcCIsIl9pbnZhbGlkYXRlTWl4aW5FbnRyeSIsIl90aGlzMyIsIm1peGluQXNQcm9wZXJ0aWVzIiwibWl4aW5WYWx1ZXMiLCJjb21iaW5lZFByb3BzIiwib2xkUHJvcHMiLCJuZWVkVG9JbnZhbGlkYXRlIiwiYXBwbHlTaGltIiwiZWxlbWVudE5lZWRzU2NvcGluZyIsIlNWR0VsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJoYW5kbGVyIiwibXhucyIsIm14biIsImNsYXNzSWR4IiwiX3Njb3BlIiwiY2hpbGRMaXN0Iiwic3VidHJlZSIsIm5hdGl2ZUN1c3RvbUVsZW1lbnRzIiwiZGVsYXllZFN0YXJ0IiwiSFRNTEltcG9ydHMiLCJ3aGVuUmVhZHkiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIlJlZmVyZW5jZUVycm9yIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiZW5xdWV1ZWQiLCJjdXN0b21TdHlsZXMiLCJob29rRm4iLCJlbnF1ZXVlRG9jdW1lbnRWYWxpZGF0aW9uIiwidmFsaWRhdGVEb2N1bWVudCIsIl9fYXBwbGllZEVsZW1lbnQiLCJjcmVhdGVNYXAiLCJOb2RlRGF0YSIsIm5vZGVOYW1lIiwiYXR0cnNBcnIiLCJuZXdBdHRycyIsImtleU1hcCIsImtleU1hcFZhbGlkIiwiaW5pdERhdGEiLCJnZXREYXRhIiwidG9Mb3dlckNhc2UiLCJzeW1ib2xzIiwiZ2V0TmFtZXNwYWNlIiwiYXBwbHlBdHRyIiwiYXR0ck5TIiwiYXBwbHlQcm9wIiwiZWxTdHlsZSIsImFwcGx5QXR0cmlidXRlVHlwZWQiLCJ1cGRhdGVBdHRyaWJ1dGUiLCJtdXRhdG9yIiwiZ2V0TmFtZXNwYWNlRm9yVGFnIiwidGFnIiwibmFtZXNwYWNlVVJJIiwic3RhdGljcyIsImNyZWF0ZVRleHQiLCJjcmVhdGVLZXlNYXAiLCJnZXRLZXlNYXAiLCJnZXRDaGlsZCIsInJlZ2lzdGVyQ2hpbGQiLCJub3RpZmljYXRpb25zIiwiQ29udGV4dCIsImNyZWF0ZWQiLCJub2Rlc0NyZWF0ZWQiLCJkZWxldGVkIiwibm9kZXNEZWxldGVkIiwibWFya0NyZWF0ZWQiLCJtYXJrRGVsZXRlZCIsIm5vdGlmeUNoYW5nZXMiLCJhc3NlcnRLZXllZFRhZ01hdGNoZXMiLCJjb250ZXh0IiwiY3VycmVudFBhcmVudCIsInBhdGNoRmFjdG9yeSIsInByZXZDb250ZXh0IiwicHJldlJvb3QiLCJwcmV2RG9jIiwicHJldkN1cnJlbnROb2RlIiwicHJldkN1cnJlbnRQYXJlbnQiLCJwcmV2aW91c0luQXR0cmlidXRlcyIsInByZXZpb3VzSW5Ta2lwIiwicGF0Y2hJbm5lciIsInBhdGNoT3V0ZXIiLCJhbGlnbldpdGhET00iLCJjbGVhclVudmlzaXRlZERPTSIsImVudGVyTm9kZSIsImV4aXROb2RlIiwiY29yZUVsZW1lbnRPcGVuIiwiY29yZUVsZW1lbnRDbG9zZSIsImNvcmVUZXh0IiwiY3VycmVudEVsZW1lbnQiLCJza2lwIiwiQVRUUklCVVRFU19PRkZTRVQiLCJhcmdzQnVpbGRlciIsImVsZW1lbnRPcGVuIiwiY29uc3RfYXJncyIsImF0dHJzQ2hhbmdlZCIsIl9hdHRyIiwiZWxlbWVudE9wZW5TdGFydCIsImVsZW1lbnRPcGVuRW5kIiwiZWxlbWVudENsb3NlIiwiZWxlbWVudFZvaWQiLCJlbGVtZW50UGxhY2Vob2xkZXIiLCJmb3JtYXR0ZWQiLCJyZXF1aXJlJCQwIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xNF9fIiwiZ2V0dGVyIiwiZ2V0RGVmYXVsdCIsImdldE1vZHVsZUV4cG9ydHMiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwiY29ubmVjdGVkIiwiY3RvckNyZWF0ZUluaXRQcm9wcyIsImN0b3JPYnNlcnZlZEF0dHJpYnV0ZXMiLCJjdG9yUHJvcHMiLCJjdG9yUHJvcHNNYXAiLCJyZWYiLCJyZW5kZXJlciIsInJlbmRlcmluZyIsInJlbmRlcmVyRGVib3VuY2VkIiwidXBkYXRlZCIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9faXNfdHlwZV9fIiwiZ2V0UHJvcE5hbWVzQW5kU3ltYm9scyIsImxpc3RPZktleXMiLCJpc1VuZGVmaW5lZCIsInZhbCIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fZ2V0X3Byb3BfbmFtZXNfYW5kX3N5bWJvbHNfXyIsIm5hbWVPclN5bWJvbCIsIl9fU0tBVEVfREFUQSIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fdXRpbF9zeW1ib2xzX18iLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3V0aWxfYXNzaWduX18iLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX3V0aWxfZ2V0X3Byb3BfbmFtZXNfYW5kX3N5bWJvbHNfXyIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fdXRpbF9nZXRfcHJvcHNfbWFwX18iLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX3V0aWxfaXNfdHlwZV9fIiwiZWxlbSIsIm5ld1Byb3BzIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2luY3JlbWVudGFsX2RvbV9fIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2luY3JlbWVudGFsX2RvbV9fX2RlZmF1bHQiLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3V0aWxfc3ltYm9sc19fIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX191dGlsX2Fzc2lnbl9fIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX191dGlsX2NyZWF0ZV9zeW1ib2xfXyIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fdXRpbF9kYXRhX18iLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX3V0aWxfZGVib3VuY2VfXyIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fdXRpbF9hdHRyaWJ1dGVzX21hbmFnZXJfXyIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fdXRpbF9nZXRfb3duX3Byb3BlcnR5X2Rlc2NyaXB0b3JzX18iLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX3V0aWxfZ2V0X3Byb3BfbmFtZXNfYW5kX3N5bWJvbHNfXyIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fdXRpbF9nZXRfcHJvcHNfbWFwX18iLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19wcm9wc19fIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fbGlmZWN5Y2xlX3Byb3BzX2luaXRfXyIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX3V0aWxfaXNfdHlwZV9fIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fcG9seWZpbGxzX29iamVjdF9pc19fIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fdXRpbF9zZXRfY3Rvcl9uYXRpdmVfcHJvcGVydHlfXyIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfX3V0aWxfcm9vdF9fIiwiX2dldCIsInJlY2VpdmVyIiwiX3ByZXZOYW1lIiwiX3ByZXZPbGRWYWx1ZSIsIl9wcmV2TmV3VmFsdWUiLCJkZXByZWNhdGVkIiwib2xkVXNhZ2UiLCJuZXdVc2FnZSIsIk5PREVfRU5WIiwib3duZXJOYW1lIiwicHJldmVudERvdWJsZUNhbGxpbmciLCJjcmVhdGVOYXRpdmVQcm9wZXJ0eURlc2NyaXB0b3JzIiwiQ3RvciIsInByb3BEZWZzIiwicmVkdWNlIiwicHJvcERlc2NyaXB0b3JzIiwiY3JlYXRlSW5pdFByb3BzIiwicHJvcERlc2NyaXB0b3IiLCJiZWZvcmVEZWZpbmVQcm9wZXJ0eSIsImhhc1Byb3BCZWZvcmVVcGdyYWRpbmciLCJ2YWx1ZUJlZm9yZVVwZ3JhZGluZyIsIl9jbGFzczIiLCJhdHRyc09uQ3RvciIsImF0dHJzRnJvbUxpbmtlZFByb3BzIiwicHJvcE5hbWUiLCJhdHRyU291cmNlIiwiaXRlbSIsIl9yZWYiLCJwcm9wRGVmc0NvdW50IiwicmVuZGVyQ2FsbGJhY2siLCJlbGVtRGF0YSIsInJlYWR5Q2FsbGJhY2tzIiwicmVzdW1lQXR0cmlidXRlc1VwZGF0ZXMiLCJhdHRhY2hlZCIsInN1c3BlbmRBdHRyaWJ1dGVzVXBkYXRlcyIsImRldGFjaGVkIiwicHJvcE5hbWVPclN5bWJvbCIsImNoYW5nZWRFeHRlcm5hbGx5Iiwib25BdHRyaWJ1dGVDaGFuZ2VkIiwicHJvcERlZiIsIm5ld1Byb3BWYWwiLCJkZXNlcmlhbGl6ZSIsInByb3BEYXRhIiwic2V0dGluZ1Byb3BGcm9tQXR0clNvdXJjZSIsImF0dHJpYnV0ZUNoYW5nZWQiLCJ1cGRhdGVkQ2FsbGJhY2siLCJwcmV2UHJvcHMiLCJyZW5kZXJlZENhbGxiYWNrIiwicmVuZGVyZWQiLCJyZW5kZXJlckNhbGxiYWNrIiwiX0Jhc2UiLCJvcHRzIiwicHJvdCIsIm1vZGUiLCJwb3NzaWJsZUZuIiwicHJldmlvdXNQcm9wcyIsIm5hbWVzQW5kU3ltYm9scyIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fdG9fbnVsbF9vcl9zdHJpbmdfXyIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9faXNfdHlwZV9fIiwiZ2V0QXR0ck1nciIsIkF0dHJpYnV0ZXNNYW5hZ2VyIiwicGVuZGluZ1ZhbHVlcyIsImxhc3RTZXRWYWx1ZXMiLCJfc3luY0F0dHJWYWx1ZSIsIl9jbGVhclBlbmRpbmdWYWx1ZSIsImNoYW5nZWQiLCJzZXRBdHRyVmFsdWUiLCJjdXJyQXR0clZhbHVlIiwiJGF0dHJpYnV0ZXNNZ3IiLCJtZ3IiLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3N5bWJvbHNfXyIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZ2V0X3Byb3BfbmFtZXNfYW5kX3N5bWJvbHNfXyIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fcHJvcF9kZWZpbml0aW9uX18iLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX3NldF9jdG9yX25hdGl2ZV9wcm9wZXJ0eV9fIiwiZ2V0UHJvcHNNYXAiLCJwcm9wc01hcCIsInNldEN0b3JOYXRpdmVQcm9wZXJ0eSIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fZW1wdHlfXyIsInRvTnVsbE9yU3RyaW5nIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19hcGlfcHJvcF9fIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19hcGlfc3ltYm9sc19fIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19hcGlfdmRvbV9fIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19hcGlfY29tcG9uZW50X18iLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX2FwaV9kZWZpbmVfXyIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fYXBpX2VtaXRfXyIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fYXBpX2xpbmtfXyIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fYXBpX3Byb3BzX18iLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX2FwaV9yZWFkeV9fIiwiaCIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fY29tcG9uZW50X18iLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3V0aWxfdW5pcXVlX2lkX18iLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX3V0aWxfcm9vdF9fIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX191dGlsX3Jvb3RfXyIsIlRoZUV2ZW50IiwiY3JlYXRlQ3VzdG9tRXZlbnQiLCJpbml0Q3VzdG9tRXZlbnQiLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3Byb3BzX18iLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRWYWx1ZSIsImNoZWNrZWQiLCJsb2NhbFRhcmdldCIsImxvY2FsVGFyZ2V0TmFtZSIsImZpcnN0UGFydCIsInByZXYiLCJjdXJyIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX191dGlsX2Fzc2lnbl9fIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX191dGlsX2VtcHR5X18iLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX3V0aWxfdG9fbnVsbF9vcl9zdHJpbmdfXyIsImJvb2xlYW4iLCJzdHJpbmciLCJkZWYiLCJ1bnNoaWZ0IiwicGFyc2VJZk5vdEVtcHR5IiwiSlNPTiIsImNvZXJjZSIsIl9kZWZhdWx0Iiwic2VyaWFsaXplIiwiemVyb0lmRW1wdHlPck51bWJlckluY2x1ZGVzTmFOIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX191dGlsX2RhdGFfXyIsImRvbmUiLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX3V0aWxfcHJvcF9jb250ZXh0X18iLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX3V0aWxfcm9vdF9fIiwiYnVpbGRlciIsIm5ld0F0dHIiLCJuZXdFbGVtZW50Q2xvc2UiLCJuZXdFbGVtZW50T3BlbiIsIm5ld0VsZW1lbnRPcGVuRW5kIiwibmV3RWxlbWVudE9wZW5TdGFydCIsIm5ld0VsZW1lbnRWb2lkIiwibmV3VGV4dCIsIl90b0NvbnN1bWFibGVBcnJheSIsImFycjIiLCJhcHBseURlZmF1bHQiLCJzdGFja0NocmVuIiwiJHNraXAiLCIkY3VycmVudEV2ZW50SGFuZGxlcnMiLCIkc3RhY2tDdXJyZW50SGVscGVyUHJvcHMiLCJzdGFja0N1cnJlbnRIZWxwZXIiLCJvdmVycmlkZUFyZ3MiLCJza2lwcyIsImFwcGx5RXZlbnQiLCJlbmFtZSIsIm5ld0Z1bmMiLCJldmVudHMiLCJhdHRyaWJ1dGVzQ29udGV4dCIsImZpcnN0Q2hhciIsImV2ZW50TmFtZSIsInRvVXBwZXJDYXNlIiwicmVzb2x2ZVRhZ05hbWUiLCJ3cmFwSWRvbUZ1bmMiLCJ0bmFtZUZ1bmNIYW5kbGVyIiwid3JhcCIsIl9lbGVtIiwic3RhY2tPcGVuIiwidG5hbWUiLCJzdGFja0Nsb3NlIiwiY2hyZW4iLCJlbGVtT3JGbiIsIl9sZW40IiwiX2tleTQiLCJhdHlwZSIsIl9sZW41IiwiX2tleTUiLCJjaCIsImN0eXBlIiwic2NoIiwiX2xlbjYiLCJ0YWdzIiwiX2tleTYiLCJfbGVuNyIsIl9rZXk3IiwiX2xlbjgiLCJfa2V5OCIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fdXRpbF9lbXB0eV9fIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX191dGlsX2F0dHJpYnV0ZXNfbWFuYWdlcl9fIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X191dGlsX2dldF9kZWZhdWx0X3ZhbHVlX18iLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX3V0aWxfZ2V0X2luaXRpYWxfdmFsdWVfXyIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fdXRpbF9nZXRfcHJvcF9kYXRhX18iLCJjcmVhdGVOYXRpdmVQcm9wZXJ0eURlc2NyaXB0b3IiLCJpbml0aWFsVmFsdWUiLCJ2YWx1ZUZyb21BdHRyU291cmNlIiwiaW50ZXJuYWxWYWx1ZSIsIm11c3RSZWZsZWN0IiwiYXR0clRhcmdldCIsImF0dHJUYXJnZXRJc05vdFNvdXJjZSIsInNlcmlhbGl6ZWRWYWx1ZSIsInVzZURlZmF1bHRWYWx1ZSIsImNoYW5nZURhdGEiLCJjcmVhdGVTeW1ib2wiLCJkZXNjcmlwdGlvbiIsIm9uZSIsInR3byIsImRhc2giLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX25hdGl2ZV9fIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19yb290X18iLCJtaWNyb3Rhc2tEZWJvdW5jZSIsImNiRnVuYyIsImNiQXJncyIsInRhc2tEZWJvdW5jZSIsIm1lc3NhZ2UiLCJnZXREZWZhdWx0VmFsdWUiLCJnZXRJbml0aWFsVmFsdWUiLCJpbml0aWFsIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19kYXRhX18iLCJnZXRQcm9wRGF0YSIsIm5hdGl2ZUhpbnRzIiwiYiIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYXNzaWduX18iLCJlbnRlciIsInNhdmVkIiwiZXhpdCIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fZGFzaF9jYXNlX18iLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2VtcHR5X18iLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX2Vycm9yX18iLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2lzX3R5cGVfXyIsIlByb3BEZWZpbml0aW9uIiwicHJvcE9wdGlvbnMiLCJfbmFtZU9yU3ltYm9sIiwib3B0aW9uIiwib3B0VmFsIiwicmVzb2x2ZUF0dHJOYW1lIiwiYXR0ck9wdGlvbiIsInVuaXF1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
